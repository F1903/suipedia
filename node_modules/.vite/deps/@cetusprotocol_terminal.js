import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __require,
  __toESM
} from "./chunk-OL46QLBJ.js";

// ../node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "../node_modules/react/cjs/react.development.js"(exports2, module2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error2(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a10) {
          return isArrayImpl(a10);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e10) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkKeyStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty3.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty3.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type2, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type2,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement9(type2, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty3.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i10 = 0; i10 < childrenLength; i10++) {
              childArray[i10] = arguments[i10 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type2, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement5(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty3.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i10 = 0; i10 < childrenLength; i10++) {
              childArray[i10] = arguments[i10 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement3(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex2 = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex2, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index2) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape("" + element.key);
          }
          return index2.toString(36);
        }
        function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
          var type2 = typeof children;
          if (type2 === "undefined" || type2 === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type2) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement3(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array2.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i10 = 0; i10 < children.length; i10++) {
              child = children[i10];
              nextName = nextNamePrefix + getElementKey(child, i10);
              subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii2 = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii2++);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else if (type2 === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count3 = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count3++);
          });
          return result;
        }
        function countChildren(children) {
          var n10 = 0;
          mapChildren(children, function() {
            n10++;
          });
          return n10;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement3(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext10(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error3) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error3;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy2(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef16(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo3(type2, compare) {
          {
            if (!isValidElementType(type2)) {
              error2("memo: The first argument must be a component. Instead received: %s", type2 === null ? "null" : typeof type2);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type2,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type2.name && !type2.displayName) {
                  type2.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext9(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState25(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer4(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef21(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect30(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect8(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback18(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo11(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue2(value2, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value2, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value2);
        }
        function useId2() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore6(subscribe2, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s10 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s10 >= 1 && c >= 0 && sampleLines[s10] !== controlLines[c]) {
                c--;
              }
              for (; s10 >= 1 && c >= 0; s10--, c--) {
                if (sampleLines[s10] !== controlLines[c]) {
                  if (s10 !== 1 || c !== 1) {
                    do {
                      s10--;
                      c--;
                      if (c < 0 || sampleLines[s10] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s10].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s10 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex2) {
                  error$1 = ex2;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i10 = 0; i10 < node.length; i10++) {
              var child = node[i10];
              if (isValidElement3(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement3(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement3(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type2 = element.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type2);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name3 = getComponentNameFromType(type2);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name3 || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i10 = 0; i10 < keys.length; i10++) {
              var key = keys[i10];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type2, props, children) {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (isArray(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            {
              error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement9.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i10 = 2; i10 < arguments.length; i10++) {
              validateChildKeys(arguments[i10], type2);
            }
          }
          if (type2 === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type2) {
          var validatedFactory = createElementWithValidation.bind(null, type2);
          validatedFactory.type = type2;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type2
                });
                return type2;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement5.apply(this, arguments);
          for (var i10 = 2; i10 < arguments.length; i10++) {
            validateChildKeys(arguments[i10], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error3) {
              popActScope(prevActScopeDepth);
              throw error3;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error3) {
                    popActScope(prevActScopeDepth);
                    reject(error3);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue4 = ReactCurrentActQueue.current;
                if (_queue4 !== null) {
                  flushActQueue(_queue4);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error3) {
                reject(error3);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i10 = 0;
              try {
                for (; i10 < queue.length; i10++) {
                  var callback = queue[i10];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error3) {
                queue = queue.slice(i10 + 1);
                throw error3;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children6 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports2.Children = Children6;
        exports2.Component = Component;
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.Profiler = REACT_PROFILER_TYPE;
        exports2.PureComponent = PureComponent;
        exports2.StrictMode = REACT_STRICT_MODE_TYPE;
        exports2.Suspense = REACT_SUSPENSE_TYPE;
        exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports2.act = act;
        exports2.cloneElement = cloneElement$1;
        exports2.createContext = createContext10;
        exports2.createElement = createElement$1;
        exports2.createFactory = createFactory;
        exports2.createRef = createRef;
        exports2.forwardRef = forwardRef16;
        exports2.isValidElement = isValidElement3;
        exports2.lazy = lazy2;
        exports2.memo = memo3;
        exports2.startTransition = startTransition;
        exports2.unstable_act = act;
        exports2.useCallback = useCallback18;
        exports2.useContext = useContext9;
        exports2.useDebugValue = useDebugValue2;
        exports2.useDeferredValue = useDeferredValue;
        exports2.useEffect = useEffect30;
        exports2.useId = useId2;
        exports2.useImperativeHandle = useImperativeHandle;
        exports2.useInsertionEffect = useInsertionEffect2;
        exports2.useLayoutEffect = useLayoutEffect8;
        exports2.useMemo = useMemo11;
        exports2.useReducer = useReducer4;
        exports2.useRef = useRef21;
        exports2.useState = useState25;
        exports2.useSyncExternalStore = useSyncExternalStore6;
        exports2.useTransition = useTransition;
        exports2.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../node_modules/react/index.js
var require_react = __commonJS({
  "../node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// ../node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "../node_modules/scheduler/cjs/scheduler.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index2 = heap.length;
          heap.push(node);
          siftUp(heap, node, index2);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i10) {
          var index2 = i10;
          while (index2 > 0) {
            var parentIndex = index2 - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index2] = parent;
              index2 = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i10) {
          var index2 = i10;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index2 < halfLength) {
            var leftIndex = (index2 + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                heap[index2] = left;
                heap[leftIndex] = node;
                index2 = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap[index2] = right;
              heap[rightIndex] = node;
              index2 = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a10, b) {
          var diff = a10.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a10.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms2) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports2.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports2.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error2) {
                if (currentTask !== null) {
                  var currentTime = exports2.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error2;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports2.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports2.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports2.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports2.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms2) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports2.unstable_now());
          }, ms2);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports2.unstable_IdlePriority = IdlePriority;
        exports2.unstable_ImmediatePriority = ImmediatePriority;
        exports2.unstable_LowPriority = LowPriority;
        exports2.unstable_NormalPriority = NormalPriority;
        exports2.unstable_Profiling = unstable_Profiling;
        exports2.unstable_UserBlockingPriority = UserBlockingPriority;
        exports2.unstable_cancelCallback = unstable_cancelCallback;
        exports2.unstable_continueExecution = unstable_continueExecution;
        exports2.unstable_forceFrameRate = forceFrameRate;
        exports2.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports2.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports2.unstable_next = unstable_next;
        exports2.unstable_pauseExecution = unstable_pauseExecution;
        exports2.unstable_requestPaint = unstable_requestPaint;
        exports2.unstable_runWithPriority = unstable_runWithPriority;
        exports2.unstable_scheduleCallback = unstable_scheduleCallback;
        exports2.unstable_shouldYield = shouldYieldToHost;
        exports2.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// ../node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "../node_modules/react-dom/cjs/react-dom.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React47 = require_react();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React47.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn(format) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error2(format) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment9 = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = true;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i10 = 0; i10 < dependencies.length; i10++) {
            allNativeEvents.add(dependencies[i10]);
          }
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e10) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkAttributeStringCoercion(value2, attributeName) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkKeyStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkPropStringCoercion(value2, propName) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value2, propName) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkHtmlStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value2) {
            case "function":
            // $FlowIssue symbol is perfectly valid here
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value2, propertyInfo, isCustomComponentTag) {
          if (value2 === null || typeof value2 === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value2, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value2;
              case OVERLOADED_BOOLEAN:
                return value2 === false;
              case NUMERIC:
                return isNaN(value2);
              case POSITIVE_NUMERIC:
                return isNaN(value2) || value2 < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type2;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url2) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url2)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url2));
            }
          }
        }
        function getValueForProperty(node, name, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                  var value2 = node.getAttribute(attributeName);
                  if (value2 === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return value2;
                  }
                  if (value2 === "" + expected) {
                    return expected;
                  }
                  return value2;
                }
              } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return node.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node, name, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name)) {
              return;
            }
            if (!node.hasAttribute(name)) {
              return expected === void 0 ? void 0 : null;
            }
            var value2 = node.getAttribute(name);
            {
              checkAttributeStringCoercion(expected, name);
            }
            if (value2 === "" + expected) {
              return expected;
            }
            return value2;
          }
        }
        function setValueForProperty(node, name, value2, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name);
          if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name, value2, propertyInfo, isCustomComponentTag)) {
            value2 = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
              var _attributeName = name;
              if (value2 === null) {
                node.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value2, name);
                }
                node.setAttribute(_attributeName, "" + value2);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value2 === null) {
              var type2 = propertyInfo.type;
              node[propertyName] = type2 === BOOLEAN ? false : "";
            } else {
              node[propertyName] = value2;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value2 === null) {
            node.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value2 === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value2, attributeName);
                }
                attributeValue = "" + value2;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s10 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s10 >= 1 && c >= 0 && sampleLines[s10] !== controlLines[c]) {
                c--;
              }
              for (; s10 >= 1 && c >= 0; s10--, c--) {
                if (sampleLines[s10] !== controlLines[c]) {
                  if (s10 !== 1 || c !== 1) {
                    do {
                      s10--;
                      c--;
                      if (c < 0 || sampleLines[s10] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s10].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s10 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type2 = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context = type2;
              return getContextName$1(context) + ".Consumer";
            case ContextProvider:
              var provider = type2;
              return getContextName$1(provider._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef:
              return getWrappedName$1(type2, type2.render, "ForwardRef");
            case Fragment9:
              return "Fragment";
            case HostComponent:
              return type2;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type2);
            case Mode:
              if (type2 === REACT_STRICT_MODE_TYPE) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            // The display name for this tags come from the user-provided type:
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type2 === "function") {
                return type2.displayName || type2.name || null;
              }
              if (typeof type2 === "string") {
                return type2;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current === null) {
              return null;
            }
            var owner = current._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString(value2) {
          return "" + value2;
        }
        function getToStringValue(value2) {
          switch (typeof value2) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value2;
            case "object":
              {
                checkFormFieldValueStringCoercion(value2);
              }
              return value2;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type2 = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type2 === "checkbox" || type2 === "radio");
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function detachTracker(node) {
          node._valueTracker = null;
        }
        function getValueFromNode(node) {
          var value2 = "";
          if (!node) {
            return value2;
          }
          if (isCheckable(node)) {
            value2 = node.checked ? "true" : "false";
          } else {
            value2 = node.value;
          }
          return value2;
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node[valueField]);
          }
          var currentValue = "" + node[valueField];
          if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get3 = descriptor.get, set2 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get3.call(this);
            },
            set: function(value2) {
              {
                checkFormFieldValueStringCoercion(value2);
              }
              currentValue = "" + value2;
              set2.call(this, value2);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value2) {
              {
                checkFormFieldValueStringCoercion(value2);
              }
              currentValue = "" + value2;
            },
            stopTracking: function() {
              detachTracker(node);
              delete node[valueField];
            }
          };
          return tracker;
        }
        function track(node) {
          if (getTracker(node)) {
            return;
          }
          node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
          if (!node) {
            return false;
          }
          var tracker = getTracker(node);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e10) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
          var usesChecked = props.type === "checkbox" || props.type === "radio";
          return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element, props) {
          var node = element;
          var checked = props.checked;
          var hostProps = assign({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node = element;
          var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
          node._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
          };
        }
        function updateChecked(element, props) {
          var node = element;
          var checked = props.checked;
          if (checked != null) {
            setValueForProperty(node, "checked", checked, false);
          }
        }
        function updateWrapper(element, props) {
          var node = element;
          {
            var controlled = isControlled(props);
            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props);
          var value2 = getToStringValue(props.value);
          var type2 = props.type;
          if (value2 != null) {
            if (type2 === "number") {
              if (value2 === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
              // eslint-disable-next-line
              node.value != value2) {
                node.value = toString(value2);
              }
            } else if (node.value !== toString(value2)) {
              node.value = toString(value2);
            }
          } else if (type2 === "submit" || type2 === "reset") {
            node.removeAttribute("value");
            return;
          }
          {
            if (props.hasOwnProperty("value")) {
              setDefaultValue(node, props.type, value2);
            } else if (props.hasOwnProperty("defaultValue")) {
              setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
            }
          }
          {
            if (props.checked == null && props.defaultChecked != null) {
              node.defaultChecked = !!props.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props, isHydrating2) {
          var node = element;
          if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
            var type2 = props.type;
            var isButton = type2 === "submit" || type2 === "reset";
            if (isButton && (props.value === void 0 || props.value === null)) {
              return;
            }
            var initialValue = toString(node._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node.value) {
                  node.value = initialValue;
                }
              }
            }
            {
              node.defaultValue = initialValue;
            }
          }
          var name = node.name;
          if (name !== "") {
            node.name = "";
          }
          {
            node.defaultChecked = !node.defaultChecked;
            node.defaultChecked = !!node._wrapperState.initialChecked;
          }
          if (name !== "") {
            node.name = name;
          }
        }
        function restoreControlledState(element, props) {
          var node = element;
          updateWrapper(node, props);
          updateNamedCousins(node, props);
        }
        function updateNamedCousins(rootNode, props) {
          var name = props.name;
          if (props.type === "radio" && name != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
            for (var i10 = 0; i10 < group.length; i10++) {
              var otherNode = group[i10];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node, type2, value2) {
          if (
            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
            type2 !== "number" || getActiveElement(node.ownerDocument) !== node
          ) {
            if (value2 == null) {
              node.defaultValue = toString(node._wrapperState.initialValue);
            } else if (node.defaultValue !== toString(value2)) {
              node.defaultValue = toString(value2);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props) {
          {
            if (props.value == null) {
              if (typeof props.children === "object" && props.children !== null) {
                React47.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props.selected != null && !didWarnSelectedSetOnOption) {
              error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props) {
          if (props.value != null) {
            element.setAttribute("value", toString(getToStringValue(props.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a10) {
          return isArrayImpl(a10);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props) {
          {
            checkControlledValueProps("select", props);
            for (var i10 = 0; i10 < valuePropNames.length; i10++) {
              var propName = valuePropNames[i10];
              if (props[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray(props[propName]);
              if (props.multiple && !propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props.multiple && propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options2 = node.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i10 = 0; i10 < selectedValues.length; i10++) {
              selectedValue["$" + selectedValues[i10]] = true;
            }
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i2].value);
              if (options2[_i2].selected !== selected) {
                options2[_i2].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i2].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i22 = 0; _i22 < options2.length; _i22++) {
              if (options2[_i22].value === _selectedValue) {
                options2[_i22].selected = true;
                if (setDefaultSelected) {
                  options2[_i22].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i22].disabled) {
                defaultSelected = options2[_i22];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element, props) {
          return assign({}, props, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props) {
          var node = element;
          {
            checkSelectPropTypes(props);
          }
          node._wrapperState = {
            wasMultiple: !!props.multiple
          };
          {
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props) {
          var node = element;
          node.multiple = !!props.multiple;
          var value2 = props.value;
          if (value2 != null) {
            updateOptions(node, !!props.multiple, value2, false);
          } else if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props) {
          var node = element;
          var wasMultiple = node._wrapperState.wasMultiple;
          node._wrapperState.wasMultiple = !!props.multiple;
          var value2 = props.value;
          if (value2 != null) {
            updateOptions(node, !!props.multiple, value2, false);
          } else if (wasMultiple !== !!props.multiple) {
            if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            } else {
              updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props) {
          var node = element;
          var value2 = props.value;
          if (value2 != null) {
            updateOptions(node, !!props.multiple, value2, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props) {
          var node = element;
          if (props.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString(node._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props) {
          var node = element;
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props.value;
          if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
              {
                error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props) {
          var node = element;
          var value2 = getToStringValue(props.value);
          var defaultValue = getToStringValue(props.defaultValue);
          if (value2 != null) {
            var newValue = toString(value2);
            if (newValue !== node.value) {
              node.value = newValue;
            }
            if (props.defaultValue == null && node.defaultValue !== newValue) {
              node.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node.defaultValue = toString(defaultValue);
          }
        }
        function postMountWrapper$3(element, props) {
          var node = element;
          var textContent = node.textContent;
          if (textContent === node._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props) {
          updateWrapper$1(element, props);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type2) {
          switch (type2) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type2) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type2);
          }
          if (parentNamespace === SVG_NAMESPACE && type2 === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
          if (node.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node.firstChild) {
                node.removeChild(node.firstChild);
              }
              while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value2, isCustomProperty) {
          var isEmpty2 = value2 == null || typeof value2 === "boolean" || value2 === "";
          if (isEmpty2) {
            return "";
          }
          if (!isCustomProperty && typeof value2 === "number" && value2 !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value2 + "px";
          }
          {
            checkCSSPropertyStringCoercion(value2, name);
          }
          return ("" + value2).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string2) {
            return string2.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value2) {
            if (warnedStyleValues.hasOwnProperty(value2) && warnedStyleValues[value2]) {
              return;
            }
            warnedStyleValues[value2] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value2.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value2) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value2) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value2) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value2)) {
              warnStyleValueWithSemicolon(name, value2);
            }
            if (typeof value2 === "number") {
              if (isNaN(value2)) {
                warnStyleValueIsNaN(name, value2);
              } else if (!isFinite(value2)) {
                warnStyleValueIsInfinity(name, value2);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node, styles) {
          var style2 = node.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value2) {
          return value2 == null || typeof value2 === "boolean" || value2 === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key in styles) {
            var longhands = shorthandToLonghand[key] || [key];
            for (var i10 = 0; i10 < longhands.length; i10++) {
              expanded[longhands[i10]] = key;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key in expandedUpdates) {
              var originalKey = expandedUpdates[key];
              var correctOriginalKey = expandedStyles[key];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
          // NOTE: menuitem's close tag should be omitted, but that causes problems.
        };
        var voidElementTags = assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props.children != null || props.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props.style != null && typeof props.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            // These are reserved SVG and MathML elements.
            // We don't mind this list too much because we expect it to never grow.
            // The alternative is to track the namespace in a few places which is convoluted.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty3.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type2, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type2, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            }
          }
        }
        function validateProperties(type2, props) {
          if (isCustomComponent(type2, props)) {
            return;
          }
          warnInvalidARIAProps(type2, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type2, props) {
          {
            if (type2 !== "input" && type2 !== "textarea" && type2 !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type2 === "select" && props.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value2, eventRegistry) {
            if (hasOwnProperty3.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value2 !== null && value2 !== void 0 && typeof value2 !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value2);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value2 === "number" && isNaN(value2)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value2 === "boolean" && shouldRemoveAttributeWithWarning(name, value2, propertyInfo, false)) {
              if (value2) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value2, name, name, value2, name);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value2, name, name, value2, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value2, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value2 === "false" || value2 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value2, name, value2 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value2);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type2, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type2, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            }
          }
        };
        function validateProperties$2(type2, props, eventRegistry) {
          if (isCustomComponent(type2, props)) {
            return;
          }
          warnUnknownProperties(type2, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i10 = 0; i10 < queuedTargets.length; i10++) {
              restoreStateOfTarget(queuedTargets[i10]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn2, bookkeeping) {
          return fn2(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn2, a10, b) {
          if (isInsideEventHandler) {
            return fn2(a10, b);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn2, a10, b);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name, type2, props) {
          switch (name) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props.disabled && isInteractive(type2));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (props === null) {
            return null;
          }
          var listener = props[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
            return null;
          }
          if (listener && typeof listener !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e10) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name, func, context, a10, b, c, d6, e10, f) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context, funcArgs);
          } catch (error3) {
            this.onError(error3);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a10, b, c, d6, e10, f) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
              }
              var error3;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error3 = event.error;
                didSetError = true;
                if (error3 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error3 != null && typeof error3 === "object") {
                    try {
                      error3._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name ? name : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error3);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error3) {
            hasError = true;
            caughtError = error3;
          }
        };
        function invokeGuardedCallback(name, func, context, a10, b, c, d6, e10, f) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a10, b, c, d6, e10, f) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error3 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error3;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error3 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error3;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error3 = caughtError;
            hasError = false;
            caughtError = null;
            return error3;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get2(key) {
          return key._reactInternals;
        }
        function has(key) {
          return key._reactInternals !== void 0;
        }
        function set(key, value2) {
          key._reactInternals = value2;
        }
        var NoFlags = (
          /*                      */
          0
        );
        var PerformedWork = (
          /*                */
          1
        );
        var Placement = (
          /*                    */
          2
        );
        var Update = (
          /*                       */
          4
        );
        var ChildDeletion = (
          /*                */
          16
        );
        var ContentReset = (
          /*                 */
          32
        );
        var Callback = (
          /*                     */
          64
        );
        var DidCapture = (
          /*                   */
          128
        );
        var ForceClientRender = (
          /*            */
          256
        );
        var Ref = (
          /*                          */
          512
        );
        var Snapshot = (
          /*                     */
          1024
        );
        var Passive = (
          /*                      */
          2048
        );
        var Hydrating = (
          /*                    */
          4096
        );
        var Visibility = (
          /*                   */
          8192
        );
        var StoreConsistency = (
          /*             */
          16384
        );
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = (
          /*               */
          32767
        );
        var Incomplete = (
          /*                   */
          32768
        );
        var ShouldCapture = (
          /*                */
          65536
        );
        var ForceUpdateForLegacySuspense = (
          /* */
          131072
        );
        var Forked = (
          /*                       */
          1048576
        );
        var RefStatic = (
          /*                    */
          2097152
        );
        var LayoutStatic = (
          /*                 */
          4194304
        );
        var PassiveStatic = (
          /*                */
          8388608
        );
        var MountLayoutDev = (
          /*               */
          16777216
        );
        var MountPassiveDev = (
          /*              */
          33554432
        );
        var BeforeMutationMask = (
          // TODO: Remove Update flag from before mutation phase by re-landing Visibility
          // flag logic (see #20043)
          Update | Snapshot | 0
        );
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current2 = fiber.alternate;
              if (current2 !== null) {
                suspenseState = current2.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance = ownerFiber.stateNode;
              if (!instance._warnedAboutRefsInRender) {
                error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get2(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a10 = fiber;
          var b = alternate;
          while (true) {
            var parentA = a10.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a10 = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a10) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a10.return !== b.return) {
              a10 = parentA;
              b = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a10) {
                  didFindChild = true;
                  a10 = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a10 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a10) {
                    didFindChild = true;
                    a10 = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a10 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a10.alternate !== b) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a10.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a10.stateNode.current === a10) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            var match = findCurrentHostFiberImpl(child);
            if (match !== null) {
              return match;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match !== null) {
                return match;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error2("React instrumentation encountered an error: %s.", err);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root2, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root2, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root2, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root2.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root2) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root2);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index3 = 0; index3 < TotalLanes; index3++) {
              var label = getLabelForLane(lane);
              map.set(lane, label);
              lane *= 2;
            }
            return map;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = (
          /*                         */
          0
        );
        var ConcurrentMode = (
          /*                 */
          1
        );
        var ProfileMode = (
          /*                    */
          2
        );
        var StrictLegacyMode = (
          /*               */
          8
        );
        var StrictEffectsMode = (
          /*              */
          16
        );
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = (
          /*                        */
          0
        );
        var NoLane = (
          /*                          */
          0
        );
        var SyncLane = (
          /*                        */
          1
        );
        var InputContinuousHydrationLane = (
          /*    */
          2
        );
        var InputContinuousLane = (
          /*             */
          4
        );
        var DefaultHydrationLane = (
          /*            */
          8
        );
        var DefaultLane = (
          /*                     */
          16
        );
        var TransitionHydrationLane = (
          /*                */
          32
        );
        var TransitionLanes = (
          /*                       */
          4194240
        );
        var TransitionLane1 = (
          /*                        */
          64
        );
        var TransitionLane2 = (
          /*                        */
          128
        );
        var TransitionLane3 = (
          /*                        */
          256
        );
        var TransitionLane4 = (
          /*                        */
          512
        );
        var TransitionLane5 = (
          /*                        */
          1024
        );
        var TransitionLane6 = (
          /*                        */
          2048
        );
        var TransitionLane7 = (
          /*                        */
          4096
        );
        var TransitionLane8 = (
          /*                        */
          8192
        );
        var TransitionLane9 = (
          /*                        */
          16384
        );
        var TransitionLane10 = (
          /*                       */
          32768
        );
        var TransitionLane11 = (
          /*                       */
          65536
        );
        var TransitionLane12 = (
          /*                       */
          131072
        );
        var TransitionLane13 = (
          /*                       */
          262144
        );
        var TransitionLane14 = (
          /*                       */
          524288
        );
        var TransitionLane15 = (
          /*                       */
          1048576
        );
        var TransitionLane16 = (
          /*                       */
          2097152
        );
        var RetryLanes = (
          /*                            */
          130023424
        );
        var RetryLane1 = (
          /*                             */
          4194304
        );
        var RetryLane2 = (
          /*                             */
          8388608
        );
        var RetryLane3 = (
          /*                             */
          16777216
        );
        var RetryLane4 = (
          /*                             */
          33554432
        );
        var RetryLane5 = (
          /*                             */
          67108864
        );
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = (
          /*          */
          134217728
        );
        var NonIdleLanes = (
          /*                          */
          268435455
        );
        var IdleHydrationLane = (
          /*               */
          268435456
        );
        var IdleLane = (
          /*                        */
          536870912
        );
        var OffscreenLane = (
          /*                   */
          1073741824
        );
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root2, wipLanes) {
          var pendingLanes = root2.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
          // bother waiting until the root is complete.
          (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (
              // Tests whether the next lane is equal or lower priority than the wip
              // one. This works because the bits decrease in priority as you go left.
              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
              // only difference between default updates and transition updates is that
              // default updates do not support refresh transitions.
              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
            ) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root2.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root2.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              nextLanes |= entanglements[index3];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root2, lanes) {
          var eventTimes = root2.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            var eventTime = eventTimes[index3];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root2, currentTime) {
          var pendingLanes = root2.pendingLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            var expirationTime = expirationTimes[index3];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index3] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root2.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root2) {
          return getHighestPriorityLanes(root2.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root2) {
          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root2, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root2, lanes) {
          return (lanes & root2.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a10, b) {
          return (a10 & b) !== NoLanes;
        }
        function isSubsetOfLanes(set2, subset) {
          return (set2 & subset) === subset;
        }
        function mergeLanes(a10, b) {
          return a10 | b;
        }
        function removeLanes(set2, subset) {
          return set2 & ~subset;
        }
        function intersectLanes(a10, b) {
          return a10 & b;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a10, b) {
          return a10 !== NoLane && a10 < b ? a10 : b;
        }
        function createLaneMap(initial) {
          var laneMap = [];
          for (var i10 = 0; i10 < TotalLanes; i10++) {
            laneMap.push(initial);
          }
          return laneMap;
        }
        function markRootUpdated(root2, updateLane, eventTime) {
          root2.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
          }
          var eventTimes = root2.eventTimes;
          var index3 = laneToIndex(updateLane);
          eventTimes[index3] = eventTime;
        }
        function markRootSuspended(root2, suspendedLanes) {
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            expirationTimes[index3] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root2, pingedLanes, eventTime) {
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root2, remainingLanes) {
          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = NoLanes;
          root2.pingedLanes = NoLanes;
          root2.expiredLanes &= remainingLanes;
          root2.mutableReadLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          var entanglements = root2.entanglements;
          var eventTimes = root2.eventTimes;
          var expirationTimes = root2.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            entanglements[index3] = NoLanes;
            eventTimes[index3] = NoTimestamp;
            expirationTimes[index3] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          var entanglements = root2.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            if (
              // Is this one of the newly entangled lanes?
              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
              entanglements[index3] & entangledLanes
            ) {
              entanglements[index3] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index3 = laneToIndex(lanes);
            var lane = 1 << index3;
            var updaters = pendingUpdatersLaneMap[index3];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          var memoizedUpdaters = root2.memoizedUpdaters;
          while (lanes > 0) {
            var index3 = laneToIndex(lanes);
            var lane = 1 << index3;
            var updaters = pendingUpdatersLaneMap[index3];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root2, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn2) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn2();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a10, b) {
          return a10 !== 0 && a10 < b ? a10 : b;
        }
        function lowerEventPriority(a10, b) {
          return a10 === 0 || a10 > b ? a10 : b;
        }
        function isHigherEventPriority(a10, b) {
          return a10 !== 0 && a10 < b;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root2) {
          var currentState = root2.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn2) {
          _attemptSynchronousHydration = fn2;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn2) {
          attemptContinuousHydration = fn2;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn2) {
          attemptHydrationAtCurrentPriority = fn2;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn2) {
          getCurrentUpdatePriority$1 = fn2;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn2) {
          attemptHydrationAtPriority = fn2;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          // Intentionally camelCase
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  queuedTarget.blockedOn = instance;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i10 = 0;
          for (; i10 < queuedExplicitHydrationTargets.length; i10++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i10].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i10, 0, queuedTarget);
          if (i10 === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map.delete(key);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i10 = 1; i10 < queuedDiscreteEvents.length; i10++) {
              var queuedEvent = queuedDiscreteEvents[i10];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i2 = 0; _i2 < queuedExplicitHydrationTargets.length; _i2++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i2];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container8, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container8, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container8, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container8, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  return instance;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            // Used by SimpleEventPlugin:
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            // Used by polyfills:
            // eslint-disable-next-line no-fallthrough
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            // Only enableCreateEventHandleAPI:
            // eslint-disable-next-line no-fallthrough
            case "beforeblur":
            case "afterblur":
            // Not used by React but could be by user code:
            // eslint-disable-next-line no-fallthrough
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            // Not used by React but could be by user code:
            // eslint-disable-next-line no-fallthrough
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start;
          var startValue = startText;
          var startLength = startValue.length;
          var end;
          var endValue = getText();
          var endLength = endValue.length;
          for (start = 0; start < startLength; start++) {
            if (startValue[start] !== endValue[start]) {
              break;
            }
          }
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd; end++) {
            if (startValue[startLength - end] !== endValue[endLength - end]) {
              break;
            }
          }
          var sliceTail = end > 1 ? 1 - end : void 0;
          fallbackText = endValue.slice(start, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root) {
            return root.value;
          }
          return root.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize3 = Interface[_propName];
              if (normalize3) {
                this[_propName] = normalize3(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
             * We release all dispatched `SyntheticEvent`s after each event loop, adding
             * them back into the pool. This allows a way to hold onto a reference that
             * won't be added back into the pool.
             */
            persist: function() {
            },
            /**
             * Checks if this event should be released back into the pool.
             *
             * @return {boolean} True if this should not be released, false otherwise.
             */
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== "Unidentified") {
              return key;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          // Legacy Interface
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : (
              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
              "wheelDeltaX" in event ? -event.wheelDeltaX : 0
            );
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : (
              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
              "wheelDeltaY" in event ? -event.wheelDeltaY : (
                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                "wheelDelta" in event ? -event.wheelDelta : 0
              )
            );
          },
          deltaZ: 0,
          // Browsers without "deltaMode" is reporting in raw wheel delta where one
          // notch on the scroll is always +/- 120, roughly equivalent to pixels.
          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
          !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars = nativeEvent.data;
              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars = getData();
              reset();
              isComposing = false;
              return chars;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node) {
          var state = node._wrapperState;
          if (!state || !state.controlled || node.type !== "number") {
            return;
          }
          {
            setDefaultValue(node, "number", node.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from;
          var to2;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to2 = _related ? getClosestInstanceFromNode(_related) : null;
            if (to2 !== null) {
              var nearestMounted = getNearestMountedFiber(to2);
              if (to2 !== nearestMounted || to2.tag !== HostComponent && to2.tag !== HostText) {
                to2 = null;
              }
            }
          } else {
            from = null;
            to2 = targetInst;
          }
          if (from === to2) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from == null ? win : getNodeFromInstance(from);
          var toNode = to2 == null ? win : getNodeFromInstance(to2);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to2, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to2);
        }
        function is3(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is3;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i10 = 0; i10 < keysA.length; i10++) {
            var currentKey = keysA[i10];
            if (!hasOwnProperty3.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node) {
          while (node && node.firstChild) {
            node = node.firstChild;
          }
          return node;
        }
        function getSiblingNode(node) {
          while (node) {
            if (node.nextSibling) {
              return node.nextSibling;
            }
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root2, offset4) {
          var node = getLeafNode(root2);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node) {
            if (node.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node.textContent.length;
              if (nodeStart <= offset4 && nodeEnd >= offset4) {
                return {
                  node,
                  offset: offset4 - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e10) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length = 0;
          var start = -1;
          var end = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node = outerNode;
          var parentNode = null;
          outer: while (true) {
            var next = null;
            while (true) {
              if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                start = length + anchorOffset;
              }
              if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                end = length + focusOffset;
              }
              if (node.nodeType === TEXT_NODE) {
                length += node.nodeValue.length;
              }
              if ((next = node.firstChild) === null) {
                break;
              }
              parentNode = node;
              node = next;
            }
            while (true) {
              if (node === outerNode) {
                break outer;
              }
              if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                start = length;
              }
              if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                end = length;
              }
              if ((next = node.nextSibling) !== null) {
                break;
              }
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          if (start === -1 || end === -1) {
            return null;
          }
          return {
            start,
            end
          };
        }
        function setOffsets(node, offsets) {
          var doc = node.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length = node.textContent.length;
          var start = Math.min(offsets.start, length);
          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start);
          var endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
              selection.addRange(range);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range);
            }
          }
        }
        function isTextNode(node) {
          return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node) {
          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i10 = 0; i10 < ancestors.length; i10++) {
              var info = ancestors[i10];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start = offsets.start;
          var end = offsets.end;
          if (end === void 0) {
            end = start;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
          if ("selectionStart" in node && hasSelectionCapabilities(node)) {
            return {
              start: node.selectionStart,
              end: node.selectionEnd
            };
          } else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            // Track the input node that has focus.
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            // Don't fire the event while the user is dragging. This matches the
            // semantics of the native select event.
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            // Chrome and IE fire non-standard event when selection is changed (and
            // sometimes when it hasn't). IE's event fires out of order with respect
            // to key and input events on deletion, so we discard it.
            //
            // Firefox doesn't support selectionchange, so check selection status
            // after each key entry. The selection changes after keydown and before
            // keyup, but we check on keydown as well in the case of holding down a
            // key, when multiple keydown events are fired but only one keyup is.
            // This is also our approach for IE handling, for the reason above.
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            // falls through
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i10 = 0; i10 < simpleEventPluginEvents.length; i10++) {
            var eventName = simpleEventPluginEvents[i10];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            /* falls through */
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            /* falls through */
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            // TODO: Disabled elements should not respond to mouse events
            /* falls through */
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
            // nonDelegatedEvents list in DOMPluginEventSystem.
            // Then we can remove this special list.
            // This is a breaking change that can wait until React 18.
            domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type2 = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type2, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i10 = dispatchListeners.length - 1; i10 >= 0; i10--) {
              var _dispatchListeners$i = dispatchListeners[i10], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance;
            }
          } else {
            for (var _i2 = 0; _i2 < dispatchListeners.length; _i2++) {
              var _dispatchListeners$_i = dispatchListeners[_i2], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener2 = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener2, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i10 = 0; i10 < dispatchQueue.length; i10++) {
            var _dispatchQueue$i = dispatchQueue[i10], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node = targetInst;
              mainLoop: while (true) {
                if (node === null) {
                  return;
                }
                var nodeTag = node.tag;
                if (nodeTag === HostRoot || nodeTag === HostPortal) {
                  var container8 = node.stateNode.containerInfo;
                  if (isMatchingRootContainer(container8, targetContainerNode)) {
                    break;
                  }
                  if (nodeTag === HostPortal) {
                    var grandNode = node.return;
                    while (grandNode !== null) {
                      var grandTag = grandNode.tag;
                      if (grandTag === HostRoot || grandTag === HostPortal) {
                        var grandContainer = grandNode.stateNode.containerInfo;
                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                          return;
                        }
                      }
                      grandNode = grandNode.return;
                    }
                  }
                  while (container8 !== null) {
                    var parentNode = getClosestInstanceFromNode(container8);
                    if (parentNode === null) {
                      return;
                    }
                    var parentTag = parentNode.tag;
                    if (parentTag === HostComponent || parentTag === HostText) {
                      node = ancestorInst = parentNode;
                      continue mainLoop;
                    }
                    container8 = container8.parentNode;
                  }
                }
                node = node.return;
              }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance = targetFiber;
          var lastHostComponent = null;
          while (instance !== null) {
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance, reactEventName);
                if (listener != null) {
                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance = instance.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance = targetFiber;
          while (instance !== null) {
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
            instance = instance.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance = target;
          while (instance !== null) {
            if (instance === common) {
              break;
            }
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
            }
            instance = instance.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to2) {
          var common = from && to2 ? getLowestCommonAncestor(from, to2) : null;
          if (from !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
          }
          if (to2 !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to2, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            // There are working polyfills for <dialog>. Let people use it.
            dialog: true,
            // Electron ships a custom <webview> tag to display external web content in
            // an isolated frame and process.
            // This tag is not present in non Electron environments such as JSDom which
            // is often used for testing purposes.
            // @see https://electronjs.org/docs/api/webview-tag
            webview: true
          };
          validatePropertiesInDevelopment = function(type2, props) {
            validateProperties(type2, props);
            validateProperties$1(type2, props);
            validateProperties$2(type2, props, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name) {
              names.push(name);
            });
            error2("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent, html) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop3() {
        }
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop3;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i10 = 0; i10 < updatePayload.length; i10 += 2) {
            var propKey = updatePayload[i10];
            var propValue = updatePayload[i10 + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement9(type2, props, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type2);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type2, props);
              if (!isCustomComponentTag && type2 !== type2.toLowerCase()) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2);
              }
            }
            if (type2 === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props.is === "string") {
              domElement = ownerDocument.createElement(type2, {
                is: props.is
              });
            } else {
              domElement = ownerDocument.createElement(type2);
              if (type2 === "select") {
                var node = domElement;
                if (props.multiple) {
                  node.multiple = true;
                } else if (props.size) {
                  node.size = props.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type2);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty3.call(warnedUnknownTags, type2)) {
                warnedUnknownTags[type2] = true;
                error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type2);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "video":
            case "audio":
              for (var i10 = 0; i10 < mediaEventTypes.length; i10++) {
                listenToNonDelegatedEvent(mediaEventTypes[i10], domElement);
              }
              props = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props = rawProps;
          }
          assertValidProps(tag, props);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i10 = 0; i10 < mediaEventTypes.length; i10++) {
                listenToNonDelegatedEvent(mediaEventTypes[i10], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes = domElement.attributes;
            for (var _i2 = 0; _i2 < attributes.length; _i2++) {
              var name = attributes[_i2].name.toLowerCase();
              switch (name) {
                // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i2].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
            typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              propKey === "value" || propKey === "checked" || propKey === "selected") ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (
                // $FlowFixMe - Should be inferred as not undefined.
                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
              ) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text) {
          {
            if (text === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props);
              return;
            case "select":
              restoreControlledState$1(domElement, props);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
            // TODO: Distinguish by namespace here -- for <title>, including it here
            // errs on the side of fewer warnings
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
              // but
              case "option":
                return tag === "#text";
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
              // No special behavior since these rules fall back to "in body" mode for
              // all except special table nodes which cause bad parsing behavior anyway.
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
              case "colgroup":
                return tag === "col" || tag === "template";
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error2("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type2;
          var namespace;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type2 = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root2 = rootContainerInstance.documentElement;
              namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container8 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container8.namespaceURI || null;
              type2 = container8.tagName;
              namespace = getChildNamespace(ownNamespace, type2);
              break;
            }
          }
          {
            var validatedTag = type2.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type2, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace = getChildNamespace(parentHostContextDev.namespace, type2);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type2);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance) {
          return instance;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance(type2, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type2, null, hostContextDev.ancestorInfo);
            if (typeof props.children === "string" || typeof props.children === "number") {
              var string2 = "" + props.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type2);
              validateDOMNesting(null, string2, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement9(type2, props, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type2, props, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type2, props, rootContainerInstance);
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type2, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string2 = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type2);
              validateDOMNesting(null, string2, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type2, oldProps, newProps);
        }
        function shouldSetTextContent(type2, props) {
          return type2 === "textarea" || type2 === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error3) {
          setTimeout(function() {
            throw error3;
          });
        }
        function commitMount(domElement, type2, newProps, internalInstanceHandle) {
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type2, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type2, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container8, child) {
          var parentNode;
          if (container8.nodeType === COMMENT_NODE) {
            parentNode = container8.parentNode;
            parentNode.insertBefore(child, container8);
          } else {
            parentNode = container8;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container8._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container8, child, beforeChild) {
          if (container8.nodeType === COMMENT_NODE) {
            container8.parentNode.insertBefore(child, beforeChild);
          } else {
            container8.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container8, child) {
          if (container8.nodeType === COMMENT_NODE) {
            container8.parentNode.removeChild(child);
          } else {
            container8.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container8, suspenseInstance) {
          if (container8.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container8.parentNode, suspenseInstance);
          } else if (container8.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container8, suspenseInstance);
          }
          retryIfBlockedOn(container8);
        }
        function hideInstance(instance) {
          instance = instance;
          var style2 = instance.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          instance = instance;
          var styleProp = props[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainer(container8) {
          if (container8.nodeType === ELEMENT_NODE) {
            container8.textContent = "";
          } else if (container8.nodeType === DOCUMENT_NODE) {
            if (container8.documentElement) {
              container8.removeChild(container8.documentElement);
            }
          }
        }
        function canHydrateInstance(instance, type2, props) {
          if (instance.nodeType !== ELEMENT_NODE || type2.toLowerCase() !== instance.nodeName.toLowerCase()) {
            return null;
          }
          return instance;
        }
        function canHydrateTextInstance(instance, text) {
          if (text === "" || instance.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance;
        }
        function canHydrateSuspenseInstance(instance) {
          if (instance.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance) {
          var dataset = instance.nextSibling && instance.nextSibling.dataset;
          var digest, message, stack;
          if (dataset) {
            digest = dataset.dgst;
            {
              message = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message,
              digest,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          instance._reactRetry = callback;
        }
        function getNextHydratable(node) {
          for (; node != null; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance, type2, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance);
          updateFiberProps(instance, props);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance, type2, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node = suspenseInstance.nextSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node = node.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node = targetInstance.previousSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node = node.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container8) {
          retryIfBlockedOn(container8);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
          {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance);
            } else if (instance.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentContainer, instance);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance);
              } else if (instance.nodeType === COMMENT_NODE) ;
              else {
                warnForDeletedHydratableText(parentNode, instance);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE) ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type2, props) {
          {
            warnForInsertedHydratedElement(parentContainer, type2);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
          {
            warnForInsertedHydratedText(parentContainer, text);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type2, props) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type2);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type2, props, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type2);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
          node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node) {
          return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props) {
          node[internalPropsKey] = props;
        }
        function getEventListenerSet(node) {
          var elementListenerSet = node[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex2) {
                  error$1 = ex2;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index2 = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop(cursor, fiber) {
          if (index2 < 0) {
            {
              error2("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index2]) {
              error2("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index2];
          valueStack[index2] = null;
          {
            fiberStack[index2] = null;
          }
          index2--;
        }
        function push(cursor, value2, fiber) {
          index2++;
          valueStack[index2] = cursor.current;
          {
            fiberStack[index2] = fiber;
          }
          cursor.current = value2;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance = workInProgress2.stateNode;
            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type2 = workInProgress2.type;
            var contextTypes = type2.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance = workInProgress2.stateNode;
            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance.__reactInternalMemoizedMaskedChildContext;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            if (instance) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return context;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type2) {
          {
            var childContextTypes = type2.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push(contextStackCursor, context, fiber);
            push(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type2, parentContext) {
          {
            var instance = fiber.stateNode;
            var childContextTypes = type2.childContextTypes;
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type2, didChange) {
          {
            var instance = workInProgress2.stateNode;
            if (!instance) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type2, previousContext);
              instance.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push(contextStackCursor, mergedContext, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node = fiber;
            do {
              switch (node.tag) {
                case HostRoot:
                  return node.stateNode.context;
                case ClassComponent: {
                  var Component = node.type;
                  if (isContextProvider(Component)) {
                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node = node.return;
            } while (node !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i10 = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i10 < queue.length; i10++) {
                var callback = queue[i10];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error3) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i10 + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error3;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id2.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index3) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index3 + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id2 = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id2;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot << baseLength;
            var _id2 = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length | _id2;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id2) {
          return 1 << getBitLength(id2) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(
                  returnFiber.type,
                  returnFiber.memoizedProps,
                  returnFiber.stateNode,
                  instance,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance) {
          warnUnhydratedInstance(returnFiber, instance);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type2 = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type2);
                    break;
                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _type,
                      _props,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _text,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode
                    );
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null) switch (fiber.tag) {
                  case HostComponent:
                    var _type2 = fiber.type;
                    var _props2 = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                    break;
                  case HostText:
                    var _text2 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                    break;
                }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type2 = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type2);
              if (instance !== null) {
                fiber.stateNode = instance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance);
                return true;
              }
              return false;
            }
            case HostText: {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(
                    parentContainer,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode2
                  );
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error3) {
          if (hydrationErrors === null) {
            hydrationErrors = [error3];
          } else {
            hydrationErrors.push(error3);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node = fiber;
            while (node !== null) {
              if (node.mode & StrictLegacyMode) {
                maybeStrictRoot = node;
              }
              node = node.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set2) {
            var array2 = [];
            set2.forEach(function(value2) {
              array2.push(value2);
            });
            return array2.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
            instance.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function isReactClass(type2) {
          return type2.prototype && type2.prototype.isReactComponent;
        }
        function coerceRef(returnFiber, current2, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
              // because these cannot be automatically converted to an arrow function
              // using a codemod. Therefore, we don't have to warn about string refs again.
              !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
              !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
              !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
              element._owner) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                return current2.ref;
              }
              var ref = function(value2) {
                var refs = resolvedInst.refs;
                if (value2 === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value2;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init = lazyType._init;
          return init(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone = createWorkInProgress(fiber, pendingProps);
            clone.index = 0;
            clone.sibling = null;
            return clone;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current2 = newFiber.alternate;
            if (current2 !== null) {
              var oldIndex = current2.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (current2 === null || current2.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
            }
            if (current2 !== null) {
              if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
              isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                var existing = useFiber(current2, element.props);
                existing.ref = coerceRef(returnFiber, current2, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current2, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current2, fragment, lanes, key) {
            if (current2 === null || current2.tag !== Fragment9) {
              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, fragment);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return createChild(returnFiber, init(payload), lanes);
                }
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                }
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                if (key !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key = child.key;
                  if (typeof key !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key);
                    break;
                  }
                  if (!knownKeys.has(key)) {
                    knownKeys.add(key);
                    break;
                  }
                  error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", key);
                  break;
                case REACT_LAZY_TYPE:
                  var payload = child._payload;
                  var init = child._init;
                  warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i10 = 0; i10 < newChildren.length; i10++) {
                var child = newChildren[i10];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
              newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                  if (child.tag === Fragment9) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                  // We need to do this after the Hot Reloading check above,
                  // because hot reloading has different semantics than prod because
                  // it doesn't resuspend. So we can't let the call below suspend.
                  typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element.props);
                    _existing.ref = coerceRef(returnFiber, child, element);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element._source;
                      _existing._debugOwner = element._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
              }
              if (isArray(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current2, workInProgress2) {
          if (current2 !== null && workInProgress2.child !== current2.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context, nextValue) {
          {
            push(valueCursor, context._currentValue, providerFiber);
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context, providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          {
            {
              context._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          var node = parent;
          while (node !== null) {
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
              node.childLanes = mergeLanes(node.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node === propagationRoot) {
              break;
            }
            node = node.return;
          }
          {
            if (node !== propagationRoot) {
              error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list = fiber.dependencies;
            if (list !== null) {
              nextFiber = fiber.child;
              var dependency = list.firstContext;
              while (dependency !== null) {
                if (dependency.context === context) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update = createUpdate(NoTimestamp, lane);
                    update.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null) ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update.next = update;
                      } else {
                        update.next = pending.next;
                        pending.next = update;
                      }
                      sharedQueue.pending = update;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list.lanes = mergeLanes(list.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context) {
          {
            if (isDisallowedContextReadInDEV) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value2 = context._currentValue;
          if (lastFullyObservedContext === context) ;
          else {
            var contextItem = {
              context,
              memoizedValue: value2,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value2;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue];
          } else {
            concurrentQueues.push(queue);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i10 = 0; i10 < concurrentQueues.length; i10++) {
              var queue = concurrentQueues[i10];
              var lastInterleavedUpdate = queue.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue.interleaved = update;
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node = parent;
            parent = parent.return;
          }
          if (node.tag === HostRoot) {
            var root2 = node.stateNode;
            return root2;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          var queue = workInProgress2.updateQueue;
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var clone = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone;
          }
        }
        function createUpdate(eventTime, lane) {
          var update = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update;
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
          }
        }
        function entangleTransitions(root2, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update = firstBaseUpdate;
                do {
                  var clone = {
                    eventTime: update.eventTime,
                    lane: update.lane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone;
                  } else {
                    newLast.next = clone;
                    newLast = clone;
                  }
                  update = update.next;
                } while (update !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue;
              return;
            }
          }
          var lastBaseUpdate = queue.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
          switch (update.tag) {
            case ReplaceState: {
              var payload = update.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            // Intentional fallthrough
            case UpdateState: {
              var _payload = update.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue.shared;
          }
          var firstBaseUpdate = queue.firstBaseUpdate;
          var lastBaseUpdate = queue.lastBaseUpdate;
          var pendingQueue = queue.shared.pending;
          if (pendingQueue !== null) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
              var updateLane = update.lane;
              var updateEventTime = update.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                var callback = update.callback;
                if (callback !== null && // If the update was already committed, we should not queue its
                // callback again.
                update.lane !== NoLane) {
                  workInProgress2.flags |= Callback;
                  var effects = queue.effects;
                  if (effects === null) {
                    queue.effects = [update];
                  } else {
                    effects.push(update);
                  }
                }
              }
              update = update.next;
              if (update === null) {
                pendingQueue = queue.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update = _firstPendingUpdate;
                  queue.lastBaseUpdate = _lastPendingUpdate;
                  queue.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i10 = 0; i10 < effects.length; i10++) {
              var effect = effects[i10];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
              }
            }
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c) {
          if (c === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context = requiredContext(contextStackCursor$1.current);
          return context;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context, fiber.type);
          if (context === nextContext) {
            return;
          }
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node = row;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node;
                }
              }
            } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
            // keep track of whether it suspended or not.
            node.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) {
              return null;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === row) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var NoFlags$1 = (
          /*   */
          0
        );
        var HasEffect = (
          /* */
          1
        );
        var Insertion = (
          /*  */
          2
        );
        var Layout = (
          /*    */
          4
        );
        var Passive$1 = (
          /*   */
          8
        );
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i10 = 0; i10 < workInProgressSources.length; i10++) {
            var mutableSource = workInProgressSources[i10];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root2, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version2 = getVersion(mutableSource._source);
          if (root2.mutableSourceEagerHydrationData == null) {
            root2.mutableSourceEagerHydrationData = [mutableSource, version2];
          } else {
            root2.mutableSourceEagerHydrationData.push(mutableSource, version2);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray(deps)) {
              error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table = "";
                var secondColumnStart = 30;
                for (var i10 = 0; i10 <= hookTypesUpdateIndexDev; i10++) {
                  var oldHookName = hookTypesDev[i10];
                  var newHookName = i10 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i10 + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table += row;
                }
                error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i10 = 0; i10 < prevDeps.length && i10 < nextDeps.length; i10++) {
            if (objectIs(nextDeps[i10], prevDeps[i10])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current2 !== null && current2.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component(props, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component(props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
            // and creates false positives. To make this work in legacy mode, we'd
            // need to mark fibers that commit in an incomplete state, somehow. For
            // now I'll disable the warning that most of the bugs that would trigger
            // it are either exclusive to concurrent mode or exist in both.
            (current2.mode & ConcurrentMode) !== NoMode) {
              error2("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current2.lanes = removeLanes(current2.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue = hook.queue;
              if (queue !== null) {
                queue.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current2 = currentlyRenderingFiber$1.alternate;
            if (current2 !== null) {
              nextCurrentHook = current2.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init !== void 0) {
            initialState = init(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var current2 = currentHook;
          var baseQueue = current2.baseQueue;
          var pendingQueue = queue.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current2.baseQueue !== baseQueue) {
                error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current2.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first;
            do {
              var updateLane = update.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone = {
                  lane: updateLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update.hasEagerState) {
                  newState = update.eagerState;
                } else {
                  var action = update.action;
                  newState = reducer(newState, action);
                }
              }
              update = update.next;
            } while (update !== null && update !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
          }
          var lastInterleaved = queue.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue.lanes = NoLanes;
          }
          var dispatch = queue.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch;
          var lastRenderPhaseUpdate = queue.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
              var action = update.action;
              newState = reducer(newState, action);
              update = update.next;
            } while (update !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountMutableSource(source, getSnapshot, subscribe2) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source, getSnapshot, subscribe2) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe2), [subscribe2]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe2), [subscribe2]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
          // checking whether we scheduled a subscription effect above.
          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check2 = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check2];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check2];
            } else {
              stores.push(check2);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe2) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe2(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create, destroy, deps) {
          var effect = {
            tag,
            create,
            destroy,
            deps,
            // Circular
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
        }
        function mountEffect(create, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
          }
        }
        function updateEffect(create, deps) {
          return updateEffectImpl(Passive, Passive$1, create, deps);
        }
        function mountInsertionEffect(create, deps) {
          return mountEffectImpl(Update, Insertion, create, deps);
        }
        function updateInsertionEffect(create, deps) {
          return updateEffectImpl(Update, Insertion, create, deps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function updateLayoutEffect(create, deps) {
          return updateEffectImpl(Update, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value2, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value2) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value2;
          return value2;
        }
        function updateDeferredValue(value2) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value2);
        }
        function rerenderDeferredValue(value2) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value2;
            return value2;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value2);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value2) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value2, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value2;
            return value2;
          }
        }
        function startTransition(setPending, callback, options2) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start;
          return [isPending, start];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root2 = getWorkInProgressRoot();
          var identifierPrefix = root2.identifierPrefix;
          var id2;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id2 = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id2 += "H" + localId.toString(32);
            }
            id2 += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id2 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id2;
          return id2;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id2 = hook.memoizedState;
          return id2;
        }
        function dispatchReducerAction(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update);
          } else {
            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update.hasEagerState = true;
                  update.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                    return;
                  }
                } catch (error3) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe2, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe2, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe2, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value2, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value2) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value2);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe2) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe2, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  root2.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  if (root2 !== null) {
                    root2.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        var didWarnAboutLegacyContext$1;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type2, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type2) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get2(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get2(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get2(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if (typeof instance.shouldComponentUpdate === "function") {
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance = workInProgress2.stateNode;
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
              // this one.
              (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                didWarnAboutLegacyContext$1.add(ctor);
                error2("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name);
              }
              if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
              // this one.
              (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                didWarnAboutLegacyContext$1.add(ctor);
                error2("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name);
              }
              if (instance.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error2("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance) {
          instance.updater = classComponentUpdater;
          workInProgress2.stateNode = instance;
          set(instance, workInProgress2);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance = new ctor(props, context);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance = new ctor(props, context);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
          adoptClassInstance(workInProgress2, instance);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return instance;
        }
        function callComponentWillMount(workInProgress2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (typeof instance.componentWillReceiveProps === "function") {
            instance.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance = workInProgress2.stateNode;
          instance.props = newProps;
          instance.state = workInProgress2.memoizedState;
          instance.refs = {};
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
            }
          }
          instance.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance);
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance.props = oldProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              if (typeof instance.componentWillMount === "function") {
                instance.componentWillMount();
              }
              if (typeof instance.UNSAFE_componentWillMount === "function") {
                instance.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
          // both before and after `shouldComponentUpdate` has been called. Not ideal,
          // but I'm loath to refactor this function. This only happens for memoized
          // components so it's not that common.
          enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
              if (typeof instance.componentWillUpdate === "function") {
                instance.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function createCapturedValueAtFiber(value2, source) {
          return {
            value: value2,
            source,
            stack: getStackByFiberInDevAndProd(source),
            digest: null
          };
        }
        function createCapturedValue(value2, digest, stack) {
          return {
            value: value2,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest != null ? digest : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error3 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error3 != null && error3._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error3);
              }
              var componentName = source ? getComponentNameFromFiber(source) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error3);
            }
          } catch (e10) {
            setTimeout(function() {
              throw e10;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          update.payload = {
            element: null
          };
          var error3 = errorInfo.value;
          update.callback = function() {
            onUncaughtError(error3);
            logCapturedError(fiber, errorInfo);
          };
          return update;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update;
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root2.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node = returnFiber;
          do {
            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
              return node;
            }
            node = node.return;
          } while (node !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update = createUpdate(NoTimestamp, SyncLane);
                  update.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root2, returnFiber, sourceFiber, value2, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root2, rootRenderLanes);
            }
          }
          if (value2 !== null && typeof value2 === "object" && typeof value2.then === "function") {
            var wakeable = value2;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root2, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root2, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root2, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value2 = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value2, sourceFiber));
                return;
              }
            }
          }
          value2 = createCapturedValueAtFiber(value2, sourceFiber);
          renderDidError(value2);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value2;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update);
                return;
              }
              case ClassComponent:
                var errorInfo = value2;
                var ctor = workInProgress2.type;
                var instance = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        var didWarnAboutDefaultPropsOnFunctionComponent;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
          didWarnAboutDefaultPropsOnFunctionComponent = {};
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          if (current2 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var render2 = Component.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (current2 === null) {
            var type2 = Component.type;
            if (isSimpleFunctionComponent(type2) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
            Component.defaultProps === void 0) {
              var resolvedType = type2;
              {
                resolvedType = resolveFunctionForHotReloading(type2);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type2);
              }
              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(type2)
                );
              }
              if (Component.defaultProps !== void 0) {
                var componentName = getComponentNameFromType(type2) || "Unknown";
                if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                  error2("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                  didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                }
              }
            }
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(
                _innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(_type)
              );
            }
          }
          var currentChild = current2.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual;
            if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  outerMemoType = init(payload);
                } catch (x) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    nextProps,
                    // Resolved (SimpleMemoComponent has no defaultProps)
                    "prop",
                    getComponentNameFromType(outerMemoType)
                  );
                }
              }
            }
          }
          if (current2 !== null) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
            workInProgress2.type === current2.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                workInProgress2.lanes = current2.lanes;
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current2 !== null ? current2.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current2, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current2 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
          markRef(current2, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, false);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var instance = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current2 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root2 = workInProgress2.stateNode;
          if (root2.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
          } else if (root2.context) {
            pushTopLevelContextObject(workInProgress2, root2.context, false);
          }
          pushHostContainer(workInProgress2, root2.containerInfo);
        }
        function updateHostRoot(current2, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current2 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current2, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root2 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current2, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type2 = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current2 !== null ? current2.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type2, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type2, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current2, workInProgress2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current2, workInProgress2) {
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          workInProgress2.type = Component;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
          var resolvedProps = resolveDefaultProps(Component, props);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component);
                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
              }
              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component = resolveClassForHotReloading(Component);
              }
              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
              }
              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      resolvedProps,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(Component)
                    );
                  }
                }
              }
              child = updateMemoComponent(
                null,
                workInProgress2,
                Component,
                resolveDefaultProps(Component.type, resolvedProps),
                // The inner type can have defaults too
                renderLanes2
              );
              return child;
            }
          }
          var hint = "";
          {
            if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value2;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value2 = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value2.state !== null && value2.state !== void 0 ? value2.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value2);
            mountClassInstance(workInProgress2, Component, props, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value2 = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value2, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error2("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            var suspenseState = current2.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
          return removeLanes(current2.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend2(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current2 === null || current2.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current2.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
          return createWorkInProgress(current2, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if (
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
            // already cloned. In legacy mode, the only case where this isn't true is
            // when DevTools forces us to display a fallback; we skip the first render
            // pass entirely and go straight to rendering the fallback. (In Concurrent
            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
            // only codepath.)
            workInProgress2.child !== currentPrimaryChildFragment
          ) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2,
                // TODO: When we delete legacy mode, we should make this error argument
                // required — every concurrent mode path that causes hydration to
                // de-opt to client rendering should have an error message.
                null
              );
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest, message, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest = _getSuspenseInstanceF.digest;
                message = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error3;
              if (message) {
                error3 = new Error(message);
              } else {
                error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error3, digest, stack);
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root2 = getWorkInProgressRoot();
              if (root2 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current2.child;
              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
              registerSuspenseInstanceRetry(suspenseInstance, retry);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current2.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node = firstChild;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              }
            } else if (node.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index3) {
          {
            var isAnArray = isArray(childSlot);
            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable) {
              var type2 = isAnArray ? "array" : "iterable";
              error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type2, index3, type2);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray(children)) {
                for (var i10 = 0; i10 < children.length; i10++) {
                  if (!validateSuspenseListNestedChild(children[i10], i10)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i2 = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i2)) {
                        return;
                      }
                      _i2++;
                    }
                  }
                } else {
                  error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  tail,
                  lastContentRow,
                  tailMode
                );
                break;
              }
              case "backwards": {
                var _tail2 = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail2;
                  _tail2 = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  // isBackwards
                  _tail2,
                  null,
                  // last
                  tailMode
                );
                break;
              }
              case "together": {
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  null,
                  // tail
                  null,
                  // last
                  void 0
                );
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current2, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current2 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current2, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current2, workInProgress2, renderLanes2) {
          var context = workInProgress2.type;
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render2 = newProps.children;
          {
            if (typeof render2 !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render2(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current2 !== null) {
              current2.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            workInProgress2.dependencies = current2.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current2, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current2.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current2];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current2);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          var updateLanes = current2.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root2 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context = workInProgress2.type._context;
              pushProvider(workInProgress2, context, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state = workInProgress2.memoizedState;
              if (state !== null) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current2 !== null) {
              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current2 !== null) {
            var oldProps = current2.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
            workInProgress2.type !== current2.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
              // may not be work scheduled on `current`, so we check for this flag.
              (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
              }
              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current2, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current2, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current2, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current2, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type2 = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type2 ? _unresolvedProps2 : resolveDefaultProps(type2, _unresolvedProps2);
              return updateForwardRef(current2, workInProgress2, type2, _resolvedProps2, renderLanes2);
            }
            case Fragment9:
              return updateFragment(current2, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current2, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current2, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current2, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current2, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      _resolvedProps3,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(_type2)
                    );
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden2) {
            var node = workInProgress2.child;
            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node.stateNode);
              } else if (node.tag === HostPortal) ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          };
          updateHostContainer = function(current2, workInProgress2) {
          };
          updateHostComponent$1 = function(current2, workInProgress2, type2, newProps, rootContainerInstance) {
            var oldProps = current2.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type2, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current2 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment9:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current2 === null || current2.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current2 !== null) {
                    var prevState = current2.memoizedState;
                    if (
                      // Check if this is a client root
                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                      (workInProgress2.flags & ForceClientRender) !== NoFlags
                    ) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type2 = workInProgress2.type;
              if (current2 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current2, workInProgress2, type2, newProps, rootContainerInstance);
                if (current2.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance = createInstance(type2, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance, workInProgress2, false, false);
                  workInProgress2.stateNode = instance;
                  if (finalizeInitialChildren(instance, type2, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current2 && workInProgress2.stateNode != null) {
                var oldText = current2.memoizedProps;
                updateHostText$1(current2, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current2, workInProgress2);
              if (current2 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (
                    // The time it took to render last row is greater than the remaining
                    // time we have to render. So rendering one more row would likely
                    // exceed it.
                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                  ) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next = renderState.tail;
                renderState.rendering = next;
                renderState.tail = next.sibling;
                renderState.renderingStartTime = now();
                next.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current2 !== null) {
                var _prevState = current2.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
                !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current2, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root2 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root2 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context = interruptedWork.type._context;
              popProvider(context, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error3) {
          {
            invokeGuardedCallback(null, function() {
              throw error3;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current2, instance) {
          instance.props = current2.memoizedProps;
          instance.state = current2.memoizedState;
          if (current2.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current2);
            }
          } else {
            instance.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout, current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          try {
            callComponentWillUnmountWithTimer(current2, instance);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
          try {
            instance.componentDidMount();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            commitAttachRef(current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(null);
                  } finally {
                    recordLayoutEffectDuration(current2);
                  }
                } else {
                  retVal = ref(null);
                }
              } catch (error3) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error3);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root2, firstChild) {
          focusedInstanceHandle = prepareForCommit(root2.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current2 !== null) {
                  var prevProps = current2.memoizedProps;
                  var prevState = current2.memoizedState;
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root2 = finishedWork.stateNode;
                  clearContainer(root2.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create = effect.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect.destroy = create();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect.tag & Layout) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id2 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id2, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer: while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root2 = parentFiber.stateNode;
                        root2.passiveEffectDuration += passiveEffectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.passiveEffectDuration += passiveEffectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current2 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                      var prevState = current2.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type2 = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type2, props);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current2 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer: while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root2 = parentFiber.stateNode;
                          root2.effectDuration += effectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.effectDuration += effectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node) {
          switch (node.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (node.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                } finally {
                  recordLayoutEffectDuration(node);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              }
              break;
            }
            case ClassComponent: {
              var instance = node.stateNode;
              if (typeof instance.componentDidMount === "function") {
                safelyCallComponentDidMount(node, node.return, instance);
              }
              safelyAttachRef(node, node.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node, node.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden2) {
          var hostSubtreeRoot = null;
          {
            var node = finishedWork;
            while (true) {
              if (node.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node;
                  try {
                    var instance = node.stateNode;
                    if (isHidden2) {
                      hideInstance(instance);
                    } else {
                      unhideInstance(node.stateNode, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if (node.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node.stateNode;
                    if (isHidden2) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === finishedWork) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node = node.return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance);
                break;
              default:
                instanceToUse = instance;
            }
            if (typeof ref === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node = fiber;
          siblings: while (true) {
            while (node.sibling === null) {
              if (node.return === null || isHostParent(node.return)) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
            while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
              if (node.flags & Placement) {
                continue siblings;
              }
              if (node.child === null || node.tag === HostPortal) {
                continue siblings;
              } else {
                node.child.return = node;
                node = node.child;
              }
            }
            if (!(node.flags & Placement)) {
              return node.stateNode;
            }
          }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent);
                parentFiber.flags &= ~ContentReset;
              }
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            // eslint-disable-next-line-no-fallthrough
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal) ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal) ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root2, returnFiber, deletedFiber) {
          {
            var parent = returnFiber;
            findParent: while (parent !== null) {
              switch (parent.tag) {
                case HostComponent: {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break findParent;
                }
                case HostRoot: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break findParent;
                }
                case HostPortal: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break findParent;
                }
              }
              parent = parent.return;
            }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          var child = parent.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            // eslint-disable-next-line-no-fallthrough
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance = deletedFiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (
                // TODO: Remove this dead flag
                deletedFiber.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function commitMutationEffects(root2, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root2);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i10 = 0; i10 < deletions.length; i10++) {
              var childToDelete = deletions[i10];
              try {
                commitDeletionEffects(root2, parentFiber, childToDelete);
              } catch (error3) {
                captureCommitPhaseError(childToDelete, parentFiber, error3);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root2);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance = finishedWork.stateNode;
                  try {
                    resetTextContent(instance);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                    var type2 = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type2, oldProps, newProps, finishedWork);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current2 !== null ? current2.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current2 !== null) {
                    var prevRootState = current2.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root2.containerInfo);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden2 = newState !== null;
                offscreenInstance.isHidden = isHidden2;
                if (isHidden2) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current2 !== null && current2.memoizedState !== null;
              if (
                // TODO: Remove this dead flag
                finishedWork.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root2, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root2, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error3) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error3);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root2, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root2, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden2 = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden2 || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              } else {
                var current2 = fiber.alternate;
                var wasHidden = current2 !== null && current2.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(
                    child,
                    // New root; bubble back up to here and stop.
                    root2,
                    committedLanes
                  );
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current2 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden2 = fiber.memoizedState !== null;
                if (isHidden2) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden2 = fiber.memoizedState !== null;
              if (isHidden2) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i10 = 0; i10 < deletions.length; i10++) {
                  var fiberToDelete = deletions[i10];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
          switch (current2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (current2.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                recordPassiveEffectDuration(current2);
              } else {
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                try {
                  instance.componentDidMount();
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error2("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = (
          /*             */
          0
        );
        var BatchedContext = (
          /*               */
          1
        );
        var RenderContext = (
          /*                */
          2
        );
        var CommitContext = (
          /*                */
          4
        );
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error2("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root2, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root2, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root2 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
          var current2 = root2.current;
          current2.lanes = lane;
          markRootUpdated(root2, lane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (
            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
            // decided not to enable it.
            (executionContext & RenderContext) !== NoContext
          );
        }
        function ensureRootIsScheduled(root2, currentTime) {
          var existingCallbackNode = root2.callbackNode;
          markStarvedLanesAsExpired(root2, currentTime);
          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root2.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
          // Scheduler task, rather than an `act` task, cancel it and re-scheduled
          // on the `act` queue.
          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root2.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
          }
          root2.callbackPriority = newCallbackPriority;
          root2.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root2, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root2.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root2.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root2, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root2, lanes);
              var finishedWork = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root2, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root2, NoLanes);
                  markRootSuspended$1(root2, lanes);
                  ensureRootIsScheduled(root2, now());
                  throw _fatalError;
                }
              }
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root2, now());
          if (root2.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root2);
          }
          return null;
        }
        function recoverFromConcurrentError(root2, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root2)) {
            var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root2.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root2, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
          }
        }
        function finishConcurrentRender(root2, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            // Flow knows about invariant, so it complains if I add a break
            // statement, but eslint doesn't know about invariant, so it complains
            // if I do. eslint-disable-next-line no-fallthrough
            case RootErrored: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
              !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root2, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root2.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root2, suspendedLanes);
                    break;
                  }
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node = finishedWork;
          while (true) {
            if (node.flags & StoreConsistency) {
              var updateQueue = node.updateQueue;
              if (updateQueue !== null) {
                var checks = updateQueue.stores;
                if (checks !== null) {
                  for (var i10 = 0; i10 < checks.length; i10++) {
                    var check2 = checks[i10];
                    var getSnapshot = check2.getSnapshot;
                    var renderedValue = check2.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error3) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node.child;
            if (node.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node;
              node = child;
              continue;
            }
            if (node === finishedWork) {
              return true;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return true;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root2, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root2, suspendedLanes);
        }
        function performSyncWorkOnRoot(root2) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root2, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root2, now());
            return null;
          }
          var exitStatus = renderRootSync(root2, lanes);
          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root2.current.alternate;
          root2.finishedWork = finishedWork;
          root2.finishedLanes = lanes;
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root2, now());
          return null;
        }
        function flushRoot(root2, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root2, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root2, now());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn2, a10) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn2(a10);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn2, a10, b, c, d6) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn2(a10, b, c, d6);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync4(fn2) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn2) {
              return fn2();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root2, lanes) {
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          var timeoutHandle = root2.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root2.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current2 = interruptedWork.alternate;
              unwindInterruptedWork(current2, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root2;
          var rootWorkInProgress = createWorkInProgress(root2.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root2, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error3) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error3];
          } else {
            workInProgressRootConcurrentErrors.push(error3);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current2 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next = completeWork(current2, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next = completeWork(current2, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next !== null) {
                workInProgress = next;
                return;
              }
            } else {
              var _next2 = unwindWork(current2, completedWork);
              if (_next2 !== null) {
                _next2.flags &= HostEffectMask;
                workInProgress = _next2;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root2, recoverableErrors, transitions) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root2.finishedWork;
          var lanes = root2.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          if (finishedWork === root2.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root2.callbackNode = null;
          root2.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root2, remainingLanes);
          if (root2 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root2, finishedWork, lanes);
            resetAfterCommit(root2.containerInfo);
            root2.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root2, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root2.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root2;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root2.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root2.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root2.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root2, now());
          if (recoverableErrors !== null) {
            var onRecoverableError = root2.onRecoverableError;
            for (var i10 = 0; i10 < recoverableErrors.length; i10++) {
              var recoverableError = recoverableErrors[i10];
              var componentStack = recoverableError.stack;
              var digest = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root2.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root2 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root2;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root2 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root2.current);
          commitPassiveMountEffects(root2, root2.current, lanes, transitions);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i10 = 0; i10 < profilerEffects.length; i10++) {
              var _fiber = profilerEffects[i10];
              commitPassiveEffectDurations(root2, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root2.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root2 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root2;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root2);
          {
            var stateNode = root2.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance);
          }
        }
        function prepareToThrowUncaughtError(error3) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error3;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
          var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root2 = enqueueUpdate(rootFiber, update, SyncLane);
          var eventTime = requestEventTime();
          if (root2 !== null) {
            markRootUpdated(root2, SyncLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root2 = enqueueUpdate(fiber, update, SyncLane);
                var eventTime = requestEventTime();
                if (root2 !== null) {
                  markRootUpdated(root2, SyncLane, eventTime);
                  ensureRootIsScheduled(root2, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root2, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root2, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root2 !== null) {
            markRootUpdated(root2, retryLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current2 = firstChild;
            var subtreeRoot = null;
            while (current2 !== null) {
              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                current2 = current2.child;
              } else {
                if ((current2.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current2);
                }
                if (current2.sibling !== null) {
                  current2 = current2.sibling;
                } else {
                  current2 = subtreeRoot = current2.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current2, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current2, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current2, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root2, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
          {
            if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type2) {
          {
            if (resolveFamily === null) {
              return type2;
            }
            var family = resolveFamily(type2);
            if (family === void 0) {
              return type2;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type2) {
          return resolveFunctionForHotReloading(type2);
        }
        function resolveForwardRefForHotReloading(type2) {
          {
            if (resolveFamily === null) {
              return type2;
            }
            var family = resolveFamily(type2);
            if (family === void 0) {
              if (type2 !== null && type2 !== void 0 && typeof type2.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type2.render);
                if (type2.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type2.displayName !== void 0) {
                    syntheticType.displayName = type2.displayName;
                  }
                  return syntheticType;
                }
              }
              return type2;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root2, update) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
            flushPassiveEffects();
            flushSync4(function() {
              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root2, element) {
          {
            if (root2.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync4(function() {
              updateContainer(element, root2, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type2;
                break;
              case ForwardRef:
                candidateType = type2.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root2, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type2;
                break;
              case ForwardRef:
                candidateType = type2.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node = fiber;
            while (true) {
              switch (node.tag) {
                case HostComponent:
                  hostInstances.add(node.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
              }
              if (node.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node = node.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node.stateNode);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return foundHostInstances;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === fiber) {
                  return foundHostInstances;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e10) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        };
        function shouldConstruct$1(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type2) {
          return typeof type2 === "function" && !shouldConstruct$1(type2) && type2.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component) {
          if (typeof Component === "function") {
            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
          } else if (Component !== void 0 && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
            workInProgress2.elementType = current2.elementType;
            workInProgress2.type = current2.type;
            workInProgress2.stateNode = current2.stateNode;
            {
              workInProgress2._debugSource = current2._debugSource;
              workInProgress2._debugOwner = current2._debugOwner;
              workInProgress2._debugHookTypes = current2._debugHookTypes;
            }
            workInProgress2.alternate = current2;
            current2.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current2.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current2.flags & StaticMask;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current2.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current2 = workInProgress2.alternate;
          if (current2 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.type = current2.type;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type2, key, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type2;
          if (typeof type2 === "function") {
            if (shouldConstruct$1(type2)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type2 === "string") {
            fiberTag = HostComponent;
          } else {
            getTag: switch (type2) {
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
              case REACT_STRICT_MODE_TYPE:
                fiberTag = Mode;
                mode |= StrictLegacyMode;
                if ((mode & ConcurrentMode) !== NoMode) {
                  mode |= StrictEffectsMode;
                }
                break;
              case REACT_PROFILER_TYPE:
                return createFiberFromProfiler(pendingProps, mode, lanes, key);
              case REACT_SUSPENSE_TYPE:
                return createFiberFromSuspense(pendingProps, mode, lanes, key);
              case REACT_SUSPENSE_LIST_TYPE:
                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
              case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
              case REACT_LEGACY_HIDDEN_TYPE:
              // eslint-disable-next-line no-fallthrough
              case REACT_SCOPE_TYPE:
              // eslint-disable-next-line no-fallthrough
              case REACT_CACHE_TYPE:
              // eslint-disable-next-line no-fallthrough
              case REACT_TRACING_MARKER_TYPE:
              // eslint-disable-next-line no-fallthrough
              case REACT_DEBUG_TRACING_MODE_TYPE:
              // eslint-disable-next-line no-fallthrough
              default: {
                if (typeof type2 === "object" && type2 !== null) {
                  switch (type2.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;
                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef;
                      {
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      }
                      break getTag;
                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;
                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }
                var info = "";
                {
                  if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                    info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                  }
                  var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                  if (ownerName) {
                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                  }
                }
                throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
              }
            }
          }
          var fiber = createFiber(fiberTag, pendingProps, key, mode);
          fiber.elementType = type2;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type2 = element.type;
          var key = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type2, key, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          var fiber = createFiber(Fragment9, elements, key, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key) {
          {
            if (typeof pendingProps.id !== "string") {
              error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content4, mode, lanes) {
          var fiber = createFiber(HostText, content4, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.subtreeFlags = source.subtreeFlags;
          target.deletions = source.deletions;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate3, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i2 = 0; _i2 < TotalLanes; _i2++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate3 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate3 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate3, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root2 = new FiberRootNode(containerInfo, tag, hydrate3, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root2.current = uninitializedFiber;
          uninitializedFiber.stateNode = root2;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate3,
              cache: null,
              // not enabled yet
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root2;
        }
        var ReactVersion = "18.3.1";
        function createPortal(children, containerInfo, implementation) {
          var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key);
          }
          return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE,
            key: key == null ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get2(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) {
              return processChildContext(fiber, Component, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get2(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys = Object.keys(component).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate3 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate3, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate3 = true;
          var root2 = createFiberRoot(containerInfo, tag, hydrate3, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root2.context = getContextForSubtree(null);
          var current2 = root2.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current2);
          var update = createUpdate(eventTime, lane);
          update.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current2, update, lane);
          scheduleInitialHydrationOnRoot(root2, lane, eventTime);
          return root2;
        }
        function updateContainer(element, container8, parentComponent, callback) {
          {
            onScheduleRoot(container8, element);
          }
          var current$1 = container8.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context = getContextForSubtree(parentComponent);
          if (container8.context === null) {
            container8.context = context;
          } else {
            container8.pendingContext = context;
          }
          {
            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
            }
          }
          var update = createUpdate(eventTime, lane);
          update.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(current$1, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
            entangleTransitions(root2, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container8) {
          var containerFiber = container8.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root2 = fiber.stateNode;
              if (isRootDehydrated(root2)) {
                var lanes = getHighestPriorityPendingLanes(root2);
                flushRoot(root2, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync4(function() {
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend2(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path, index3) {
            var key = path[index3];
            var updated = isArray(obj) ? obj.slice() : assign({}, obj);
            if (index3 + 1 === path.length) {
              if (isArray(updated)) {
                updated.splice(key, 1);
              } else {
                delete updated[key];
              }
              return updated;
            }
            updated[key] = copyWithDeleteImpl(obj[key], path, index3 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path) {
            return copyWithDeleteImpl(obj, path, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
            var oldKey = oldPath[index3];
            var updated = isArray(obj) ? obj.slice() : assign({}, obj);
            if (index3 + 1 === oldPath.length) {
              var newKey = newPath[index3];
              updated[newKey] = updated[oldKey];
              if (isArray(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(
                // $FlowFixMe number or string is fine here
                obj[oldKey],
                oldPath,
                newPath,
                index3 + 1
              );
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i10 = 0; i10 < newPath.length - 1; i10++) {
                if (oldPath[i10] !== newPath[i10]) {
                  warn("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path, index3, value2) {
            if (index3 >= path.length) {
              return value2;
            }
            var key = path[index3];
            var updated = isArray(obj) ? obj.slice() : assign({}, obj);
            updated[key] = copyWithSetImpl(obj[key], path, index3 + 1, value2);
            return updated;
          };
          var copyWithSet = function(obj, path, value2) {
            return copyWithSetImpl(obj, path, 0, value2);
          };
          var findHook = function(fiber, id2) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id2 > 0) {
              currentHook2 = currentHook2.next;
              id2--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id2, path, value2) {
            var hook = findHook(fiber, id2);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path, value2);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id2, path) {
            var hook = findHook(fiber, id2);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id2, oldPath, newPath) {
            var hook = findHook(fiber, id2);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path, value2) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value2);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools,
            // Enables DevTools to detect reconciler version rather than renderer version
            // which may not match for third party renderers.
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? (
          // In modern browsers, reportError will dispatch an error event,
          // emulating an uncaught JavaScript error.
          reportError
        ) : function(error3) {
          console["error"](error3);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (root2 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error2("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container8 = root2.containerInfo;
            if (container8.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root2.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container8) {
                  error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root2 = this._internalRoot;
          if (root2 !== null) {
            this._internalRoot = null;
            var container8 = root2.containerInfo;
            {
              if (isAlreadyRendering()) {
                error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync4(function() {
              updateContainer(null, root2, null, null);
            });
            unmarkContainerAsRoot(container8);
          }
        };
        function createRoot(container8, options2) {
          if (!isValidContainer(container8)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container8);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options2 !== null && options2 !== void 0) {
            {
              if (options2.hydrate) {
                warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                  error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
            if (options2.transitionCallbacks !== void 0) {
              transitionCallbacks = options2.transitionCallbacks;
            }
          }
          var root2 = createContainer(container8, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container8);
          var rootContainerElement = container8.nodeType === COMMENT_NODE ? container8.parentNode : container8;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root2);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container8, initialChildren, options2) {
          if (!isValidContainer(container8)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container8);
          {
            if (initialChildren === void 0) {
              error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options2 != null ? options2 : null;
          var mutableSources = options2 != null && options2.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options2 !== null && options2 !== void 0) {
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
          }
          var root2 = createHydrationContainer(initialChildren, null, container8, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container8);
          listenToAllSupportedEvents(container8);
          if (mutableSources) {
            for (var i10 = 0; i10 < mutableSources.length; i10++) {
              var mutableSource = mutableSources[i10];
              registerMutableSourceForHydration(root2, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root2);
        }
        function isValidContainer(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container8) {
          {
            if (container8.nodeType === ELEMENT_NODE && container8.tagName && container8.tagName.toUpperCase() === "BODY") {
              error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container8)) {
              if (container8._reactRootContainer) {
                error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container8) {
            if (container8._reactRootContainer && container8.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container8._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container8) {
                  error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container8._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container8);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container8.nodeType === ELEMENT_NODE && container8.tagName && container8.tagName.toUpperCase() === "BODY") {
              error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container8) {
          if (!container8) {
            return null;
          }
          if (container8.nodeType === DOCUMENT_NODE) {
            return container8.documentElement;
          } else {
            return container8.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container8, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            var root2 = createHydrationContainer(
              initialChildren,
              callback,
              container8,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container8._reactRootContainer = root2;
            markContainerAsRoot(root2.current, container8);
            var rootContainerElement = container8.nodeType === COMMENT_NODE ? container8.parentNode : container8;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync4();
            return root2;
          } else {
            var rootSibling;
            while (rootSibling = container8.lastChild) {
              container8.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(_root);
                _originalCallback.call(instance);
              };
            }
            var _root = createContainer(
              container8,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container8._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container8);
            var _rootContainerElement = container8.nodeType === COMMENT_NODE ? container8.parentNode : container8;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync4(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container8, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container8);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container8._reactRootContainer;
          var root2;
          if (!maybeRoot) {
            root2 = legacyCreateRootFromDOMContainer(container8, children, parentComponent, callback, forceHydrate);
          } else {
            root2 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            updateContainer(children, root2, parentComponent, callback);
          }
          return getPublicRootInstance(root2);
        }
        var didWarnAboutFindDOMNode = false;
        function findDOMNode(componentOrElement) {
          {
            if (!didWarnAboutFindDOMNode) {
              didWarnAboutFindDOMNode = true;
              error2("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
            }
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate2(element, container8, callback) {
          {
            error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container8)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container8) && container8._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container8, true, callback);
        }
        function render(element, container8, callback) {
          {
            error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container8)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container8) && container8._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container8, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          {
            error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        var didWarnAboutUnmountComponentAtNode = false;
        function unmountComponentAtNode(container8) {
          {
            if (!didWarnAboutUnmountComponentAtNode) {
              didWarnAboutUnmountComponentAtNode = true;
              error2("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
          }
          if (!isValidContainerLegacy(container8)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container8) && container8._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container8._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container8);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync4(function() {
              legacyRenderSubtreeIntoContainer(null, null, container8, false, function() {
                container8._reactRootContainer = null;
                unmarkContainerAsRoot(container8);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container8);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container8.nodeType === ELEMENT_NODE && isValidContainerLegacy(container8.parentNode) && !!container8.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
          Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
          Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync4);
        function createPortal$1(children, container8) {
          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container8)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal(children, container8, null, key);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          // Keep in sync with ReactTestUtils.js.
          // This is an array for better minification.
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container8, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot(container8, options2);
        }
        function hydrateRoot$1(container8, initialChildren, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container8, initialChildren, options2);
        }
        function flushSync$1(fn2) {
          {
            if (isAlreadyRendering()) {
              error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync4(fn2);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports2.createPortal = createPortal$1;
        exports2.createRoot = createRoot$1;
        exports2.findDOMNode = findDOMNode;
        exports2.flushSync = flushSync$1;
        exports2.hydrate = hydrate2;
        exports2.hydrateRoot = hydrateRoot$1;
        exports2.render = render;
        exports2.unmountComponentAtNode = unmountComponentAtNode;
        exports2.unstable_batchedUpdates = batchedUpdates$1;
        exports2.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports2.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "../node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      checkDCE();
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// ../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React47 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React47.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error2(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s10 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s10 >= 1 && c >= 0 && sampleLines[s10] !== controlLines[c]) {
                c--;
              }
              for (; s10 >= 1 && c >= 0; s10--, c--) {
                if (sampleLines[s10] !== controlLines[c]) {
                  if (s10 !== 1 || c !== 1) {
                    do {
                      s10--;
                      c--;
                      if (c < 0 || sampleLines[s10] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s10].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s10 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex2) {
                  error$1 = ex2;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a10) {
          return isArrayImpl(a10);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e10) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkKeyStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty3.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty3.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type2, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type2,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type2, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty3.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type2 && type2.defaultProps) {
              var defaultProps = type2.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type2, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement3(object2) {
          {
            return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i10 = 0; i10 < node.length; i10++) {
                var child = node[i10];
                if (isValidElement3(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement3(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement3(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type2 = element.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type2);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name3 = getComponentNameFromType(type2);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name3 || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i10 = 0; i10 < keys.length; i10++) {
              var key = keys[i10];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        var didWarnAboutKeySpread = {};
        function jsxWithValidation(type2, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type2);
            if (!validType) {
              var info = "";
              if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type2 === null) {
                typeString = "null";
              } else if (isArray(type2)) {
                typeString = "array";
              } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type2;
              }
              error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type2, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i10 = 0; i10 < children.length; i10++) {
                      validateChildKeys(children[i10], type2);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type2);
                }
              }
            }
            {
              if (hasOwnProperty3.call(props, "key")) {
                var componentName = getComponentNameFromType(type2);
                var keys = Object.keys(props).filter(function(k) {
                  return k !== "key";
                });
                var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
                if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                  var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                  error2('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                  didWarnAboutKeySpread[componentName + beforeExample] = true;
                }
              }
            }
            if (type2 === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type2, props, key) {
          {
            return jsxWithValidation(type2, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type2, props, key) {
          {
            return jsxWithValidation(type2, props, key, false);
          }
        }
        var jsx24 = jsxWithValidationDynamic;
        var jsxs10 = jsxWithValidationStatic;
        exports2.Fragment = REACT_FRAGMENT_TYPE;
        exports2.jsx = jsx24;
        exports2.jsxs = jsxs10;
      })();
    }
  }
});

// ../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../node_modules/poseidon-lite/poseidon/index.js
var require_poseidon = __commonJS({
  "../node_modules/poseidon-lite/poseidon/index.js"(exports2, module2) {
    "use strict";
    var F = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    var N_ROUNDS_F = 8;
    var N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var pow5 = (v10) => {
      let o10 = v10 * v10;
      return v10 * o10 * o10 % F;
    };
    function mix(state, M) {
      const out = [];
      for (let x = 0; x < state.length; x++) {
        let o10 = 0n;
        for (let y = 0; y < state.length; y++) {
          o10 = o10 + M[x][y] * state[y];
        }
        out.push(o10 % F);
      }
      return out;
    }
    function poseidon(_inputs, opt) {
      const inputs = _inputs.map((i10) => BigInt(i10));
      if (inputs.length <= 0) {
        throw new Error("poseidon-lite: Not enough inputs");
      }
      if (inputs.length > N_ROUNDS_P.length) {
        throw new Error("poseidon-lite: Too many inputs");
      }
      const t10 = inputs.length + 1;
      const nRoundsF = N_ROUNDS_F;
      const nRoundsP = N_ROUNDS_P[t10 - 2];
      const {
        C,
        M
      } = opt;
      if (M.length !== t10) {
        throw new Error(`poseidon-lite: Incorrect M length, expected ${t10} got ${M.length}`);
      }
      let state = [0n, ...inputs];
      for (let x = 0; x < nRoundsF + nRoundsP; x++) {
        for (let y = 0; y < state.length; y++) {
          state[y] = state[y] + C[x * t10 + y];
          if (x < nRoundsF / 2 || x >= nRoundsF / 2 + nRoundsP) state[y] = pow5(state[y]);
          else if (y === 0) state[y] = pow5(state[y]);
        }
        state = mix(state, M);
      }
      return state[0];
    }
    module2.exports = poseidon;
  }
});

// ../node_modules/poseidon-lite/poseidon/unstringify.js
var require_unstringify = __commonJS({
  "../node_modules/poseidon-lite/poseidon/unstringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = unstringifyBigInts;
    function unstringifyBigInts(o10) {
      if (Array.isArray(o10)) {
        return o10.map(unstringifyBigInts);
      } else if (typeof o10 == "object") {
        const res = {};
        for (const [key, val] of Object.entries(o10)) {
          res[key] = unstringifyBigInts(val);
        }
        return res;
      }
      const byteArray = Uint8Array.from(atob(o10), (c) => c.charCodeAt(0));
      const hex2 = [...byteArray].map((x) => x.toString(16).padStart(2, "0")).join("");
      return BigInt(`0x${hex2}`);
    }
  }
});

// ../node_modules/poseidon-lite/constants/1.js
var require__ = __commonJS({
  "../node_modules/poseidon-lite/constants/1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["CcRunsaOm9T+H6q6KUy6OKcaoXdTTN0bbH3A29Cr16c=", "DANWUwiW7sQql+2TfzE1z8UUKzrkBbg0PB2D/6YEy4E=", "Hiih2TVpitEULlEYK7VM9KAOpaq9Ymi9MX6pd8wVSjA=", "J68tgxqdJ0gICWXbMOKY5A5XV8PgCNuWTPnisSuRJR8=", "Hm8RzmD8j1E6ajz+Fq4XWkEpFGLyFM0Iear0NUW3TgM=", "Kmc4TTu9XkOFQYGctoHwvgRGLtFMNhPY9xkgYmjRQtM=", "C2b981YJOmEWCfjhL7/s8LmF44HwJRiJNkCPXVyfRdA=", "AS7j7B541HCDDGEJPCreNwsmyDzFzr7t2qaFLb2wniE=", "AlK6X2dgv739iPZ/gXXj/WzRxDGwmba7LRCOe0Rbsbk=", "F5R0zOyl/2dsa+w871QpY1Q5Gok1/3HW71rqrXypMvE=", "LCQmE3mlG/qSKP9KUD/U7Zwfl0omSWmzfholibvtK5E=", "HMHXtiaS5j6sLyiL0GlbQ8L2P1AB/A/FU+ZsBVGAGwU=", "JVBZMBqtqYuy7VX4UpeelgB4Tb8X+6zQXZ7/X9nJG1Y=", "KEN746wcsuR54fXA7M0ys66iQjSXCoGTsRwpzn5Z79k=", "KCFqRC8uH3EcpPprU3ZusRhUjaj7T3jUM4diw39fIEM=", "LB9HzRf6Wt8fOfTnBW3QP+7h784DCUWBEx8jdzI0gsk=", "B6utArel68SGMrzJNWzrfdna/KJ2Y4pjZGuFZqYhr8k=", "AjAmRgH/3yknWzP/qrUd/pQp+QiAppzRN9oMTRX5bDw=", "G8lzBU5R2QWg8WhlZJfKQKhkQUVX7iiecX5dZomaoKk=", "Lhwi+WRDUAggbDFX6GNB7dJJr/XC2EIfKmsiKI8KZ/w=", "EiTzjfZ8U3gSHB1fRhu8UJ6OoVmORsn3pwRSvCu6hrg=", "AuTmnYulnlGSgLS9ntAGj9e/6M2d/toZadKYkYbN4g4=", "Hx7Mw0qroBN/XfgfwE/z7k8Z7jZOZT8HbUfpc12YAY4=", "FnKtPXCaNTl0JmwwOamnMRQkRIAyzRgZ6suKTUKE9YI=", "KD4/3CxuQgxW9Er1GStK6c2mlh8oTSSZHS7WAt+Mj8c=", "HCo9EgxVDs/Q2wlXFw+gE2g3Ufj9/1nWYU+9af85S8w=", "IW+Eh3qsYXL3iXpzI0Vu/hQ6mkN3PqbylstrgXdlP70=", "LA0nK+zyp1dkun6OPijRK86qR+phylmkEaH1FVL5R4g=", "FuNCmYZcDihITuenTEVOnxcKVICr4FCPy0psPYlUb0M=", "F1zrpZnpb1s3WiMqb7nMcXcgR3ZYAikPSM2Tl1VIj8U=", "DHWURA3EjBb+rZ4XWLAoBmqkEL+8NU9U2MX/u0Sh7jI=", "GjwpvDnyG7XEZtt9frb9j3YOIAE8z5EskkeYgtkZ/Y0=", "DM/dkG80JuXAmG6gSbJTQAhV00kHT1pmlcjuq80i5o8=", "FPa8gdnxhvYr20dc5slBGGanqKP9Bls84OaZtn3Z55Y=", "CWK4J4n7PRKXAspwsvbFqswJmBDJxJXIiO3rc4a5cFI=", "GogK9wdNGLO/IMed4lEnvBMoSrAe8CV1r+8Mj2oxqG0=", "EMuhhBmmozLNXnfwIRwVSyCvKST8IP8/TDASu3rpMRs=", "BX5iqaj4mz69x2umOp6sqPontzGcrjQGdWooSfMC8Q0=", "KHyXHekdwKvUSt9ThLSYjLlhMDu/Zc/1r6BBO0QoDO4=", "Id8ziK8Wh7uzvKnaDMqQjx5WK8RtSrpOb395YOMGiR0=", "G+XIh9JbznA+JcyXTQk0zXid+PcLSY/YPv+LVg4WgrM=", "Jo2jb3blaPtoEXF1zqLNDdLLXUL9pazqSNWcJwag1cE=", "DherCR9urlDGCb6vVRDs7MXYu3QTXr0FvQZGDMJqXtY=", "BNcn5yj/oKZ67lNasHSkMJHvYtjPg9JwBA9cqh9ir0A=", "DdvXv5wpNBWBtUl2K8Ai7TNwKsEPG/2GKxVBfX45ym4=", "J5DrM1FiF1J2gWLoKYnGwjT1sNHTr5tYiinEnIeJZUs=", "HkV8YBpjtz5EcZUBk9ilcDlfPZq4sv0JhLdkIGFC+ek=", "Ia5kMB3KliVjjWqyu+cTX/qQ7NDEP/kfxMaG/EbgkbA=", "A3n2PIzjRo1NopMWb0lJKIVL6eNDLglVWFhTTu2NNQs=", "AC1WQgNZ0CZqdEoICAngVMoOSSGkZoasjJ9YoyTDUEk=", "EjFY5ZZbXZsdaLPNMuELvtqNYkWeIfQJD8LFr5Y1FaY=", "C+KfxAhHqUFmHRS79svgQg+7K29Sg21OYMgOtJytnsE=", "Gslpkd7CuwVXcWFCAVpFPDbbnYWcrV+aIzgC8k/fTBo=", "FZZEP3Y9vMJfSWT8YdI7Pl4SyfqX8YqSUcozVbywYn4=", "EuC802VL36drKGHU7Drq4PGFfZ8X5xWu1tBJ6uO6MhI=", "D8krTxu+qCuepz1K+a8qUM6rrH83FUsZBObHbHz5ZLo=", "H5wLFhBEZELW8uWSqAE/QLFPfHciI29PnH6WUjOHJ2I=", "Dr10JErnJnX4zeBhV6eC9AUNkU2ji0wFjRWfZD279NM=", "LLfw7Tnhbp9pqfr9SrlRwDsGcelzRu45eoOYOdzPxtE=", "Gp1uLs/wIsxWBUQ+5BurIM52HQUUzlJmkMcrynNS2b8=", "KhFUOWB/M1peqDw7xEqTMdDBMyapp7owh9oYLWSOxy8=", "I/m2UptdBA0VuPp67j40EOc4tWMFzUTylTXBFcWkwGA=", "BYcsFtsPcqIkmsa6SEu5w6POl8FtWLaLJg65OfDm6Kc=", "EwC97gi7eCTKIPuAEYB19AIZthUdVbXFK2JKfN7d9qc=", "Gbm2PS8QjhfmOBeGOo9sKI160pkW2YyxBy5Oe31Ss3Y=", "AVvuE1fjwBW1vaI3ZoUi9hPRyIcmtexCJKIBKEgbT38=", "KVNzbpS7a58blwek8WFeTv4eHOS6shjL6pLHhbEo/9E=", "CwaTU7oJFhiGL4BhgMA4X4UbmNNytF9UTOcmbtZgjfw=", "ME901GHMwTEV5OC8+5OBflWut+uTBrZOT1iKyX2B9Ck=", "FbvxRs6bygnooz9ed9/k9arSoWSkYXpMuO5UFc3pE/w=", "CrTf4MJ0LN5EkBAxSHlk7ZuPS4UEBcEMqf8jhZVyyMY=", "DjLbMgoETjGX9F92SaGWde9e7f6lRt6pJR3jn5Y5d5o=", "ChdWqh83jKSydjWni2iI5meXczqCd0iWoweO+lFtoBY=", "BExKM7EPaTRH/RcXf5Uu+JXmHTKPhe+pQlTWoqJdk+8=", "LtNhG3JbinC+ZVtTf2b3AP4IedeaSWiR03sHtUZsS4s=", "H5uk6Lq3zkLI7MPXIqouDq3965z900e12DOepxIIWKo=", "GyMwQwUujCiPfukHqE5RiqOOgqxFAgZtt0BW+GXF09o=", "JDHhzBZLuNB0Axq3K9VbTJAgU7/A8U2wyi+XsCCHWVQ=", "CC+TTJH1qsMwzWlToKfbRaE+MiCXWDMZp5Hyc5ZYAf0=", "K5oKIj51OLCjS+B0MVVCo8dyReKufL6Zmta7kwxImXw=", "DhzZHt0s+izOuFSDuIepvoFkFj51qKAOsLWJzHAhTn0=", "Lh6sDyv9/WPJUfYUd+NpiZl3TxmFTQD1iNMkYBzr4vk=", "DL+pXzf7dAYMdhWOdp1tFXNFeE2O/bM8I9dIEVtQC4M=", "CPBbO+kj7UTWWtSdimHppnbZkeOndRPZmAwjLfpKT4Q=", "InGeKgcLzQhSv44hmE0EQ+coSSXcB1ijJaLdUQwEfvY=", "BB9Zap7hyyvAYPf8w6GrTHvb8DYRmYLA9B9isvJoMMA=", "Iz/TXeG+UgqHYo6wb2sdTAIb4cLQ3EZKGfzdCYaxD4k=", "BSS0bRqoel5DJeCkI+vIENMeB4qhtHB+78tFPGHJwmc=", "LDT0JMgeVxbOR/ysiUuFgkInu5VLDzGZzESGI3xRUhE=", "C18qS2M4eBkgfv/CtVQfty3SAltUV8yX8zAQMn3kkV4=", "IiB4VggszFTFty/kOdLP1sF0NdL1evbOrvrEH+BcZZ8=", "JNV6i/XaY/5OJBWbf4lQtc37IQGUyvefJ4VASM4sgXE=", "Cvqxgf3V4Fg7Nx11vWk/mDdK1wl7sBqFc5Gbsjt5OW4=", "LbqbEI8gh3KZilLvrHy9VnbABXGUwWwL8WKQ1isRKO4=", "JjSbZu24sW9W+IHHiPU/g8u4PeC9WSslWv8T5rzkILM=", "Ja984OXhA1doXpX5Izl1OtgaVtKOzBk7I1KIo+bxN9s=", "JbTOe9IpQ5DAlNalXt1ouXDu16roiyv/H3wBh/41AR8=", "IsVD8Q9siew4flPxkIqI5d6c7yjr3zCxjLnVTB4CtjE=", "Ajb5PneJxHJPx5CKnxkeHkJekGqRnXo032aOdIgvh6k=", "KTULQBFmygEOfSfjfQXamWUr2uEU6wFlnLSXr5gMS1I=", "Du14fWWCDT9r0xu6tUf3WmXtt12ETruJ7hJgkWZSNj8=", "B8wRcPE7RvIDanU/Ugsykf3NDpm9lCl9GQb2VvTeb60=", "Irk5IzsdcgX0m89hOj0wsZCHhtf59dEMIFlDVonorOo=", "AUUXYqCquByKrR3IvDPocHQPCDpaqFQ4rdZQrOYK5aY=", "I1BrtdhyfURh+r8QJdRtH+MuqmHex9pX5wT+wIkvzok=", "LkhMROg4rqC6wGrj9xvdCSo3CVMeHv6pf4vWiQc1VSI=", "D0vH0H66/WQ3nnjFC9LkK69KWUVFztwlRUGNomg1tUw=", "H008j2WD6eX6dmN4Yvqu6FFYI4hyXfRg5iCZbVDY504=", "CTUU4McHEfgmYNB74OSpiPrgKrx7aB2RU+uby0j+c4k=", "GtqwyOKzutNGaZorXzvANkPug+zkcijySljgo0fhU9g=", "FnKxcmBX2Z3RRwnrtHRkGjeMG5S4ByusGiLb756A2tI=", "Hf1T1Fdq8uOPRPU/3KtGjMXY4vrgrMTuMNR7I5tHnBQ=", "DGiIoQt1sPOnCjYmOjfhf+bXfWQPb8PevH8gd1MgXGA=", "Gt25M6Zb53CSs0p+d9Ev6GEaYeAO5oSLhQkezKnR5Qg=", "ANdUDc0mioRcEK4Y0d6TPPY4/1Ql8K//eTVijimdF5E=", "FAwOQmh+nq0BsoJ6VmTKnCb+3eSs2Z2x0xaTnSC4LA4=", "Lww6EV1DF9GRuom40T0YBsIKD5sk+MXtwJHirlZWWYQ=", "DE7neP98FFUwBu0iDPnIEAigz/ZwsiuC2MU4odyVjGE=", "FwTydm1G+Cw2k/AEQMzDYJQk7SbArMZiJ8PXSF3nTGk=", "Ly0ZzD6l146noCwbUdJEq/B2nJ+FROQCObZv6QCcPPo=", "GuA4U7dfyrpQU/ES4qjo3N1+5suc/tnH1sdmqAb8Zik=", "CXGqv3lSQd9R0THQ+mGqXzVWkhstbwFOTkGobdrwVtU=", "FAjDFuYBThqR1M9rbg3nPtpiT4OA3xyHX1wp97/i9kY=", "Fmfz/i7b6FAkir5CtUMJO2yJ8fdz7yhTQWkfOYIu9b0=", "E798XQ0sQ3akiwoDVXzfkVuBcYQJ5cEzQkxpV2UA/jc=", "B2IKbfsLbOwwFq3z01M8JAJLlTR4VreXGbwLp0OmLCw=", "FXTH7wxDVF82qMoIvb3YsHXSlZ4vMitzFnXePhmCtNA=", "Jp5LW3oushr9VnlwpxfO7FvUGEVxwlT9wG4Dp/+DePA="],
      M: [["Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "K51LQRDJrpl3guFQmx0P2yCnwCu9i+pzBUYrn4Elseg="], ["DMV827CFB9Yr9npEk8wmL7bAnVVwE//x9XP0MSIfj/k=", "EnTmSaMu01WjGm7WlyThra3oV+hutcOhIbzRR5QyA8g="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon1.js
var require_poseidon1 = __commonJS({
  "../node_modules/poseidon-lite/poseidon1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon1 = poseidon17;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon17(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/2.js
var require__2 = __commonJS({
  "../node_modules/poseidon-lite/constants/2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DumlkrqalRjQWYbWVvQMIRTEmTwRuymTjSHUcwTNjm4=", "APFEUjXyFIxZhlhxafwbzYh7CNTQCGjfVpb/9AlW6GQ=", "CN/zSH6KyZ4fKaBY0PqAuTDHKHMLerNs6HnziQ7Pc/U=", "Lye+aQ/a7kbDzij3UysTyFbDU0LIS9puIJZjEPrcAdA=", "KyrhrPaLe40kFr6/PU9iNLdj/gS4BD7ki4MnvryhbPI=", "AxnQYgcr737MperAb5fU1VlSwXWrawPq5ktEx9vxHPo=", "KIE9yuuuqoKKN234evSmO8i3vyetScYpjvezh78oUm0=", "JydnOyzLyQPxgb844cHUDSAzhlIAw1K8FQkord35y3g=", "I07EXKJ3J8LnSr0rKhSUzW771D40BYfWuPueMeZcxjI=", "FbUlNAMa4Y9/hiyyz3z3YKsQqBUKM3sczZn/boeX1Cg=", "Dcj61tnks19e2aPRhrec444Oio0bWLEy1wHU7s9o0fY=", "G82V/8IR+8pgD3BfrT+1Z+pOs3j2Lh/sl4BVGKR+TZw=", "EFILCrchyt/p7/gbAW/DTcdto2wleJN4F8uXjQad5Vk=", "H21IFJuOf32bJX2O1fu69CkySYB1/tCs6IqeuB9WJ/Y=", "HZZV9lIwkBTSngDvNaIIm//43ByBbw3JyjS9tUYMhwU=", "BN9aVv+VvK+wUfexzUOpm6cx/2fkcDIFj+PUGFaXzH0=", "BnLZlfj/9kAVGz0pDO2vFIaQoQqMhCSn9uwoK25L6Cg=", "CZlStBSIRFSyEgDX/6/dXwyancwG8nCOn8HYIJtcdbk=", "BSy6IlXf0Ax8SDFDuo1GlEjkNYaptM2Rg/0OhDprn6Y=", "C4ut7mkK246wvXRxK3mZr4LeVXByUa13Fgd8uTxGTdw=", "EZsVkPEzB69aHuZRAgwHx0nBXWBoOoBQuWPQqOSyvdE=", "AxULfNbV0XslKdNr4PZ7gyxKz8iE707lzhW+C/tKjQk=", "LMYYLF4UVG488ZUfFzkSNVN077g9gImKvmnLMXyepWU=", "AFAyVR5jeMRQz+EppASzdkIYyt7awU4rktLNcxEb8Pk=", "IzI34yibqjS7FH6XLry5UWRpw5n8wGn7iPnaLMKCdrU=", "Bcj09OvUpuPJgNMWdL++YyMDfyGzSuWk6AwtTCTWAoA=", "CnsdsTBC05a6BdgYoxnyUlK8817zru2R7h8JslkPxls=", "KnO3H5shDPWxQpZXLJ0y2/FW4rCG/0fcXfVCNlpATsA=", "GsmwQXq8yaGTUQfp/8kdw+wY8sTb5/Ipdqdgu1xQxGA=", "EsAzmuCDdII/q7B2cH70eSafPk1ssQQ0kBXuBG3JP8A=", "C3R1sQKhZa1/WxjbTh5wT1KQCqMlO6rGgkZoLlbpoo4=", "A3woSeGRyj7bHF5J9ui4kXyEPjeTZvLqMqs6qI1/hEg=", "BaaBH4VW8BTpJnRmHiF+m9UgbFyToH3BRf2xdqcWNG8=", "KaeV59mAKJRulHt11U6fBEB26Hp7KIO0e2de9fOL1m4=", "IEOaDISzIutFo4V6/Bj1gm6Mc4LIoVhcUHvhmZgf0i8=", "Lguo2U2ez0qU7CBQxzcf8btQ8neZqEttSipvKgmCyIc=", "FD/RFc4I+yfKOOt8zoIrRReCLNIQkEjS5tDdzKF9ccg=", "DGTL7LHHNLhXlo273PgTzfhhFlkyPby/yEMjYjvpyvE=", "AoowWEfGg/ZG/KklwWP/WudPNI1iwrZw8UJs75QD2lM=", "Lk71EP8Lb9pfqUCrTEOA8mpry2TYlCe4JNZ1W1254ww=", "AIHJW8QzhOZj15JwyVbOO4kltPbQM7B4uWOE9QV5QA4=", "LtXwyRy9l0kYfi+t5ofgXuJJGzScA5oLuoqfQCOguzg=", "MFCZkfiNo1BLvzdO1ari8DRIoix2I0yMmQ8B8zpzUgY=", "HD8g/VVAmlMiG3xNSaNWufChEZ+yBntBp1KQlEJOxq0=", "ELTn86td8AMElRRFm24Y7sRrsiE+jhMeFwiHtH3cuWw=", "KhmCl5w/9/Q93VQ9iRwqvd2A+ATAd9d1A5qjUC5Dre8=", "HHTuZPFeHbb+3b6tVtbVXbpDHrw5bJr5XK0PExW9XJE=", "B1M+yFC6f5jquTA8rOAbS55PLouCcIz6nC/kWgrhRqA=", "IVdrQ45QBEmhUeTurxexVChcaPQtQsGAihGr83ZMB1A=", "LxfAVZuP55YIrVyhk9YvELzoOEyBXwkGdD1pMINtSp4=", "LUd+OGLQdwinnoqulGFwvJd1pCATGEdK5mWwsbficw4=", "Fi9SQ5ZwZMOQ4JVXeYTyka+6ImbDj1q82Jvg9bJ0fqs=", "K0yyM+3pukgmTs0siuUNGteoWWqH8p+Kd3enAJI5MxE=", "LI+8st2Fc9wduvj0YihUd22y7s5thcTPQlTnw14DsHo=", "HW80dyXkgWry/0U/DNVrGZ4bYen2Aemt5eiNuHCUnak=", "IEsMOX9OvnHrwtiz31uRPfnmrAK2jTEyTNSa9cRWVSk=", "DEy53DxP2BdPEUmzxjw8L57LgnzX3CVTT/j7dbx5xQI=", "F0rWGhRIyJmiVBZHT0kwMB5cSUdSeeBjmmFt3EW8e1Q=", "GpYXe89NjYn3Wd9OwvPN4uqqKMF3zA+hOpgW1Jo40u8=", "Bm0EskMx1xzQ74BUvGDE/wUgLBJqIzwagkKs42C4owo=", "KkxPxuwLDPUhlXgoccbdOzgcxl9y4CrVJwN6Yqob2AQ=", "E6stE2zPN9RH6fLhSnztyV5yf4RG9tnX5Vr8ASGf1kk=", "ESFVL8omBhYZ0k2EPcgnacGwT87Cb1UZTC4+hprMapo=", "AO9lMyKxPWyIm8gXFcN9d6bNJn1ZXEqJCaVUbHyXz/E=", "DiVIPkWmZSCLJh2Lp0BR5kAMd21lJZXZhFrKNdijl9M=", "KfU23LnddoIkUmRlnhXYjjlaw9Td6S2MRkSNuXnuuok=", "KlbvnyxT/rrf2jNXXb29iFoSTieAu+oXDkVrqs4Ppb4=", "HINhx461z13s+3otF7XECfKuKZmkZ2Lo7kFiQKjLmvE=", "FRr/XziyCg/ARzCJqvAga4Po5op2RQe/09CrS+dDGcU=", "BMYYfkHtiB3BsjnIj3+dQ6n1L8jIts3R525HYVtR8QA=", "E7N72A9NJ/sQ2EMx9vttU0uBxh7RV3ZEnoAbfdycKWc=", "AaXFNic8LZ31eL+9MsF7eizjZkwqUgMskyHOscToqOQ=", "KrNWGDTKc4Na0F9desuVC0qaLGZrlybagyI5Blt8OwI=", "HU2OwpHnINsgD+bWhsDWE6yvavTpXTv2n37VFqWXtkY=", "BBKU0sxITSKPV4T+eRn9K7klNRJAoEtxFRTJyAtlrx0=", "FUrJjgFwjGEcT6cVmR8ASJj1eTnRJuOSBClx3ZDoH8Y=", "CzOdisyn1Pg+7dhAk671EFCzaEyI+LCwRSRWO8bqTaQ=", "CVXknmYQyUJUpPhM+6s0RZjw5x6v9Kfdge2VtQg5yC4=", "BnRqYVbrpUQmueIiBvFavKmm9B5vU1xvNSVAHqBlRiY=", "Dxj1oOzRQjxJbzggxUnCeDjleQ4r0KGWrJF8f/Mgd/s=", "BPbuyhdR9zCKxZ7/W+smHku1Y1g+3nvJKnOCI9b3bhM=", "K1aXM2TExPXBo+xNo83OA4gR6xFvs+RbwXaNJvwLN1g=", "Ejdp3UnVsFTc12uJgEsby44TkrOFcWpdg/62XUN/Ke8=", "IUe0JPxIyAqI7lK5EWmqzqmJ9kRkcRUJlCV7L7AcY+k=", "D9wfWFSLhXAabFUF6jMqKWR+bzStQkPC6lStiXzr5U0=", "Ejc6glH+oATfaKvPD3eG1Lzv8oxdu+DDlE9oXMCgsfI=", "IeT06l81+FutfqUv90LJ6KZCdWtq9EID3YofNcGpADU=", "FiQ5FtadLKPftHIiJNTEYrVzZkkvRekNioGTTxvDsUc=", "HvvkbdeleLT2b5rbyItDeKvCFWbhoEU8oTpBWcrASsI=", "B+pehTfPXdCIhgIOI6fzh9Ro1VJb5m+FO2csyWqIlpo=", "BajE+ZaLiqO3tHijD5pbY2UPGadefOEcqf4WwLdsALw=", "IPBXcSzCFlT7/lm9NF6NrD94GMcBuceILZ1Xtyoy6D8=", "BKEu3tqd/WiWcvjGf+4xY23NjojQHUkBm9kLM+sz22k=", "J+iNjBXzfc7kTx5UJaUd7L0TbOUJGmdn5J7JVEzNEBo=", "L+7Re4QoXtm4pcjF6VpB9m4JZhmncDIjF2xB7kM95NE=", "HtfMdu30XHxAQkFCD3Kc85TllCkRMSoNaXK4vVOv8rg=", "FXQumbm/oyMVf/jFhvVmDqxng0dhRM3K3yh0vkVGaxo=", "GqwoU4f2XoLIlfxoh930BXcQdFTG7AMXKE8DPyfQx4U=", "JYUcPIRdR5D53a29tgVzV4MuLnpJd19x7HWpZVTWfHc=", "FaWCFWXMLsLOeEV9sZft81O367osVSM3DdzMPZ8Uamc=", "JBHVekgTuZgO+n4xodtZZtz2TzYEQndQLxVIXyjHFyc=", "AC5vjWUgzUcT4zW4wLbS5kfpqY4S9M0lWIKLXvbLTJs=", "L/e8j0OAzemX2gC2FrD80a+PDpHi/h7XOYg0YJ4DFdI=", "ALmDG5SFJVle4CckRxvNGC6VIfa3u2jx6Tvk/rsNPL4=", "Ci9TdouOv2qGkTsOV8BOARykCGSKR0OofXetvwycNRI=", "ACSBVhQv0Dc6R5+R/yOelg9Zn/fpS+abfyopAwXhGY0=", "Fx1WILh7+xMoz4wCqz8MmjlxlqpqVCwjUOtRKisrzak=", "FwpPVVNvfclwCHx8ENb612DJUhct1U3ZnRBF5Ow0qAg=", "KaujP3mf5mwu8xNK6gQzbsw344wc0hG6SC7KF+Lb+uE=", "HpvBeaT911j90bsZRQiNR+cNEUoD9qDotbplA2nmSXM=", "HdJpeZtmD61Y9/SJLfsLWv6q2GmpxLRPnJ4cQ72vjwk=", "Is28i3ARetFAEYHQLhVFnnzNQm/oacfJXR3Syw8krzg=", "DvBC5FR3HFM6n1elXFA/zv0xUPUu2Up81bqTucfazv0=", "EWCeBq1sj+Lyh/MDYDfohRMY6LCKA1mgOzBP/KYugoQ=", "EWbZ5VRhbbqedT7qQnwXt/7NWMB23+QnCLCPW3g6qa8=", "LeUpiUMahZWTQTAmNUQT2xd/v0zSrAtW+FWoiDV+5GY=", "MAbrT/x6hYGabaSS86isHfUa7lsXuOiddL8Bz19x6a0=", "KvQfu2G6ioD9z2//nj9vQimT/o8KRjn5YjRMgiUUUIY=", "EZ5oTeR2FV/lprQajryF24cYqyeInoXngbIUus5IJ8M=", "GDW3huLokl4Yi+pZrjY1N7USSMI4KPBHz/eEuXs/2AA=", "KCAaNMWU36NNeUmWxkM6INFSusKnkFySbEDihasy7rY=", "CD79eifRdRCU6A/vr3iwAIZMgutXEYdySnYfiMIsxOc=", "C2+Io1dxmVJhWOYc7qJ76BHBbfd3TdhRngeVZPYf0Ts=", "Dsho5tFeUdlkT2bh1kcalFiVEcoA0p4QFDkObuQlT1s=", "KvM+P4ZncScawMmz7S4RQuzT50uTnNQNANk3q4TJhZE=", "C1ICEfkEtefQm12WHGrOdzRWjFR91oWLNkzl5HlR8Xg=", "Cy1yLQkZoarY21jxAGKpLqDFasQnDoIsyiKGIBiKHUA=", "H3kNTX+M8JTZgM6zfCRT6Ve1SpmRyji74AYdHtblYtQ=", "AXHrld+/fR6uqXzThfeAFQiFwWI1oqao2pLOsB5QQjM=", "DC0OO1/VdUkym/aIXaZrm3kLQN79LIZQdiMFOBsWiHM=", "EWL7KGicJxVOWoIotOcrN3y8r6WJ4oPDXTgDBUQHoY0=", "LxRZtl3uRBtkrThqkegxDygsWpKonhmSFiPvgklxG8A=", "Hm/zIWtojD2ZbXQ2fVzUwbxInUZ1TrcSwkP3DRtTz7s=", "AcqL5zgyuNBoFIfSfRV4AtdBpvNs3CoFdogfkyZHiHU=", "H3c1cG/+n8WG+XbVvfIj3GgChggLEM6gC5td4xX5ZQ4=", "JSK2D06jMHZAoMLc4EH7qSGsEKPV8JbvR0XKg4KF8Bk=", "I/C+4AGxAp1SVQdd3JV/gzQYytT1K2w/jOFsI1VyV1s=", "K8Gui43buB/KrC1EVV7VaF0UJjPp35BfZtlAEJMILVk=", "D5QGuCllZKNzBFB7jbo+0WI3EnOgex/JgBH81q1yIF8=", "I2Co6wzH3vpntymY3pBxThfnWxdKUu5KyxJsjNmV8Kg=", "FYcaXN3q2XaATIA8uu8lXrSBWl6W34sAbcu8J2f4iUg=", "GTpWdmmY7p4KhlLdLzsdoDYvT1T3I3lUT5V8ze77Qg8=", "KjlKQ5NPhpgvm+Vv9PqxcDsuY8itM0g05DCYBed3rg8=", "GFmVTP64aV8+i2NdyzRRkoks0RIjRDuntBZuiHbA0UI=", "BOEYF2MFDlgBNETby5nxkCsRvCXZC73KQI04GfT+0ys=", "D9slPe6Dhp1AwzXqZN6MW7EOuC2wi16LH15VUr/QXyM=", "BYy+ippQJ72qTvtiOt6tYnXwhobxwImEqdfFuum08cA=", "E4Ltzplx4YZJfq2xrrH1KyO0uDvvAjqw0VIotMzspZo=", "A0ZJkPBFxu4IGcpR/RGwvn9huOuZ8Ut34eZjRgHZ6LU=", "I/e/yHINwpb/8ztB+Y/4PG/KtGBdsutaqlvBN663Clg=", "ClmhWOPuwhF+bpTn8OnezxjD/9XhUxqSGWNhWLuvYvI=", "BuxUyAOBwFK1i/I7MS/9POLE66BlQgr49MI+0Adf0Hs=", "EYhy3IMuDrVHa1ZkjoZ+yLCTQPenvLG0li8P+e0fnQE=", "E9afoSfYNBZa1cfLp61Z7VLgsPDkLX/qleGQa1IJIbE=", "FpoXf2PqaBJwscaHenPSG94UOUL7cdxV/YpJ8Z8Qx3s=", "BO9RWRxurZfvQvKHrc5A2Tq+sDK5IvZv+36aWnRQVE0=", "JW4XWh3AeTkOzXynA/suOxnsYYBdTwPO1fRe5t0Paew=", "MBAtKGNqvV/l8q9BL/YAT3XMNg0yBd0toAKBPT4s7rI=", "EJmOQt/NO78cBxS8c+sb9ARDo/qZvvSjH9Mb4YL8x5I=", "GT7djp/PPXYl+n0ktZih2J8zYur01YLv7K12+HnjaGA=", "GBaK/TTy2RXQNozoC3szR9HHpWHOYRQl8mZNeqUfC10=", "KTg8AevTtqsMAXZW6+ZYtqMo7He8M2JuKeLpWzPqYRE=", "EGRtLyYD3jmh9K5ed3GmSnAttuhvt2q2AL9XP5AQxxE=", "C+teB9GycUX1dfE5WlW/Ey+QwltA2ns4ZNAkLcsRF/s=", "FtaFJSB4wTPcDT7K1itciDD5W7LlS1mr3/vwGNlvozY=", "Cmq9HYM5OPM8dBVOBAS0tApVW7vsId36/Wct1iBH8Bo=", "GmefXTbre1yOoSpMLe3I/rEt/+7EUDFycKbxmzTPGGA=", "CYD7IzvUVsI5dNUODr/eRyakI+raTo9v+8dZLj8bk9Y=", "FhtCIy5huEy/GBCvk6OPwM7OPVYoySggA+ustcMSxys=", "CtoQqQx/BSCVD31Hpg1eakk/CXh/FWTl0JID20feGgs=", "GnMNNyMQuoIyA0WimsQjjtPweoorThIbtQ3bmvQH9FE=", "LIEg8mjvBU+BcGTDad2n6pCDd/6rpcTf+9oQ71joxVY=", "HHyIJPdYdT+lfAB4nGhCF7kw6VMTvLc+bnuGSaSWj3A=", "LNntMfX4aRyOOeQHenT6oPQArYtJHrP3tHsn+j/Rz3c=", "I/9PnUaBNFfPYNkvV2GDmaXgIqwyHKVQhUriORiiLuo=", "CZRaXRR6T2bO7OZAXd3Z0K9aLFEDUpQH3/HqWPGAQm0=", "GI2cUoAl1MK2dmDGt3G5D3x9puqinT8mim3SI+xvxjA=", "MFDjeZZZa3+B9oMRQx2HNNun2SbTYzWV4MDY3fTw9H8=", "Fa8RaTloMKkWAMqBAsNcQmzq5UYeP5XYnYKVGNMK/Xg=", "HabQmIVDLqmgbZ83+HPZhdrpM+NRRmspBChNozINisw=", "J5bqkNJpryn1+KzzOSESTk5PrT2+ZYlF5UbuQR3aqcs=", "IC190doPa0sDJcizMHdC8B4VYS7I6TBKfLAxngHTLWA=", "CW1nkNBbt1kVapUromPWcqLX+ceI9Mgxop2s5MD4vl8=", "BU76H2Ww/OKDgIllJ12He0ONojzlsT4ZY3mMsUR9JaQ=", "GxYvg9kX6T7bMwjCmALeudiqaQETsuFIZMz24Y5BZfE=", "IeUkHhJWTdb9nxzdKg3jnu3+/BRmzFaOxc63RaBQbtw=", "HPtWYujPWskiaoDuF7Nqvstzq1+H4WGSe0NJ4Q5L3wg=", "DyEXfjAqdxu65tjR7LNztiyZrzRiIKwBKcU/Zm6yQQA=", "FnFSI3RgaZKv+w3X9xsSvsQjau3mKQVGvO9+H1FcIyA=", "D6PsW5SIJZwutM8kUBv62b4uyeQsXMjM1BnSppLK2HA=", "GTwOBOC9KYNXyyZsFQYIDtNu3OhcZIzAhejFexq1S7o=", "ECrfjvdHNaJ+kSgwbcvDyZ9vcpHNQGV4zhTqKtq6aPg=", "D+CveFjkmFnipU1vGtlFsTFqokv73SOuQKbQy3DD6rE=", "IW9nF7vH3tsIU2oiIIQ/Ti2l8dqp69796KXqc0R5jSI=", "HaVcyQDw0h9KPmlDkZGKGzwjsqx3PGs++I4uQigyUWE="],
      M: [["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Fu1B4Tu5wMZq4RlCT928vJMU3J/b3upV1sZFQ9xJA+A=", "K5C7oA/KBYn2F+fcv+guDfcGq2QM6yR7eRqTt042c20="], ["KWnyfu0xpIC5w2x2Q3nbyizI/dFBXD3e1ilAvN4L13E=", "LiQZ+ewC7DlMmHHIMpY9wbiddDyMe5ZAKbIxFoex/iM=", "EBBx8AMjebaXMVh2aQ8FPRSNThCfX7BlyKrMVaD4m/o="], ["FDAh7GhqPzMNX55lRjgGXObNeeKMWzdTMmJE7mWhsac=", "F2zAKWla0CWCpw7/CKb9mdBX4S5Y59e2sWzfq8juKRE=", "GaP8ClZwK/QXun/uOAJZP6ZERwMHBD93cyec1x0l1eA="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon2.js
var require_poseidon2 = __commonJS({
  "../node_modules/poseidon-lite/poseidon2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon2 = poseidon22;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon22(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/3.js
var require__3 = __commonJS({
  "../node_modules/poseidon-lite/constants/3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["GbhJ9pRQsGhI2h05vV5KQwK7hnRO3CYjiwh44mntI+U=", "Jl3f4SfdUb1yOTR7dY8KEyDrLMdFCswdrUf4DI3PNNY=", "GZdQ7EcvGAng9mpUXh5RYkEIrIRQFcKqPfw2urSX2Ko=", "FX/z/mWscggRDwal90MCsU10PqJQZ/D/0DL3h8fxzfg=", "LknEPEVp3Zxf01rEX8oz8QsVxZBpL4vu/hj0iWrJSQI=", "DjX7iZgYkFINSu8rbWUGw8svC2lzwk+oJzE0X/otHx4=", "JRrUfLFcTxEF8QmuXpRPG6nZ54BtZn/+xv5yMALguZY=", "E9oH3GTUKDaYc+lxYCNGQfi+tW/dBeXzVj+jnZwi304=", "DACbhOZQ5tI9wAx9zO90g6VTk5aJ01DNRue4kFX9Rzg=", "AR8WscY6hU8BmS45VvQtiwTrZQxtU16wID3sdL79ygY=", "DtaeXjg6aI8gnZpWHap5YS8/eNBGetRUhd8HCT82dUk=", "BNupSnsM6eIhrK1BRytrvjrsUH9es9M/RjZyJkyfeJs=", "Cj8mN9hA86FusJQnHJ0je2A2dX1LtQv3znMv8dT6KOg=", "JZpmbxKe6hmPihxQL9s4+jmx8HVWlWS25UpIXRGCMj8=", "KL90Wcmy9MbY59BqTuOkf3dF1CcQOOUVejL99+3g1qE=", "ChypQfBXA3Um6iAPSJvo1MN8hbvM5qKu7JG9aUFDJEc=", "DG+PlYvg6TBT1/1PxUUShVU17RU58FHctDom/ZJjYc8=", "EjEGqTzRdXjUJugSisnZCqnooAcI4pbghN1X5pyq+BE=", "JuG6Uq2Shdl906tS+OhACF6PqD/x6PGHewdIZ80t7nU=", "HLVcrXvRM94YpkxcR7nJfL5Ni3v54JWGRHFTfmpK4sU=", "Hc1z5GrNj44OLHzgS95/bSpTBD1QYKQccUPwjm6QVdA=", "ARAD4y9tnGb1hS8FR0pN7wzaKUoOtOm5sSubtFEuVXQ=", "Kx6AmsHRCrKa1fINA6V9/rrf5ZA/WLr+18UI3SKHrow=", "JTneF4W3NZmftNrDXuF+0O+ZXQWrL8X66qaa6HvOwKU=", "DCRsWi747gEmSX8iKz4KDvThw9QchtRuQ5gssR13lR0=", "GSCJxJdPaOlUCBSPfAYy7bsJ5qatGhwvPwMF9dA7Uns=", "Hq4K2KtosvBqDuNu6w0MBYUpCX2RCWt1bY/cL7WmDYU=", "F5GQ5dDiIXnkb4KChyq8iNtuL9wN7pnml2i9mMXQa/s=", "KbueLJB2cyV26agcesS4MhRSj32wDzG/bK/nlKmzzRw=", "Il05TkIgdZlAPv0MJGSpDVJlJkWIKqw1sQ5ZDm5pHgg=", "BkdgYjwlyM91PSOAVbREUyvhNVdFHAh94J79RUsj/Vk=", "ELo6DgHfkuh/MBxLcW2KOU1n9L9Cp1wQkikQp49rW4c=", "DgcL9T+EUbJPnG6WsMKoActRG8DCQuudNht3aT8hRxw=", "G5TNYbBRsE3Tl1X/k4Iac8zWyxHSSR2Kp/khAU3iUvs=", "HXyzm6+4x0ThSHh6LnAjD51OkX1XE7sFBIe1qn10Bws=", "Lskxib0atPaRF9D+mAyA/4eFwpYYKfcBu3SsHzA7F9s=", "LbNmv9020nemkruCW4YnW+rEBKGa4HqQgupGvYNReSY=", "BiEA60hdsGJpZVzxhqaFMphSdUKEUDWa3JnOxpYHEbg=", "B2HTPGZhSqpXDn8egkTKESAkP5L6WeT5AMVnv0H1pZs=", "IPxBGhFNE5ksJwWqA04/MV14YIoPfeTM96cuSUhVrQ0=", "JbXABKS9/LWt2exOmrIZuhAsZ+iz7/tfw6MPMXJQvFo=", "I7GCLSeO1jKklOWPbfb17QOLGG2EdBVa2H59/2Kzf0s=", "InNLTFw/lJNgbEupASSZvw8U0Tv8/MyqFhAqKcwvaeA=", "JsDI/gnrMLfienTcM0kjR+W9/0Cao2ECVEE9P615XOU=", "Bw3QzLa9e7rojqwD+h+7Jhlr4wg6gJgpu9Ym3zSMytk=", "ErZZW9sym2+wQ7p4uyjDvsLApt5G2MWtYGfE6/1CUNo=", "JI2X1/dig9Y77DDnpYdsEcBvypsnXGccXjPZW7fo1yk=", "GjBtQ51GOwgW/G/WTMk5MYtF63Wd3eSqEG0V2b2bqqo=", "KKj4Ny48ONrO18AEIctGIfTxtU3cJ4IbDWLT1ux8Vs8=", "AJSXVxf5qKi7NRUvJNQylAcc4yDIKfOIvIUhg+Hizn4=", "BNXuTDqnj32A/eYNcWSA01k/dNT2U66D9BAyRtsujWU=", "Kmz16aoD1DNjSa1vuO0iace+9UuIIsx20ISVwS794Yc=", "IwTTHqq5YLqSdNpD4Z3et/eSGAgI/W5Duq5I1+/Lo/M=", "A/2ayGWksqbV5wCXhYFySb/win4HJvy04cEdOdGZ8LA=", "ALclje1Su9oiSEBNVe5QRHmK/DogkZMHP3lU1NY7C2Q=", "FZ+BraB3F5nsOPyi1L9l67E9OnTzKY2zYnLFymXpLZo=", "HvkOZ0N/vIVQI3p1vCjju5AAEw6iXwxUceFEz0JkQx8=", "HmX4OFFeX/AZa0mqQaLSVo33ObwXawjslaee2Cky4w0=", "KxsEXe86FmzsbOdo0Hm6dLGMhE5XDh+CZXXBBoyUwz8=", "CDLldTzrD/ZAJUOxEJIpwWXcLXO+9xXj8cbgfBaLsXM=", "AvYU6c7fs9xrdirgo31BurG4QcLotkUbxajjw5C2rRY=", "DiQn04vUamDdZAuONiytlnNw67d3vt/0D2oL4n5+1wU=", "BJNjC3xnC23rfITUFOfOeQSfDsCYw8fFB2i74pIUpTo=", "IurRAOjkgmdN7NqxcGbFomuxUVNV1UYaPcBsyFMnzqk=", "JbPlbmVbQs2q4mJu0lVNSFg/GuNWJtBN5QhOC20qbxY=", "HjJ1KtqINu9YN6bN6P8T27WZwzY0nkxYS0/cCgz2+dA=", "L6KoccFaOHzFD2j288NFWyPACZXwUHj2cqmGQHTUEuU=", "L1abippEJMknjh23MR6In1TMvxBmG6t/zRjnx6fYNQU=", "BEy0VREKj91TGt5TAjTFGKffk/czL/0hRBZTdLJGtD0=", "IngI3pOQbV1CAkYVfy5CsZH+jJCt/hGBeN3HI6UxkCU=", "AvzKKTTgRrxiOt6thzV5hl0DeBrgkK1KhXnS56aAA1U=", "DvkV8KwSC4dqvMzrNEodNrrT88Wrkajdy+wuBg2L76w=", "F5cTD0t6Phd363V7xvKH9qsPuF9r5jsJ87Fu8rFAXTg=", "CnYiXcBBcK4zBshaurWeYIx/SXwgFW1NNsZoVV3sxuU=", "H/+57BmS1muh53p7kyCa9vj6dtSKy2ZHlhdLUyajGlw=", "JXIcT8FaPyhTtXwzj6U42F+Pu6bGucYJBhGIm3l7nF8=", "DIF/1C1fekEhXj0HuhlyFq20w3kHBdqV62O5gr/K91o=", "E6vj9SOZFdOffhPCwklwtt+M+GzgCiIAK8FYZuUrWpY=", "IQb+6lRiJOoS7385mHpGyFwbw9wpvb16ks1grLTTkc4=", "IcqFlGinRraqp5R0o32rSfHKWijHSLxxV+GzNFuw+Vk=", "BczWJVwebwxc8fDfk0GUxikR0U0DIWYqjxpImZ40GFs=", "Dw40pktwpibkZNhGZ0xMiBbE+yZ/5E/m6ihnjLCUkKQ=", "BVhTGk4lRwxhV3lMo20Olkfb/P41DWSDj1saii3g1L8=", "CdPcqRc+0vrO6hJRV2g9GJJMra0/ZVpgty9YZJYfFFU=", "AyjL1U6MCRNJP4Zu0D0hi/I/ktaKrsSGF9THIuW9QzU=", "K/ByFuKv8KIjpIexpwlOB+eee8yXmMZI7jNH3VMp00s=", "Ha80WlgAa3NkmcWDy3bDFtb3jtam3/yCER4Rpj/kEt8=", "F2VjRyRWqqdGtpTGDhgjYR7zkDmy7cf/OR5vIpPSxAQ=", "LvHg+tnwjoeju15H1+M1OMqWTSt9EIPU+wIlA1vT+Ns=", "ImybGvlbq88XsrH1fHMQF5wYA97Fro8KF3ntNsgXrio=", "FLzjVJzD23QoEmtMOhWuD/gUjInxP7NdNXNOtdStDe8=", "Lev/FW4na7V0LDNz8mNbSLjpI9MB83L45VDP1ANCEsc=", "LUCDz1qH9bb8I5WyLjVrZEGv4baynEet19BDLR1HYMc=", "DCJbe80Ev5w0uREmL9ycG5G/eaEMAYTYnDF8U9cWHCk=", "AxUhadTz0G7DOnm/rJGgLJmqAgDbZtWqe4NSZfnJyPM=", "C2GBGpIQvniwWXRYdIbVi93I9Rv9/ru4ev6LeqfTGZw=", "ID4ADK0pjar366alxZIYeLiuSKz3BI8WBG1jelM7b3g=", "GkS/CTfHItE3ZnK2n2yWVbp+44b9oREsB1cUPRv6kUY=", "A3a0+uCMsD01AK/sGh9WrLjg/edaIQbXAC9ZxWEdTao=", "AHgK8socrWRlohcSUP38Mtb8JB0yFBd/PVU+82MYIYU=", "EHdNmrgMJb3rgIvt/XKo2bddvhjVIhyH6dhXB5vcMdU=", "ENxunABuo4sEseA7S9lJDA0D+Ykpyh1/tWgh/RnTtug=", "AFRLgzh5FRiyx2RaUDknmLIfdbtg41lhcAZ9ABQcrBY=", "IiwBF1cYOG8uLoLrEieJ41LhBaO4+oUmE7xTRDPuQow=", "KEDQRem8IrJZz7iBGx4PRbd/e9t/fitGFRoUMPYI48U=", "BidS+G7r4RoAnJN+RowzWwRVRXTCmQGWUI4B+lhgGGs=", "BgQb2sSCBayHrbh8IKR4pxyZUMEqgLwKVajoPqrwR0Y=", "BKUz8jbEItH/kAo2iUmwAix6KuCS8wjYKx3Lv1H1AA0=", "E+MdemcjL9gR1qlVs9TyXf4GbR59wz3wS95QorLQWyo=", "ARwmg66R6037wT1jV+hZmpJ50WSP8sldL3mQW7E5IPE=", "Cw0hk0a4V0UlsaJw4LTLpdVsko4+LCvQoeyu0BWq9q4=", "FKveyNucbclwKR7mOGkCCbZQgHge+f0T2Ex6cmtfE2Q=", "GgtwtLJv3Cj80yqj0mZHiAHrEiAu9HztmI0DdmEL4QY=", "J4VDch+W0TB7aUP5gE5/5WQB3rLvmcTRJwSILnJ4tgc=", "FutZSUqXds9XhmIU29FHPz8HOKMlY42Lo2U14BHVglk=", "JWemWKgf+0RPJACI+lUkxpqeU+6ra3+MQcNHnc+MZEo=", "KaodfBUemtCnqznxq9nPd6t44CFaVxWmuIKt6EC7E9g=", "FcCRIz5g7+DUu/zis2QVAGpPAX+ahTiM4ga5H5nyyYQ=", "Fr19Iv+Fjl4IgsLJmVWNd+dnOtXxkV+f62eagRXwFM8=", "AttQSAoHvg6ywuE+1u9AdMAYLZtmi44I/+Z2klAEICU=", "BeSiIOajvJ97aAbsnWzboYYzDvK/ettME7qGY0O3MRk=", "HdoF68MBcLyYy/Kl7jtQ6LX3C8Qk05+kEE038cvPekI=", "AYS+9yGIgYf2Rbb+42Z/PJHaIUQU2JulzTAfIrDeiZA=", "FJijB+aJAAZfXoJ29irvHDdBS4RJThV3rRptZDQbeOw=", "JfQPgrMdrMT0k5gAudLD6s73N7j6sfhk/jNUitRr1J0=", "CdMXzGcCUZQ/b1hiow0uqegwVs5JB7+7yx/zHOW7llA=", "L3fXd4bZebI7pM5KTBs70KQRMs1GeoarKbkTts8xSdA=", "D1Pa/VNan0Rz3CZrb8zGhBu9M2lj8lTBUvieeF9ym78=", "JcH9cuIjBFJlw6CZ4XUm+g5pduHAC68W3pbehd7vL6I=", "KpAsiYDBf6rjaNOF1S0WvkGvlchOrqPPiT5l1s5Kj2I=", "HOFYCjRS7PMCh4yJdrgr6WZ23RFNHcjSVSdAV2L4NSk=", "JKYHP5Gt3DOkmh+jBt8AiAHF7FaWCQNNL8UPfw9NAFY=", "JeUtvWEkUw2fwn/jBtcdRYPgfKVUtdFXfyVsaLC+K3Q=", "I9/648Qj+nqTRo28z7AphVl0vk0KeymUZ5blts1w8V0=", "BjQto3DMDYxJt3WU9rAnxIBhXVC+NiQ6mVkbyZJO1vU=", "J1QRQoEoZUa3XwnxFfx1G0d4MD0EBcG0zH3w2On2OSU=", "FcGehTTFwaiGLCvB0Rnt3qvyFBU4M9e9tZ7hl/gYfPU=", "Jl/gYnZtCPq0x40NnvPKvjZvO+CoIQYWebSz0td9Xz4=", "E8z2idZ6PsnyLLfNCsOjJ9N3rFzQFG8Ejev9CY0+x74=", "F2YvdFZ4lzn4HNOXSCeoh9kqXgW98/5rn7zMpFJKrr0=", "IbKcdjKbMcjvGGMeUV9/L4LKalzKcM7k6An9YkvnrV0=", "GBN0eDgqrbpEHrl/4nkBmJwGc4FlIVMZk56xewH6l1w=", "K8B+or+taOjcck9f7ys3wtNPdhk1/9O3Oc7sRmjzfog=", "LdsuN29U1kpWOEBIDfmT/rQXMgPCvZStDmAgd675oD4=", "J361DyuqcGEGtByyTGAmCeiiD41y9hNwitslNzWWw/c=", "DU3kfhq6NCadDGIJBPAaVrM/xLRQwNtQu3+Hc0yaH+U=", "C4RCv+nkobRChnO2vT7qb59EVpcFjxNKrpCNAnminww=", "Ef5bGPu+oahuBpMMuJ99SibhhqZZRelldCR/3bcg+PU=", "IkAm9t+vceJNJdj22fkAId9bd03K1NiDFw5K2JwzoNY=", "CyymqZn+aIfgcE2tWNA0ZalryeN9EJH2G8n5xiu+uCQ=", "Ihtj1m8LRfnUDFQFOiigax0KTOQdNkeXoafgyWUp9CE=", "MBhcSLey8dU9QSCAGwR9CHSTvOZNTSSu3OL0g2u4StQ=", "I/XTcqPw48upieIjBWIn01MzVvD6pI8n+CZzGGMqYfA=", "JxZoOzLHVf0b+CNeoWKx84jh4AkNBhYujm375DKPPjs=", "CXdUWDaGb6IEyh2FPsCQnj0UB3DICsZ9yTDGl0jV1Lw=", "FETo9ZK9v9gCXZGrSYLdQl9RaC0xRysF6BxDwPlDSzE=", "JuBLZenKgnC+t0ocXLj+6L4/+/5YP3ASoA+HTncY++M=", "IqXC+oYNEf407kelzZ+GmAD0j0/r4prW32mBb7GpFNI=", "F0tU2ZB9j1xq/Wcqc49Cc37DOPOglkxin3R03UTFyNc=", "HbHbiqRSg/MRaPpmaUzygI0hibh8jIFD1WyHGQezm4c=", "FTC/D0ZSfoiQMLjHt9/eEm9l+vjM4KtmOHNB2BPRv9E=", "C3P2E5kyKfWfAcHOyHYOmTbq2e3I8oFIiTMKLyut5Fc=", "KcJaIv4hZGBFUqrqN39EjVh6uXf8gid4e9LcDza89B4=", "KzDVPtF1m/uFA9pmySz0B3q+gnldwnKzd99X13yHVSY=", "EvbXA7VwKqt7e35pNZ1TonVsCMhe3nInz18KKRZ4fNI=", "JSDhgwCv2j9hpAoLiDcpOlWtAQcQKNSEH/qaxwY2QRM=", "Hsna6oYJcezdqO1PNG+pZ6ybxZJ4J3OTxo8J+gO4uV8=", "Cpmz4XjbLi5DL1zVvvj+RIO/XL9w7UB8CKriS4MK1yU=", "B82p5j22458Ia4m2AcK75AfuCrrDyBehMXq618V3hJI=", "CMnGWk+VXolS1XGxkbsK20m9gpCWMgOzXUiqs4+Pw6M=", "Jzf4zh1aZ7NJWQ3b+9cJ7Zr1Sio/JxnTOAHJwXvdnJ4=", "EEmmxl/wGfDSh3AHJ5jot5CUMr0MEpgTqfF5umJ/fWo=", "GLT+locyxGLA6lqb6yfOy96IaJRP32TuYKUSI2Ha7ds=", "L/K2/SLfSdJECy6u7vqMAqb0eM/PEfGypPdHNIOIXRk=", "LsXy8ZKP6TLlbHibj2u8s+i+QFfL2NvRihs1L1zvQv8=", "JlpezNi5KXXjOtn3W/NCbUJKTGp3lO4/CMHRADeOVF4=", "JAXqpMC94RKdYkK7WtoOaHeOZWz8s2a/IFF9od/UJ5w=", "CUyX2MGUxC6IAYAEy78rxf21GVXYstZrdt2Yotv2BBc=", "LDDV8zuzLFwiuZeaYFv2TVCLcFIh5qaGMwyWJcKv4Lg=", "AadWZvYkH2gl0BzG3LFiLUiG6lg+hymeaqL8cW/bbPU=", "CjKQ6DmBE+pNEqwJHoe+fG01mrmmaXn89Hvy6H04L8s=", "FUrenKNuJo3+s4RhQluw2MMSGdj6Dfx17NIb9pqgzHQ=", "J6qNPiU4DAsbFy15xvIu7pkjHvXcadjcE6S1CV0Ch3I=", "LPQFHmyrSDAaiy47ymCZ11a730ha+h9UnTlbvL2AZGE=", "MB5w9ynzyUsdP1F93/nyAVEx/quK+l7rsIQ9f4SyPnE=", "KYvrZPgS0l2LTZYgNHqwIzLcTO8ROuYNF6jXpMkfg7w=", "GzYucqX4R/hNA/0pHDxHHtHBShWyIWgKzxGj8C5GqpU=", "DciiFGEQwLN1QykCmZIj1aoe9ueOHl68vB2bpB3Bxzc=", "CkhmOzTOXhwF3JMJLLaXeMshcppy3cA6CK+h65Iv8nk=", "Coc5H7HNjN9glrZKgvnpXw/kbxQ7cC10VFuzFIgQmO4=", "G1spRvfCiXXwUS/45so2L4gm7dfqnCnzgrqKKgiS/V0=", "AQAc9RKsJB1H6+Ijkhm8ahc6i7y4pbmHtOrB9TMxW2s=", "L9l3xw9kXbT3BPp9dpPacnrAk9P7X1/rxyvrF9g1ijI=", "I8ADmj+rStPC18xogWTznnYdU1XAVETZm+djqXeTqcQ=", "GdQ+4MYIHAUsnA32Fh6qwa7DVs9DWIjnnyfyL/A/ol0=", "LZsQwvLnrBr93M/9lKVjAovym2RtAggwkZ+dXKHO/lk=", "JFfKbC8qow7Efkr/Wmb1zieZKD4Wb8gc2uLyufg+Qmc=", "Crw5L+he2oVYIFkkRQlAIoEe6Gdu1vDDBE37VKfBCzU=", "GdLMXKVJ0dQM68038+pU8xFhrDmTrPMQHSwrww6sHrA=", "D5euMDP/oBYIqvsmrhPNOT7g5OwEG6ZEo9OrVG6Yycg=", "FtvHj9KLf7gmDkBM8dQnp/oVU36k4WjoihZkluiM/so=", "JA+vKPEUmbkW8IX3O8TyLu+DROV2+K09GCeCA2bV4Hs=", "Chuwdao3/wz+bIUx5V4XcOq6gIyP222/RvjKtY2e8a8=", "LkfhXqSkf/GmqFOq86ZEyjjVsIWsEEL9xKcFp84In00=", "Fm5b8HM3g0iGDKSpwJ054Wc6sFmTX03zX7FFKDdXcrY=", "GLQtf/3S6k+vI1kC8FeidAyszNAnIzAB7RD5ZTjwkW8=", "CJyxsDIjj15JFHiOPjx+rU/DaAILPtOCId6rEFHDdwI=", "JCrNPrOi9yuvfHB23RZa34n5M5x7lxkh2ecIY0Ud2NE=", "F0+7EEpO4wK/R/K9gvzolurJoGgoPzJkdK+GBFckXDs=", "FzQOcdlvRm1h8wWM4JLGfSiR+yuzGGE/eAwnX+ERbGs=", "Ho5ArIU7fULwDy44OYLQJPCYufj9RVlTov04DE339rI=", "BSmJjcBkmQfh1NXihLjRB1GYxVytZuipv0D5KTji6WE=", "IWJ1TbC6oDC/feW7eXNk3OjHeqAX7h179l8hxNTl348=", "EsdVNpjEv2886yUK4AxYwqn5KR773kyEIb70R0F1LsY=", "KSZD47ogJq/8uMUnkxO9UaczyTNT6dnHnLcjE2UmUI4=", "AMzxPgy2+dgdUpUb6pkL1bbAfF2Y5m/3HbbnTVuH0Vg=", "GF0eIOI7CRfdZUEozy86qrZyOHPLMPwisPhsFatkW0s=", "FMYcg21V0990K98Rxg76GGd4494PAkwPE/5T+Nh2Th8=", "DzVoQbP1Vvzl2+RoBFdpHCkZ4q9TAIGE0D7hGV1yRJ4=", "G4/Z/zlxTgdd8ST4h79As4MUM3T9IIC6DAprbo+ls+g=", "DoaowgCcFAyj+HOSTiqqFPw8iuBOnfCz6RA0GHlvYCQ=", "LmxeiY9VR3cOVGKtky/N0jc/xDggyisWsIYUIeeRVcg=", "BdeX8as2RyN8FPnR3wMryf+f4aDs03eXLOX9WgwBRgQ=", "KaMRBGOlqudsPRUodZgdDB2vLc1lUZ71yokphR2owAg=", "KXTae8B0MiJzw6S5HAU1TNxxZAqLvR+GS3MvgWOIMxQ=", "HtD7BmmbokmyowYhwF6xLKKcuRqggsi/zOnFIoibR9w=", "HHk+8NzFESNlT/JtjYY/7q4p6MVy7KkS2AyK425A/ps=", "HmqsHG090xV5ViV9PSNO8YyR6CWJp4Fp+7Sodwl33C8=", "GiCtp1diNO7mJz3W+piyXtA3dICApH2Uj82jMlb7a/U=", "GRAz1thc6qb8epojpv2ZlmQtdyBF7OUTNdSTBnKK+Ww=", "AG5Zedp+fvU6glqm/dw6v8dvIAs3QLiyMu9IH10GKXs=", "Cw1+acZRkQu+8+aNQX6foPvVf1lsjymDHv+MAXTNsG0=", "Jcr1sMG5O8UWQ17AhOLs1ErEbbuwM8URLEsgolyc350=", "EsHqiSzDHg2a+LeW2WRYcvf3dELWL9TICFsvFQ9yRyo=", "Fq8paVFXq6m4u+Ov6yRf7uWpKdn5KLm4Heba3HjDKq4=", "ATbfRXyAWI3Wh/svO+GGkXBbh+xaTP3BaNMQhCVrZ9w=", "FjmijFtMgRZq6phPum5xR54Hse+8dENNuVooUGDnsIk=", "A9Yvv4L9HUMT+OZQ9YfsBoFsKLcAvcUPfiMr2bXKm3Y=", "Ea7rUn3IzkS00Uqt3KPP4vd6HkD8bal8JJgw3h7f3lQ=", "E/m5pBJ0EpR5xeYTjGyO42pnDmvGjHpJZCtkWAe/yCQ=", "Dkdy+j11F53ISEzSbHwfY13e7tepOUQMUGyui3680Vs=", "GzmgDLyB5CfeS97Fj+vo2LWXF1IGemErOfxGpoxdTbQ=", "K+22bhrVodVx4W4pU/SHMfZkY8LrVKJFRE0cCjolcH4=", "LPCgmlXKk6+KvQaPBqcof7CLGTtghYKic3nONdqRXew=", "LRvXj6kOd6qIgwyr/vL40n0aUSBQun2wdTyPuGPvs4c=", "BlYQxvT5JJH0I9MHHrg1OffA1JwThwYuYw1/0oPcM5Q=", "LZM/8ZIXpVRQE7Eoc0Ur68xfmWkDPxXsZC+0ZL1gc2g=", "GqnT/kxkSRD3a5Kz4Tsw1QDa5TVOeVCMPEnIqpngJYs=", "An7wSGnkgrHHSGOMWREcaycJX6dz4aygeM6h8chFC90=", "K31STFFyy7sV204AZoqMRJ9nomBdnsA4AuP6E2rQuPs=", "DHw4JEPGqnh8hxjYZ0fH90aTriWx5V3xP3w8Hdc12w8=", "ALRWcYa8P3xip7Vqz092IHofQ8LTDQ/kpifc3ZvXkHg=", "HkH8KbglRU/m1hc3/gi0f7B/5znkweYdAzdJCIPbT9U=", "ElB81Va3u8xy7m2vxhZYRCHhr4ctjA6JACro07oGU7Y=", "E9Q3CDVTAGvO8xLl5vUqXZfrNmF+82/k130+l/cctds=", "Fj7HMlH4VENociJIfdqaZUZ9kLIvCzhmRoYHfGpEhtU="],
      M: [["I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "J3aGSU92RLvEqbGU4Qck65Z/HcWHGOWePO3IIbKnrhk=", "Aj22h4Tj8MwLhWGIJqmzUFEpwWR5lzsKhKRSnmawnGI=", "HTWdJF8obBLVDWY7rnM/l4rwjNvWMBfFezp1ZG/zgsE="], ["KnWhcVY7gH21Jb4llpmrKP6bx/sfcJQ/8Em8lw6EGgw=", "CDq/9eEAUfB44oJ9CS4a6Ai03T4VzMNwbzjOQVe2dw4=", "GlrXG7vs2Kl9xJz9uuMDrSTVxHQeq4t1aKn/glOh628=", "DXRf0A3RZ/uGdyEzZA8CzpRQBKe8LFnoeQ9yXF2E8K8="], ["IHBnnnmHgu9ZKlLKnO+CDUl60u7Lqn5C82az5SHE7UI=", "LhjIVw0gv134AHOaU9p12Qbs4xjNIkq2s6K+l54tfqs=", "D6hvDyfk091/M2fOhvaE8fLkOG0+W584+ig8aqcjtgg=", "A/Pm+reR8WYoFo5LFNuutlcDXuPaayyoPwwkkeC0A+s="], ["L1ReV4ICyXMkiFQOQfeDto/wYT/Xk3X4uos9MJWOdnc=", "I4EL+Ch3/Bm/9+7+rj+vS7gQTDK6TNcBWWoVYj0BR24=", "AU/NXrC+bVvur8SUQDTPMhwGjvkw8QviIH7VjSo0zdY=", "AMFfw6HVcz3YNerggj43f4ukqLYnYnzCu2YcJdIPtSo="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon3.js
var require_poseidon3 = __commonJS({
  "../node_modules/poseidon-lite/poseidon3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon3 = poseidon32;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon32(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/4.js
var require__4 = __commonJS({
  "../node_modules/poseidon-lite/constants/4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DrVE/uKBXdp/U+KcysmO19iJu069R8OGTzwr2BptqJE=", "BVTXNjFbhmLwL9un3XN/vKGXrrEupkcTunM/KEdRKMs=", "L4O53yWbK2i810gFYwfDd1SQffDA+wA19Qh8WNXowtQ=", "LKcOLo1/OaEkR6yDBSRRtGHxX4tBp17zGRUgj1q6loM=", "HLX5MZvmpF6RsE1yIicclJlBlvEu0ixdTscZy4Ps/qk=", "LrT5nGn5Zuv4pCGS3n/2FiHHu0e5N1DCueoI0YRGwSI=", "Ikoo5aNThafFGYFp5AXZ6g/H2ouT7hO21ffQmeKZUg4=", "D3QRtGXmAO7Yr91q/KScMDbzPsvZoPl4I3lrmTu9gvc=", "D50NWq0slVWivnFQOS2NmBmyCK4zcPmaBib5/12Q5OM=", "HpqW3IKSu1lvUqWVONMpIpcyslJZz3RLahLTBwLW+6A=", "CHgFFMzZA4CIfVeMRVVeWTz+Uuq0uUXGws1NUo+z/jw=", "JySY/O1obHrIFJ+j9z74ws7WRxfjVW1aWfEZ1inMtfw=", "Ae+PndfJOqxLfLgJML0G60W9NQr/WF8Q49Dvingu998=", "BFufWbZZXmFNwI8iK0abE46IbmS/PECql+oK51STTTA=", "CsHpHFfZ2pGf1vWdKkD/jqPkHiTiR6OHrfJYQpXWHGY=", "AooWIalAVLDH+aQhNTzYnQ/WcGGu6Zl50S5o8E5i0TQ=", "JrQYAsBx6kyWMmR+0FkjblDBnD+zyW0J0CquKg3Nnbw=", "L7XdqAcrtyy6rC9j5GghXgXJ3gZ1jbapSvNDhK7bRis=", "IhLToPX8yvJE/zVH/YIySa2KuLoqGNOD3QXFbuiU2FA=", "GwQa1bLwaEJY5N+u6gm+VqMnb9sZ9EwBXNDH7tRl4uM=", "CgF3a7IvS2uOzP8z52/e0xRPt+OsFOhGqR5kr7FQDv8=", "K3tWdKrsw8vzTT8nUGbVSaTzOujBXPgn95NkQIEKzkM=", "KdKZuAzUSJ5M91d57VS0jGCwQiV7ePwATBuAM4Gjvf0=", "HEaDHZp0UpNXZBwhnXIadKQnEQAyteHdGd3jBCS+QB4=", "BtdibJU8y3LzcUHcNNV44DYpbAZXZ0+Ac5rh2IPpEmk=", "KP/dyG8YwTbFQAJ0jgxBDtxcRAowIs2WDxCMcc2ikww=", "Lmf37l5KopX4Xe7QnkALF75n8bftKratuOwGGfb7xek=", "Js44+mNskGMOl/JRFKeaLcpWhZ73WeU856vyLCToDyc=", "Lm4Hw8lb98NN16AdAKf/7ELLPRah9ychr6y0xM/TXbE=", "KqdPdZfwyfRfkdeWHDpU+4iQ0nZhLhJGOEsUcNok2Mw=", "KH1oGkai+q4sfAkPZoq0W4pxMTwVCRg+LsDKY5t/c/4=", "ISvRnfgS6q70pAYAUo89faXTEG/1Zao7EeKfMwXnPAQ=", "EVT3z1GRhr8ar7FLNQ64YPl/2XQJJtq5OAnChARxNQQ=", "Hf9jhcsx8cJGN4EKS9Gxb79RUpBb42WD2nR+eWYfwgc=", "DkRFgtIrTnbAgdNMRMGOQkARo01UdiUoY+o8YGtVHlw=", "AyPJ5DO6ZsSrq2Y4Mo8C8YFXc+nChGMj/3LTqrfk7/g=", "EnRrvXF5EFkZO7p5zexEjyW4zwAnQBEttw8saHapwp0=", "EXO30RLCp5j9m503UYQsddRmyDfPUNc+/QSetEOKIkA=", "E9UcEJChrUh20eVV1/7RPajlcTslAm6+X9tICHAyQ9o=", "AIdME0SkrVH/jct8vS2XQ8tydD8DlO/n9KWOvrlWuqE=", "It8iExqquFhlziNrB/JE+g7qSNNUbpfWoypWIHT+8I8=", "C/lk0tvSW5CHCLQ3pEX8PphFJKWRAebBi/XrBakZ8VU=", "CbGNm5F6VbyjAr4ffxgeDmQLnXOpqymMabQ1tfxQLzI=", "CU9VNERPrjakv8HVvz3AW/u7xwpjZTZt1nRaUGconkM=", "KZm6saXyUhBRn6ZiKvU6FaPiQMDaVwHLeE/dwNwj8B8=", "L2iYwHWB9jccqU23NxDogIQwG86Kk9E2aVdaEbA6PSM=", "ByaOqroIvBnsFtfhMYpHQFZd6x6OV0L4YhdLGmhm/Ms=", "GGJ5sANFTbATOf93ETvJ62JgPgeOHGaJpslYLEGgUp8=", "GKP3NlCRl9bkkVvdBNPl3bZ+LMXemiJ1B2jlUkc3Fyw=", "CiH6GYjPONh3zB4u0kyAjHJeLUvLLToAe1mHuHCFZx0=", "FbKFy+JsRn8fr172pkYlIoMowYSixDvACzahNeeF+6I=", "FktwYsRnHPCMCLjD+YBtVgt3dbfJAvV4jNKN4+d58WE=", "CJC6CBmsCm+G2YZf5+UO82HGHT1DtuZdeiT2USSbqnA=", "L76k1l1+1CWkJxLlpyHk6qYnrFyw64eMzC7grtVD6SI=", "BJK/ODw2+lVUAwOjtTb4XntwpY6FSrm5ED1/Xzeauqo=", "Bekf6UTpRBBOICUcVlFC1h1hhanOhWdfapadViktwk4=", "Ev5cICnksziT1GPLBBrK0JlbliHm5Jw7fjgKduNubBw=", "AkFUrfAlXUeVj3cjkhR0Ex8mKfrciUlpBs0B3G+geE4=", "GIJKCeavr0o27SRiqGvQuteYgVZE8rveiBPBNFekVVA=", "DItILboK1Rvp8lXeDD293d+EpjCvaNULuwaYPj1dWKU=", "FzJf0KtjWHE2PgoWZ9O2fFpPpn/Naq+GRBOSh4/bBeY=", "BQrpX20vFRkSL1r2e2kPMeVQdz+o0Yv3HMbQ6RH6QC4=", "Dw0Tmg6B6UMDjLKI1iY2dku7YpXwdWmIV3HshO3FDEA=", "HA+Gl3lWic33D9LywPk9Gnmznrx6GxxUnbvKe450fNY=", "K9D5QK2Ta3ltK8LgSLyXnkm+I6SxNZj5/lNqFtwdgeY=", "J+sb4nycTpNHeMCaAFMzf6BuuydeCW0WfOVNHpbuYss=", "LkiJ2DCmflqPlr3TFVp8oyhPvTB9H3Gw8VG+YlSOKuo=", "GT/j2wq0fTxdLsXpxb2Zg8mJHyytwWXbYGS75vzB4wU=", "K/MIbpbDbHvOQVkHrQxA7W6WYcAJZ55ON8sTAnyD5SU=", "EvFuLebUrUapjNtpfGytXdXn5BP3Qczyn/LqSG5Zuyg=", "KnIUfSMBGfOgJi42U93RnzPz1dbsbEvwrZGbA0O5LS8=", "Ib4OLEv9ZOVtxH+VeAbcXwotm8wmQS4pd995rMELqXQ=", "Di1+HclG1wsnSaO1Q2eyWnG4T7kRqleuE3/UtsIbREo=", "Jmf3+1pPoSRhcKdF2KQYjMMa2w6uMyXcnz8H1LkrPi4=", "LMxvQx+3QAcwp4O2YGRpehVQwSsI3+tygw4QfaeONAU=", "CIiKlPxaLKNPAgFGJCAAH65tvunoygwkLsUGIeOObl0=", "Apd7NO6qPLatQN1Cybb916DS++dTr4izas/NPMvFPyo=", "EgzM4T0ot1z9b7bJ6hOmSL/P4Nfm/46WELXp+XHha5o=", "CfrSJpxKjpPIHhuXcOoJjJJ4ekV1sr1zoL8q8y+G/zw=", "AmCR/T1MRNUKSzEOSsbw+g3r23B3XuuK9jDP+2AJLW8=", "KUBKorpWW3e7f7qd+2/DISVDzFavrWr8uQT9K8qJOZQ=", "J0lHXDmarznU6HwlSGlbTvH/2GWQ4IJ95yATUbfIg/k=", "CYyEIyJHn3I5kStQQkaFy6Lr4twuTacKx1V9q2X/oiI=", "GM71gSIrZH4xI45X/q19XHWKzhTJPE2kAZHQwFO1GTY=", "Exd4OcaKUIDU50Z0XkNxHTy8DKShCPmNY7KqaBaY3mA=", "AgymlvUx5D7AiPVvS3QyVibMTfcSwOXwqQfYjl8N7/0=", "JyMO7enMz8n6gFow/FSNtpPRNwjGRoQdFuAoOHx6wCI=", "AWRZEcEZiwHWT940o0KheGSXwFlpoBVDkFfS/nW7KBw=", "LDI/4WSBv0luQ5yINBziXxmJceFEhwVs/cpKRRpdhkM=", "D8CC3+cHKOhFC9IHTD4i4bAiwSTTv/6LWviK5ttQhcg=", "IFLBdIANsgnYzcpWjcwls76WQhFqxMd+/opIi0I1Ie4=", "KOQg4Q3y+7WvltYh1VQjGQvjUc6BKQZajdn9BbPs6cA=", "JWmMpeJKG3mfeDxEYqJNtlXWrhvazRy1SdbgvDrlBpo=", "FgqZgaXImlfPj/v6V9UQSaKXthB0QirBNNm4V9aYTTU=", "IckaOeFFw7w02baUuEPzv4t86/Wd27CgZGQrBpmX89Q=", "GsjYDc1e6HbSsJNF7xEjRdbqoCnZPwO20Ql1Rh5Bc0w=", "CrPmrQ7Pi458FmKkF0xSIl2CKJXidVVEuNvOpWV84Cw=", "HGdRglEmIK4n47C5F7OiHKUu8+9ZCbThxbIjfL2rM3c=", "LNvJmN/Xr/09lI0MhbrS4uN6Sj4Hp9ddDIqQkqwr7UU=", "I7WEpW4hF7B3S/Z8wN7jMyQzc1Awnf+DPkkaEzu2Oy4=", "Hp4rMQ9gup+MtzAwo8nSoQ0TO8a6TsEVLz0g3hRl6aU=", "DgHjZbpbMDGrw+cgFArnRsmrXauYdSDEYLzU8fpbIts=", "BAiEzc/GS/x7cSc0BJjVxEM4IBG2HJpLE4fYW8EmTmg=", "GQse4SBeuVAMdKOZjyvqNjU/FyTWBn7QoKF94xHvlmg=", "FkfHKuxsQ4jQT1L8I82cCMHfz2XOYeFl/CjR+DK9Oyw=", "JDAAY0agFF95mIDMTIc2Jp9UlNiftIsChC5ZW3HkVB0=", "F3uaCDQ5F+E2UQej2jrn9p2FOQK7FrrLMiGFAlK3V68=", "BKQg5kKxGulOWIYqaPXjJgnNU9CuKUI0ObEdBGZt9Pg=", "JdDg9zn7OfwQWoj6sK/YEN4kYYWOlWzMzfq+3baiXI8=", "BEdtkbfv8v2FkFy/WGUe3DIMsVYQ6u1FLE1P+gx0Cic=", "EJDAtos9fXuLycokGeuN6hwo9tXhJQy16XgP2coob64=", "JTk847klbVBEinJcXHzVrTdvLUNYVcEOvyiZy1xmF74=", "JZMcDHNx9PH8hi8wbm5YMO2CQ4jWuTQml9FE8Pq0ZjA=", "I5bLUBcAu+bIKq1RsPt5z4pNNTGF1YCCA/c/Iq+/YvY=", "JqNjSDNItYlU6nSKcSmnsKPckGjDzKe1s/DOA7hySIQ=", "J8oQfKIE8qGNbxU1uSxUeMmbiTM0IV9rp6DltF/NaJc=", "Jtoo/Al+13zkZiveMmsszqwV9zAReFgdjS0Cs7LZEFY=", "BWqzUWkdi7NwPjBVBwrJzGVXdMG7NdV1cpcbpW7gy4k=", "Jji1fyO3VK7HbRCaL0gao8IlR6Ef/FAVLXKa9jI3apA=", "MEdUu4xX1gcy9JLCYFGE/cM+RqUyveyA6nvFUZ7efO8=", "ANFyf4RX7gNRTxVbWAbL90jsaFf8VUAQdSrJOpt2Gaw=", "AO4fPGb7wFxDuilaMDxy+rW8qGgF7JQZxYjlCUd2H6M=", "Cvr63PW03UpKdrWh2CQV/RChn7z8WQeMYfkpfrZ12XI=", "CyRJ85dGCF6GzkXo7tEI7mWiNINaCmpeqJltEk3QTQo=", "IGsM4vGyxbfJ83sARSJwlfbG8HHsO92nan3fSCPdXdY=", "D+uk+4eDTHy2luZ0M2KM1sr/w6TvIP6oUsfhApRZQJw=", "JU2/rHTEmwuJJnUuCE4CUTsG8TFebXDhgXPpcjNuVdM=", "Ct2xNyzuThZGVRaMNnVZ4ZYGxb0XkQrrN3Ge36DKh2I=", "JrJbfiV/PpfHmQJPsBn2XGyk2NgbGuFiIaWJ1ogx11k=", "CQmVt5rOwkBBO41MZYeH5aRle5qwC9tbGWCxBZ4RO6M=", "CNvcLiHvEfLFcploeEPOo+sNjkDpkTH0KXQXjUT3O3s=", "CeirpnFIEZdnn691Kg9440L+nEkVlqtnWPFwk5eFF58=", "HesFGA6DPkVlkFKn66+BbH79Eqf57slLe8fGg/E2PVw=", "GacOxr38kJipJu+8wEqp7iSJl+iywkrzNf1lI+UlCHk=", "IddzZgra+4qHmYb5qrSJBWY1Ojd32KPx65Or4Qu/H2Q=", "CfGJD3Lp3HE+ILpje4nV05emsB/NZnNH9vRmF4QcOQE=", "Ba9Fk2HrRU0qMAxh5EaZjUj6H4l78hnWCMIUXDOxEcM=", "D6Gh1oKfA0VmSmbcdaZXM18zbxXzQHVs+hL8hQzItRM=", "AuR6NbzAw6C9oLHAMHrVQ/QoD8+H9jb4U2Vc+Xpii7A=", "FPdz6YNMa964+Q54v0wktyA0EUYBEkkQNmIYlSBNDxI=", "EC2Yz1Au2EMlXPGdKbx9jmQqvnz9Y5mS/7CRli/I98w=", "BD3V9Kpadt1MR/bGXafKIyDUxzrTKUc4y6aGp+kTc8I=", "IYM4GcMzcZSmwNKaSNTyZ28OfHl0OjBvTP2ysmvRHvo=", "DygZJc9e5km0dKaBnRFso+tOyiRsMR7K3FMmKjz/K1M=", "DT4kd6exC+tEcJx3RtaCTt9iXdYFBNXck85mLxXCONY=", "LNf2Qb7b9mlW/4oBvpzeNdgPgKtR5ztJrL/D7/Wu/EQ=", "KelbSSvy+V9NCTgPmLdOOJFJ0kBFgR16ht2GExBGPPg=", "ItpmvGLo8BEmbvyoamyBD5rkxRr2/+tX+LPFDfg8wT4=", "D+bTDeeoLRYwI0kXlPSsoyINt56BKd82QwcthBklVUo=", "AFDoQqEpmQkSPEbv8YXCOtMS0D/vGt/sx+B+yymP1n8=", "ITCjp7MiEiK+NMxTpC13M2Zvnd9xTtfFiFy722MQjCE=", "LfnuKU7fmePY1Yg/4FZsJKpmcx80qTKA4dMo5nszyfo=", "G/fW5ImtjAzybraMwh/1QVgTI5bcJQrrpLb8X8M3J2I=", "DGAvoVW+lYdh6vc5YXqxNs97gHcov3/jXUd40xF4DlQ=", "LlDixbNqogUyQH2GuNItfVFUCAokly+utj+vASHtfyE=", "F8JRCYKntYJXENYpDsT3gvZ0mV7oQJtCtFkSOxgDMuE=", "Cw1S8DyK9ydoA+zyRluIWyEze1OOq9L2sqslXzdrQqg=", "D1Yz3xlyuUVZU9iKY/gGR6msd8bA+F1FYZct2Pq4vRQ=", "Dr960pyhOAThQi6TloEVUSR4D/Q+dukpA1SYEwp/FXI=", "Gv8TyBvaR+gLApYhc7ujQ+GPlL7ifIpXZhsRA6cg/+I=", "IQRJ2/XPMGHaJGW+hVBYYtPzHeGjtY/zVxO+V++sbAc=", "CIIwwnlOUMV9dc1tPHudvhnR4vHTABBEuTrRw+5imBc=", "HECMJWSQsKHaCNxGQTjfx4zOmp4Wx3BWF6TW27IOfjo=", "B0UX4IHrTB8i0XcSAPsHZY98d2VNWEQEkN1vVX6eOQM=", "AtBOnCHfHb2IUkvbIDaRtM7lUwVZ1s8PoFrfYeEv3L8=", "LregEbi86RCC4T69dd47WOubRlDa6fEaqB2zLPG2exM=", "Lv2nftNfSvApn3XW6KhJtU0qxr+VNoME5gMMGPDPF7U=", "CRmdyv1QzmQu3b7aZSBtT2GnPRCFK4EUxRskQBkq4GQ=", "Joxc/ERtOZxN0xnbZmp1tctlXYwXl+n6dhgctCFuFWI=", "IwOmUslJBxgmsOmjbIBXhpe0TpEszmaHAShU7aEaGNw=", "J8U1Y7EqbuLD8EHzHcRZIrxTU+sRCGjSNwc/Tvs1+98=", "EgGofq9K5hjwK9gtClEJBJlptSSM/pD0LCePImFdKw4=", "LEMWlDn81p6tghSZe7Bpvsr8sbosUeVwbLS0PasqRD0=", "BoNZcxU1kEDqA8RdaYTGiU9Gy7NtcC48T7mEfmME2UQ=", "A1RXBnBuqzavuTsSj+vRb7BCXhWDFBl7d3la06eY0YM=", "GjPCVOwRdhnTXx/AUbMXKHQL7SOmo3hw7bOTtxoMDms=", "H/5paKRHDNVnsMACKByvmW6I9x51m4fm8zjlF/FpDHg=", "D9ZuA7qICP/ssFnImf2A9BQN3V0qXESDEH9OAuNVs5M=", "Jjq2nxO5ZvgZc5RVKQaxfmyGF6e91ddKe+M5a3/gE6s=", "FqQl5H0REGJQVNWhZd5BPjvYfVqjlY/dbrfgPjm6QEY=", "LcUQpHGewQytdS8DxnPw4lPMMdE+OekJ/MX3OvkTjZo=", "JN+OjYVsW14b0crSPQfdo0I8UXkym3qCy0qnCalFduU=", "K8yU/0/Dx2881caJFaBC6HYoJJoBsJVhvfJKbNzlYg8=", "B2weiNxUDI2N5U40PffEKdMpX1LDjP/mtIvoaFLal98=", "CbXyCaRRrEMcBR+xLZpeT+QO4WARIJR9qZD7jhLLRuE=", "IF8XsNhyni6qiNakQTWmq2TpQk9VsPHqBoOvdetnfAc=", "KBxcaIg29s+RJjjDi+BGzQkWgfCkF2FyDN0e358jcCk=", "GgU+aHjpAPRfTWdEjEcc8wCaROegLqUOSvpE8lkmIfU=", "EA3H1CbevjAH+3zqyE5PVGjvy4l+e77pgXQoOdWeBkw=", "FwImcqAWqVe7h+LPrci3X7KJBb22LILICxyzG0EeScg=", "EIbbfidg/ItxBTqH6+FRI5+4tUcYKxcN4MJyA/lU9NI=", "FThP451ztjMCRgrkwpQvrCtB+2WhhVNvuF3ST9dYQGQ=", "LrtZn+kTbUJL9KvFNCxsdEexqFMgX8+1UZ5VE1dwkAg=", "G0teh8+5Jiz+w8DwVC5MWkzyeCkrTOPu2Zb6xvTTcog=", "JGUFOuULaIWAHz+C4wLK+7tKdYG7T7pgtjf+vmWeUFc=", "EU8y7c3qCc0JXFu1048bl9qfBeGLNwi/bgq509VIWe8=", "K8cN/rK6qy9rOHzXe+d5rC5eVRnz0YEj7ijYwlQ8cUg=", "Acm/eiA84it3XjphrX53tqeDSLn27GikEuSb/jLAVBU=", "BRSw/lkJ6oh77bApX7vOw1XPtXX/apfNn0rQDMtX7ps=", "Jnx27IGTTMgaEyqLBYkQoSCSUgsSogGvA+MgLXtsG34=", "KRcOMyKz2NXHjIS6u7RwrfFiJJPOg+lc+xUc91e95dY=", "AZ9qgSSxnjOvM+XThz+cM1xvCaRUhsq1Nt1ZbKQdlRk=", "GQSqTWkIVEqLNI6dsZgcJwCe2OoXFRiuVAXQNiQrYOk=", "JvF4c5Sbxnn38EOVZpTkIrPO4d6d1vZHO5MqR2RV/xo=", "GsZo9hK4JDwZOzNyC4qlQEDEdgMRlxMevcrJsYvEj3U=", "CZbZYadcDQcZba5Fv2JHZsz7+FVb6XltpS+BVo7wZj0=", "AwyX4bjK0dT9UNG0OD++ZnTRcfmcY/67VCWzlcJPyBk=", "BuOtakaQDi05UzcCVbaPibPlI/H+UCZC7iJvLYvQhI8=", "HWs3VTMc0CFraIDkL5iA9WXLlLDgRVFToymJBYjMkW4=", "KOTcukuW8SpZsEFTXnMKyMNRidwLhawDPdOMCLrlMfI=", "CLYIYEaoNVCMz0hPKXS2prBxKkdiYDdsejs+S8SkehQ=", "FizSyn/jtfFES87JeBIBm7b9hfumoFNqiWQ+Fbm7O1I=", "KPHgO6rqm7wFr1sRk35PXLXJqcEZIGPRmYwBxk1IOnY=", "G9sGJ3jXwV2jla8nNMJfqgEn0qq0qnE2YDGgu2eRzhA=", "I3WDlQLgmJDLKRToKWJ+Dg/JiHCyMkqLUDKevdJHScs=", "H6hmL7y2H7OtfFVmjclCOjMtyHz7LfRW6S0zYR7Xu1A=", "Hk+tLdawpvH4cH9yFxbIpEbi+yxHpROPP3+XNgeddpQ=", "IRJW0Wxyaf1t9vX83R+niLo70FAFn1PSYbD18Tcx/+c=", "LkkISzNuzqpPjiouavCDGPQgYOV03aNB9KEHmxK8xaU=", "DOGfVM3Dn38781GSrGgIIRrs6gjf4UyrdY0liR+wC7k=", "ABHF1Ww5Dok8w5QiEmHYdI3GBFHkrk4chKhGi6ssFMs=", "F9ef8GtjrCqKngXuavPbt8pg4Xv6ObR1FKjNgFFXm0w=", "GafTpEbLU5PcdFYAk1krBrGos1zWQWouyrABc2OQFfo=", "AwwAoJM9zboqgIsuG5KC8zHwRZbYko2nqmw8lyNwN6Y=", "Fry0R84tUPOuJa0IBpU4LpNdLQAYTErMk3C+iqtkE5w=", "EjQbRrAVCqJepOyHFTEpl+YhJPN8q3ttOSVbfNZv6x0=", "DobRORf0QFC3Kpeyv2EMhAAvwo4pbRBE3IkhLbakn/Q=", "CObrQInTfWbTV+ALU9fzDRBSoYH48usU0FkCWxEMcmI=", "LqEjhWJF9shHONFd0UgaDAQVzLNRoeDO4QxIzpfKexg=", "LcpysuvKuMI0RuADMLFjEEGVeJAlQTq/Zk2w+chN+m8=", "Bv+e1Q0yfoRjMp9YXskks/L2tCNfA2+kxkomy9Qrams=", "JGoQt+PgCJlH98m9o9VN+OKmDgzKhOoqxjCkU1r79zA=", "IqY1AcXwS5AYcZ7ZnXAO5S+EanFa5nrXXJaznWiLZpE=", "L0xQR39/2cZxeZrF0uIkzbkWT1g1HYqhQOwH5RT66Tc=", "EP+3qtH1HH0TsX9Nh22aHjjwuopKI9S1DNoyythRVn4=", "Dpzv3cPC076k05ciUy1UIHhAJzUhh+evGgVpNcNYA64=", "B6+EpNMUHnrCM1Lm3G6kr6Flb5ajPIl4o+g73UumK0E=", "LZ4xoQrrx2H43gDRSx5WbRo5Mj1uibY46UDz7Ioiw8U=", "J/GaZTLma1Mz2xr9WS9m8dNgNLMU2thEdlZ0e+J+ZMc=", "AFj6PIRU1jNUsgJMO0pXehgO2Z+PMVXNfk1hfUfQf/0=", "BBYntnFbeAlnlXwIBpk0PrBBSiBdOhddcIlklWgWpdU=", "AGrEndklPtx/Yy5XuVjM7NmCAUcc8fZliYiPErcnxS0=", "ATGt/9i9clSx2MNha74zhuwMnA1tJamk7EamvxgwE5g=", "HEpvUsn8z3pBOOQT72Kig3eXetfiXkmjzwMOHNj59bY=", "A/KmvlHsZ3+UZVGzhg6kef7gSK4geK630feVjSwmRfY=", "LadwqtLC6wk5Ggy3jvOpZIoTcthUMRlWTXN2OWuN3GI=", "FSeEY2ZfdM3cGAL+v6sCzsnUX+hmw1nHOAYq+3XWSgM=", "Ev4niqNlROrJcxAnCQUY1DTjjqlmoIpvjVgGOKxUx3M=", "FJucgCGCVYpMRdEZ0/TMf9hYdgTKTw1uIbBv8wtqI7Y=", "CBLntNhHvIUX0ZMZdy88mFXgRP1g26yaCtxJWbaR3+Q=", "Au2Njd6v49nY338ooL+qf1VYE8fnUDrqKmaXNwOgxhs=", "Dr0HO6BTe1FN62Ap+SECnlXl5NmgPWtroTBAOGYtTbg=", "FcdU1bFLLEIFxrqNLM0CglWz55LGr6CLRO51ti7/n1k=", "FpUVyJrFR52w7Y+m+jEbORzBI1Jw9MvFwp58vDDocyo=", "JUefv7Omj5gjiPJiEAEQFgi9wp9v8DdpbZFh9c2aT+8=", "FEdcS9UgRR88hSywMRpXjKf45ulyGCGWzglIbpS+YHE=", "BFppEGbMZr7JuvJ5iDOh39OoR1Aq7I1fXE5zNj0Jd5k=", "JgKcDCZ8eZ+4M6yKEeOj8BR6jKA3IhuQATuLyzfrpoM=", "Fj+ss0/1cvv3yUaWnBwmCHPOEqapSj5FuBAdW5SNFkE=", "LHFOluGROzUdlpMgzGnV7BPgamJ15YaIr47gDEJA7ig=", "HBZh4qfOdLdauoRmXs0r+d3WJo8G3r/i1SuATv8dX6Y=", "Bqaa55Xum/5eWvPmYZpH0mY1s0wqCIn+qMPAaLfcLHE=", "ET1YU12JIRXF0otMGaNgk3Tb2631QZXHMUFshdcx1Go=", "KriRAuK41eY4/5fXYdpgQuU08f9H95F6LKGnQGO0YQE=", "A8Ecp55B/f6WJzDEXmmVRjSQMYk9orT9OYBP1qFa0bM=", "JwlsZyYhQDiIAU3bu/ydoff2e01M/oRsat8ED6ryZpw=", "LeMq0VSXrvTVBNTe61OxPGbbeQzkhhMMqp3CtX71vg0=", "DcEI8rCigNL9XTQTEHIqLSjHON3a7J89JVdURI7v0AE=", "GGnzt2P+gWTJaFihu5761bzcPuvECb58fTTKUDZdgy8=", "Ai7Totn/Mcv4JVn+apEYQ7YWlF4WpWjUjG0zdnEpaC0=", "IVXWAFIQFp45RO0TZb0OcpL8ofJ8GcJmEMauwHfQJrw=", "DeG6elYqj3rK6TJj9fG0u+wMBVbJGvPbPqWSjIyuroU=", "Bdu0QGAkvqvPzlv0bsfaOBJvdAvOjWN7Y1Hfp9qQJWM=", "BdQUm6rEE77U2NyK13jTLADnieP81y3MyX5UJ6No/V4=", "Ac34tFLZfCub5QRuc5fnb/C2gC+pQceHkhLiIXLCey4=", "H8anGGcCf1avgIX/ga3OM8TXxQFeztjHGwoiJ51GwHw=", "EEC+9MZC0DRdTVmlp6OkK6nhhbdTBtnDVo4P2paqr8I=", "FrecOmvzFuD/LJGyiTNKTSsh6VZ2QxkYqAgUdauPrQ0=", "IN/xvDD222tDSzoTh+PIxqNAcOUrYB/BPL4c3NWfR04=", "AhKsKrem6q7CVJVQMKlw+AYt1BcacmqL37f9hRKuBg0=", "Lyk3dJFHREKGmhCckhVjfLAtwDE08ARCE8gRn2mWrgk=", "CYTKal+RhdUl7JPDP+pgMnO+nzhmqihMWDfZ8y2BS/o=", "DQgKa2s7YHANKZvW+oEiDeSRNhyKa9Gc6w7pKUsk8Cg=", "DmXNmehLBS9niVMGOMsK2CGsyFtkACZNzpKe18haRUQ=", "LiCIdbx6wSJICPcscWzQXuMOPSA4D/amVZddoSc2kgs=", "KYnzrkd8L9N2oLD/PX36wa4uO4lK/Sn2SmDRqoWSutU=", "ETYc5UTpQTeSItEB5vrAzpGBBqRjKQo+OnTDzqcYlFk=", "Ho0BS4bLWn2lOeEMFz9qddEiqCK4+zZsNMi9BaIGFDg=", "Fz9lreyN7uJ7qBKtKVWOI6DCMkFn72yRIS7iwo7phzM=", "AcNtqvnwHxuv7ovQx3msPl2l33rUVJnQmRvWlTEO3dk=", "E1OssIwFrbSqmrHEhbuF//J30aPy/ImUSm9XQfOB5WI=", "Llq9JTcgfK0YYOceoRiO5ACdM960+TrrIPHIejsGTTQ=", "GR1cXtrvQtPQLu27erhWJRPetOs0kToTQhcmuo9pRVw=", "Edf40fJpJkKComP+ptdZnYKgTHTBJ96d7nk53S3NCJ4=", "BCGP3jZoKe2Q95rV5nmXlzRFy0zWvG+VG60IUobKyXE=", "AHB3L3z1JFMEg5fKX0eiAgJ7c7SJMBwyJ7cccw121t0=", "A4o4m6712afIZbBlaHodm2doGpjNBRY0wdwE2+PSuGE=", "CaXu+rizaoDNpEaytLWczQ850AlmpQvq8ZhgeJAVpuU=", "AbWIhIuLR8i5acFFEJtLWD2eyZ7frLdInRYhLHWEzYw=", "C4RuSjkOVg9uGvbfwzQUGVReWr+jI9gX/tkeMNQpVKY=", "I6ZnnH2a22YNQ6At25AAQOsVE7w5T8T5hcq/6FznL+M=", "LgN0ppkZfjQ+XKo18TUen0w0Avt8hezM9y8x1v4IklQ=", "B1LNiZ5S3E1/egivTN4/9kuMwLEXa7nsN9QZE6eie0g=", "Bo+IExJymdrDSaK21XOXpQJ1FCtmS4AsmeKHPdeuVac=", "K6cKECNV1UlndXQWdDSz+YaHLQSilbW4s3QzDy2iArU=", "LEZ6+IdIq/ajNNHfA7VSEwn5CZuCXdKJuGCecKC1CCg=", "BcXyC+8b2CcBAJorRIrogeOlLC0aMZVyltKeV2Po9Jc=", "DcY4X9xWe+WEKjgfYAbixgzQg6LGSdnyOsjJ/mG3OHE=", "FC05g/Pcf34Z1JkRuGcPpwN41bhBUNJe0lW6qBFLNpw=", "KaAe+y9qqJT9fm2YyWoPoPNvhqepmqNcAPoYwbLfZ78=", "BSX/7nN9YFE4xKUGZkTsYwq56K/GRVW30qGvBOthOnY=", "HoB9yoHXlYHwdmd8oOgidn4WT2FJECZO8XfPQjgwHcg=", "A4X7P4nHTcmTUQgWRyR000wCI+D3M6Uv26VggtvYdXw=", "A3ZA3Br8AUPhpimOU8rln8+r1wFv1u8a9VjzN7qw6gE=", "E0GZmh7YaRnxKmxSYIKe7l/VbPAx2oBQt+TA3olgdLQ=", "Bp6wdYZrCvNWkG1Lr7EK13Ov1kLv3MVleyRPZb7Y7Oc=", "FxwLgeYhNuOVs46OCLPmRtJyYQHTr6oC6hkJphkDNpY=", "LIGBTJRT9Ry261XDEXU+hMu9yzm/5pb5VXUQdQKsztg=", "KdhDwEFdNdnjsz+tzydLKrBLOQMq3Kks45uKhqfDpgQ=", "CF1qEHDzUT2ENrzNq7eHUNjhXqWUfyzap2ac8/rncos=", "EYIDY+1UHaoQpEumZb8wLNvx3U5nBrAsnipc2kEvw5Q=", "IBk1pY9cV/wCtg1hqDeFvd/TFQ4F8d9dEFhAt1GhYxc=", "CowoIMVpcariepUqvTOgPUZ5Tu3Whs2Oz+1hDofALpo=", "GAY4/zAaZMoEq9bQvXUAtmULZf8z5r4f1Q28FjooGHc=", "CVxxYmbx3lkET5cRSkFYo/hcqKk3z77GPpsyGoEt02s=", "F8MeoC+8N4Mg2G/+1sfKFYO2GMXBpoeBjUCHpJfXNJA=", "BbhsS7jvMYtqcifkGS0UnTwXqXZMzWYN5NUKd/GSqRs=", "JlvJXfSkxIdv9w1+ov3ix6sV9KauDSN81s50uphsens=", "JHUrR7xsa8jZu+SPX+8vaQhwFznF9bSz1siG1HFceSk=", "FIFKHg9JKk6g2G5SepZIIXjWJLmNqW7l5YO5Mk2XTv4=", "EN75MQc7ZHm9YFdzePKTgZl8jgQdPPs9x1I7ypBvAL0=", "FPeudwv36V9/cGwNirTtA/oLiA0oxp0DG0WSyYYQF18=", "Gu9QoM7nUbWfkmr0DoA10Z3sydQo6+TndcXMnc4c5Yk=", "BBk1YHFy9o66ZcpgBo3+OwhsKi1X0JYClRIUtX5zz1o=", "JoY+ndJCVdFXO9CDlZuFbAST++/oPIGYN6FR079FLLg=", "IDbvtvmDCWXrPXoGi9CHyfWt8lG6YgUsZSc45j/4s68=", "DHEql1t03J12a2OaAplpyjC+T3WnU/hUsA+k8bT07ps=", "CAFNqzzRZn4nr8mb+sHmgHr9/2RWSSyjN1cx04dTlpk=", "GY0HGS20+sKoKkp5g51qK5fE3U03tOjztTAJ95s05qQ=", "Kesd5Co604GyO0ExQmiXoycJsp1Tu5Rt/RV4TR9j5XI="],
      M: [["JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "JftQtlrPT7BHy9OxwX2Xx/4m6pyiONbjSFUEhukcd2U=", "KT1hfX2nIQI1Xznr9i+RsG3rUyXzZ6RVbqHjHtV2eDM=", "EE0ClasAyF6WARGsJdpHQ2ZZnldam37fYUXxS6bTwcQ=", "Cqo14shLrxF96j4zbNlqOXkrOBOVT+m/PtW5Dy9pyXc="], ["KnC58dS7zNvAPhfB0dzbAgUpA9xmCeppafZhsut0yDk=", "KBFUZRySHnRjFamTTxuKG7qfkq2O9Ll5EVuOLpkczXo=", "KMK+L4Jk+V8LU8cyE076M4zNj9ue4rRfuGqJT32zbDc=", "IYiAQeb+vVRtQnyJCxiDu5tibYy03BjcxOyPp15TChM=", "FN21+toBcduAGVuVktjPK+gQkw4+pFdKNQ1l4sv/SUE="], ["L2mnGY4fvMfepDJlMGo37VW5G/9lKtaapPqEeJcNQB0=", "ABwe3WJkW3Otkxq4Dje7sme6MSs0FA5xbWo3R1lNMFI=", "FbmM6T5HvGTOLyyWxpZjxDnEDGAwSUZvp/mksii/wys=", "EsfirfpSTllY9lvi+6yAn8uoRYso5E2SZQUd4zFjz5w=", "LvwrkNaIE0hJAYIi57iSLq9nznmBbvRoUx7C3lO70Wc="], ["DD8FCmv1rxUZgeVePhopoTw/+kVQvSUU8a/Wxfch+DA=", "DexU5tv3UgX6dbp5kr008Isu/i7NQkpz7ad4QyCho24=", "HEgqJacp9d8gIlgVA0sZYJg2ShH02Yj7fMdc8y2BNvo=", "JiXOSKezmkJScyYk5KuUNggSrC/JoUpfuLYHrp/YUUo=", "B/AXp+vVbdCG981P1xDFCe1++OMAuai7n7nyivcQJR8="], ["KiDjpKDlfZL5fJ1hhsbD6nxeVcIBRiWb4veMLMwuNZU=", "EEn4IQVmtR+q+x6aXWPA7nAWc67YINnEQDsB/rcnpUk=", "AuysaH71tLVoACvZ0blrS+81emnj6GtVYbkpm4LWnI4=", "LToa6i5tREZoCPiMm6kD073La1i6QEQe1OvPEbvh43s=", "FAdLsUyYLIHJrRceTzX+SbOcSnpy27bZyY2AO/7WXmQ="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon4.js
var require_poseidon4 = __commonJS({
  "../node_modules/poseidon-lite/poseidon4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon4 = poseidon42;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__4());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon42(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/5.js
var require__5 = __commonJS({
  "../node_modules/poseidon-lite/constants/5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FEhhRZjgD5jnrn3qRfvYO9loZT74OQzeLoa3Bq1AxlE=", "CreykTiOXJ5DwNwfWR+4Ps22UCLhtwr0O4p7QMHf98M=", "K3y7IXiW9SyajAiOZUryHoTN51SjzvWxXE1UZmEtat8=", "K8aw3b4dcBtlcEKL3Byhvw2ln/O7u5X8K8ccDG5nplw=", "EjpVoxmAOE89ILLOy8RO1gw4wR99IOknHvq5qQXu/Tw=", "A3UBzIydyBkwmnafTfCY5YiwGFi8jrfieeKIO+n7jFM=", "HCEW5H4DqGuxFpWwpfbatrmkYLHrlRqwHCWeyj/UfVE=", "LBghNIkDLoWpyMuOmmWDm/rtE+V7wPrknb2uv1T1b5M=", "Luj+09TSxxoEKer9jl2xcY8p4iJ5hf3yrYcDyDW54DE=", "KMZNj17XqsAEySAp2em/kbqUNtHM6UuTFtERxwoMFxQ=", "GKAdn/t0euDePoPHB/iyT2gshPFav1cbNCVKA0eGZeA=", "HCHZK+8ZfnOyNOR3e2DbFOZCpWzucVFdVOGscc3nK9M=", "CtQEzLyx4ZWJfLYMgJgeu51mpmd9u+2ti2RV/mLYB7E=", "Cptt6DMGT5O2rbma9sAFlFy2VMt70UyLl6+LYMwfs4c=", "ExKeP5MK7W1HaQMx/wncUWDvpY3c4sPmGA1FvsOqOm8=", "DXphTImRUIqxzkiVgTuxyC8Yv3v8nigMzKGAeYOTh/E=", "BTL37DbjAEGwSGmGh1yROkm93y9a9f6+jDHy9AlP/qU=", "BrvLjo4YAgEpPnEvSVDxsLvugIydZCY8hNnYrhVcuJI=", "D1WKTbGjrAf2Hi5r7pR/c1hr9A8hHOtPaHylZ4qdyzM=", "K+FApgtbXy+O3XioGKlpsgxkPkGbzwtXfCSg0Oes/pg=", "HEnEuanwn3ua1fdOusxxBRK46Ge6zifLDeoG6JuW9jE=", "FwwacychsSzefzPkdqOaGqd6gcBuLqxQOEewDVl2Uts=", "GcJ9DlL2XKNPTjGgaOSTMca/w52SQfnUwwIEFhXPJ/E=", "LxvcUlT5Igwacx/FJ2lk2rJrOF+kC2sEvtmWDiVDugg=", "BbQtL7zL9NOdK+kznKvp0Nxtkh6FXNkRVLY50o1KHPA=", "EiAEBxWkGtWfT0EODAWkLF/TKsUv6dBviBiNcfYeCTU=", "JflSZSYVW4OUZgn3u5UH3Ukl74cd7pFtkUTrtOzhNDw=", "AXv+QoQpmud0C20OIElR4xSopdBFJBkUeXipWzR0JEQ=", "Kl1HZAIcpx14qWdMtnCPFYjSzq81eMQRHPizWe7wic8=", "F/Atq3RfvjwIEyH+XO+EXnuNBwslFNKbKnt9icwIFdo=", "GdpiYm23GZtl9K3PV/pKPbqhdkp70VVwjubzeMie8BM=", "D4jilfou2BtCbJH6aTZqc+33Xzm/GGNM0mbsQDiCngU=", "H+McVUhUbHlI/k7hvXQS4ygO/30gywmqhfSfJ2YUgBc=", "EP3BYTvb9n84vd5WGy+R5MxItZ+Y1kNjj9wK+tv+Em4=", "HyYYwuvpV0UIucUvAADjPr/drRoD/da8pu9/AJMSe+8=", "Ep/n/D76xqirI9um2IbzlNoR9ZU8+Y4oJpoNuip0XdM=", "Fa/UzfHk+CDBYx1KuFykujuvz+5yvq3p+uYFIxAkSOM=", "Hyx0ulw2fjcNco5x4VsmiFGnu4tFUoy3NJVgeayZsBI=", "ETDhhy128vk2nPWble35zhnwH6icnDaybgne9nhtrTw=", "E1I9Fz9+a623O2P8HJu9vuJCxhvGhlZJMydTOlwbHco=", "FNpA0K9CemXxhBta3JZThlM2j3JUy1Zn3a27rXpXTNQ=", "AJH5ZADkKX6oW7GGwXswToJjjlf9Yx/2MVl24aXdi4Y=", "MDMpv5AxxVFbmjTUmmS7agJnvHtUoN7KXEUCd6ACzcs=", "FO1H5VwdocLwXTwaGy5sGFCfyDNuz+nbc3kW4oP6ghs=", "EWHxCzV3ddgQrVO8xKINWt0rAyUcdH3rBO6UxWXljWs=", "F6ilCucs5wfyK8Bw65koUcqRTrlMxo6vu4qWpxTrgiE=", "Gmxh15Xbr2L5klCzfsXfiGRaHBU3kdtjErky3CUOT2I=", "H4vSq4qoQGZMTu4ZjEaE3EsFdyuyoIadpnIrFfRHoTM=", "H/y4UqTwAnqXmfExzXS5jM+4y8BjSdj+/MYvEMj7Pi8=", "A150LsUvGbNtSJxyD0Z/+td81TvC213dskayMCH3nxg=", "Hfqu5BvflNeDqin8Yrfse1VnOqgY0wX9QtF1oF8uPYY=", "KCE3hHegLplQBaVjUIhUCUW9Mz8tFFXwOKIZuMR5azo=", "HbSk0PI4pXCxBhxu7IHALzH/3Up8GedjF08jjQSJdCE=", "FL94iUV7ILehNns0o6U4IX1pO1JCav9ApLtyiTsXhMo=", "LO1Swr8pb4fldBDD7JqUg6eW0WT2BJEnEJ/w06nAhGU=", "Hd6sWAWn9K2k0EQe0QjjFJ1M5lhPSa5b39RtZ2buozQ=", "Lja05enJe0YjBOjitfnciOHJ8hYboEBnP5ERI/BCrnA=", "DGhA0csGZtxZ6JsYZSddihZLRHxe1kNHyu5jUCwjjV4=", "E34uPonnHUYfTJvD6PEhgyYqTR21XFibLK6qwBI49Yw=", "JQky57CtzyyE7Uv7YKNra4LlWqlHURV7HUV5Swgciq0=", "FwpykvVjTAbdO/CatcnE7NSwDVzi81+XK0VVOR8WtC0=", "DWjLvnconnjVy/UdcPG3W6IV30570BSdELLFDypPO4E=", "DK90VjuQUl9kWm0gNuzRMG+h3GgLSdnOTtJMl0mXMXg=", "IKfRwKJ/zOeP/jcvTFgwaxZvlFbtRs3rJV45W30w1Co=", "BiPzImtUcLJ4m4pTBA5ERDOF6Wuc+gvk01AVFYpGhGU=", "FjIwhojCXnkPV9aKU1AkEkKlYwU0feSlAJzka4zcuR8=", "LeR5Om+ZzRTj9mQiEfTQt7z6NhWXxUT/y1pWfpB29H8=", "HU0G0Z6hsJyteQhtUb3hFyWlVPqZVZyi8J87tz1yjGY=", "BIDnR5pmp82ephyLKJdDiZCDUKvEqvwYzXXjPdEwwUQ=", "MEMLAzaOvKqRJGlgSQvPkX14aBRj4ufXRL+0QzXawk0=", "C1ezcyASfUxQ8mkSSw29yysfE1IkGl0SEDKD4InAx0I=", "LPSJBlDSckDhlfYKT2mO2iSbjdYUsjN2tQF40t9tK48=", "HiIcVSaJi/0S3oaFGg2XA3UaLyOQCKtfm307aRHGQYQ=", "KOB0ha19mS7RpY8ynKEq3OTsaT6927KVLlTTOfLuvaU=", "L0TWT4TeFtxnvV6tUe+x3IOByEUgwShU3V7zoHms1OA=", "BQp2vDLr0d/ivjMPME7ces5xZ6t7oVFvQCHGLPDU+sI=", "L1jEXl1lmmfXgTZyQfbDXYy0Y2HZeyiUfSlCHCcFlKk=", "JejamuDkLoQOBLIwNw54K9tnU0hEMlujb8fl4WDGanQ=", "L+xzTaIP4yAD6gTxJ/hEck84o2i6EMKVRCUr55YED38=", "KIpnePOoOYio7Rcn8V6TtMsU9OOju7kd1tH6yv/9Xu8=", "INzGx1/Yklm+f0BnULPbZ5olqM0nFdJFuRdTkKySLIQ=", "F/QroQlC3yXLilQXgqGLb9Mc+WXREXjHsErEW03qXdM=", "Ao7rhdEVqQQCDgxhSO7GYD6c7avGZKvudkqv1FWYa6U=", "Cx187POnmyrT+imPbOp66V2AwCmezJGOn4ycPTjVnUA=", "BEAznJdkzsecFu/bg0omJh244/Es4c9yLSPA4R/0zwc=", "BspkfClyfBlioAIXfaLVBPSwel9+tXx5uI5reru9rVw=", "LqEgqGT1xAk90ali6PATx7jvd4sE0rpb/DyrKGGbqeM=", "K7c3VGxK7nwMwrqHwRV+KnfEeev7Xcdq27Oc+Gl2M/0=", "DjDaZJBiXTPnnNUBdvVo+aLCjC9EmivVGiXRVoaAOpM=", "DffKcnihNlC5GdhUl7LrsPcQNafCBDDUEx2QOrf1dSE=", "J8xYn1v1hXlKus5Yn7inSi94TAmQuA/KppRAl/hw4tU=", "IlXDajjIc13kXO30Uq+oQjMtMwQveOYMQ8dFVCGzJb8=", "Ez2WAr0zeNafaBwnsFvf/Ji32GzKY9c6YMrtSFeE0Ic=", "DhVI6UKunT4mhgaZuTcnyBeplIYWyT70rM2YGx3D14o=", "DyDw5V2TaJ/gnsMS9q9HYnSC5L3goWAqjiyNboTopq4=", "LlIyhIPLW3/y605FsS5RsmIyybwXtykpVMCp9r+lG7k=", "ArIWLVM+BZpu2iq7dHEu2zp4YL7qld2KSr/JV2YIBPQ=", "GeCSdxXRzG04lCmUf7Nzfa1zOXTGsuE+Wz1DJRlRbHQ=", "DTqABFfXd4VjYwO4uU8X3P/LRgSIcqyfdO9/J+5XNwU=", "LJdNGVJVehqsX3uuSZZhbaYZtz9EHE5QTcj+nPtVnjI=", "B2a/7u3izPNwjhtP8wcUwiwdQ0zb6PVVFLq8LdXZe+8=", "I9rI6lQIL8Ex4XOuVeRjDNTKfIcbKgpHnB505/GR5iw=", "F9X7bCyzcBDj41irLVdTdocO0zGGuOrkmtO0fjQKjX8=", "F13Kx22KgSYTm1g644hTKQJG5D54P6aQPsgAfxeMACM=", "DE/Qj+3l0iGtt6v1SYmMkeW+foW/H9KmEb8YLMLnFlU=", "J3k0uQnnLTo0dbsex2arejitWbEoMD/FAC8Cplvf5yk=", "Dog0mZjf5wPxsYRST5w5TWAEzKz5y5UolujP2wsHi2g=", "HxsgeLYLD84Hgk4qK8jK6O5nNRSwBwqLRXEMx4y7mUI=", "LrFVlWbFNt28MW9kgtUfo0BVdldwD1uKhG6BKg7TNNE=", "HE29wzXPZ2Q1Ugi0ydJD00VB1iPGad7Cw7oGa76vZ3M=", "I3SmstpvjKuOXP6NgF3Tot/KHot+ul3IV0Ah/RJB47Q=", "Gd00JTPMxgOplzjj+1pWm5TvcbPkn5D7h09hYXMwcvQ=", "IX1m22x/s+/6UIgAWH0us8bQPYOFEy8vzOfzXycFzM8=", "CBX7hZH+AQOM06OziyNvnvynfGGNO/xsKn+okpbH5k8=", "K7lDtAwr1FamwXhTscqI6w/zb1l0sv+aX1CT6b9joW8=", "EaUVP85llRPufLmXSubLpYHjtM0UVwxXCf7D2NP8guk=", "G3K/0HY12FAbLv+HhaJJW650x2U8+Q5tXJ8URCaDbfQ=", "FJAsBwDuyJeuF4uoyvhQ15Px2HUSvqDs6jnPax/uIz0=", "CcE4xuCmFqSf+Q1DprBD87dFt4hlhW3EwaReL9hMs/Q=", "BbWKPc5XsoGicdaYlQUtiHRYpxV4PoMX4CSmGjXsELw=", "K+jSlSXAz91eazEl473jv1WOVfvoZ/AkRXqWdlR00Dc=", "Bh1y948bqdxrTX93hCJdaoG9/Bta1sJDafnAVgUj2a0=", "C/GK78rP+r30ES7drcphRXOLSAOzYUW7lRbbUBoGkuk=", "LnPdEF+osuyTHYzfKexnnjqYAakwcafV6jBlklXwO8Y=", "D4RA72Z8mugTN7pdjJJ6U0fecpaGCyEcrR7L+101mO8=", "AE0wOy3qYnsnMb6D+TrDTn0U0XihOABVjKc5Y5XrEY8=", "I0VBrXIECnDaKZajUmkjDJRpnu8xOk1IBQgAjLw9N8E=", "DRI/HnLSa5K92P1z0UKGwxKtTCOstGsuCMFXEEQJ4XQ=", "L7Ngd28N551wmO56pBI8Be5rBai+Rgp3TzoEjhOFRbs=", "A2hcB5Q04WcnbFfTzHlwO339xBwVbqHot/mbaValUyY=", "Jgrw4P/8yXcsFjGxeTRFZrR6qto2geuQNMb3XDcFwcc=", "KGK0E3T4m2lSdLM7dz8lVJFuK/+f9nJUX8L0lWP2J2c=", "AqmRL+FwMQInGJ6h5pHQNi8Ys4tACw7/GSyllRPrqNU=", "COUTreaUoNisHz6/GpZEDTLHE9UFjhIk4HA0jCgfSm8=", "FApKQx4u55QA7XRll42EdzITxigmT/gPIax6a2c9Cas=", "KWr00BnLXffZWbKdVJw/BxICtOuotT3F7pee0UM3eSc=", "AYMuKEp/TIFhSIK2k5/A8YVXO9ICPj5QV2VHC7gSs0k=", "GoTVame/3T2WWr3NMpqnjU/pNDRJby0QOGH9GdZtcmA=", "BAy4KEd3OSfSrv3AdIkDep0fdjHsp1yfsN2gy5294UM=", "AQ3PCEzCnLfK7PJqpjO85O0rAZ8oh87nsaePidP6vi8=", "B+3CKgkR6iFEJe9UK3dtsjsP5YF4ENQMcsqYqr2a+oM=", "LupKsIrsd18hSEeeo2+7lpNtpYuki9HS06zUgXOqq+c=", "HkDA6CV/5KYQBc3PrRSM9/R9G1z936oIJzhpVRgkXxk=", "I6J4CVg70epR9DbeVEPhCPadRM31HcHwPiGUi0mAuHY=", "LkZSsETb/kDmO2sjL81fPzmr+9IFHuaK3HVAgNSSUKk=", "Eeer227Lr8Ln2M3v6ce5xQR160dds8LK9/fWf0hXdfI=", "GZ1SNQzDDoxzgh+AIJbw5UehNVGye/a4mTlvY6xc+Oc=", "D1ddbuZ8vs2YNFYk4DKjfIWafL7zCz/dyUnNCXhIQQE=", "HEtvmiritBjmJlrLqclrBhhNBwKOX7eE80da53cv8Fc=", "Lctc+Ilt458ijhV8DFWT9GJvubwiUgY4PbIDYKvwySU=", "E0CrufThExhr3CbL30vMpQtTGhB/hjylRFdePPhw+OE=", "I2jmkrcnh8uIcOqIjnFOAG9Z0rRGDPt0xIqMxzsdGls=", "H6ua3ZuqSk9W8jFld1xvLZIqdjKpT5Y3S33IUnVvVLY=", "DH97gjANPGzj+JV7oeSt1UxMAV4g2XZdIgVxwWq4aA8=", "FdY+hr6s2Txgg2iOXZyPPGlHkp+fH5mrV4pMOpIu/wM=", "C+hDrl+bB+UlcheK99ro7QXTaxLAYHhikpNV6nQCPZ4=", "EzJ0nFI2lMtpNeCWOgfoGwWWfOHZUMC3MQWOySp6DJo=", "JUOUCIEOB0wL3UWYuYFf7okruVylECns8Am/+lubloI=", "BX6NGd2ZmpGNopsJQLODup/RXbCw9kmW3/Z/61X5p0I=", "HgFON+mxF887SHDZmfK1XTU00Ka+mOnjV/pD8B5wop0=", "Gk7STm4DrrzWvbEAUz3JZll6/hXIUbS4Y/boiQhMZHk=", "JTQgAHCD8aqGOtR2CQXBA57UERyfBT8ncQRS+DzjapA=", "InahRBlxcJr/5tKpkyAAHsRexyFVxXXd7srA4ydZqwY=", "KJV90SGOp5n9NBHrGTJYU633rorhKB91MwL+fTHfp7A=", "L9klcmq3lMiL11eWqj5/HmaS8pFM+AImfd8B43kCoAg=", "HPilycdqhLFHyCONklPNVbR8DEPYKWbEY2ooZ0cF/Zo=", "A3PLvDBuG6uecHc2hxXmIwtLLi5KHbnGdLjDWaQekQg=", "BgKD0v5/I9/1E9kRCz3GJEi8SPUxzgweq1kgvyMpCkA=", "DatGXW2RB0DzPvbMDq3HG/gRm9/Vo1J9yLv636pAJjw=", "DLp7y8giSyqOSroXl3IwpobNZCHcDKU0bzRGtiQ5xMM=", "HkNl2weQycT0RbBlPEZv8h25bDi0B2uovWi8tN6mkR0=", "G7LbohmamrO8hu9fnef2xcoT1g6rQs7WjemPxkOACo0=", "CtPBhwxtbvQO661SEjzRopE9nWLoC/usroEuCCAh+co=", "AbCYyR57DLtcNFiAd8Dd+VMA3fYUk1YwwM46JickUwg=", "Gf1cDqwU+udZi9TO6jseKZiwwWhJO21yrkG1duVbnD8=", "DUdJ15zBY/FxEKQEpG/kJ8ZDTz/me357TM+mq5W9fhg=", "Hrv+gRSkG7gJ4LMzmSQSMuuUCthyjIpRbUCtpEDb/c8=", "JwTlthM9l2TW0/F9SdgzIj45N/gOufrqu/upuvS0wbg=", "IWXhyAJzBbGuDjI1cWNeXVQNE9cQw/mjkLaRPxTQNeM=", "LjSX5NNf2llsBq+mO8Og8uVdTuukrOtg5lCBrWOqi4o=", "Ax2kNF7s1ttsD3sHx4Fdet0f4FRtc49NeatcV6qEHt8=", "CJ7OVOR6pckI5D5fCHN8FDaWcIkAasqxyc0Z6sSiCHY=", "L1PBXire0zxH9VoHBIPmzH84Ifv4qkBnfQVS7Z0Q2Ec=", "FCqjT0suitDfeiGz45wAyLCqKFcJSAHqr9cr7+0Hf5M=", "F66k2kx7zw11iLAU64tAl53Scl7aTmrOMxmCRnx/8r8=", "DpcMGdGXSNjEZRBNjwIgA2P5pBeG8C8YJ3QrINwNFyc=", "BLytnlU3lWQvWbr3FKa9tDL8RaCgt38aujqYI0dt+bk=", "JCwL+82qdvcV29S6glxx/P7WccGxkB+khMh/gQMV0M4=", "JdsTQ8JBBAcQI/tu002ZCQeDEeHv6FrwoRsZEU+p55A=", "L/5NnEIKWenNx8Masr81GHyhR8uJijlC3rNnd4YDaoA=", "EluwOvPizxi75vW1kOs7+NDRumO+aWSD6Y8oO8fNB6M=", "CBa+QnRbfbtM7/5bjiTqYP2LcZ3rpQA3rHt1lIdFxrw=", "ERFg+az27DYNG2pxIxOg28viPmRCAFVHHS7kxd7bNdQ=", "E3eXjhsfaokl+o57eUG9+PtZq5VCNCQZKD2CA0Nck5E=", "De/B2IghZu88zeU6TyNvuoPThGIZN87lfkIaUT0NM5c=", "L4+lx4xwbjpdSgPyp6OVMEbX6Uy4in7zUOZ7W6Dw3r8=", "GiqVfsCnI9phwhNLqwvxe+sA5tzYRpDCMNy55Y2pSCc=", "HN+HEJlfXgNBK0p/aZUy+f0B8OoWeo38Hd834oBa3e8=", "Jv0xRxgow2rjbCe3SAVLDAxP5SObMBaZ43Ze6+zBiUY=", "B3XZlswsRFbzA6LB+QB2R+Eakh2f6j97kmFDuZ0voL4=", "AW+5M3cIymOM39qRvQ2uprlyJO97IGJnKt3RvRi7iQA=", "LDkvvn0/3kL8pPlHi7Q5MxJYJVNW8YSvb3bxGQVBF9c=", "GHoqO/eaafo+UInvnx/Vb9tHxV7s53qiKKo94bSGvLE=", "AnGoY6KAoyZB/6M1ELLt0njJhjA1lTLz5Qaydf1dIM4=", "FVdFnJx0yUqgDlr2mh4xEvtpU3zol+wMcYlY2WUW8qs=", "Ko4myo1kfZpjiFFuqdz/iQg9U55YFowqUMba4w8QnyE=", "Ict1IZTPQ/O1GULrAEDrqd4rz7HCo/rpeSS3EPJoMs0=", "LCba+Za+JHrNbdSsrWDTi1pHHmMiGI0CwTfny0hDd+w=", "AkAXbuDnmC7r6Spo0+OjjCaCGswPXQWM+ME3vKLSbxs=", "JjbglzyGXBvZdN142qqNCoTNr2vhrUfs8qDRjxFzGPI=", "GehPTyWnmUlgQWYdxdl1toH24GdEzuibe+XZ/eF0SsA=", "Dr+JBko68kfKHzb281cBiOJx4LMmxPsmZk6J4UVMoRA=", "Jcfpe0db4A6LVZo4xFI2T0ycUx/suKxpj3/XPOIucew=", "BETJnlkjU+WuyqMCrdkBwU2MVScKFgr+1EKe9VmK108=", "E424iHgwVl8mk9Dg8C5OeeFEln8LpTsDUZq6dktcmUo=", "JNQPRiEU/p7gKq/PdLT8ok4a42XcdcO1K7E8u7LyHt0=", "IeZdbY7kN2C8pA5zC130xM86inMtsUj0spUbTGHWjow=", "JI3XlmnsCdvwNQoV1sdcapvarO/KFNUTAJePE9GrbRw=", "K4I4wVSPnL4p/TXPkee0jw69p+Y57faf6NWrp5JNU2I=", "JDn9I5JX84GBx7489RPxv3I166lPa4lCqUy93s9vYvc=", "IAlYI1KBphuixL4KoygqGMdLbSYvXefC4z0rs+iT3+w=", "Dh7KXfiO5fYM+n4f5b77txn62CEfqbLQL8wjMZDBfxI=", "JrU0J/mz6ix2nZxmD8YIgaFpwScy0AG3FY7ksbhCyiQ=", "IPOz9Kyv6fivPgZmGzqPd4+igSUiudcKZ0As/42ysbQ=", "IR5dKznWJSCnpifs6MrLrJ+XUG3vTsKGkoumwn1GOxc=", "C7dD7jSAISnFVnMa7Z0wLc0IUxPOVy9iQtE4MuU2tLQ=", "I8smYbSI7nHkx1P/I65L0l2KRAlPZrZTKXfiIUDrpcs=", "A6NaoxI5Ec20U1uu0zWfX2pSBbnJPvMdNTI6R4B7i8k=", "J4A4SKCu2WqT+pQ7ZjXkUCF+E39K3nSmLXkXMicUtpc=", "DLN4OcLJp/95iEy+x19B6b5eR8dtYVOCMb2BYpltb2c=", "HwAm0L8fjh3VQjzC/sH7XNqh7NxMPLIY287vd8ANL5M=", "AqfXu5cLim7S7mb6u7qVa22jsQD1tfuSju9C+XCCc8k=", "DP1/QhXkNMjaF+wyWLC8YFrRqy6QqklDUeTuQLvEkfo=", "GAsRtyBiKhVoSdxvf25/VxZZvmloIjDF7ZrDOXAKfN4=", "BOlqllvOPToKJKSkV8lRWCyHE0nOfu4aq/5XipTGUBE=", "FZMfeCtF9/tlbyzb0fdwXDU6I/4dMKWkahUi7RYN860=", "LiluV8l6Uwms0m/r9VrJY6VETBxfcDrYig17l7ndOLE=", "JhV7zreOhGu7Ji+aHgbUJxveWlvOjwQZlS+X/9E+rKg=", "IZTriYR9aw8Yl/Z18ZwMVrYbEySO/zyjbjT7nRx57kM=", "I1C/NUd2VomRUa193pbqeFfhVQFEcAjatrPSfI/6J08=", "GkhvCuWRys2vCcWKScTReVQFQ1NAgZ4APwRp0RC3dSs=", "G1bc92+yPMSoNNRVpAZeEzVxQCt98wnVm8MQXUKowwE=", "GnSdeWSvC3ICkT7yBMZT8rS/tlzqt7aFIzq1nOO7aSU=", "GK5ZAHP5aWlq92L/pOjw67+X+Mx4fjfN3R8yG+O+rbs=", "IcR7J12C3eZGDV52mplCEUSxxanaWSlK3py7MXED8kk=", "BHPdvVLnN+UnNk6OtjIHl1w41f1swysnIQKwgs0VGPs=", "CxL6yVttOogdiSZXyEJOZFrE5rAFFfkC1ZRXQwKybgI=", "CK52FqJgz2ZX+Pc6woRYjSxfB/9CXYN6p83O9j4+IQM=", "A52vaHYoC4Doc78qMv0oNKg8aXV7rdWKiI74Gekmzig=", "Jeex10cKPHXxPwtWVGyOCfLY7+/wbvdm+ceDyoadEw0=", "Ho/TY0w/92QYTQNDX5hYSxG1sVrrnHUmLaPx6iwqnno=", "JB3MUaw3gIpBXdHjwoHwWv8ReJ3Ayv3XejVITgmT+aQ=", "H/wxU8Vu+XVZMs6ivgVzdJva/hxPoHgaS4tAeM6ddUc=", "F2MNYtmj5RDIik1Dw2D5K8D6ALZgMa3sKb2VQ/06F+4=", "KYBADt0ddOPWnbVFjSzNX6vbI27BaoKkMBoKtZ6kpuk=", "MDT7JDZhI+xtyvytNXJtv7FhlMA23NZI+mlDm/zQDNQ=", "Gqfo9Bicqd/z2yq3ZIvgojkplc5GBB4EaA3KitcjLfA=", "H6GV+DSmnmI3L2DrSX2hZ2RurhQVPYA7OdxdEfXXgAs=", "DyPxx01fv2GVrVpq7l5WmTxUd+hFP1uToNe6/TMwNtM=", "AWVW+sk0inNatQqgiclxUbPKrwogo0+52TcFBaFRVyk=", "I9kreTZIEQ/Fru8GM/DHfKyw27yhh5uKb25d9EXl9ws=", "LkwQ7F5l4vI5u8Q8EwMd8mhqtA/XmjBLBdYRuCPyO3M=", "EkGLv9d7Y61eFoZK2cMv+/xaPdm3jsK3kyn+XgqNKVM=", "HkqKrOFavB1bdqnoSEMdLAanj3K2vrsSk+bFjlGFaW0=", "Dz6WEH3s29aHLCDqCaz5LN8Xo+4dEzFIgJLZYXbet1U=", "ASw3gCB/OVzCHesKvZUWge6jJJjdumzol6j58MI1cGc=", "E+qxtOZyuhscG7kBdpMB8eVlnQPqEMYd4kd/8KwiFCE=", "INxmSrsgt0VsBmKc43oeyxonpOiyTjG0i5xGNaowMj4=", "LGseLP6njiw2eF52qM+xsFfpRx8k9bORF1w97LAeAA8=", "GIySYlX1t689qWNVcpwqhnCrTCxwQASBsqyQN0Dgxas=", "L5kTII4J49bp5vumOE/QdquJ8mYpduPjDghwuzDrVPI=", "KzOAPZCIlwbnFPcgtWKNJvtgtUWh8+nOSaaukSsCQIY=", "JsyrwQ6wQyfLXMPd4quzbwlwhsl+c4wTPJ9XB350iwk=", "GxauDXxUQIy3X9kx8kZ1HysMPcINeegqJTG3bCK01d8=", "EdC7RhvYryhE9J8PhAyU75UYslETRHQtH1Q4/j1BWuQ=", "IzAxhHtHa+rQEY09szjokTPsQg1nPlBK1kclnfZVVx4=", "H4TpeJW+5DjrPJLcmxhGya0pwWQ4ewautu0YQe2MTco=", "J39/m1QvDCu19FvtBU8JYkU2AQw8+UUtInMZMyf4AdY=", "HvyckGnlBouqwT0uZkVkG30n6A/CMHcWFTXERoLuV6k=", "DW7Ed3YeLvusTxSzvz1SV6meZMPyX+EE+vmIsg/l/0Q=", "Dg59fFUBmZt9Fhc7WbfK4fIDvvIa6/ACUYgUOcz5MBM=", "IXvvL08SxtzJHCBYojORy3feU8puRNzcbqPTb+oybqY=", "BXgMiK3wFTG1D4F+P+RER9KbNaqKOJxx6M8SJqzvaLo=", "GHM4h6ays7TJDY5JkBluI0ReR9fqWTnr+4mj7j1ntL0=", "ILrOY6z8rgscnyvuJLjp2oW6WX03sJBXIMTxXbIxsHo=", "Fm6llTdaZ4asUn7p7O1z7Wv1UIdqvK86yStCyAiwDY8=", "MEJiqe/0BArPQ+Mi1vUmdq4vhT7C56gNsAxIjPkXx04=", "ImuscFAWbl9tt4zQsS028wW26MmgVRFK13Ceb1ckW2s=", "JrL1OcVzgp9qypG6qVRQW8XD604d8dY4WCcX+98jiMw=", "BqD79M1S6Tul5MbEr2XbAu6WKX+K0gDy8c/yUudptVE=", "LLnCQRLTU0Gs6siDYPtSiSTli27KwyG5+ynmqjNo/yM=", "IOiKTWB1Jt0H/gijVSpEZpEp64f8wLE6rI/or9kwFSE=", "FURkmivXPjunLzlt+R3WVAHdj69R3jJfuu251TatlPw=", "GYAHdFeZVxLETafhdxMljj+Os1S/2A7Z6vPsuvaWAQU=", "JdHSL/E+dwXTwIX5f8Tk9pFLgv+qXSCR7GTaxCN2Xvc=", "L+yZDvVW7+EDWkZP9VgedAZ0Rc1Uq8r2uMA5n+DSTPw=", "G9lWNQbZVE7z5IMOE1RQEsV5N5wtzBMwQWxK5JvE7GE=", "AK/80XumADxW36hVcfwpc3siWoDUgOfdft7AHxTyMBA=", "I2cNuu+WaIHwf5GaLYgxKMeyPPdnpHeysuB2K8DbwYs=", "H5OlMpFzlMfiL9F6vupjicZv164t2fAvhg9tlpR/Dt0=", "LeQun1N7fWGwITdxwOdPVVUSvge2pQk0c04sW+tAvjc=", "JcVX9FuZeBzTfTuyKTFmKmf3izd4LIhbRWu5bVXohAQ=", "IHTItwlwXJiIU4p/ijxK/2R3Mb0W+OJU+nTqnyvnZiw=", "Jzg1WVYpgTiUnkQhcdak5LdO8gZXQNt8/DoLYP1XOss=", "E9Nq0KTr64GWl3hkllnGXLfQxBzFGYcf23Gp6moMqlY=", "CKLBi6QTgTSMGs+/lhdxaAa0YqFpG8LjQ7ebgIXjdrA=", "BZCS/Dla7ShYB7v1V62aEEH1nAeYIrEIhFeIL+57YSw=", "FhkkFRtaWtLYysEZUiqZGpBvFehTHccFZ/ayg3HMJOM=", "HGjKj3qhdlkHVAXvY0G45popi5pNcvO7hUswnkuoehs=", "J/XQO8ocggf3I5pLLPc65VmhWqN+e93fOqsF7sXOVZI=", "Dsv/SEaWKpddNH6pqPxGX7RoYVV2IvLCVkp+Y5gzwWk=", "J3xN4jY9i1tFbPxaf/jkb/LsjapZhV9a1kvAUh86xWc=", "GxGGLFKs01G3pGR5P0+7V/7Jn4MrYyJvldF1yNL8CLI=", "BqcZxYTHT/vdchjrVly0yL2GyS49+zxz4VJyAapRI04=", "Iw5K3uy3mYd/fOmljINrmdUzWEoZXB13oxOr4cfRJr0=", "ELEJuGSAnEdnoTPM5sutbIhigXO46lHozKhYMMp95SI=", "DiEReXDc+9SxUmslNjbzd1ONO0+q61qLJL9iANFMxZE=", "Jmc0mXhAE2L2sXk57rDmT/VWB+vbNccHHbRrs+e6R3g=", "BQAPpf2lBeApoTv+MEwmew2GxywDm6v20/8C7iRr4C4=", "Jk2eCUrtX0GmAkIiCjSihAiQh7JDapv86BdMyb6MLiA=", "CAdvnEdD3mEw/2Is9AHt0skvJL/hFPPF5ySJF0YxXEc=", "EyNwq927Cx3VfypSDCUza9fO3pS5W79cIVHW2I5kG2Q=", "CP8RFreiJ7/f1EZaZ4kIgrYVyMTBfyjY0klY7fYC3cs=", "K8sLDbi54+ArfpwclGD92cbNmFYjMuZI2KPgq5RZdSA=", "EupozmiBvsrX+KaxF7A6uXb3q9WX+QOwvyMNINIalDo=", "J0OcmKdmiAZ6CXsZtv3X141fiOJ04Nj+peprdAb92n8=", "AvQNCtBfVlLjHvlECtcevIQZ45NJOTfwXwBJnQKpnjY=", "L78EKEMn7k9oDwa9OQ4wnQ0TrMdLnFsUtjBZuMx6v/U=", "G+aG1T4qitV6gosGUUJc/Gl4xwJ+2/JH9rZyPCHfhuc=", "JoO0JehaUI+WhS8UtCIPz+n3rYsXv+/A40jEfKeLtX8=", "FtrOmy6AEuMdscfr5nLYa75hoao+FpPg7d/A3gqd2VE=", "J6Mh+MfTyQIuli9/7y48hItFOdu3WqE58wQw/lRbzts=", "BszXIQ3uHWsOIreeEtGQgtgHi3iNcQB7leendO2GplE=", "CkHdQiIWU3Ur7zUPbXSpF7bLsf12o6EhZvTQvpeOQCY=", "IgoCiB5NR6yU2VDN+DhidNF4LifL0NhFl43uyRKY8WU=", "DiFVpUX+Xzy7Y5dgZYnqwZzZJjkznGsBcpikrTQItLk=", "Dw8ZxikeUVRqJnxgzHdOX7nQiLrFMHgtiR7Br0uEcHM=", "DpJbzRxt20o6HGfsje771AxTwNM+eu7xtGeVrtWUPJ0=", "KtAAsXSKu4Es1uVBEoa5/z7wpb09JZo25F7wW561vus=", "CmWqIy0y7W6N5j0c3/68Lz+mFkZcJ6r5fozT3P9khlI=", "AmPYRwq0scYddNjoliQvTyYdyxZ6OgaSOJPXyyyT1qE=", "KQHZRq3clLBA/VgATZpfjNGSZUDHqGEs7BxYy2DCs6U=", "GInPqCCfSVLfkCLbncWDtXF6BpbaQc7mSTfQzWMh5pM=", "I2Bk1xy2xkyEdHrCX8+NiBUC5fA7/4dWG4WhFrHzmso=", "L/ehdP/Owphi4E9dvcc+vzZhVwAzV2KQwMH2zYztJ64=", "GeckoddCyrEDRV8AQO33RaJpanEITJPjInFUUN1Nb1s=", "A+7TiStvDmxdoQWcXzeTmFg1qig1AKgSmQSpTIfxYb8=", "COK4Jzv6MMGshQMG2R5Gip6NBQkq7ky8gMaHJIRjujA=", "B63Mp22DN3KIOaG2rDs+1Cr7h9cq+Y9S9Bby7FiyjOw=", "Fx7zeJa64rECCgpYOb1ReEzhG7QjfVSMFxFp0y+hm0A=", "IP/fy4b00AUGTtvClpGMMy0y++/xcp3lBWomq7w6Nfo=", "COzXpvFzXu2GuqCU5gj0iPONuzmPz+1LmUODoMqORkc=", "HD9dhuWSH96YkBifHYxhh1QohgDmkovBgqxNXkyfDMs=", "KcYRhO2dRg8zdVihr2Oap+PAl15AFO2OvK1KJdUeq/M=", "De/UWyiVhygiituy29rval6bGmSQKnNPQCuM77irO1Y=", "CnTqItigkzYGBhAXmsHYL/+pSS33be7U6mDgEzsIEag=", "A6N78S2vFADSl6xKwTuiTBfcJi2xbIUj3u5ODM3ppoA=", "Ef4XkNWrv1k1/yIxjk9//mmWatovkTa1T4MOrLCmU2g=", "AYFlhC9AY3XyNGaGkVr7FL8f4FZMiFjuO94Kuj3l9o8=", "Jh2yXnz/Wp+3LydrH5JgtmcwD7fTYbUP1cDotplbBfk=", "KjrDMUsrZueW++Nt93jF5GlyMgzEPsgHBIgmtnBLp8Q=", "I8qkuA7PqZ6dP+orvB2782nRv8iTfQPQdAYcMP2M12s=", "J9smAIXiJImN8UXyP2NfIGbY5OEk5YHoxiYZKbHf4Qc=", "J09sX9NKeE1rkV7wXUJO5sC6u/Np55qxOLgWe1YY7H8=", "LDop4TqE0moJEckona8apM9YQKraBwHVfiPfx5babaE=", "HqIQ8gAaM00+gB9OUycNQtp6rzF6VTtCgqp46qIoLm0=", "JU2+tSiEtpnBun+g1ugNYQkDsYo+UJw2NRzMOwJJRuM=", "BZ54HWWJbr4OS6JtwvKZB/R7ze2kososcT2FBeox/V0=", "C1sc7GPULV5hXcJpuIWiTO8wPseMly3RfNuz6RXMT/s=", "KnwBXpw7LFfKi30m05obzIXW/6y32fvWbSqPHWTtDJI=", "Kbc2uRHXGnnPY9im94bxG9Wr7iQWHcVnp8hR6uHkO1E=", "KFdFqQp/49Ca9agIcEvGnG8XAeVzkS31zB4mXVlsQUE=", "LZAbgZXDyWyMNuuZ/sATTsK4MEroEL0w2lVOMICCZxU=", "GQXTUYNV6rp4WbWR7XuMnCU5gPBFDb31TXp3groFg5I=", "I+gTAm/AuABk0ZtcVCiUL99+/qgL+o7ECVJyv9t7TJ8=", "I8ChmiUsh+axwcIbGnmAAgDD+/8+MwDn5VaAcd6e+4E=", "EcSuYHuuSSQTv2LNqiwoaO0f7G3AYxsGfKYPqxJbnio=", "LNBV67fuRoY2XepFDwRv9iQF+uGxr8n7AXB8+B2g47k=", "BTyf7y4CH6miD62iL96hUFtYoxWbu0czfb95GyFbFFI=", "CjW9dOh8urqr6JrRMZ0snoY7TGMcIZOMmlOVv5eHKp8=", "HBFQVlOc4gzVoE0aXEPisA++g7JZAb429d3EZm/Dg/4=", "JClUBH5Xcv073tWQ7IvrTFQvLiZMjD4oTNxHNQXFGpA=", "Diq9MVtHwNyThJwM3yZ+gRy9vbIApufCtn7ffLAXQhQ=", "KCs3AgwIkNdRw/12lQ2AaGaOHf6uYh3VUtLeiH2i6nU=", "KJM4UiZrUtnqa1u5I9nZTy5aW+XHeOdeB5QsI0tkO9k=", "CZq2dlUFuhGY7xQOd7eVTU++eaBWznK6zjnASMANo88=", "KvIR2OCsLY/af4SbjyKaIlxhhrVXYsensq4tHdhcV8s=", "DNBw8jQBSigJq5DHHB2mHpipYyL+3Zm2qq4coQTz+s8=", "Jnk+KryNPDDGBib7qhWPJjWH1r0Vgz1EixFiZLkwJWo=", "IlvjbtDuheH4Ra2oTldIpWaZFSET/2G1BWtti95gwZ0=", "AhdPSe2wLVFU0r7KLckrnMWVOD2h/ejwnkte4+paBl4=", "D2SJHCyLAg5Gw1lMt1jwvdzb0JvQMIgW+0FzSoaYcsM=", "GSqEyi+Z02mR4tKx3v85idHBVsI54Q6fVhQOGFRXYGc=", "Kd/Ne2PwWr8nU6jDQda3pgxiQ7BMmhuLMyC7oEpNR4c=", "HuJ61rm1qGdzOvxhorPnalK6PkvV5let6R/AOIGduls=", "CrR3PxUMP4rTvJU49DzsOVp+NzGulz/v62I6CSF+ZMc=", "E8NSoC9ZUYYgLLC5n6WMVUKrZ/m206Cv0QPe7/bYD0E=", "KpfPLBDEv7/SmfZ8UqFp+SwFt9rFakHE3U/ofIJGzhQ=", "AL7LtHBCvX+Mn2u0IhYtGu0ImihIL3/RarBqEyhf5wI=", "AI5E2iHXOGkbiBdX7zftKcW9n3pEUPz1MpCpLMLKIXY=", "KyBai21LcGPZMfO7XTRkBThD/n++S4PBeIP4ZSeIKhg=", "LZ4yp8kFVv4QjSVawB513zOPzWOyv4TBkoDUJymIY/w=", "KaMiqEwlvS3fbi5CACKNlavWNJoCJmrB27pSBzjOypc=", "BnjJv8by3wEvT+VeM7torBTO0d8NAhUnkgidBG2CjEM=", "D6/zpedCV5T+IKfg62FbixdgOUt/IwQoajrkAJEk2yM=", "H49bYRr5/rnOqGwIQFgSBVPkBBA67iE/WkHR0CVBwNM=", "Fgh12EeWAvlvQKzC0ELuUsFYi2op3kKEllptxskw6gc=", "Fth6UYOjFqHXCvyVHv4s1mfHcyj8/aRYy/X+MEX0bZ4="],
      M: [["EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EZJPAv0ZsJJVqqHPRuoFGOPXv+70dCFglJEBHbC9CwI=", "JH+n8CIwShmU/1BUVsIgHvm3FzaUmNP/zkRmAe2d+EU=", "A/17Ge8shh8i93/4EPVOJ3vJTrdsAtedmGvj3N8FHD8=", "GL1BI5w+cVeaZ3RD7P+9VVqB7u6mk1Kmi2fIVjwMKgY=", "LXjDpdKN6f81vwoldjUZblcwyn9ASTJ3B4zXXai069w="], ["ClFKXCJ/TOyV36Ap6N0STDSJWqRrsnwJEfN4DVAVVAo=", "GS4W0X2VayV7haZS7v3y7glYnqxb6AkVd1cj0ssdoG0=", "KYzgweMRO7k1xwWOd3K1M7GqnbDAkmvciRflYFyjrBA=", "CUy06DYhr9Jx5BvHFyfwFY69YSI5rJ1pixf+S+Bbf8g=", "A9iAOVvpPCfWSa9f0ULnazORjLiEHVooFzvVz30yh5E=", "KO6ua1hmrWjkQ7uvkWgNt9fiswN+OP72G0LLzP/OyoE="], ["J4u0mntORK6kbrD4gstpKAGm5g/dW1wjxjzWXMzk/go=", "Bj7ewb7YMfUGr422SNb96hRTRYh+i9z/EJA1odm2dNc=", "G67xy1UJtSakIGH7U2V/mbMjJQDoVRksvoyUDgaMR18=", "EyRWSse9+eIhZOmFjX+o42ixZerqPa9Otn7lnA3y5dQ=", "AFdhuMauyxqMpOpN/CyDdgZKSoAEzu2iEKVSQFYt3BM=", "EMnigxWdWMtMsuNf3oOjuh/cKAAu2ZY9KpnxhheKFI0="], ["DDmen2eqQHB6ID/u+wuVi72tzsXKNJAdJT0CaiQZ9qI=", "CD8N8/GgNR0DMOw/9gLKjMNTt/bnYscQcYTNe0I0SfY=", "Gmdk1ZQ/xKcgtMChn9uMcRmEMHKHpYubX59dWCEssmM=", "ARpjom/qv4f6Zr3mbMJakiyWOC12xqf/SPFTe+rtaDo=", "CMp7ZGV8NUjzK+9bY60kKIpBwLJRCZrSf5Q0MH4+ZNQ=", "AZmCcEcek2GVVEawzbi+qRXsBnXxzWSN3LBDA1B6RIk="], ["HWs9X26jacJvgl0jYpM+qjHqNewKd8H72eAcoVI+RDI=", "EZ7xiLs90NMjBpdsGZQehmS+aH56aWkton2iFabwbUA=", "LZ4KtcBok9/f0DSBOBuoa25ikt9WCdcfLGSy2aefgJ4=", "JfFmMb93Bg9+o0CHwCW/E1eEMZ7wjNouMUGe4KUp5lg=", "FEx6EdpafF2rrj8z+9A8rYbRi8WUx5pJfsuYlO21VPE=", "D5cRYmJ3I/P+rayyiwwQTLj3TeUIdS+o18DbKvE96O4="], ["JL5RAJVDYgbdCr0LDLuVyIOrMEqlJZixppMG7JgaaI0=", "IRYQ4q1KN3Qm+t9waLDBpsKZoWTBwaYD6u2USHDQubk=", "FaZ9mBBBsfbwnz+evv2GTnedOvCBV3hqwHdQXlDsefw=", "BJMn+nnSjBKiyCQGlH938Gd1sCh0aLMTaHdwHb58lZg=", "IwlA3MUjJlj/nClpej/UFtFw6MmY8aqF3qDELXn5Uao=", "GxIcBJzRFZ4okAfgydqZlcxLq0wm+4iOw5cqii5laWQ="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon5.js
var require_poseidon5 = __commonJS({
  "../node_modules/poseidon-lite/poseidon5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon5 = poseidon52;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon52(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/6.js
var require__6 = __commonJS({
  "../node_modules/poseidon-lite/constants/6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["IZdwP860y/B8bb9GxK2T59FOVU22bQkQL/hIJHQ/5Oc=", "EyLw//x+SFS9i1/CPnEGtR9ZvVBh2LVlrKL9Pv5RL3k=", "GeQU+AOAqi0iITMRjDN9gqjFiUwviIYe5G9Ej6nWE1k=", "IiQRmaTfnLfWUknZViytbGXxZGDnmnk5y/3W17kgnZo=", "AwEGFzU4Tfzs+aMRwireMntRx4shFhX0HHf22F6KQbY=", "Ip4dhsHygQ9KJjO3tLW7YbfcXRmslf2NN5VI/ytoUO4=", "DjHc+cUyCagX7rKS6YlyfD9Wv/ZYg6/l/cKKw9++pnU=", "IixzGOvpYwbJ15rBEjcmPGuOslJy64hAfowpo1i0Dyo=", "DLQWtCxTqCnPT8gjvo9P7dElkzlM1SkFP/TjYEl0osY=", "CJJynQlZSo2LGt+/Li7XU5ne5hKEK22z0tLCqt22wKo=", "GOOemuRfFLqXoVvWcnEa4SQ3XZ9IKkSHoOM03uLSfHE=", "JWDJ/2cubqaduzOETQ0ihwRh0Y6vD4mS1NesZJ7dZhA=", "Ib7iuO1UtybvF/dzZrHc+9p8zx5If5kW5flj6BTFcxI=", "MA4bKNq+vcDUvbwZvimj3uTtqEJd0MfG6C/sFHywcLo=", "LESl/0Xe6mndKWHWcBGvSYK5QF+f443kpzLSrq6IzCM=", "DI1Z/ht/VQleaqrZ47Tnsck9h2ujI03RrF7GQQgpG/0=", "Bs+CvF/RFdNIowsMRTeNkMyhZgRGugSXWfpTED/NeLU=", "L4DtAaIRjQLiFFERw/5spw79+V2Kvq7ogpKTNH3JBhw=", "C9/n9oA+Te57Am4HkHWQjLhBTj1lHdEv2mffCN3tnkI=", "BsxI7YgkBVlbNNOROPULtbMaljoNumau8XwZrWIuKbE=", "Kmfzum0VlJkyrFYiz54rSTgBvxalAzakUYJYvMaGfJU=", "JXJyWmfGBxjfZWk0qnj764DI85WutqIM2DPEsU/vQSo=", "A7t/bKQ1RbEfGXISZbQWFmV5y3UzMLGHm3loXR3wv6c=", "JBKBXoY/jzvCi/y7lX+qXzkzALJRM+kiG46zFW7VwSs=", "Db9k1Y3yEuQweHGWbeCXpdsJqT5bwwXOvc0GMPQzr0U=", "J0wGwBFY4Ef/SnkeJbe7PbGQUp349Qtjhic/gQ8Vxqs=", "I89AaT9Sq/DtPYQve8hdGiER0Kvs/Bis0P45ke5f0z0=", "HaqpJlKPM2j05M+SQWa4vT/42u+8+QDm3MTuY8QJlpg=", "EBA3idyUca1xhle+u2eB45vZL9IO4aMtDePqKBegFVU=", "AAm8JQZQgObG6ZMuNL/eeNEIXxnp/8iWWkZgpNm21gc=", "ExLHJ8tUibsXTh3LgliO36sxopmbN32r7ORm6dzWr+4=", "IClKRix9DCWutTdGGOXncxZoKuPXJoJPFfAPfLmnAJ8=", "JeDGvom7sEvYORyQzzVYjw6dc/2wYln0egVROteiPpE=", "AISguH4LM2yakRBp+J2HWji+MT78Qg0ouewofyiBD9M=", "KKA+4p9hKqsmj3YkHVTUd6HZf1gHui4YEvTTUNfG99o=", "C2eUGCtyOhLgs192vVWn0QbuakA1UnxNMppvMwaNfto=", "AVuaaYRlQo/GhredtJWchJW5K4USL2ppMpQINvrOqG0=", "G/5SKJ+BH1w2GfFIZhOK6aEnm7dujOyaiTb9w29Z33s=", "HNV0/o1eTEKLkrI6lxc0IXbh0wmn4lkFLDG9ya8JH6M=", "IS0bvfqvAgBzW8WFGhVq3L+k9gf12hIuH2Ovrs04yrc=", "CwR54ogg6IPZA6lR+VsTCTeI6eHKZN3yq7lLE/7p7bw=", "ARD1JXwhyTedc7dunKlcUTx3oVzI7g73JthGDU+72qo=", "CMUulAGpdk8MJIff7TTiFcGGtsKDjjjrWlDMpPC8aZQ=", "LkIrQyPLTAr0b0sOUFL3V0TFOKvMx2Q/M5RA3Dqu7KM=", "LhJIK6FgRy1FVJ/3nNBK68SjJ8S7nXjCVzuDWwXFX+Y=", "Ek+l+cWpbWzOks/HPqJEYgLwkQDu0gOuQmeqY3oDLTY=", "C/ZR+C+Dyh+gN6lB1OKks+CPXhYD+TOhcjrfQTV5bec=", "IcZ06nuDR0HLrTmyGyQquaVVTGyfkugByx/kOCthlGM=", "IU+R1sSu9X6DGGtX/Z+kihk+HK8W1/bcFVnRRKJxs0E=", "ID4iGDiXKcJsb2YhPyJpwmJ4XsaMdZWZwtjj9oA1BVs=", "Gqk0GYcTzhdlj1EpP61EscIvyAORQFznbJKyNJt+s6I=", "EBTU5d3ZwXs8KyloRHav269/xW6LeZYWpnu8ZnjkU1E=", "AzwT7UW0dipH4dLUXX/I+/nU4kVG4g3FlpEfuZFxA1g=", "CbwcMnTFaeflxdd8Uf5psjt+Q1E49PMhcBai1wznHV4=", "GAMXHJ28BhDjjYMI2xAdapnKkBN/arjNqyqRs2tjMio=", "C6YHGqmK/sP73rRqiOSl0XvURUwOfajHSxWwhEiM/c8=", "F56Qq0sIpOrSgahwkFdIfgd7cQh5kR8hX71ujr+Djpc=", "HLyoi4qz8FiP+H3uqXjQAAitutgI5lEIlyOOoAf0kaQ=", "L1CyCzNpK7D2J3feXjGYN315I+8vqO3giDHhD36bn1o=", "FboDDo8e9vJgVm/W/P/80hoc/BIy9+xxSP8HbRumhwc=", "Db4FPaAapLfA+tg6PMlm8LgoG7SUD5elUWz7nc1UOm8=", "Ii7KXXVK/sqJl/Mdb8uUpdeZr7eV5o1Niwzm2Dn23X4=", "Kr/6Q9dW7yQtt/WEvWJAWZERJhg2Lxspoz7iExtGpEY=", "A8klJOvmcwDQ3QqsRk8Obs+WLWrUG/JoXwd7/XiOs/0=", "KCJBdYreTvj/OFgwUojTtKUiCSldGkvInYhbL13DNBo=", "AmNcuXPXG7PSE3vYFoDdO8YH/FSH6JjEwtg8HcKBdoc=", "E8hmqmbo1QYHncJMLfex5pGZSIfTViL0z88BS76iI+k=", "FR8AB8z0Kn75afG29jFZkuZZS7U0TSg5/uZiC2DiwCM=", "HBxqXrzO6Mqk3H7xjhlCdPbhmNKxQN3Ml8sVySuhQJw=", "GDMMnmfWL3hhqZbX7Wm7qQSw3UWfKyVPx8xT3SjkWmU=", "JrdHdAyVvxOcsRvfAvpjpL2ympDxWJM6GCLN3lOHKQ0=", "FHVnb7IFCEJG75vHI08xLCFPQmhS3LLsfcN3L1ea+LE=", "GwOtkIDSm3Cq8wu8MgDv/+c+4mncAy0uMr0ZB2e8OA0=", "IcF1+TfC+C6Zc1vHwgEoT4lXeyeh+E+iRkLs61UvRFU=", "EZLgJpprZqjFiHUnqkR0wt6Rz4xx69qDXfLNzN1KTks=", "DzoSwO5S8NNPK0oNzRNUG0ius9USHTERE7upeSpFpY0=", "B/tSGIO994szaJIFtF5SJpRYoGG8uH7rOx4YPG1+tbc=", "JI0OgFHBqWVkDJbG8BDEkx/mSLlvle9vW45HT2TPMWk=", "KrVT256tLILOkf6+GAUp7/NSGHX36Qqbi3o8TeSHfNY=", "IR7jvaPJXxlU7vIqCoLC7ehETkKnKoIAurahM4RtW1w=", "ER2ztRhP90EvecEpkEqcrE7mWlHCBi1mcy9UvN92e+Q=", "GnOEMmTPmjobtvto73YDfE+pgzflwQCWxjC0SexKX2c=", "HC5aLZMy9lEoyFNYZi1qfEQ1Ot0JwnzQfaAvkUTahV4=", "Dis1/hAhuHneW2enRY+mGIu96jniv0aKGiTjYlyv/5g=", "LlaFlOXfv63ycrjW6Mmb14XE+pTOnof6ipo34yx6KN4=", "BwQ8dXHLfcUgW/2kLWk1J6S8tYI47WpqJI55F92vDDo=", "I54YoMhbhF/9a4XpY0PxqDePPGkdrfsijab/eqee/h8=", "JeJHryUMVkwA9f8c8fK8hgZgDxc8tl7weAr59aG2dsg=", "AxujOFZkVE4+CAHxaYsVAzpgSbJQTpzcLG4+sv0SEA0=", "KjN3dzniqwrfscpWh9seBZsgNwy+7MrTLaXDYJQx/2U=", "K/1vDp6Za6E3STJ7nFzsaZA9QTst8pt3fQU4Sz56+VI=", "LUU9k/s2+/jjZ0fuktkMrZ4C5pLQdIwH/UPq/CzF6CM=", "GHvYBD+GQs2itrrYKVjRFYGIgOuA9rcwOB2XSsXVA34=", "IaymBfkqSKw1cI/lFAcp+zXD5IzOxEEhdxOwhklEOTA=", "Fz/RZPUiSsBsLpnz4uqmN53xE94wqkhei7zH8P0tHgM=", "BxxmpkY8P9QpK/HlrLbeYRFC1zzR21kOibYbV9RNab0=", "BEpA45aFW+VQ2MzOe4LuLKrvZnW+vpImbGZpgv9yu/g=", "EXbZ9S4S32fwhxEKFar5jR3tKT/9+ZWZ/t7y5RVp5PY=", "BujrfdAm0lexXGYkvuLzfVtntKZxz83+5Xl+hFe2ORY=", "BpaqSMHV/oTKXPWQCasLqu+7YS4yyR1e8wbe843FZzo=", "CFPDOpx6fDs1XJLHXeRENl24LSQe758/rEFwBKOhrMw=", "MBbAujRnjgpn9Zz5bOFukIFU9fmAJZFxfmbpW6Jat38=", "CvAIYB3JVSUX8wP/niLHk6aCyqkyVvLwmk90ZUJgOw4=", "BMttdrWielquOHy2R3kDGMJfwW+NfRhVo4dl+Ef3MbA=", "Ls9ww3LY5e3K1J5Y1Hh18mkz1iYU8mbmtPWGF3FIVl8=", "AfOTpu503WxNUrDnggpxMvjEiJdCMTwGyqbsxV891BM=", "Lk1M4/l7+W/4a4jpadE+QV4UchKCdp98+MOnNyPwlNs=", "MGAA7ySn9anGUuOpNnV4VU6lm/jvoL2LxXdkYMGMGt0=", "JuWNYodnjz25wiXB07k658Q6aQJOvySci95AYXwrPUk=", "Ce7gn4c9G/aDlx30185WyPC4uY3cBblhLAoNMXMQZVo=", "DwiHnf1PoNwR3tVW7wHG+UzG9NGFU7CLyx3WBDkuwAw=", "EUWffp8OPHJ3d+NNbZPsKKJb2GcXFSO61b4NWiACnrc=", "BOnLtvbo6AWiD72AGlO3I/eMH1rNIniA9/N/TlsFKK0=", "LS/zLregwCZt1GvVk5yamq6Is+mvXa0BpzBPmGj3x8Y=", "I7d+sPJ+lQIApZBEfWRacj2bQF+iU4pct2/F/a4W2Dk=", "LNbSxWWOwHktruIGfi+VjWhJiGMYpsHCcjOkaemZjC8=", "CuHapCC6yQeA0MgwJr/MhK+DlT4m7Kg52naGHnOYVec=", "K0lbhUVT0Cp1todjvabdjvDoH+MrXLBy0/WAqRSWe/A=", "BW+l184sMrxXNTUdLUivXWySVqS3LhKjVkC1PqlZ4pY=", "LsvhoGso7HjqfSLfEc0iSg4aCsejR2xcw8TlDalhqHs=", "FDBTwcOH+TU71nfl226ZdXkr/+7PAtaqD+j2J1ef5s8=", "BAZLJVhEmaAR6nSsBHqLN0lBibxjNCuxGC4jQhLUK9s=", "EA9h9rgVQhVnYKbSmvXdhkTILeq1uQ5qxm3otKBpVko=", "GNMxsugYC3qnBVwCn6d6/08CsOKiB4v/Z2iO1ltR1t0=", "D8+bieGbGlX5sDJVz4DMuftqr94rRiB9hz+sgMzvCFw=", "JU+AHzyJxiQ272PfZ9kSwfIxux92xse0l/dwjbz9wXs=", "FtjoXleBmhCmFGG82NPTyWPE+Vr7o+TY/Q1uyIK50WE=", "KclWWqcCCIvUQ+RiDYS7K/uTJTqPDwTlz0CMkoIK2oQ=", "KU+2gGRkPYvrI3vXBaVXhxtfFAhiTtpG1HtYOmDSnPk=", "LCbzCDFAwQS68kw9+SIxdYSqEXcEUeaoRt59x5UZcxM=", "IxgRJ5hUcH26pTfLJyQecCGpSaHZZxOAp9aUTIOJBMs=", "FBk2Wtu5Hx99G7CqiktdEcetBXDMbPNji+nFoqJ1tJU=", "FnRCXy6fyqZusAH+ykjd1LKinobUUfANF26jW04C+4Q=", "KR+Vbe9ZuHgCgADO8D17VNzC/h3Vp13BgNbVvtiYzTA=", "LxMCiU/momtbwD+6ppxNlQEjlNeN5JRUnHBXt++WW8w=", "BifW1tlNChmhfbRcB5b3243hPSeKKyTJmsXZLQoaHOI=", "LuKXZiuv68sB345ivV9Q8DAlUVsQRl1Z86KU8L+7L8U=", "EYAplF33c/Uv71Qp2nZrkC7q59lnBi/dh5xgob+rp1s=", "MGBC0mL2JounietDI8IWknl1L/7GuFNsxotTvU3w6Fg=", "BHKhOsfanr4RMuBfnvYJE1yCoOvZJ43vKzT4znCa7ko=", "Lo92sntHQYDwDFpsLWWFC7+WAZvw1227R0OpcPQqEw8=", "HjOYQWX0fCBKM/7jH2E1RLfYRqfV6kUoDt5LNiwyqqQ=", "F/IuJyUr3PkacrWesnamZs5P6nrfussuqf3yhSS3tD0=", "AFR+fHDuTj+0pNOGyLqlXYI6DwK8ljtDA5uIR8/25sk=", "COpMy/gVvjJczRVJTzjz+XFTqwnFSoeoUrKplIByTiU=", "J3y0Xz5jJxhnO6BdSMcS/nQE357/VAHOvkXRlMZ/qNs=", "AVnsfqSarbOosKI8HboAI4B7DQmdPEC2nfhmqS3Iezc=", "DDNIkpfiRJVt5XnFwRKrQMf7LYmGaihBj2YKhu4YUk4=", "AbtPy64oovM5lWjGs4Sdon1t30/mrau1kRUWee030h8=", "KiM0PSSpz6O49BP1LuGyM85MHVub80sD28bXM9UjBck=", "Bwem1RWzutA6mwbWvgSN76hQE0qs0SDzj6kyZAFrd4Y=", "GDfbVAHdbsMLprhmGE2lbo20Of/QQVTsRptiEgzjXLQ=", "JEhyoNJ2a4VH5ralr+q/GY4UCaDwAm3jbBAXk5UvbPs=", "IE+xeSfOhzx2EZY5X32kb2ecozGDKln93SrjHoTrofU=", "BW9TA31djvx89qb+uhjRAr+Bi7unC4bdm3Y6EgcvTC4=", "HfS8XXMjn17DuJ761T35zYrY/KVDvgH19A/qKVIHG9Y=", "H/tsy7oAEVXUbhZ9H60cE78okqyHzZw0fHNKte9lg2c=", "CO426IFJZTmwq9ZH01PlG2P++R/JRIgABvLCbC7PKiQ=", "HDCAwlREMzKj5ig9W6tvf86KqmhIe57k43LLxswXJmU=", "LcYEBQDnMp91o876TbSfm0cIWxZg+Ic7PoG3sa+Cr1M=", "LIvKndKTu2fbH2b/LoIEeuk4XOZ9fzNWjNTCFqiZlLc=", "KhV7l4b5Ikz2Nkiq7BufYcenCH7W64qyDGxUadQBt98=", "Hg+wzdilRZHELnwmuQJ7d0F+TmUitHK/5h/4nDm8QOk=", "JQFE0c6gM/14vXPuTqTP3NakL3wA4tfuZ5TUZCB9Kz0=", "C2s/6aelJcpgRDxLeKjoMJV6rgQDEW0imDouaA7t/2U=", "L99hPmfRdlafR0O0lj+MU+Ukgvoy5wUkfrZQvHvWFuk=", "BI9ksUJ1+4b8VbPARpzYkwZ1KCfDwERjvlvqZvvXs4w=", "DyAnt4HCxSSQ4R7Ut7SU1mzcFuaQtqSzySTcnW6FSDI=", "KWUnhRYLJhwcIMdBUkomFHzDGR8zt06/F9RM4viLD5E=", "EXaQngKls3v9R4EPy+c6+H/qEwRwqkS99rBYxNNZ4Xk=", "GA8mxs4qOkd7rw2ljQaXacK/AVbWNvIlXhvDXAHpiZM=", "Kv7tzCzsVyha0i5zT7f+PdZfYmAcHKSISobHpqBfCD0=", "DdIah+4iYmmY281z3XUa/7SdR6AumVpBvKJjmRAwh9I=", "HSG6oJ1/UPAVn6igtuDWFEbRx9tdFWZGnaaoWqciSWI=", "LcWcTJ4nXNjCUGKCzFu4QsAUvqQjaxvCeoVjUbSK+AI=", "LPYtCFQd/wkZumiml/RPR5HELRRHpBUTq51fdV6x84o=", "L1uIU+LNLkep/t7qQEfkYIPJes1LaHrr0iZOeg6zVLE=", "BYZTKKmy/UaRcMORxbqNtcZu75k45NpbrjPycDxHBzA=", "KXYcn8PSxMwbEmvh3ARwqXuPJyXTJ8bRypI8KqgJKx4=", "HT+x+Nw8d8tRXDe8gQ06XjuWVS1Lu1f9sBwq7rHZoEg=", "BfL763yuCjXuLzpNKWTSQaDO60ez98TIe7OwUshwXZA=", "H0RQFKDyZggqUCVxUmCcwhkGIVT018EyiHRpVLl5mPg=", "LTWRfLHQymEe43z9kHjJJPyEvRpL/X2zzjngWzj2mLE=", "BaiaTrQDh7hRLy85i2Um7+dnFpUcUA/I2ryDV3UzXO0=", "BOJqo/AmARdPRs7RVZQynk9OW9XX1T1d9shjOpTdAd4=", "IE1YfWFSbB4Efh3GttQDueuHMPLi37e8c1DZObrFuQ8=", "IcjKIT0vRERq6Qpr2uWEO3wstT7WmfNmdeqCgKKkIOU=", "EwO9kh8y+kxOc68hRXxGttaeLmosOWcWIXeHtG6CLr8=", "BhOCPFtqvu8UOHRlMX5xO0Ws55wORDPXxNNSCX5cg5k=", "DyfFMF7pePT3deIT47oSqQH1EUTOHqibtQRpMPXsVdE=", "LK0RxpPGpidTGVCjB+B7MOqKSVEV9aU4iCd5ISDHvbA=", "FrslaIPETPNzZmGORsbbTj2pep1K59XFhZWd4ycvgrE=", "Ka/lC9ePcsx2NpWXZBAyS/1nFXpczbeuRbAAMuHVelE=", "CTKZAuWeUkOnJq5co1QIogcUhgmrNpgTlyWu/imusWc=", "BLGADmAMkOxHdrxq8XZMy9wQv1XDMU9CrNBTGtU0IP0=", "KY0BELuQ5MNeKTx6fazt737pNCpZG0Mw4nJ2qhO2etE=", "Ak6m5oyxqmtAfgImSaoy0bfqSjUOUQwH7uQ5KTleT4I=", "Iq46GoHEVQ9foBFuE10t8r2faDWg8NA/Tdk04TIKPY0=", "Hw9e7p6auyovSuBNb+CTEf4BFcHhmcKOInBeaBRC7Tc=", "AjyGYGYW8xevAiRk81C0vugML8oyBkvL+D6M012sBsc=", "KonE5bB0++Z9BMsD7+GMS/kEvsR1mzPa1rLIbr/SudU=", "BLD0jE8uBb2kuc+AYHX5wnXfLPYLX9EUcOqnOUqCcn4=", "Dt3losATJ60EKmhvRDQXvY8QfJnrfAKQDJMae9jLNJ4=", "LKysycnYsABNiTIID5N4tgZ1qL2FOq0dxQZy8TchLME=", "CBbzNQhiHy1WNxFWsKP3cxAw5LIY5EyQqIzsrwcXDew=", "LvjgpFXUcrSb/9qTXI077hrpJIYI4qUtU/S3YxPJeSA=", "FxhKivkZmrpgXdHy3RjrwC4wVc5AgGjsyq8+p8CjNK8=", "FjleFTk3qDZg2294RGy5lYNkNmAnd9gfBgcTC0SIFEg=", "DhdAiCI8OOlED8dzB9ZyCsMnhMnS9ZHiQ36uqbj14rs=", "GecPqTd4j3ohJ1c9VsgZe9DdCWFA85BkhlxlwxtH1AI=", "DkNMMp1SQq29qyR4BJX/lyML6zRLkY9vjWvX0hsDaS4=", "LIioLrh8gbpCohG/LvPBWHWsFXx/OGj/81r59VqMIrw=", "ER3CI+PJ/HRSqcLeRpODkV8zrfTPW0n9LgHFHQnM9DY=", "EGRzU94xl7nLSPRTm1B+RTk7AAhC6LqhIYrwl/hxuuo=", "DlPWQSHAqFHBs/B0I1ggNKvOaYUl0KR3JDVMBxUvcDs=", "KJGTisuD7hk3VJafSqWmKlMQgdvKTewiYljqkphLQ0g=", "BBBvleS6P7dNvkvFOrwXAmK6AMfGPtjEV8MidTLBLOM=", "KnPmG48bq/uzixhvQB7tDZLFYTuiXdL/TQmffdPBn+U=", "GOFrJGQvGRk7eYuSO43SX25IVtayG3Ka7SKBqxVPfF8=", "DV+EmxZqufb8GmRGfFVXAp81mi0PGUAwxN2HXhKuNIU=", "DiUlDFc2WinGOk8VMbiw71I+qpPB1wrNCqfNeETdBEI=", "D4E9FK8Mhbzt+/SAs9gLnzNYU8YBiFJtgHYSdAdKWZo=", "DSNWqS26rowkqM6+1kKAg+8vRpRg8Wam53Q3fngFVDU=", "H7bc60lb+Q//Vsiq1wtAv3c+oQA83Qkv13pDlh6dfcc=", "LApwzteZUadeI8WjI/1wbCq4fDgc/DwmkIFid0HCu+g=", "E9xrO9sFFn3OtLEQNwZKxf0i214inkxrpV6DgjIdxe4=", "IQ+ot3eQfsMLuI29fA5sqQBOs0JdSYAl2myQpHw1Alw=", "DFz6lXE5tFpy+7+ApBCqtUVKmCZouvJLDdPATk1ZnNk=", "Hx87xMIdYzQA/Pi9t75Zt/Zc7cBrsvyTqHO27xLg9Ss=", "GI8O6Vqd+wPNXj+zCCcFfpM3EWRO571XSQN0wNZ1MuE=", "CCOHfr+KhCt36ODztEhz6UCXJxAbGGyuK4DQz6cm7Iw=", "D+gWA945zPFIymOQ1vi9yTlcovP1CHgoPZjx8OYbGv8=", "LvYf4ZL1Kp186/QcE0CY8syuNcq8qhKWNWZ2j/G4NwY=", "DbbQdrLdG59NVtL2b6tNe/xqOP73+a4dTC+MRLFRD1E=", "KhlKSuhYPygYn5wBHRB7gvJ55qD4yovJywqlgYMcfQY=", "CuU5+pymfUr0j7KS+RiMnnLy7qri5QC35yAXGMjajek=", "I/ZqiUsd9NJqi6ptBbGs5RH6/9RgWzbP0Su0xtwrtNc=", "E3zvUirylCrumk+4AXvzMOZGAfRmtW0yJFZp2f5bpwc=", "GHqvy4eEGy351kwXZ3iaayIXZ+RjTw1VAGOgv5J4jDI=", "IyEudfS4mZKjZHA27jbXSTi7mphR4T17blLa9mxMvSU=", "D1TL6Wd3DfqdBosvxTq8lkibt9JmISZU0ybea5rxbWM=", "I9g6YLmIerQ1m4Vp/zohm7gTZ5Vf3nKmIALTzVEQH8w=", "LqZ2/n8h/Fg6sLDhiQINQssi8ERgfuFb+sfdZtpevnY=", "FvN/NXoMWEgho1arVqFtQfBFApy1FfWO3gAfBagHiQs=", "E5CTt4/JYDpCiK5YEe0TEb6RbkyX01pc8Y5LfkfROwM=", "Cqul/K0cBHAwyL8kb0FhC2jWC60oXMFfVZAPUneKEbo=", "FhGCeVbzQ1wfxn3T03lUolXqoBls3cXVphh/oKKDnvs=", "I9tWNi8kiRJCHl8IetFuDJ5tK7WdswpSgY5Blkt9gSY=", "LyFeZAIHqIsCmZyY8a+PoXMx0Z6j3h3s/o8uR4IkIJw=", "KyomGRfA/s8rzhkCH4UG43jp0+GvtFHp0WKz2T7thhI=", "L2YuTN/vX4IsuVbfdbF7RvF7CPkw9UurQySgNj4jOEs=", "CHDuqy57segsQmwqsdZf2iXUJnSaU4tOpmnqox9mGgA=", "FpQY3/yZ8u9dxrEBNxfBNECTSdhGRXmFclsVrGoVL6w=", "Ah08skDWQAM5rVvFNbT7tAkZzmuQFi5R7GiVp8q7Q3U=", "EuRcRsRbZgtq3cFJ5CFu62+xlHTIzOTXjjTDzBgCSvs=", "DHyGOUt61h2MNI0YVAPcdxUv0xC10FlwN1oRtavQNUg=", "MCTniyF/hdjv62AAj/cNM8PoTCONnCGgQSG0mKL7sTE=", "I1l3EBtWBxztMWPB7HGHkJo+12ebtUrUCBG6MY4a/IE=", "FL+IXmb3wB/ZdO/cC8LWKO15rW/GulEcWo7Dg+GnOnA=", "IjMlrn5zzwk+HViRqpLtQ/gmEPEoPyZfVlSLOAcvONM=", "I5pa4Tjc5qAZ9EVg73wZ0rgCXa3wQFWSJvVIcNMYpX4=", "AdzDURXZBX769GjXyKfUYEjgE1nJdIVbyZc48LJHZy4=", "E1mkABLFMyWHpN61YEpDbiacKCuiQMygptd7ND52u/M=", "Cp7jlxIiPUwMN8JqlvJnyF/I4xrK7gwHNU03mNxQA+c=", "EYEtHKNnGuaIqYdyM+617CmGj3zXxeEydTkahBZ+AjE=", "JDXNaZvJSYWUXYeJYHcPkpjUDA4otrWXkGngWQlS8Lg=", "K/AgeF5BF6HqWTDNU1UwO/mqsqHqDWaFOR9A7qsq8KA=", "LO9seFd8npenaFUpLKkuQmmsU+m3Q53/usLtpcZ1gCQ=", "CaMOAMnw9vJg8F8CnNqnx6/KUGpc5WLId7O41UMTVCk=", "H9hZKPjIBTybJkp08SG5C7+a6AY+DolnAWW5umaj580=", "JEgiednvpXhips1FJKoonmlQYG34zfj7yu1LZ0/a3pE=", "ECYKOc+w2CrYGCppUfnHgKRV/B3kjEF9bOayfzZGIYU=", "JSB4J6dgUtSJuyaYcw1cP8lxkqRCBXjSR0o3rn1+MUg=", "KONrY07L33uOT54aNH35XXcfFdl/LVxAHt9qbjdYdL0=", "Bz8N6m+D1EPuO6J8W38AZKt8wNNLq66Fn2v2bUah4WU=", "FMZhhWn3SP9lUUQ3rbz6l/h7mw0WkEjoTFU7qYiMRR4=", "DHZ1oEK6bMdPpYigsm/cTy0fEZoP5u8RG+ai1FtLvK0=", "A9+tfbPzLG7YEwxDz/YE2+HCnb/yUMaEyVXwnklfs0w=", "IBFCgfvjXBiBZPxtQUQgD8HZ7EM+/Gd0gL0s3LNbZOY=", "KeQvUhix6j+tBqSOIpLA/j3wiixKgjo75LmYlV2ooh0=", "E79AOUiNlLG2pn8lYpba62x8gPrScm1um+EeF8I1KBY=", "GEek42s+rOE95Y+kZiqfiMnBekZObb0gg8KTjCJ+4/o=", "CnogVse3k4Svn+PGgmgwFF9R9vjKXRo0Tilcp2Y62ic=", "GBJ4yqFb37WUDP8rwyFv8GpFli1Jed/A1slJk7t96G0=", "CopvT7ui7gmjbTkPuxSF+3ic8/n2QdrgEVIMjxDlekM=", "CPa0wNe9XkyH+8aHRSDjMpwGe2hB/IM6o3UUQ16YfOo=", "IgaywY8ykuepqRA5aDpV2BPdkUsMfVIyEEJP8PKBffc=", "AYbO9cBLOmwy2iZAWhbN01nfV76Okykay+uj9IcynPw=", "B1r/Z1cOoXx8eckRTHoQ1TPGCAttFaW+vRIE/c3ncvA=", "KwbYOJupYhw4adLoslrBXiyXOJyq9/l6NXAL5mwWVag=", "BPxtCmtndEQoFhy1IoqU58DpXe3oBLK0ehgFWs1zeus=", "JeSilbTnotxxOU1B7CqPSxJOWMI0RIoCiiw7xq0l5ps=", "AJTCSrAcbbWU/akHtjmns6VDAUOTQOiJtsqctsugZ7A=", "J1GCGm47IgbNa8PNXZjLrohQdF7Gy76kE+clTSpRRUk=", "FFquzCTjh425qNdxSbJBntW0LfAl7L0ajpfYuBeQS7k=", "DSqgDMblFn2EXuGHe3qgWbXlFRxX5MFj2jQD+alXVfI=", "JCM7aYYccMRJ69NuRCDd/DwkK2n/bj1MYJDCvQinZMI=", "LFX+GnUUfJyCb3Yvg21WRaxBhLoZJ91Wp23AVqmJVmc=", "GXebHLFqnHllQBZnSXi4tu4aeLZFed6T7S1nueSfCY4=", "GAdyG6YPuuR2/2ASDB9H7AvOaSz8ABAq5QvZN2xaIqE=", "HAII9auhJ1CAL73DvxLqyeAK2nCPFn1LFnvX1LA9dvE=", "CQtuKP9UHMOIaavi9dv7n76IjSECHynSvduRJ9PCc74=", "GT1sfnatlOtZogAQp5nHv5ao3ajJCIfWUhTIZl7NoBs=", "Cd3VvAsfjUxPGnoQLBuhLsfnVAzaKFpWTqfEdTr4qNE=", "MAod1f2hXRqc/iooeAGBcWhyHaL5cBOVSeFoEfVVvh8=", "FSCQjfLu+6B1u0HP4HQOHloe4YHOSSAW4VJwbkk89HA=", "Cz8hXVLoXsPGgmmOvLYigjOulRj5RQ9IBonnzzATeEY=", "BQmWoHr2dlxWqO4vc2ZQ3rSXK/zdsZSg7+sZVNqopNc=", "I6WTJtr1+U87UZLBjtBsxYzZYI5EE4aGOZ3E8e6Aet0=", "HSILmt0FkoZomM6DSxvcIAOXboFcDPfT9ri/lnrVZJY=", "GbScTaPZ46JtNlZnOGWJI0d8UE52o4qCsbEkcQT2geE=", "E53sxWewa0lb1vPPAGwFt+HyXVt6xVREXDfdKFvqrno=", "Glp9i8qNTwfUzW6bzQDACeMJnpmvMIDeu7IfkPjltCU=", "BiHjgR09y5WE0Ki+QeQx1YjJMnTIVJ5iX5j9FZg6gJ4=", "AqQcLSvPFGZKATCgIdqm79SjsMOt7ThjW/+X43he1r0=", "Ic+1S6cvwGeUlHzDvaM9gVNVQW4qrhkITYRHHu3KOZ0=", "BRFQk4lAiaICpM+NCuoynYPL4OznQRYPmXXPAbfIXcY=", "LkBUHKynZTISgnEpVZq0IqHAam9IyXQpFHDGX8Bw37Y=", "B+6t1zAoT1q2B3iQC2AwDSeXAAGqY+Ruu3+c2hFXYA4=", "DPM+SWTTUK3yBR+OLoRI0zJNJNP0hYQH9P1g0zM72Y0=", "KHxgSD4tsxPxor2pLB4cKLZe8Lmd9Kz7dXCe32o7/Lk=", "KJRA9Lf9uLKyJmHQdC6WlROcGh7O9Tw/694LX22btKU=", "KRvaLDf6yWKiRVWnq+s22Oi56yUiL5f0gX7y5bC8cgg=", "DhBUSViUEkBM2nuC8U1SdZT/mdBM6olNbswxURn0K3M=", "DmCX8K1BiscSOufrps1FIrf/qNyM9gofg2viPkHsJeU=", "Iv22dnJAF6+oqAacYtMHqk/1LBRFrUG5TD5AbjPg3vE=", "AgTVlK14Va0PaVB0KxnmDCxTOIF6q37nv2McOqkhYPE=", "C2pkPa0/lTh3EQUX97M2UYyPwR2Gi8cuds12w7L33Bs=", "BBiepsK9SwD6Y0mt3hcCfrfXY1OhC9B9CUJjlEfLQ9M=", "I7yESdiYp1JLLf3iYwNsrC4Uk1E0+MO69/HhPqLe7Dw=", "ABfvpgjZlBvGTTngslk7dCV226JX+rMj1MmcekIQehY=", "AvBhR16diIizh3+TCOd1ihb5Hjo0pYVvFa0Lny+S4rQ=", "HyV9TW8yd2dKBhMw1z1roTXafLDLoxhoaHL+HvbVLiU=", "GVNA9sH3tfYViIS9I3cVFJzqSI7b/YD8m5zGHDhIU6s=", "Jz4gAXnFxF2GCyaiCywIU8EAj5QkWdXNvtYz7eAxqh0=", "JL0OzqHh35evDylsDnktZ24sjgLoCKFYvb4BQxxeSkg=", "DG5vD3wggR9ARZnUWK9cbLQatnFZnWNQ3zjoIQS8aDU=", "He4TUkcCNc2OEptWEfqVNwa8CNWPaj7z2ANw2NGWg6I=", "G+DMMDQ6Fo/afHV6wMfl4Wr92/tyZYeAgHJaEvoSrUw=", "GkSav2RPaKZMIXxqBCojEQfKjZxhkghYDrdrvZIV2YQ=", "CAEX3eWPIopFn1nZDmS6vi2vR2qaLKAY+qPF/sqsF4k=", "JKuaFnthhV4PLGC/8JjV630VFm+rUfK2LICd4xjW0XY=", "K1asqdWVRgUDNjKSvM3IDoIyAfcbVL2mhMk+sIk3hPY=", "BXNh7CPIezAID/HN80Z9V8laEq+/xIq14eTeAWKkG1o=", "G67Rdxd6Jey7+vTyBNmSHq3jaJuhN4zZNizBQUUIn5U=", "AMzbbV9JE9dlaInDEpdf2+DgMJqEGEn9gI119ZOnFIE=", "LFL14e9X3l3eUoRxzB8O54OZKd+Y7nQ9nv+WJRVWGRA=", "AjSkoy92fy4cpI2tOi/dP/VLLKPVPOE/yQUkFK1/dVU=", "GCtMDFUasM4ZkLRyJ495S6nMYqvMkKie/dgHdlWONDM=", "ABqyu9vQQ9LX0aTrdttN5x/d8Z7fENfNuVUOGEblP9U=", "IG5s0eMVTBE6dipijiSUCQe0HpDnwtQ6olbqUkmXg1g=", "J4Fsq0vsGFd70zW9r4KYeYomG7F1E3F31GupXdA9yLs=", "FoC2MqBL4+se1k71iUQLP5Umsq2CzwuIOdPnsPWFvIw=", "GWsswObgdijfgjT1jAJ8GQx1sDQlEe/qTDckxP7dbnU=", "KasLYGXrvvxoRgisxr87X8aTdww4v5G0vjj+b3JkdIY=", "IkzoFNOcOC2i1l7M2d60gFbt4Yxe/LjiVRW3J+VAqFk=", "GV4cso84qctXsscZtQT1/dHUJVm2o2gmT9D7/vpmVZ8=", "Dp5etw9EkLptvRwO4dZyTM3Vis3xOHhc6Y7jhI/7eEA=", "GZXJyOUgAU5EEuxlODnXgVSM9x9G++tRkZWCImy9WyE=", "CIYJXMN2yH+mUwACg6bq4RAImC8nEEr+4Zj8N38m4yQ=", "E3YeIGs+ibI94jQr/Khg+bDZo21IaqEVVl+fUjacEk0=", "IqjGz8DjilAKR1FcUZrWpyUG7A1QjeJZQsEPUfDfq4E=", "GJhenH6m8aFpYuTifPGqSqMIaTixP47pRlpex7697gM=", "IVtSPOPwVckusUjAACfRrUBqKr1kCBBD4NFUkoRbMaQ=", "AQL3jHUTsJO4hXJrffLnApiAGz5AGc3UIjnXZEhYjDE=", "C86IYC/ToPCriIWJGtRARQWPms4R/avSTo36GwpK5yc=", "B0X3YPjUZvwhBD4ikubLsgtiJ1F/UgAlESnFSB9S+ks=", "BAbeOAdEXG08vfexdMQQqZihUw/MqZFTWiomLeTi7lY=", "Jneec0Y0kGjbumb3hPh+JDzCfKtZ6If37XoBF4h9Gs0=", "JRUGUqCK+MpXTHxcd//Zixclmh2RSm6kHbdQFCZ5Sdg=", "ALuNE0OAQPZ0p57UIgLFv25n3m/D9rZcqDfOq3lfzG8=", "DB6/QO6qw9Shkt1Q7iXABn9m7/YinQRdWoAQZ2Oczyw=", "GjlzHrMv21HdeTdU92EDtcq4aUeq0S1JDUlRky/yByc=", "K6rT1BsYrhDEY68WYuyyjGmIUk7d7TaUNnKg6Fe5YPg=", "LneNoVGLak+tLoM+QUZvsv6C9PjfG1whjN07fkmvZ+E=", "FW3HF5MNZJAWd0ORHpv01GNK4Em1OtqygWmGRfixbcY=", "EX8u8XEmkqudvcUdtJaLRfXgEE+eUoEyk0nZCLI+Ixw=", "CygbXZ3SyhqS4tg7UIe2oI1qsIMw9HUSqgR7L4i6aMw=", "HCgDdm3ZCWVnozZgYXZPjJFvKi3WQLbuwJQsy3XUB2c=", "EgF01TulfRoUG/QOTHBWg2aL1VgAAAqrbzR2a3tldaI=", "DDeyUCD4x26lU23lTHIuR9AXldMbXtc0ZufYuK03bUY=", "ClCPNFzJqLDDC6J2UbocOtg5gCWkAApcJQAijET6kbg=", "Eq+kn/TYtMbDcvfgZYQHg8uUl+6syEejQPYfGCPLKo0=", "Kfw3617HzQBICVFreqPHFvT39ud3L0Q+BzCwHdUHGlU=", "IEj7nB/aztD9xRWUkNspd+V9vL/3UUrR5SonG/hN0ag=", "AKbEIjqr5YPombvNAxSkdDGB8dXgPbwRyKTQJVD6tk8=", "FfRiq1shwxVX4l2cItjcagzKk8jtaKNWVc/3RWhnZNA=", "J7wcmvaO3443MBlxJL5VnxRy5+O7oNNeB5stG55Cce8=", "Gi7BSPkA7q44wNPW79pk4UaSnHHrgtoxOaOoWWjsbrw=", "BP9By1U8phbQYWVFki8gMLcbI1S80cVdfqvK6okEwi4=", "LyxOexioRfzWrdZwCfwjexSphGGSYKez04cS4DoISbc=", "IpJcYGofCRwdXHEi+OGo/+pqFAAxEGgmrFOpxp2EwKs=", "EOKox7Er9wJmwldXPKJZTYgRYz93gi18IysynFtOcnk=", "FxIxlZWuRkmSUkv45Ii3g/pFs1SM0/Fi1Ya84x7HGEw=", "LpYWmH0zMziOpaHLVrTBYfJ5/xlFSmSt5D2u1NzaXAs=", "LGghDXVmDfXZqDkqKAXqFhL8YTfPWzWmj8HwOs+/5Mo=", "BTzzcHKD34cwtuH2N9I8Z7CzUzBho1vLDLD5u+TorcI=", "B1d0kUg9A9d2nazHlge5iXCBwAld7Nzj0ifAWd3t22Y=", "BWObIyTAsK+BxbJWymstRrler4Vfwmztv5BBExLeShI=", "DskJROuPw2xS8/0TdjcU9BzqH/SH6jnXC9lOm3+PFtU=", "HpbNOsNFuy5b0+dVki+Er68wPW+yJ/xo9wO5NmX16pY=", "BAhCVAXGa6p9SYWObVhx5bQv/rsN+IWoJJQtoeLjbVg=", "KE13VmtC85E9QeuwUouJlCbggFqtuZV6U0sCKwgaqXc=", "CwROWYSIfNozf1jHylCngSbetWJPZEUWI5QnlI19Brw=", "BIaXIXnuNJZ5W97RwvyWdMDD9xtYFQycUlBjpvKzQNg=", "JbdWgxbEsv75tyVDtgM7MXp7/kBmI+R8to5ceSlua+4=", "DOyedMNEGYcDzv8opNESdfbFwVc4qlpUoZJpJh7GqKg=", "K8w0qZNFF0yXpl6JeBlEhqmVfJ1zbwyjm5gTCAHRoRQ=", "LdsuvArJj2SYwPK+LXPoanhpQKHoxVjY2+2Nb0SwJVE=", "JkK0ogjlA+NIBxjU0gU1H0PaGD7ShO16OF73zcqAvqg=", "I/q9sJtIG8dkECroXM8eb/ccd2L4utBKLeP3oCXLUIc=", "CuTtDqatt0udMn+80B2/N/X2xGdIDIql9JUSTPcLgj4=", "CQNOGmRtZnS+8EGvp3TjY0+vitzHxxvC7W4DsLRJIBY=", "KBfqILRxpL8Tjex52E+fbAAV4MoUe2UGg99LM3K1XvI=", "Lft/gUJcLe9r+k6DPlHpEimDl954/Sqhf20d0vE3nKk=", "E3tb23RlI8BR1oC+CNqmsNVMn/cJnyv1zolMJKjvHzc=", "A5AOx63I4or3BGgz260/oQJOOCrr4CvLU1JD3cohqoU=", "KyhbbCOyXFLyB5hjx1nmoQwz348ZFVHq1T6lCFEctVU=", "EkIGe+IgLRssMrecRk4tbJd+b9EtizUoHoTDdYZGE9g=", "HoaQ9bCocpuVNu8pIKvn5vPu6AUjexWNmX22OxdSXu8=", "BH9RE+Eoe1VyyC7bNp+w9xepHyYe+dgXZKWyea2cE7o=", "LYgA8hzWd01aaqWK4s0yWTWT0XO2hxIqTWHER0OQIQU=", "J0uhUh1bxcWAZH8Q0aTEyt7vCIaF0ZdpebrYE3VvhLA=", "F4lbfBDWpHUxDTSgc3767d3Kjx7unY1W5/5JNMi1ZEE=", "Bu7RGun3DfXO0JsabbJYl4z1vsrS9m0Vdhv2Hn3BNEA=", "MDa1IcYxzl01meN/al2vkohCzvy80sa/hOLbXe10jwk=", "H1LW6awol2xab78WjIGEeGRckNcuNnYJ19eAWmNnSC0=", "Kg5gNWh11qzhBVkys92e85w92HEJHpajI8FZbO2zXms=", "AgiWM6YZTz7Tju7CyPVNDH9DSTj967nA4YMNvlMRw48=", "F4xz0naXZdhTgyg/2w12lFfP7wYSuqljM2usEkC2BMI=", "L8ILyrqePZbrzdcQ47NBg31dDbhJ54nyjEvlAEr6GaA=", "FRpCO+5n+xTVrSefQlIT234PIUlJgt+HI1TAHw9Kciw=", "JdYWGeE1aQxOEOSv609VeK0PjiXCBzU2aJWzHuvN9H4=", "Fd1Xm70HVCkwHXKV0+aF2DK/nzbFEnfQnyw6ZksEXNc=", "I2+im4FnjIoQn9NhwcqQrfRCPBPPW4zBAytyg7zJWbE=", "KoDLrJuITiA2hpG/FWfLcyBTepd9oQ5TxbrqNEbAHR0=", "EdTLiVeTezYoo7P00n8nbMDBebDCKywT//vehf2RI3g=", "Eom/jsUHv3UqB8m3HvwPgApS++sWN8UBD6VOratAKUY=", "JvhCsamTlCl9JXmfLwPcnkkD530t3APsL7FVRm2m8wM=", "FZRLmVS2GCMU6Hj6L54JHcxA6txI0305vdXwmQXDo2k=", "B0IWbc2OvYV2pr/g8f7RN5OSj4RELHRloAEvWEQm+t8=", "CGA9Wg6Te1NTtWsFdo/VC955LnL9YcBjRMvXNXB7aP8=", "DKoXEcZukwG28l4hoxaD2Av1jYYDLQO/0luXd+23SnU=", "LWUG2mldIIff+HtfY27mdvqwDDKuRcdbPbNF8/50oxE=", "DZJEsHr5turv9vhAScsuAdddxMtoUzYG6Xa4swB1jIQ=", "JDq8PDOC+qXd4/HDtDIELT8DDvah9UAao3rNFcscjEY=", "FoQW4KbSddMO2jmJJC4HIwJHJ9OweRsG+OG/6O/kAZg=", "G83u8DaT0a0OqAxlaIZUr/5jSqFMsRrjpJFoHZxfjus=", "AvZr/aPSob3tsKuL9+scTlUb71jZT61/fCMRB+VlOQk=", "AZ9oAhcauCpZIvAj/ezAl+uKwf0KHtNJr+mnuUKYl1o=", "GVocc4OY/u2MdgRooFVsIyZFod2GLYfB9QjJSa1Sw64=", "CjajpG5uwWVn364fhT82Dm8kkkgQ6DjLJO0bD8438eM=", "ACEjwp6of36ns1wl+ejdPoG7w5dMPBfGB82EDAnzdK4=", "AqcXSZy2wx9x8PA1Kw9b/vMAW4DpOlILbkKzmFeJ4tM=", "D8BTWEsKRgeiKT4YuqMJxS/ckz6bqQ/TJ6qoyM/E2qE=", "ExDRlCEpc3sy6HqG9FcwMrG5muPG1xuv73tJR5SFVUE=", "G/ra5T/IKQD1dhxVj+5eEhjmsqZlfnS1QJae60nguN4=", "KMCKaeXzZBRg/yxgt1eTlWUMW2r7OS2hQtMt6Gd1Vuo=", "IjIi7kK2ypl/RNZD7Wo/KwQPR/6M2SIWPZ2diyYi2Qk=", "Bk2tR1LnCP8puwhC0sRSpxRItDlJNFaQAxyxJViIdqA=", "LV3cIXlwQ5lrItyruaG6bIK3HpobxZGduL79NUEQVqU=", "JjFfzZteGiZuyOn2YA9abgvNsi+SbWFZHoP6IQacDgs=", "B1knOkF3/N6rI9o4tHj68tTyLoLzRqp1SwoTMbyDce4=", "CeEzAOrecFaPoKhA6pcpiW3dhMNk1iedNKC50UePzyo=", "E+l+08FvrWy1t7uVTyePJDSyL4zAVEY6FFy+AkDU+Lw=", "Bc00htylj06yIbwsvtuKowJ83ldllxux9hwnLFqlGtA=", "AFzlI/a8Idrx30aLEv0+hmXhwWl4FqmmcaOythScfeQ=", "IQMGbMXfVeZ815FAKBRftx8InWccg8W1N6vqSCstjLs=", "A5+Ad72bcfkcoFAurMwWcsU59yMpMXqvgXPS7ddjaSg=", "Ike8DMQ3NwW4lnKiIFNG5q86ZCLoG09Ihdw698rcxcU=", "J7zHaL0xudAGh6flPDzlPEJnYnBhiHkOogsugZY434A=", "DZHO9Rp296YsUcc6KAlzLXmsNQFZgU6lNkhzaM/f1wg=", "IKns3GSaJjiNxo3AI0Og8We61G1qoc0AhTf2J7oUBzA=", "IxNBSaDUVnxt/JEdXLgMGhAWIg054MIwMl2uKUH1KLs=", "KgdQfp8DCkLG8pzPHJzE8+WlsNvwWHTV7a3AP+dLlHQ=", "G99mux1X/XiOVO8p8G81/bJym3GM6BFSzzqvxklmEQs=", "J1wz0H+eczjd9QeDvxWNUb5hm/d6EgIM9WMLeOfg0Lk=", "FkEVVOVf5gSh/xs7W3r7aiv9DzLEBwtVvxrSNOiygRY=", "Bz5qx+avInVXJJyhpcVSIqNsZBvChRoN/Ptggx9nWag=", "EKb96IxfYh10hUPHaiGPlcICu8O6ygaDjzEzGwVW4S8=", "KcWGWiZYjKiogSigcshDTMl6G87CPhNvA40p3PlrDrY=", "Iz4O9q0TLtIRsZEc3VaVdv6owXymTk1d1Rb8ygchLBo=", "CW+bkrnPLH1mRAiimGA2X1tq3CONh4pHa97T5NLguEA=", "L8eI/oqtTCi5Q7tXy5Dt9tex8eg13h+/MZLjldt4VVQ=", "G6wO1gkjMUhQN5X8XhFAdu98nXIrxkjdAzjZaJ9uAjo=", "ABw1JoqgMNbNFI4Qbj/CMJTlYVc9jHKmn8ODZD4q3II=", "K7H4/l2ZjQuLkoN/+ye/56Oc45/5T8Fn3cyVpyAuNLI=", "GphXZFCkPl5wW5r2jNDBRUItojlFYwsQuOgh3WH5orI=", "JxTTfuUG77wrqZQQQ/sj8Wr5ZvEj1lPzg4i8vdUOYDc=", "F10EgLoUq/C8uAdaA/SioB/37XVBORe1PlDqAMwqStA=", "ID3kWgN7de9jdhdQ3OCNor53CXAeyBWMF/wCb9CE1UE=", "Jlqr/Hi3DKmFwykIDWMpoSVg92sBzD1DGnKDAiGTq/g=", "E1Ro3763Dowu2v+shlimwisq0VIKwIGcEnry6l86h6g=", "IWpB4kMp3tplqKggAchM6ChsYXWER/8b+p2Sk7ZxH90=", "KIftSXl71mUr7Yu5muNFrXDRonzbIblGC7b9DU/kguY=", "A+K/gmkMgEu27jx52r0YkupTqYEeJCShn65Ea4rknK0=", "Dm3OG75unkZcvhTcxhVhGGdBRnbdiozplGZJscToERY="],
      M: [["Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "G0vFiF0c/I62kYdTANtaDHNirjgYmKyvi2PK0E7LNsY=", "CKcvu1Xd4+k8WBhXGkJKVJU2lQKe7bz5Hq6wEnUcf4M=", "D5U1mh9oRdSSGJL4PlALuxs9N2PY/HYkAK8Dmwq7g/U=", "FvAXUc6YUyiv3jTYFhne+0Pmx7Xa31LQ+CRy+853cNk=", "HDkWJjKEV/yvpinz5tM+JVXo2IXjwHzsyK8fTVZZZBc=", "AJcPZxubo14+PGQtHguAMgI+1brJHCwQVvA5ZaQsUpc="], ["H+n+tcf3x6Qmv/AyzWoxWCeLbGssxXqHEhP8r9ZCeYk=", "DMfquxVKp5VerEehn2Q3orjewP6eVoYVD/boixp7S8Q=", "A5Pv2WOZqgcm75r3m+i2xxXkKZBsoNFQdrWpkP6nWs4=", "CHEjODW3UuoDDPik9DdxKW7rM/aX0bCCXbR9OayeWVU=", "GgJ5jwR6Ubquo0/Psmymr+lqX60dLbQnBJe25lBIkcs=", "BVZl123zzQ/LcTwjTqedBqMdbj5MO8xlfbpMZk1aDaA=", "Ju6WkaY47cfJGIfjAvxV6Od1goakSEWtiP1947sQUsE="], ["AM2y255PnXMtIXxeMRSCEWXUnlotQVVrzVPQxNQzIkw=", "AS87spyXJ5MYISP1xJMG4Wo6eHxLzZx5ihMbcIVtHL4=", "C7qQBkBMXt6CtSdnfa9ETtQ/0eDb3FUo3SzR8XrXNIE=", "F+TnO/cB+I0hms8cpjkMweF8n4SxcTggg3ygcL6Eotw=", "I0uKB371K1OjQ7jaWyDMNYrWB2DdYCdtSFAV9z1T0gc=", "LcP9dzlLe1rBy9G0bm3tW4NdchekxQpIeumjWn/UXZ0=", "FmhHdkD6sUxyscFv8BkuSM+ILxIna9Evl/gsbuLmHkg="], ["CWZCFspWXBpE/CuYNH6os2kEs4d/IVncyZmJWt601ws=", "ER/Y384r07e6DPqT4g+2hav3bXcwWFe43zCRTkhJ7O8=", "GfU8ClkrPqk0l6UR5W9mdTWYJlsatndNpI7sBOTZNCY=", "GbaDw507AC/DUjt77lpgFIsdvfGN0cMY5qVB6M9moXQ=", "JUcROoGHefE+NEhxnH7xALgDa7Pogt1eZFbDUxHBvVs=", "AM8Uj4BFzb57sQE/cuvUEmo+NcupqXBEG6jVvHaUOws=", "MAhCHu12egkzIqCcNzOXOgOBaMsozS4fcJB2wAuGlZk="], ["FGP1HUpMseuhbbwRVWaqSP53tDwkTJmIo8ZY0vVkk9Y=", "Fq/Y9MOQOLgAalnSkq6oRzHA+DgyphuCJQ7ZARjo/sI=", "IpY2HzvxVO+6uZaSGTbpsd/4NScR+VhjgXIFUzPgdXk=", "HDFg666xD4CfaYQ8+NW7rKGY0fjjQ5vim+uS2QnsiRw=", "CUxmvc/1Q4LNkhOr5DMS7bW01BTG4JrMokkSp2NUBMY=", "Log71AjEyCbQBP93fXwJOENKtbuE80IOXZS4U7F0b4k=", "Ior21CXpGng90Y/Ymms4vaBT8vI8CUuHXyfLOruiAws="], ["IU5BeIvSuZA0fH8qj0dhLU386xoebaOBZYc99mzlH1k=", "A/uoLT94NiCHPalOn06EyLUp129U5LXX1IBScq+bl3U=", "BmeC/j6GneLOvX679g+0NXhTKd+xKtm9G05G7TYolRE=", "HFzWsj7zNr4B76N6J+a3quXRZD/O6yEs3/UViINftTc=", "LztL8PEF+I4nJIrwlOKf7tn/P62aeU4VgwvSsxFTlFM=", "L0CF6qn4Cmm3Ofwj8v5AV/ZHKbMReD/PqzoKNvwf9DI=", "I2NgM0npT1IPofmP4lB/aq42GTQHiqWaFiFMCIGFY4s="], ["BUhUFyT2TiASgmCJmr6PvN/xhKGVepOF+3FZI78Px50=", "IcXiWmmRNk5ZogXlsByBHe6wlWgKcpKDac/S3nGxT5g=", "EcXMU/YzjIJYF6/3eSou+86P/xcTANQUVaLtrDdmPQI=", "J6CUn9yfEElcTuchSqDt0q2O72j1d9qLlvnYejlQS/k=", "HH/Gjz+95KI8RV7w0NvODOVWoBlObVUsBFXLtbDCMOI=", "EdD1b8AOfYWzopOf0zmR3Iq8HO0MPzxTDL+0UA1j3pw=", "AbLp0g2bVd6wSMq+Fjbw6WNjvsiGZ5y9kfMy+yut5E8="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon6.js
var require_poseidon6 = __commonJS({
  "../node_modules/poseidon-lite/poseidon6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon6 = poseidon62;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__6());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon62(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/7.js
var require__7 = __commonJS({
  "../node_modules/poseidon-lite/constants/7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["EjmS3zudqmUTnsE/u1L300jhNDM2hMFZb+sOjYw61ZY=", "L6RvXbqZCc6ZhKAeKvMLVQ3+yXi+krSRGaOVnH9iNwM=", "Idj5TTvZjwtjp6rLF1ssyhOy3YqM9o/DbZSuKUAbLSw=", "GowGxhBG4Pjcajm8V66g0H/X2zTmj3NXnaieEWr4frg=", "KYzXBG9YwMq3dSOlim/f0UAbieeuXu9JlEQtFn960dM=", "DqxzeWZxXfSiCzGraT7ahqB/PoMPykdaZXTWf8Xxn2M=", "Brm3GLs7bUXgy+bV2aLwlqd76wVoIXUNByJirypwoz4=", "C8za1uix/fuoRqlVP8eQWz+W5DXWU+7DlyVl4fu8MCo=", "Gz/0pryEkJk6u3oAI5PNHBwAf0kkD/wq4fEFfPzYx60=", "AX8MlFLXDuzfXMi2sLIF7C2h3ll1DW0XCXUYMbfkziY=", "DPGrgFvEehA0mudxNeqVpBRKbtBxj97tQpccFgeRsmk=", "GNysrGExivZEqw8uYe9IwpqK7PoCgun8MltcAocQPOA=", "FvuzvfQGbisvBQuJtoXUCHEWhdt+RjjeyQqxzHlDUP4=", "Du/QuGF6Hs13Ef/V9sTNBJZIehsRRunz1TJ1rxj8bG8=", "A8cH0YNQZvow5ylaCXpv9GO4W3eMoR2b0piNQbYAquI=", "BjrT9uP4RD4JCK+ZzjLSwJYG6EquXjrTDtYNemYHOMs=", "LPZ8yc06UxPZkuMVAQ2Qy1AfeQu+NaFmOSpR2Q0Rc1M=", "Km56e/fBkNTk9/JY2JDdQXgOKPa3Hok3FvcBQPRAazQ=", "JhQEIACbbYxzFHI+ZpJbrc+YRA2mwrl7ZqUrmMvfHUE=", "ISxhEUnQV7L/78mTirFJjTsmU5LHNIC5ywInaQbkRbo=", "CJGKtobBoWClXbEgELIBUPgmMt1ZM+J80BEpUYzZ6VI=", "Fz73dndJoySbAE6seqfpTasg1GXGXr9Lq0IvdD8X2LA=", "BJ2Q+1SeDiV5D1plcHVcaME8l7GNZ7uRmdx2U1X8sf4=", "DRqnz+bKngSKxs4s2kDG1kr7uMFafNngIiVm+ZIqFUc=", "LYLizNi9Y7K6RLwPTLXsiBQqRAis8drUUqZughn2Z8k=", "Krc6hC4Lv+Ip6hFUv4rrSM8vwom5OUcda0ZbcgLrI1Q=", "Iz82uyBd1Z0EUxAGRAjG6vcQFzoRj57SEVPJmmsHg/w=", "GMFKUFlbjfMhJL9X+LjfQwRJ81mGJCov95pkT1EM7yc=", "GGUI1rdceQLtahlI+RCIx83flz2M/NtOWlsMrGtbItA=", "EL9CmQEEw5sn7wukUbUQy7AB+Ow5oxPSWb5DCdZCm9I=", "Fj6HX9ngSyVZcQcsDS52FO4fPH0rk3maoVcL9zFT86w=", "KSWln4LBRyuBIJiOOvbPJMLr7JqfD4MLtcgmBhxl64w=", "Jcr5/2VD3MNOLQuMKvOzbr7z1MP+YuKTfOWQo43y2hs=", "FMxBf9Z0CDCQ9EY/ZhgOSj84yluof0iJ5RCtqST2t5k=", "GCVQrtf7O32S7wuR9JFqx/fbO5QxA657ouCewPSghRc=", "IWMFhSRnR1qfk007ETKplkL7eftruR2UjzkayeHD8cg=", "BCO3cfchVxbPl7OnLM/+FWu5+Al8d6K23Ge7WEhom40=", "IkfNWvi1zgqYOu3pSfgdx9P8Wiy7640WrUP6LDqIJTc=", "BJkM5JEj7R7Kkt97yisnHQe6SuWjDGoBGfd7UcNkPS8=", "Bk6LspzAcq9yevG3mvUIlqZUjexBusEPAxn778G/750=", "Bfm+gzUaA39XT9D1TU6a5crbkwzrUckbB4lPAWD4+kI=", "ICzhfpbLJOiYbNCTUauVdtWlFnFo+dXzh3xMXOA2KbY=", "CYovtcsBhozeZCTEIRuVSbj1UKfwPn/Ni1EhUWs/RS0=", "LL2UflMs2g+PG4mf+83V4LawhFHmN/5T87So6ngyqic=", "Dg+kYgz8lD2oG0C2tC+G/nTlWQD4AGRbpmE3trfHKKA=", "LhyggcltWr8sxAs3l8OLCuio71125tA+m7BnQcIYQSM=", "Jxzz6nsGtOdDWFrmiZfAFDVC5AXHCFV4cYEWPkrCC0U=", "Cd6hJ5ctIQnK236Wq7p1d8CsAHcxK5VQ+Bt3FqkvXqs=", "GYLMcW2iCxGVJcZKP+hfXjG6qXx2yCN2mZY32O8cigc=", "ImYA3ou2Wzjs+Zbluyb9YojGkPFqXu23MNk5MR0MP/E=", "Ag97d/u8rZmOd0TKJ8D3wMJVCj25D+KJROc9AdJK5ss=", "HC5EXPyYY3quvCwat7bXkOusUCcHHRBXqUW8kEN8ScI=", "JEs0lQLfSjNWOzAjfudQ55veE18LCJbw2c3gTxAEFx4=", "EIYKh12AvXHGJnwdVLAvtYyJCxz/w1+nB/5qlJQSgc0=", "Luxa3ezE4kZQ276lMaD+8NwyfcaU8imyUm0vMLLEmcE=", "GIu3FQtuQGJLAuooIa62tSsehbW3JLwOxRL4+mQRgso=", "BeVgB9q94syD1Jg3HpmtqVPs1p4TXvAgTS07bMH0mqE=", "JVN1WzbeYR7VV3aLtVE3MUdKCozcbbqPBPMDGwdoexY=", "HPJn3Zv7bmeKgsd0WFemPitXBmqGJrUsD9X/QkGKpl0=", "EGsqQAhzdeopiLjgcA/dcdNxavK/0Lawym4kq0tMJeE=", "C5eOShDbzcvH6QquLKGWFd9nSBnLYR2TtMv18v+aChY=", "LtaP+6amRuUEdma4rWn2yzWtCW1tNP4cpn5TK1GGu/Q=", "I8Yywv5o1PCnGx7mOVHHK300l5fwcFPfLtM1IOo+lM0=", "J/2l+CbOaoNA0SpYTUuchPCk6jydM+ro1sDiOlqYl+M=", "LSSqTAdyJW6QNE0g1G3727Xp3BMqT7B/r47dqjDadnQ=", "BI1SxOPXFIXOavEi6hNuYAU+OH13Np7t+Nm7xmP7mPc=", "DgwfAFoXWd0WEwL9sjPLrF/hUbXCGSJVvXV7PO2Jn5I=", "Iw1kHEVS5eVUFuNg6qMpAHUd5cpT6GVK+NQi7sYn77I=", "Av9vqDZKjPsZ4wvofUze7Z+VfdAk+BONU1xjgKi104o=", "FomgR2KlqxOI9qclfnxyg4UTxX2n9UaiAX/xKK/hYXE=", "KI2McyUgQlDoYy9C3r7ooxpHAxKrL9AK+8dpT5W4J80=", "I5lhNa+fOkKm2zP9VTGafK7Y2i5uM4Bo149UCFUsg8E=", "FdBS2tzhRQb8zSaQwzP47Kw4LStnNHJiNs+ce+J4u+Q=", "FJT7ZeWZPZbDC/C84/Vtzmii3lIpm0gJzBGeN9jgQuY=", "C4AO+HSfkbMHlHxYEJXskoPDsTG+WtW9pCAJkvv/BTw=", "C6wfU9Wn05gRuufBp53Jl/3V8ScPcoBfsF9cUtd8HLA=", "F5JJiT+obuBntHu+gzW4lCvJIa4OCCwwPjK4Cdk5eG4=", "CYWnybQoBdkQqJ4tyVY+fjRJ/VtAH/TV6sddzn/LQg0=", "LBkFtfAMknpXoVTEdEJ+MfPKq4GYHWIft/6lJczam/4=", "CyNQLOBMD0yzDAvbbE8qT4HC7yI5NvB+9XhW8Km7T3A=", "LcBRwbz2NyM+p8Xghq7X3N61G3o1JYIL3W62XleFGbo=", "Jz2KQWbcP1Ox/yTGHxo7MAeigrUmxyOe7IHpL1HHQa4=", "JXmIvn3CV6DF3XB4ty9pLHVfAbo8jlfYLZuWlWXb8Po=", "IT0P5aPnYI+mAvW1rVuCYGVERevXJJKjKtOZHzpaYhg=", "B6OD56IhvHb7FDcNSz7ujeUCYBpeTVSzNwxMUCsJeoo=", "GM57PmR86aOpDQ7ZqlfrmoldWWpUlYzJcC2NohliPoE=", "EjIO4Q78H4EY0+ppdXTq4t+vjynBg6vRIzkuPCgpkAo=", "CT0OEwTGYP3a/bSClZKPtqgxFIJ1ZsvN4m70yHyfqJ4=", "KTG5KV2W5blzZLN9rv2n3L89yfSKszZNqdxqcjTXFMY=", "H1M6HktIeML8LpcG5UHShIHOQ7FifQukZZaQbPMoFiQ=", "JRfLck0S7m6/p7Sw0lzwMVRm6Y2MrD/7+xobze4M8GQ=", "AOQ9yYO8j+vqrUATBESrf5GHGFYkFJp/J0SS2b2Dieo=", "GGvAmn/8Tt0pFXmHa3fC/T7tCxuD8h3fuJkDnOt383k=", "BdIqL0j2RljhgbiuXnLhqUJ5avK/5u90rJq/U6xl7rQ=", "HwBujSRjY2vKeH92X9ascjrSwuRmrmMk9dOfPu5Y8M0=", "KJE9Qr32gEeP/Rc3Tolf53mdnRABlvbMww3Ajzmkefc=", "EbVXyNfpe9ma5fSegjMIvW4iaUIl1AKd/c2DbLfArXs=", "B0S1OSbhoO85W7BJCLEzJq4YZqaJg8Qd5W+3zH3M4pc=", "K/svJFanCYmxZftqPub5RNKDYpNcq+UWEUmA8UFCKgM=", "MCcEeUTsgs72JA0WNwcMYixdKKdDAt4O/W1K3dTcLbI=", "HtC15LKa6wtbPrEozwMXWcs7xHzBKGZXzf6IxcQR1KI=", "JjR57nfkTosquVPoLvY6fkr/SPDnMPR4KyJcsid3EE8=", "GZBMhOVeGvMUfNt/OkKCZeIMG7zL7Cpci5UEF8ou5HE=", "L6hGj+oyBO0qk0oe73x4WAqNowxexZIvrImrkq2Bo6Q=", "JnwLSxlmLPCbhw4F90QeBC5bli9z39eNIzhNx+pxr6U=", "LxUEZ1BBdVQJlG6MX1Qy01hJunvqDRJRJUeuaEuDrC0=", "IEGZ1kmC9XQyf/P0AHBeClOyXVmukc4LnTH9u6HuKww=", "Cgh1VOVRFCZ4DkV3V8F1z2GHou+5Voo9OQ06UcIpfM8=", "Lvm4hChGX1NcsEEZ9RjRwgUiaEVfGrFFzPFpO+kkFqs=", "KpbJ8gC0d+ungxb8RJfgiypDhLJsl8e0zod8tl/1Y08=", "BDKT5h7xthSFC8AV3TFuLHxU8S0tt0b3wM3LDsVRz8I=", "HYHg4oBhG/MJicGnQIhJNQS4GLOF0E2WrSmNvtmnvfs=", "GtnPF7g2jZgALO0s9u+ThaB0xeOqCy4S9LdozEgEveM=", "GbMKJxGf9Q2ic0sSergymaSwmWlMMazBgqtFP8AA75U=", "Ey2B8Au+8oBJAcQHP82cgXpjgyww1lMGP2f9hkguGZg=", "KS6j7yMThjoSdrHw5Jc/p4Tep4oeyY9NWTlH9qTnOSQ=", "Aoz7XgxBsMd9mH5zelAYeHB58v+mUBAvL+tzXH2bzoQ=", "Ea/XXchDU+L5wvBdHzynNOtFVGuSOWIzo/KfTo9nkbM=", "Gq9D7W2jm0UxIL0DEvJZKU6hAbZ43/QnhDwPyBZAntY=", "GdsJ34M4ex5Bhc15QAYJ55835aRljb7geF2rXczjKGg=", "Apyz3K8uuw9bC5SehCeP7S0R24wfzzXjgYmvyhbAy/0=", "KIHfk1LSdPDP61Xfj/6x0Ngfzat5QILiEH4bBCanMKI=", "Biig+VlMFZIGx2J6jxB0ih3yzlgrdgSo5kpwFevdtls=", "ImVzk+t+2fRXLCLNe51RNNH7zilcKpXxr8ZEHeYNf7g=", "AGMl9QnwNicUxIUNrth0QGL8+AmGCABefQi1CbujNiQ=", "Fx1kmLQrOTRdVuhmHMwrV270SbH45b3FrHLZ+T3D3Zo=", "G+gvOxzJ2ElZXYXjOYMxGGtuS0y99Dzu7b8Ec1MVqNI=", "FUcRvmLyPNRghrkxGyjurajSYyP4hk3n425VQ7zXo48=", "Gezl2MC2zAf6ARl0bn82ycjUlqweHZXNW7jXaaZ0XNg=", "JtYWLY2cnGAkTLzBu3iBQmX++XpToWjGKkO55vTLLRY=", "KLuF/vn2WITkqZpjpZqQbVhs3Yi7p8USWbH+ajdf5K8=", "JnzKweNCcZceR0F5xYAFJs7vLxpv3arB3iKZ6S2djOA=", "LmtIaNFTkNgBQkjuwMfxDY7p7r+mQCX5Yezkmp/62YU=", "FwOQI7ok43vEzeSX6V0TT/Nd3m/gk+14jkg50rzs+EA=", "IURV2R/HR8aqmQitktGbLcdahGURg9z0O5olYyDDPlc=", "CgdAXwNtMOx37GSwNLn8XfLP9Yd8PGe3qyO58tja0qQ=", "KfaAcoS25DXMwvwUV5uu0KYGF+DuM6NYyzFoEbPYhko=", "JGiU9gcfyWMPaRh8tatQbAUIQRTS788jF4C11LXEoMY=", "BCJAgbkKZ3dNFf+Y5hNEk8AZJvfsJQU95WIVwUXl2mc=", "DZnP52SdHf0pLxF3O//xzjZFzkISeH7TacCga2ArqyE=", "H8dgIzM7pNwPKo26+7ob/zO3U/135rG9xMeWoDG3gVo=", "L2DgX6H3RGc1o3F6nXNyilsgFmU3/+tlcH5fdQPorPM=", "Git1CJIfoFT1jKTW7rEzRTZjyJedYhbsnuEkC4yJToA=", "CgrKSSS+ppeaVuR68L+hnB2311a7Sq3gpY5b3dfdy00=", "JiojZcx4D2JVfIVFZvosiCLm/f+OrbkJSfqlq9Y6f4I=", "Ga1aiC8dxJcUKVRd2j2xhXscoKJGdos6KwAUulowJDk=", "Jh4zYPsjwI6HuPWIvVnwjO8Hu0im8SJqZM3H1N5+lco=", "BpzGfK5G3tGP3HJcnK2d1k5EXJkCcbDi0szEL9zgv1k=", "Fi4hiWyNH2wrfsFvt65++MjuGSFq4Ymm7y1+vbHOYsg=", "Eo1CwIRE2JVoeZlaEFozbEJI/5WBE5Ei7ZydVUZO6bM=", "Euk5H38THxPDlyXEQUZpvMZMekG2dk5ofO6OUHQz4+k=", "HemI5GwsmhwA2F36+x2nUJvLNkIqq2BS/R+SffdBwXA=", "IALLinefk96LRNf7CM/1CCjgdx1lAR+ZVLQk5ngCzw0=", "KPblrydSx50Bo8bH0pMP37FkmJwg+QXM/AmCwpNl1jE=", "GeustTVPfycvXBLWxxs52J4UqqTvv5hzdzN/+jwCays=", "Bd1HxpXMbJXirNG/wM4zXLMEo8M4CpTot8BwaCyoaaE=", "JGvDwDejya4run5zV4sagl4WcqdBiAHMB0OVRTTZwMc=", "G37iVYFbpwIPDPeM65hggVwO66Jopyzs+eP9Gmhws64=", "HOBPZDvJUTMWIR/cC8I8mlK9r0vM2coYWQwXA6LRIOE=", "LjplMq+pU4i0GtWdfCcFRF184QyI1zQRtycfUu1MRMs=", "H5ESHyy9Hq0vcPT3RymiVyNyGolah9czlMycGAn8z7s=", "EQgkAziKmdoN4+19O4c/Wrz3H4vqbjWPWw8XylJ22SY=", "A5YqaR60LPXvd5vuglCGQTKe2e63hX8c7MRtyTBG4fY=", "CmeRDilFg3OcK20Y6lrXThQbsqNT/N2T/D74P0/Xhjo=", "HCD5vRMjcJ/aEk9x6IkBI19ExeSCh78PQ7RUQ93Lrlw=", "ERq1bhknTv1HOStwFx39qwyM71tt5XneZ/V56GtQb70=", "AG5riObwzfmC3kg6oEu50P4ojuWGOmiSkV0SXq7XhrQ=", "KbxZ1vum1pLipehbpQ1v2bz8zFfivL3d1liBr0Rf/4Q=", "Jh0TrEQbLzAJbB9/ZqbZcyRMLAcCESdaN9SbHXA0Dt0=", "B3+NknP/2jftHqaD9pNJcV+VmG0mFj8A1ByePDZsy/w=", "Fnj5/GxFAsI1Jn9LhB2VQyCFQjVe19tCCmCay46Ovc4=", "GmW0HcMCuQb9FEpZS+ptkJ9y+3B1ALJwg3yaJJWQB1s=", "JlNZvw6td3Jk0Y27TEZkMBojsQV5No9AtDNxC5f4B6k=", "LpRM4OtlN0WkVjLAcLkx0I7MSXPqCR5dxnElzJBF5B4=", "J+MCWi0+gmFKTdBVD1k1n1ZDuGg1kmrtLrCnqk8GIZo=", "DZhI4NO4vI1D5eaVTm8BgZhuV1BUhA8jjKtMtbA//8I=", "GsOq2BXY7BOwNd7PZ6aFSWqHsQS/V+84zahVh3/KfHU=", "DJEBhvkS7vlf1nPq0igf/Q1c6cgMxR9vkx0MdbnAo68=", "JItjp2oCTVzy5Cob9wqVTwGxhJ2sMf1UWnzXTFw6HlQ=", "GnH7pgzTY7C+PqNgSjhs0d9Ga15p+TUDhYxp9ahoaV4=", "FaKGm2NjzQKkcsvOxckb+hckLO3quDCE8O7fKDQxeLE=", "KBPBBzH3aUVA6s3oV3hqskQ/sYkWGSQ7jU2aUppzNUg=", "KqlpBe9CvB6EUgh/4T3D1VzpQGKTb95I/Cn4aY7V7FA=", "Dwk9Np+tCg0lW/wxHEpY3JihkAzzWbPn2WiPZZG404Q=", "Bo27xTCWd2XPfH5puL7k7gjUhrQg1TOWJshBHKmEAn0=", "HdDKtxVwlB7pYr1h2tHLaKjtgCKt/zVqZ/yrOm6vWu4=", "KahX8ISufytQbv1s+wZy1jrpYM0ZefeNf1XXgllVN3c=", "IIH3cT9Rs5MN+gpt+Og2EbyIKc0fhHG34uF/SA2FPDM=", "Luo3SmCrGiBkjLkI5gXG2FmbpgFThjXIzO4AyryFcns=", "GhtovSlREx5tcZUiM2R+QWW8QS2m2Zwhl6o5fY0+5bo=", "He/fFEFaeNXm8oeubknrsRgiuHNMnfkcgOCN5XstTys=", "EAQMxP0gusymniYocTi+TayUBAzGIk4r/cdmYRBqckk=", "IM5n8y6CO5iAEdDDOrsPclvpb8mrWy63EBL1+ApV/0A=", "IC7NUMgsnhx58P4TZRiyJVHAWMIbbuzkNYW80ozE6oc=", "EPulDAYPzrmJ11NsNpLwwyQzOCENFF1hh5JnmLdHCH0=", "AmgJNuQCdl3WzP3+LepxnTxQenxVESPA+d1ZpYv43LU=", "ECvrSlxMkD6u+eyw1XlBVGINfp3oQ2T+BYO+ebTefPs=", "CNAdsY+uzRomwoW+ZUFL8YqwEtfvsmdfSuHW9eE3BiI=", "ES/l0hfzPC0tGXYtKGhBNmungrS936M72oNvot5BkBA=", "BkiF9FfPr+bs4pRKmpNe/ccXr/y0RJzrMaJ5LV7qZ2U=", "C73DcattQpbnPtIHi5n6R9AMRM9R7sCtStCqucCc2IY=", "C55ZtpmqaI3RIUPokLb9DjSADWtED19rbEJrMK0HiIc=", "ClqjHU+rjhCbD9/FXrFKXC2SZ9f5hrYQFwzlVDv7MLc=", "AyOdULSgEo45x2c/L5nYi1kD6xu3cExsDN1MMUCKems=", "EaaUWUmhgnWbbx2mDq2vLHMMzmbqBG+PXreB58RfjJ0=", "DFAv8b7YpocmgD4iK4fVkHSVbYNPLWOBfyqe/tPckx4=", "Ii2dqjhK4rQOQ+J0zAfS27nraYjQOJS2+/UTNmNMkX4=", "Hfj+DdqOUZcbkXsP8PPgXtSwDAlUU1GhF3gFxQ9rwAk=", "Iiu4KQQFxbM3PxsZmWnG0Pm6jrdy8kl8VcD1UXdbJjU=", "B5Ar7CPZ+RoAOpKOqv+WR6wDAondXqzYyv3TG5MmTRA=", "LHBvBZ1qhupJbC5Gk9FxfkCY/4fQWoLXOP2Ig6grnV4=", "Ba4mFpS+4kRqGBNgjt7GlvJSki0z6UKAqoBb/YQ3hvU=", "GG7iynecXCahk63w/0fZ8zO3UPmbd2VQEcZLPozN+T0=", "HCq26W9o47LM5to0ZbGePkpDex8gnFXm75mhrAc2vRE=", "L9F9t+GCcWnDLM/ArRTZ+Xx1B/jviNxdbwSwIgPDflU=", "JB+tdXBihBirl0jO1TZGwuEAruvWKmxzgE8IDeZtlyA=", "ABa1tTQD7m9H5hAMJ3jKlwtAr2vid+mLcQMviU5vai8=", "AAoJWEL3GOcWRbLoHJCz8IV8jJNbE1sMsl3xVB04x/8=", "MD8roE7t8UJbXXzEvixQiLnS7yv0eLnpuM5v8WaJCb0=", "FJRDUULJb8lOjWbZtkPgGRY8asLk4WIFb6j+7lGVZmc=", "Axzbua0o7FfE4ayP9mx5HQSyWiirytroOlVz4/PUv+o=", "DHh9/wEvE2uJzjUWwc+GeSjXEH0hjWLVGwstjMmFBJg=", "CyCzFJB/Ui4XqdXajBD8+Iy5VlVs8HdFfB5KmtXcCw0=", "EdXK39BBicbBSknoumeDVArcftcL8lr+Jd+eL/2bw18=", "CFIwnVDxRTjIt9NWWNibow4pqrZiZTGqoRhf8Mq4of8=", "JXOV58GQs83OX5NNvqkHcFAIowWTxpKT/XEFYiYCYEo=", "Cq43r1w6VCICk19ZC2Z/l5+0FCc8yHkxYQpLMUSuv7c=", "HBZUp3/q/Nf+66lMMmBfld7QPhPAimJ0xH7bQRNOJEQ=", "FIDMTLO52fyXuZ40D+wZgj3NLt8Zj3CV7lxwqSAJleA=", "GHEQV4aRiRJviFNqzOpIgqNHl6ndlqlMyHuOpGJBdlU=", "DpxHNe55e5xwgzp6a+fCz8uWLwcMqqZJRm/fm75YKM0=", "Li44zOp+9sKakisCfTHZhwrA+dJ94Z1wA5u9H5D/dPw=", "HWY2npXC52Aw44DWU4qTJ4+R6l3WDloxaz3O0n/BN6M=", "Ke+RArXmce3AX4e8zrbZAEhOfudAKjLMx3/eLnhmoIM=", "IQOwTBc191Eet3XHM0oLttYm+2CTe6N2Ha1zqER4490=", "DdG2uoSjwptikjdlBoz2PHEbwda7KO7+OKDkhhrROWM=", "HqtMf6q+xYq5tzsrqvIeQogLd7Dw39MNOOHJVendchs=", "AC4aP2ad/JKbnMhNltSJ7OEU1b5duFcUafd0z29sgCI=", "EhTKQk6hUXhRUNfbV7k8xrvI110ZKZOEYKfGfwx5HxE=", "LhdN1Kr/9hAxZNkWX/gxnZJgyGIYUQpNkQNB8LTgHTg=", "ILMvSkI2F/7xRtpfGiaV/P9kl/+row3s9v/mKulSxDU=", "KfTdRo2whzSRRotwCduvx5lR87g6tk77jdLlbMmzGo4=", "JRmAHeTljkFk9/DYaZQxHIfyeaOK/EyzxNJs9BxkKvA=", "LKEj+vh13k6q2A66c8sqAPIur1thCe9Bpl0tKG9gLME=", "Dv7WUaYfowtwk3venQK5tqMCoaq3Bmh7IjOumyAzEmc=", "E+Idu/1+VSa9xQdec97grvRaDtLIgLKbfb1cnmQ57j8=", "LCSG2FqtvDWLEGXdexSVfoz1v3RRr8s5Rll0HPa+WCE=", "LJel1bl1GUO8EeBMLWClbEPZRblrCYLIo/XmO3NVDWs=", "DTh2sFU2lDgK3AhsyScuF3Di+Gszb/eAQEGeXtzNjPU=", "EjZcfN1hbSWPmuNQSzfUTpWMgWoLujdCeOi3rXmrlnk=", "G2A1TRawGENUC4/Glh/4Sljr5eQrRtIq62GOLbSt5l8=", "A3ePxyPM0DrYyQwxHBQZY96mOdJSStly2EltEp4cJDQ=", "Luch3ehSh54SOMt6eSBxR7PYZObIoUoyfi5Vi531dmI=", "EQINBYH/jnnI9apNUL4tx5KgOLy2GuxMzqLsTfLQr0w=", "Hg6SEZPjWzxC3tAD3Lvtjq5GcS4V5jrscV8/cDHPT48=", "KmwT16/WY2wtTV029CwJrDKGtncDrE0sJNz1o63ZAg0=", "J73e3qfY05i0tukVLhfC0JIhdgmxCcFFdPkyuwLIhEA=", "LhP5y8NWco5tK3pcWTqp7Mm5ALuYkBWT0CHWHrplVaM=", "EJrzN3PkFhVohbqwUT3BmaAEXUBdgb0qFRaQva+6O2Y=", "C/ehIamF0g7r6/Yk84NzB0Fa5ICVS/SVUt2MXz5QMBo=", "D3i6fD5tFdESkt0SGq1FlIMnG1/i7lamOBTV2xkpBWc=", "FiXfA16qmS9CTdxtyIwbcArF5tWYHirQ35spCla9UAE=", "GsfR8zu1mP6VgaxzsKrU6azpnq0BmB/PLFAqca/VZ2I=", "LTcpbvDNVnbQgJYIujQM17IC4uHCVG2YlBfTA+wxkzc=", "AZyqYsUjjgPs33W7LCdr4YBb4/5EqVfYqjvwfKzxwRQ=", "DzLeoQQyDODwCRnZD5xsdtSWiCeRFGxSKorKzq4+Skg=", "LOXSRSwKWp+2WkpkgvNJmIZb6aKfJm+IqK/6hQ9exuU=", "E11ZDegKDnF9pzJceBqhZ6JeXDENkt+DEg6JHM7SSos=", "HTzpanzXnpRJLjK4mD1i+sc2SZhQci9/590ViXBqtpM=", "DqOh4fXco/99hnHy/s+0Z/ak5lFsgDipMGs23IGDIbI=", "HtCMTw4W0UQFkQDwX7RjCY49hp80Lg74tKR6/nSoOiU=", "Ct9hK8DCToJhNcfeDbqQ++G9JJ90JPGXC1LouyTZhu0=", "JAxCSgJOWb6joU/Kc9e2OGnrm2h0atnDVrk/tuqj4is=", "JN+rcjiwW/CPZvvlmXY/Y9XHChgafp/jXa8EeeKxy9Q=", "Fg15oDlZyWja+3bqPgj/0s4RfQlOgg1en3zh3r07sIw=", "G2UhYYehyhZ5ZC1MQKoFv/clv6UCSKqJ1X9XDC/pNFo=", "JDUDutitrxSo5WUBOGPBOnf296D/9XHBJ1sY9UvXc1E=", "BsKtR79N5XTKz7pRXRjdr3gqit360cGO5DkRY8VBpiw=", "IUNmZz04cUhXj++JQ0vPx+DOTrCGYZBAJrMLoQ86E0E=", "HbgdmLTU2DImrkExMByONiKjLit4hIYOhSV/X3t+beQ=", "KdK9vBmJbo+vDOFdfIg7y/qjiGHXySKZpr70L3xEPw8=", "GSlfcsWQfo2fjYzez30ZP6hkBMu3qFUi9/wzhXt6nIg=", "C/AVdgdwy+jm9pCA86yhgljyzQkuM9PtYtjRnRRLrKg=", "BsshqsC+jcJSjDl0cks41zqRhTCXb/EY0IdkzULgskA=", "Enb+LHUbpJ/Vt1yrW3H2SqBYjt6AfbG9WDw9auaUE1Y=", "Khf9gEHs12L1KNEgZ6CSBPkpbqVzdIBsOYlv6UmbmM8=", "GQTiv5wFEsclWecePxMvZSWQWPfWi519baGo+fXK9nQ=", "EVteuZIzqKIgAXBzPEdDuATGAbXY1GVqE4IS1m64nTg=", "AGtYiF8OCb5rqRF2/IphcrwW1oD4iKPZLzGjvyE+fvg=", "E8ZwTpBTU1KTTc3ASDtLuXTVC+t6W2vjCvDkb71zJc4=", "D7vLlsyvQ8dzuhznBhOJJUNzL+zMhyl1uOtz4/tNVKU=", "BZtN9j29K7ZuCyqCbFy9qWwzj8w42/npxGBBkYvdi/w=", "J9hZ54aMmdgPmdGB5u9+qTppRiOom75Xpsjn7lS+If4=", "IerO0I+dC0LG+lH1nWX5ZZjpylDWzR3Um4T9wGRu1o8=", "BoFbejuAlx0F/ebX3FzSgjNj840K9cD/ir6qcaMjoqc=", "Bqd40pqr67WjzZQLHDPwVVEhe2AFJI4OcWvVoQ1VjG8=", "FP6fsfFnxiV+oBAIgRV2nmK2DvOt0POiLJ/npJGOlMc=", "CQMF3/MUF04n7evldL2PDI/YWEPn0mJ9tgeygW41fcE=", "LOI9++uOGHS5uolMuF8Gi/sEl1Vc/T3684iKpJLSBEU=", "Gw/ZTdnP53TZFGvlhO0LJcssdJWnCCR/V2PCOA5cHNU=", "Bgu3FrpyOk5fX6oXk2OjZ3RhnR4M2Rv0eJoarbPmEqo=", "BDsQxQjoaBhD7dwF5zuVt/VNpak7cBy6TWgi+cnc9DY=", "Emc06VArqfrkoxS2et5s6IkOMEpDDmyfT9YMuK1plQ0=", "Ju3TXbl8KrLOJ7UDWShZtDF6JaaI+XQ+8N2cwmGdt+c=", "J7Il5KmBrzbOqGP1kci8WqlaS+ttXJq8XgO6kG7XIGI=", "EQJyiDL3UcMTrGYQ+uWLnL1RG1HWEhs7+mD0fbElGNo=", "GCdssBG9xtdescfV0GzOEMfJB5yMmSD6OJsRZiDuQUE=", "JQLX3s6M19egShcwv9KGj8ZPg13+FDzuGEgMfD/K2nY=", "BrIL6qV13YRiVGlQaEhGEbvuGuSChbosPZnBTmJYGiw=", "Bjq0oHj8shInX/X9BgQr29F6zq6ZTiwnobqHYTn47Bo=", "BjctWVK7aaRgvxMz70rGsgsHrUq0Ek3UBmps9m9AaZM=", "D0HU4+9V2nHPQDfEnUTApkH1KloXT3q+xSJHbjxiPOA=", "Dw7phBshubIjwdGpBpk71msOvLfa++K4AruBZcYBF3M=", "Ad8usvpCPwE5bgczkBBMrYAEpqXxQKKxjtZYBoFnUho=", "HOBbxVQHyIOlpBeS7zSG/yLkA9OEdM+pD17TDI0wGYw=", "A38fx5NLvV/cNDiL+9D5VGclTl3ytbYsrtBQCiWU3a0=", "G9amFABDmPMptwgP/mnT3/beBsgZ/t6iSu0W5MRxZOc=", "D8Llz/fp79Rv7mKqOz8ivMnxo72JF+Lhz1qjNNKdKgY=", "J0+k49hufviw/fGoGszo+e0vLrRifedXgagT8Qajd+c=", "GTrxxfoFfOaC7HKM6pBzWTWiK1r/RuovgDopQhqpUNY=", "DnLDPtYFVHGtrWHQJ8WsG/dURPxOFJiLQiaPB4fimHU=", "HHWASk7xyByDaE1ojEQpqxp+UX38YCyaJEPFnzLulhQ=", "CIA/adg+DDOX4J3UeoDPn05CNDcAjKutLlARBFbIxg0=", "LRIU7Re/gRYqXdQ6P9zxlfv0dCYETLIttThHjpQrB+Y=", "DIWyS3mrV1BEIhNfscsMXh46XwoGEDwkhu5qPu+scog=", "Lin1F90bMLeRv6sDznR/lQIC8OuCZ+8/cczsQOkdleY=", "EygclKZw/lqwl3OvQmBnQFA1Ce/XTB7Zk7xq+vPWQXQ=", "IaIRQHzvewRCFgrMnb/OGh4dWMnpjzgafrSPe9oPHgU=", "CF7x53+Sm8/60ak/kgwdjIs2MuHhoczU7LAWAnWeCH4=", "K295beNQnqcDyNpiduPqFUtQQXDFmo7EWB6XV9dLp1k=", "H9pQdPpbrl4W+08tGNWJpyMLmhweTQioBp/I1Fsd480=", "AtIqPA0yR1DTvjEhmvMqgoLDct/eSGHvhu8VwxVdzxQ=", "DCH09L2uB6ebs6mM+zUapinzI5xNJK75Lqeb+snC+iU=", "G3IewcHfgcg6zXqVrOFrPi/0KXqrtvWBALXasG09xAQ=", "J+yenpI+3uWBidbH8wPuPlJJxa73h1jH9RHPh7lTVh8=", "Hs8QYDZt6pUG/aDQHLoBbbliAJChYNWnYKddEtXXLng=", "JdQy3zEuAFxpoGofAE7ImVdQNNomOSdg0XrMgMOVBs0=", "F6DqUfmiAboqD4V8mWmn9rxvXVvA5JV+HA3+SyAuSiQ=", "AtNMR7hH1nybTcMTvHFP8iOrARJ4Bv9ski2HY/FCAks=", "Ag5Z5eW7CVGmYBIvwa7+opTnzNX5x5g5KC69nhGflso=", "JJychQFz26D/6jVowoQWAgEhw9mZDf4ukXN3RndZJns=", "AejsV7doHWMaAtUwya7vk3dYae8JPekgFM34XuLUWdo=", "APc53Lnz7m57VRl3S1QLKJi7bLo2KbtsYOQjt+trX/w=", "DgFvByT/+F14GusVSNdsVm5cJqp5lu31BOQWcoX9pm4=", "J1Jwgoud3JZLuNaKYlhUNWjIRJR+1e2UsxgMuHTGgyU=", "APHKP8KKrLisIaW0S76wrmTMM53hPgTHT86CD0+T5I0=", "IWsvickBBfVw4JEb0c4g4GZP/gGBHLd3+QN2cZwOIPM=", "GpHt+QlQyyaJ0sKcsi+N6mHsQfsGHxtgAvciZWlMeE4=", "LaM0Lq85orJCcTSERilxr+U99VvtX11Q1n2ROM14/oQ=", "KfechvWpyW/K8ilr42Qltyr6rUhly5CQhIJJFY4upLE=", "BRlCahWlmfINKXkwIGfb0UVLRlOclJnGX2GVtVx2Azc=", "D5xHXNcrfi44ZelrrviaFJ6s06s0AhCpxeDeb8CC6J0=", "FfHXEZed/hPkXuuXWaifUds9J1lJhYkLiMm/J2kiFzo=", "Hwg6wFSaGrANS8kGbwVJQUj2DJVp55iZQcP1D9as92A=", "FQXuT3m8gYeFbV8/WiTel6oIK41FLGOxesOlkUUbdH4=", "DyCHbXEvFH4vufe+alHzRuooRH31KetBNClI/C2PCWs=", "FpbRLZrneckhIO5xX2uNoR6pOvJnNxWi33cx25HjYNw=", "KEhfQ47sEzsL42sy+ugtpX+0AGvX9bsVomfndGs3utE=", "J4BDb52hJGH74x2Xllbm0aEzhuDmpTCbBQyoGeEK2UU=", "Jx6oY2czMt8r8kcebIk1sDfqgxjqWzI3lYP2EeBrPaY=", "KfG6SynB2uy5g5vcCEMbyr5oORylQPaLSEpPjpap3GE=", "KU9MxyjdQj/a83N34Gmrpm9NMADxpVm/TESRAzBgMeM=", "FGtSGxwIyRgSE+vbwqNPw+/Yfd6xv8Xl0XypUfVavRc=", "Da4K+XPqCw/N2BWOpRue/e7V62ZLhO9n6qJV/k5V8+I=", "JgTMzDcPClDz9ybt8SQrzBMd3fJpeFMnbAeev7iD2MI=", "KHOxnbHQOJbT1S1vk2Hj/a3l57Lmgz5NXORmEYa7u58=", "CwTQkLzEz6v6R/YAQ4Wa618zpt4gXf3w49CZ1Kg5Tgg=", "BQihlcDKWD7BAVbyBcobtvaRcxi47W67c0e3fXLc90g=", "CSYt+oCqoLxhxYkcI3pRnTgIxT/AXc49cfF8Dj8qXus=", "DObSWxxsG4n6AFwjYZ2Hfyqy/ecI0wkjZppJ/iWzx9w=", "LmloW0bIBQJo28EEDiPHOdchayxedhCBNtaJXe093EQ=", "Anj7PfP+kTZXvMzrVTE4+nuKtuBipd3q393dWzBf+CI=", "FtqJKt41dU5X2PA/Pm9BEKncFjnZtt5l5HkWXKSfek4=", "FZdUkk5zNIVP+AOheC/8BZkno8JtxD5mHgmhJhvXyUo=", "IhLKZIe4RbpNFsCeIkKX1LGhbjQebFk9f6utraOSnXo=", "LdCI3oMYUtFpruHWvmm1LF3uC3Phj8qRzc75uQOWoEc=", "JKtCrWdJoU/i9wfsU6w7AxXe7PQhuXUwMlM+KEkdsw8=", "L2Rm5Q7zxhoOZJOxjTSRFAbi6X01UYh6+AjWfhzpric=", "H1iG+4YYyHEewI3pR3Vx8OtuRiuPXlNJ+FYx8FlZRIA=", "Bbo0lTlZeEpXwAGekW4q3l1qUjEQQ3zqnCuURT3N8qA=", "J67mejxu94PLVZFRZaW7/dhrwGx3bxRQSLskAdzxc0E=", "D1fvwF6fl+f2jGlLorO/IW7vvVxxcQpW9GBoKmul1e8=", "HTXrSkCkHdd1BthypFisk9czbcty8VsYKmcCylO5Tu8=", "GKMwZFhtWnArxL9k9wtEtad5GCVcLf++/FN+QL1ZUf8=", "CwrlcW5CtEC3QjvYmTGciApKZ0VQt70DYgfgBqx6LSE=", "ETag9sAEosV9IaAMQN7G8CexQLNtNZTBzcGw6HB7YvE=", "Ic7FKsSyqn+A+Y63W04CgFkZd9ULZ3uP8QsKPQKFMqw=", "KEpjZ4b6Y1ebFUF0aQHUjkQM8MWG8bCJzEXouDD60i4=", "HUoKugysUcMmH3xIPYlijXZ0iwgzy6a7/KxSQ+S8tNo=", "BBCgZZJekPxw7RqqRkd6isgZOhDEi12E+16c8hI64k8=", "MBRTsj0FXBhKZa1qas/9n1IGN/51H/e3aUCdUS/JLw8=", "A3gnEEKH2Uu9wGWE021NXixGxOoiT04NwMO7VB8FO3k=", "KUZBuooCdoxeO39ULSgcadwsPy6AMvhkKVpksIqT2ZM=", "HBL5k/Dx7dgJ7u+uaTLluIc4sza75vl29fegoXj/6rA=", "DLLZSNOPuOF8YLpsZ2CMn/2RLgpifu51a40ir4ueXkM=", "JvH/cxJo2bvSarM+WIrOwJ/VpLcNYLVTkE9eLQXolMU=", "Ca74ogKfgrdtgK2KOSbLbhF02Li4nFlwfBI0cxILTH0=", "G+gMqxL0vRc3eWvHcPFwc8awBGwye8vzo24mQGx3XHQ=", "JHbnvGN/JD0j12LLPizYQw2tiXYldsvdkYQop1gog2o=", "GW1wfKWp7cwOMQOu38YKvdHJ5Xc1TZML4NW20DYXwgk=", "HSYkhyN+hQOQjVN1oaeYqbjA+szAVu3diqh9CmawfSQ=", "KiHgPUEVS/MZHxqDS5r2sj1AvAHQJ8K0hB+yPcn/cVs=", "ApxkeCKhrlZbK/EkntrroMuzrXMN620uZhj7+edNqtk=", "I+GXEXW4+7JsCYneqC2PSj9wh3TChuTtL4367a89teM=", "EwYYi3kjaOvaHy4x6EaFTLs08XXgHJJFeVnuHG2g/z0=", "En0PfrmAT8IKtPi5QJg0rlIWRf/6hrDCIdkiP6Dp0rI=", "JEGYW8rONagbH4H8ZiEhXfC6QkQeRQ/GXjUZoDk7EZY=", "LffU6xFRFFRKxPUvyjbWsz8J9jklPp41SdWYew4JcTY=", "D2xVGPku4uVJ0xrbtOeANu+ao8IWTDF6ypIgPjuZ+UA=", "JuLMnepH3GgH+HzYfFMbF6fy9eqGrAlOXVoi/DQz3Nw=", "HHHjPIZLCo3k0Q3Cb3a+1Vdx0WAaDgTTmcsjlwZMXPg=", "Ki8LVjtAg3Zsi2xghywy7v8rIHoZgcBbHzlhePASB68=", "DBrwvFVGJQp/3fHL0+e8269067l5U14LNDZ23J+UM8o=", "AYvfLnB43ECvHL5IjLVi/TISBJnEyXKm1DuSzhZ93+U=", "IrNoWaFqjNw98QryggcViR93lmCh+aJe9lIBn2QL7wY=", "EOaX27xDx64gMPXUmXT4NE1eSKtm1jW0HnuW+8fGKJ4=", "BX3rT+VjkKu73NiCLKtdoSB6CteUI5IGIrDEoS/vNVI=", "ErJ8FjnxYvhG+zeucUTykTdoLufrFjLnkbRiiv9KrCM=", "Cyx8dtAYQ6LRRlXCPoCRr7bzVZ1mw7vz0RXcnXDbWvI=", "C32WhMDI7KDowxY0yftosug6vnKjZ5s2eKjJsaE6SJU=", "E6sKf+qbLIKHZtL6v1dCSNLX97L45g4mHO8pzZFumis=", "LeNXnXkKw2f2bZBVe1RmgVOlw31TkekqalYVydYL6Xk=", "G6AQttY7lTiygb43ZOjmIxZCxqZzXYnJgI+re62iH24=", "Jv/eqKjZiU674CpwX7dQbhKxp/EAxZAlhOTcvh8hGaw=", "Ef8WGaSdaru1Y5Dj26rwwcsBuVGnNCGLPL2k6AUsy6I=", "Jgw2uAiQvvronLs0eLn3tbP2sR3tR6riwNXgxI2OUXQ=", "BcqIhXyw3V84Dlkqo39vlPfwwyYhMc7ymUihpJ/RhPs=", "GLODKhnrfuGp3PV0MC7gY+wZBGs7nrf7J3pI7oOQ5IU=", "JTUpHwPa0ePFQOfyYgHC4zAYj9pYvngwZ2mKFzn3k2k=", "AU+DKzip9Drybl7C+r9sQlAIPPh/C6hrlQU+kYLRNz4=", "JUjmxHZ8Z2ka9VFi2c4OReieoIpCMvoKIj/ehpv9PqQ=", "Aj7Nqj+UK9RbpG9SjLyBpRzhQlA59EeBp2lvSNKd+9E=", "FhG7WaOyh1a4QNsxiaOl6iLsFoRUcqvWhXCsdxyPFe4=", "C/dhiEUBMzD/Rl8SypUHmrctDKnYp+YzBIwRvyxGx60=", "FciPouuj0If9Kfbeb9hkuHVmL/pDgUQ1LWhHF83NPM0=", "DVjRJ5irVS+W8NlR6Xy+74h9hYZWsfavQBDIAJGwxmI=", "BAbuzXu8IesE+h5WV0XMZUReT4L0okHvuLqwbq+cfLw=", "L6iO2gZXFLmuXhhFYTDjG9b0jQKyQV7GHtIJrY3cMWQ=", "AXSYY66rE8pRImEQPquTtD+sU99rBAIsfLfxdjj1HCk=", "AVUyY6MY7fNEKdkB84eZMrcvXDKtVukAq/R2cvhvmmI=", "Aot6i+R8IjkHmgHdbQ5X3cA/ypxqWNPfbyNN/oL5aso=", "LEib7w+sGbsYfl+KBk5nY280sonC6K3HbsvbtRBfwck=", "H/VIxmkPUifVdmaP72dB+ZnJkUz0hC55P9W1GUvQw90=", "A8G1UchJAwQPrz1tuTToPa/F8O/et6j+snVHckcno0Q=", "HuNiDo8N2oxvFVzoGpN2AJvO8sjY9vJm4Et7gKyM+Gc=", "GORf5+oXH7EdDEr1M4VomQ8iFH4UQh8zb+bgvLuKABQ=", "Jzk0BFIaVeDhpOWMVhGABAwYaCgUiC9Fqt0TG58IdT0=", "B/9oVwEaJLINaYrUOl+Vms7/9ymUDjRqsY+dJgD4PQU=", "KYGzooi0Mng5VCxXls4vCa+dAipgT/rWH+AHfXZ0i/4=", "AN1bC4FY6Kc5le/QudiY1P01hwEfpYbP4CzoAPMGQDM=", "CEwF+uc8vWQy5iLPmIDw0oM3xodLh7iOwLRaVdOTYj0=", "Hi7i/um5v40/NyLnAo/zr45exjGfptiZfcEV5d4uqLE=", "AANBj8WQm2KwKW5utCqgepcQUJOeme43H2QS5E4O9Xc=", "HEmUotQSWAZDdr5c88mYh6q3SAP2fBLGTmWq9/HvVrI=", "BBPCs4czlh/toKaEk9PPRP6813lSuIBv9YPoxAsxAy4=", "AcRq05RVJVUlsme4oFM8XGZQT4GulTS90JHqmJlJl/E=", "Iy+iwJD/Pd6oOtyguc0OCRjJRYt1sLo7fWd63YIL4ok=", "HNVwHIChD0IOs09TRzjA3M/Mtsh8z5rs41q6s3zwX7o=", "A7mB/gxxiCxhlEZVN9XkArgWEYqulL+FGOsHpSnk6lQ=", "FopYiQAQAAZENlimHKnWWfCsRR0eC/1abGo67oVyO+o=", "HlH1WLztJAxlt8683LvbepqwbjWA1G8xjehO3Hleb4g=", "GvpajF/OOW3lbsl9zwMXprfLw+4fjpo7zNbYcAIrdQw=", "ETXv1j6PjMnMBmHdSdNqyOv3kA2Q1m3V+oFgVNQBfco=", "KRTSHC0oRc4rFOlR9CEDWZyHVQFWQdsDxU3zNxA0QK0=", "IMh6LXWXSa6psvD4zAFFJFLnEeOer1qLBxAKGXEn7/Y=", "DbB5IN13nBn8HqjsUyPVrw1RG4adtn3uBAh4XtkikF0=", "DWMfGPrazL/dOzvkZ3KjvO4nY3jNLka6upDVZGjMULY=", "LFAPeQ1GP7E28tjUyt5iKW59fEm84YOVswFMn8ctAFo=", "F2qeupdjXR5ZsZ+qKzMlpbGic3ahbexzF6rkr+4Cv7Q=", "EgL84aUBuItFXKRHiNVSFLrrO1TjfRzIDz1uwOCdR0c=", "IilIN37p0n/GQGAH4XJ7VmuCXey5UJbJrt+o5kU6XLw=", "LsZvwn2CqrLJjrUOZ6CTIhDzxuEkViadV+qQlfQRZus=", "L1wjPb41cYNv2sCRXOZZb8CET+w9C/WpuWjKWMRYRqM=", "E4ibtZucB5U7UvZhI8jBOA5vJyQmEDrc797029KGXaI=", "HPePJfqlLHRzEtCftOmrtPHlWj2jScyNzG3Kgc+ZrDo=", "LA6uKGbWXJcHcEfQ9MQ8KMjX82r2qcb+B+yJIZ8cxzU=", "KLgWzYuMmBYzgAZtClDYsOBv8caQuBuRjH3dCKa3Bmo=", "HUbZFmnOW+ZVT8Ps7oldQf2u7hia3uOBq/t17eFIjPo=", "GEHgO5/FJ0UORHCqjwiI2eyFmdtrD3Ii3KJs1D0iuwU=", "LS6teyB4sJCFgFwnd8kPbFV0S0mnO77wTImTE7r6D1c=", "AYMKjbNCZ2z3SSKBtM/HsTjFXUTarkexT8iI5b90UJU=", "B05M4yvRSwH+n2cp3ioS8hj+RD+3CHOKhg8ZEL36Rng=", "H61MsUD6TVWc+VJfsk5/F0lNI5r2eaAw59G3yc/6lJ0=", "HlDGUmxzJLl7fzOHUr1wDKW9bA78siUmAiRVbXaigzE=", "As8DWbjaGr///XP5B1hkV5P10REv6Jjorwxh555nPls=", "ChSuSXtJeFrndx8N/vS/QYV7sv0fJ9FcPLyM49+Ylc0=", "Fr+gL1dzVmLqwcH1ILSz+cS9Js0nkhd7J2BokWlUzUE=", "D2+pXgEXtzRXn2jcWXNsf5r9nN1KkOE2Ke6r/YRSXps=", "HVnK/ie9/Xj1ZIlDAHY0Ntr5P4Y8MhPBqEnRwxabp3E=", "KJ451qLUvIF6sQREO4m4pgixO7uTs63ncqY77jALvDo=", "DUftr9ao1GUcJ/a+5I6XVvXWUVrxo6NRL1np4+vcwzE=", "GY1qqQcqBt4TEo17FxV/hZlKEMSVcmJ3DMT1nmxtMy8=", "F0uA5CEPnYG+e/cOOrCyHegGX3Ii6Ay708+YXWqrDwU=", "LXgDa6CUh1KueLETi0ucS2fw14qciWXhu7+jVhWFMr8=", "DB/0BFma+COQjzLmB1ZPUht1gSxnBUPjkMsC4wh86SQ=", "ClYbV49L5MUzFR2hpSm8mPSUCqW0j4wBKpwYHYEbjzQ=", "IBKm7SReSM9lAwKJoc0B0m0+suQ5u8TxbyVq3OtAvew=", "CCRCKrtkt1j2AMGOa5mMGdgqn/rLlfnv+eAY1a+zC68=", "JQoJG8kTAbsTk3gqfiHuqBwLyOaBYaOk5eSop+MJZK0=", "GkrbyFMOrOThlpbXegbh7t66PewuRKzNOs/X+ubQdrM=", "JaUR97hZWxInjysFtO1mhO4SsdKY/OJ8zWeHtahuJrs=", "B98l6PdvMtmbmd0E2SfBsvoZA3dmNuOPcYjYwrc8OlQ=", "BZQhztm7kiYvl+fHvrgTVTndZrzW8L1BvRJKkpgj91w=", "JuHNrN6R4RJ5bfcN06R5tZW4z+fEyVtZVu1HegeBOEI=", "KYCD3q6eDMQKm2DklORObv6TqOD+IRgcsTUdl/wNlUs=", "DwH8e/TS8eyMsa+P8XcVMW/EQ4fVFRhfSaJEOtKhTt4=", "GGBJVzsyhrFwA/nlsnuKNqeLjzLvvwUQ2fzI+n5zxfA=", "BzNYKdjjdYy7/EzEm2Vex1gIZna005Eto58szcSijRQ=", "AZ0HLW5mqm4DSEPMPXylHEffUfNdu/SpnTQpP8PVliQ=", "K+o0CiI7ZmX1vm3eLrVbQKBaribTSabErwfjRYq5vl0=", "G5D1wOU0Cfi1cwVkOL2eY5X1JW+rsWAGwAm8reHuzac=", "AZMsPz4cRIFCDGA+I/FgKdi5dgNWX2MUGEd22GW6Ln4=", "EuTp8xvjNnd1J6861EOITjU1Uto2KSEHTgI/FFgLXnM=", "JeegmlVpiwxzI0crJAllTvEvKVmnZWwNzzWtmnkm8/E=", "F4ySOPuR/lEvaIXlEuKlm3aGo0rtD94d3s5rHQjUItQ=", "K1aIMuYmJijDHkBTBfiEApSLUV0ohh8N+u8kkh5+NSw=", "FGyg2/sPu5jBYuuEs3Ioz9cxHg0V0uSN74X50ge9F1s=", "AJU3FnPtPuVYkuNz1a1cdgJoyD339Q1E0p02bh16k3M=", "BRxXzDc0OYl0QnKGnNyUwGYL/PbqHBx65RQn+ymMnbQ=", "HIvZbKOQcUorAHnsOOJa8P56afzhYg83b3cOEyWqZd8=", "FxL2foL5BEZVDVHB0uTrsUddbmBDpcRu2jFwg5eFByo=", "HDNjcV3+qVfelhS2zeoXBmw4Wohk2tW0Ov8JyWNXOSU=", "JnK4re90rbC3HAFm3nZqOeXhyuA3Ga7Q/M+3/0Mv6RY=", "EGNXcaN4UMJBfJa39fpIqYc0/6WQONi3E2y10MZG4ao=", "Cxb9W6l/KPVhn2mJzw1mXpCM/oofwk5TJkYZc9Cb8Oc=", "ACffJ+FhgnjtIkl1kBdWktJi1Kr93+NL+NthnDemYGg=", "A2q43h1993MB0Wy1dqE0b9GW0lU0siZn9QYodprhNuw=", "BJqw837FvMcko+oyGpGVH5DMAK/a1bo9UIFwbfXnXmw=", "ES/j9mSEmvn0lMzzzPDUuPHkpgDCljHQWbxuw0NFDEk=", "Iys+HUcVJy1fGKA2wTfwxvpWh4yaoFTMMwZOKl0w9Wc=", "BWyR3OrOQasTGhxZzkoyCFciSgllftgvcUHnYZpdtUU=", "FEzZg8+iWVFjghSOKQ2rFLqbXY5udrhN2uKrCG56eVI=", "HSGq1ca0B+bu59C1Wqks4KMqOekYuzK8jUXCgJSmNK8=", "F29gvlohuY00aeEzm9XHoKjuhKDTQzm+9nXQZObgpGY=", "AynQSGWNDu/tfzqqm8FDsMJmNvEyYhdtZQoaeiBE00s=", "D+8o8RTWQg0aKI+WD9ndQL1KWgLVgIFiFxHd0oh8dXs=", "CIGIE7o+mpMpJU544AqDs2DJBccgJFnPrQq0dlgnaoE=", "AgoSi3ESmU5SxISbuo0SF/E6lXu00LpqDZfPGRS2Wwc=", "CYDbPH0siGbpygkCw7jgoHhYWVHqSsusJFthz1WnA68=", "FPK9bcMX/hkSa1g9oY4tcXXPpwTFJnuEii/5oSuxiMQ=", "ESJv6dgfqmxqNdOhIjDWMkUGHyBFNh51eqDFunxbMVI=", "H8FEqidcrZUO5OMYK7h3g9xFkGsuhG4nAyKOXVMowfs=", "B4WKPhWt/BQUEJDZcs3aNGGQjb/RyRt+m5kXYMHUd0k=", "GShEide1PtJUnF/GYzHHG5sxRG6zZoxl2FrQlHJ9ReA=", "BYdwLBm5c3hX+Zz9Ah+Pxq9xtCjjrpD59dLsjnFA9dg=", "MGArKWziRQ1ysA7ozs6fiWhC/zRwuY4cuiobOth1Oes=", "J3bb7AeaUDRwDNnG4hQE6r98E/oX0GWi1p0ph6cY544=", "KL3QCVSal/0MKenDD3r5VV2GSu4FrRiG+5GNNxrSnpA=", "KXkaLhfcIEr+ZFMG9YStdn8r6UmqbQYfiG8h0EAarRQ=", "IqZntlkIaZoi7cFpcyS9N/+w8Y8AwLpykuyOBUcPvXY=", "IA1IY7LzWoU7fV3NwivP/Y9FtgvQNsL5SQfYc+XZXKI=", "GL3MrKEcihChK+b3zJbUVX3Zzb7NX4QehzA+OjEuniM=", "Em/1AnFLWMOkD/o9lt8N5Oiv81Q5dSNb81EMerItiXw=", "BXD6TRySzykXA2+y1HdyflW1abSliJGgf5bFAMKLvOI=", "CMhAANuPclZV9HQy2zpN3lFNz0m0D8TTAaF85dcij+s=", "ByEtqK+zU3akufk8IPdBnscEsiyJiyDrvzrJ8b9RMDg=", "KMa9hmen5TNuu35TxySZD8ivagWTkDU77hbYyNupceA=", "AXkOeoxZ673OGOp7m+JhuISKj1xps816e2OhsebUySY=", "Cc4QdRwre5C84NYuj8sp/TyKDShuk0EfxmWIpwoUpP4=", "ID7FeUF+vV8FbhNGqMW+NM2mbJkB+7C8J7jXc95/Zl8=", "IpeYEQC/0L28SVVyquXtVnbs8raT4zkTuPz/5l9X9M8=", "AOP/82u1VKAX+U6IEwlXqXXTQ9FcB3KmfOiLsXNts+U=", "IiFPncMcF2Z4SEYmCXHQUa7ukiJrbxPixGeGie4TBLo=", "HuzKrKI6FEYwnKTD2bfQeWLb+LzYs7NyGPQZkoEmMyc=", "G9Us8Ku9MuiI1AKqwKNYMJvIPrdCVu+hftwautGWv2M=", "Js2M4qznkRTi7pb8HKOAHQEjRcaHUACXRXNe38TinXE=", "HdkhAT5lGeKbmqD1LMjAL/86169qGH7w6QY1AIQG3QI=", "EDWOHLisEuVJiKZL7k8elJIfAwppJqANVyNig+oMCsI=", "HKEWixZ6pSmL/5bYI1a3OH69HXBDHDCxwMDfgfwECMM=", "CNGrJpLSkarvLlCYXIaUhQYVeKLfw3mXIiyB7zAfqUI=", "LVl4DdCgCoaVFsagswDtBvb8OeD56tYFB8skwUREiZw=", "GbMPBjVWkK+neWk/f5nEpHD4q4q9aYmZPUiamxcYDLI=", "G5PJNn1Wsge7Gi8XG1YgjGqhJ5viVywaWeZTRdhzdo0=", "L4tF4eB5RIregYvLeFsMi8ru8ATZVhQjR6CEZ+GWGAk=", "I5r2kbfW7fJ2H4je6uxmUWnemTmc74GdzDe0YJtstOA=", "EmC9KZ2emTIVYQkFWbP5Cv7To282xNOXBy3ik9NM+LM="],
      M: [["GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Dh9OTSbp2l+O496vSLSTYQvmHX09sdl1T+yjCHmtxkQ=", "DCmMFDVqWn8ibFpUnlkYSQA4Wq/Y6kHZdGcplk73XzQ=", "GeBwmC0+5nXhYiyiDROyN15Si2dnBoguuPGv4cUEXqE=", "AzPikjmS6J3uVwplASXtp1ogpy5p4QhjoZ0Xt77qkpU=", "GUSqxyv2+83sBDYSOMPE2VENXwdDmhtv9B9lKZC+ATk=", "J9gCrQGaQv0EiSrRZ9noNZanMGBYkEATGWYWdXNjWfM=", "K9BaBAoJh6xrwB9nJC1Ut6LFJ6lwrSgVsnNHHrliPnM="], ["JUuBJvRSQ/FN2CEd9B/lUWs1lS1WxiZ4wUjnPNutNxg=", "IInFl/6qTKmiAu37yCN2MQDilMnjMADlE7KiFkkdR0o=", "Dd6qkGy2Xz6cm+pjRN2o25DCU8D3+Z7O+IeG/v4OXMM=", "ERTJEgRCdQST2ZnU3UXb1PO3WrGDIJI1OWzoPY7pkW8=", "Los1qMKeY53ejf1JtLNH8A7kZ4Y/bvyzVfoVNO9weD8=", "IObMYTrmywpRhCX1PbEpin+IWe4gqtCDINCk+bv+hRI=", "JCDdEoH8DfrBdqdS0VkGtV8Te5zDINXV2qnfPz1D0+Y=", "F71PJyZ0jZmSWvmi8pKeIxwYaUKME7Hjl7sAmRkXI6M="], ["JwcS8YsVGPr+CTZg9JLNvC+3D/qzHYpNihk0vmh5I2k=", "EHz++h6GQEWmaDllJu2fZ1srvycspjXY0+iAEJm7l9A=", "BLlqKWo1rPQVkpuHhLa7pkpjDSnf8otij8mO9wgjC1c=", "HwRlqcEzocaAXXBb5rPqmRKi0GLDTb75LeRpVbg+e9k=", "J6K39VSeXu25AQXA+OIPBXGrevCAHxvdI+qtkfIimhM=", "AxsK+3qy8dJB+IIXj33NrUhZHMZ5BdZR28r86UsU0HM=", "IuAyO7vazl+8dKCz3t6m4eO/EOhN/HH+OVCJrBl690Q=", "Hu821i8/hk6uZ8YzJOR6Y0TjOi1b+4LwW++ZAMVOdFo="], ["K/w5gaJJrqrsSrkAFyfTLU5v51WY7pZPyFzzDVDfWEs=", "AhYw7D8jbtIZ9zzGF7n4smfb7pmmPFKFROoxsnzeSfs=", "KIkKAxmbcn/t5e0AkO1pSUwFPJeTD7tsUjWLDX0QTBY=", "G4Dz9Dk5bC9Ga46bJXZaAUlwRVob6u16b6MI2sdftYI=", "Kku60kWjPl2XAVN/dRQQ5P8pe48dHZCY/pxRjCYaGwo=", "HkMfKxt+2uT4y7XTB79RMcNSwqIVqHDXOWF/SwF8bRY=", "JVY5iJolnr5Z90qP3y785/3h46Zms12ObsYB1NCyJok=", "LQ2KgUz6FsIyPxdL4ty+DClYKfxZvyqJ8TtOrQ6wVqg="], ["FgYKF+GxH4Uc6rIEZFcrPXjVguoFABSEMQFIX2Wrcj0=", "J0EgPWbFI8djnqcTsgNGEZyWHMHpZZpFivdMvuFtcb8=", "IgjFAEgGx6r1gxRZC8vqFhaP5i7ASXr8a90pOMEtmiM=", "HAH220NdxIhe75zf7RkyULnT60zuNmZ0sHvdGU/zSf0=", "Hw42ws+awsQ4jnSWbZ7n0aCzGGkWoIz6MG9rs20h5Ug=", "GZ/CvmDknmeewu3mzzNF3LO5GOWz4Hws2BQTM5NOF48=", "CjjRY7ii+jCSmZwXl7GvkJvZcaJaZWuu+9vfo2KOZ48=", "GYlJ7vKyfCucPWmeP+V9o9W1CcK2cK/OQAq6Gqqe1R8="], ["AOcyF6EGxALkxsFmzZ7x/SoLFqwctDZGvBxyb4MXd3A=", "F7IJKw9jRXa2VMbeIaGo2BK9TAFVn/+DIXEpCC4rKyA=", "LyTWCcsjcg7aVfrinsbxmQLELYv5BPtlYgJzbZey62k=", "LfGD/ivJuLdXc/qWHI1BF+WCqAtlavXFh2PnAk6kGJw=", "Ff6WP1vQ2Sh4wQqJThGAGNuC5jUor6TUcD6Yge2hGNE=", "CvWU3EAw6FCXAfvT2JlfcxJq1yp68P/zRO7oKjHOd/8=", "C46FfZ+x1VTzpOwwetkH3npDZDhgOvGyjU5O43mWDOc=", "B+vNJaEOVmk6KBVfza97NRnZ4OCCQeIXiWlst27gYpc="], ["BLlZygfnGCygjyNRoDVFvXq2dvdAsCMxY36hQ0yFRew=", "Bo6OY0Ed8rOp18Vn9mQZpYDTuhW7/dEibv+j/WvUezw=", "A0TQx3LC8FNmSnuSZrGdSK5dKrPRwaGBUHVKtLg2r9M=", "B+DMoaNe0V+9thm/rsx6mo9MUSk5J1YqzqjquBfGuEs=", "Ii7fPia/dLL1A5gxiSAdTujm1vrTQdf/UHSN1zl0nfY=", "LUMItII7Rl22U9NoGBgSCdI80S+ET3L3VI1J5VBVpgE=", "Lo5n/IX5tNAOnhGXs1vt9Vr9cwCkw3CYfIPBXPc8rjw=", "IvG8TsE4tZYSjOXuW4GElkzCYjGOF60h1FxVJHf1PmE="], ["D8nMlSIvknFc90dgECJeFMw48xQHHlDg87yexnSoqsw=", "L1oqDNDLJIlslIeKgQbVfoLGjc8eIJFnpFrpz4Vw/tI=", "LNGbXFW6sYCeUsyfwaA4wIk12hnPxWPnBI1r0ZcKDI4=", "JP8phngf5ArmHo9coO8XxaXqe928En1DFUfB9qj1zt0=", "Eqh9DFQZ9EhBmEDl5aktJ2rOAJY9mH8qEAiRPZiicRQ=", "CvPO/yyGWpAblAbV2bL8WIM9ZC9Gxkk8oDDvWVBh7Gw=", "J/QthoQvTYqMOv8vR//B4Xnwl6rszlW7oLD9/VsZCqc=", "K2s7w0DUEZ5Xgx5KIYcBPxIWqztjmUXdkqmElDJB8dA="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon7.js
var require_poseidon7 = __commonJS({
  "../node_modules/poseidon-lite/poseidon7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon7 = poseidon72;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__7());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon72(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/8.js
var require__8 = __commonJS({
  "../node_modules/poseidon-lite/constants/8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["IIjOlTRXe/OL57xFfydW1VjWbgwHucwAGlgL1CzaDnc=", "G4bmOQjEsSr0POxoEDVslNIcnjfXPf/5dCpY4Ow1a+E=", "CcoCK6EULRcPdVIS4u3J0KSs4z4Wgl9UDV1Q1aAhoWk=", "J35p1HoTOAQkH2rr6USb5uIshJxtitjJOOr2E7wa7NQ=", "F7V+oDdU4krg70Jaoq2TGqybpUV6GM7FlFRaI122smk=", "EcdAmDOV4PSgJuLHyTkjY3XJB3dV6xo3p31aH9dKusY=", "HNhVKQEN1+L7fqQDUVurVydVakecWbgi78WoHrN7xb0=", "LLk1QALOxLy/qYXeNPQ9cCztg9GXqjdLWh+W+HsS8pI=", "H3r5jgj2h3kj8no9rUDFJaxS9W+72HhQZUT5rNYaoy0=", "KxUXaSXfM6RcnpmnxPJq2UaxB13ljHBkwP+SxDHTHdU=", "IsiYWbTTmdOmCjItazmbiAYTWEk/PLNlP9qUDpiMHKM=", "Gp8nMMgIVNj23ZgQk2PUBVlwOTc69QVapn/BjlsZOP4=", "BAuuLFf8aOPOXilJmOoGDiVj67rFj/j8ShoKQFdfDtM=", "Fr9PViJylGful0nMOAYF0rxNiFy5lpmqLdhWXE+vi34=", "EEXs6gRLocscO/B/9JaDkKPqB1ABshY37H/O9hsRMpo=", "JqMZ/mt9bgjdbOqVh8/j9SNJLs52n3D2bTthl6Ji/Qk=", "KKVim0wggzh+rLCcFXElbRcu8e2cBzhobahCFrqBvW4=", "GGviK2oGPRjMh2DbpjsRnPxtiJfjLWoLGd4oBTL6lyY=", "LEHq+cASjEhsVZWhztaz3RW9m3MhjGr4gTfLiqXFdOc=", "EYZCZdduiHO00s7M0Y2tpGq3ITMh2+BoNyf6LffjzXo=", "E4PnNx1/Prdfl0Yf95VlU4Fm7eb7asaLAstg2DIkZ+Q=", "GgBTRuntxZVz45ifNMME/xNR3pZC85gWNgLhOMWcdGk=", "K1QTRbxP4VidZJJwzu1LLcYpnGml0ktGDjbztOtIYFI=", "IT5047iGkgaLQg/ax6YvPpD4fovZkzELmCiBtOp+tY0=", "AlQ3D99g4xnfXSe5hOIdiXnIbMbJ23e0fp4DfUGuK4Q=", "CDtzd5h77T+9DF7jJ5zMsxmtqmYLtqec7uYn9aY2nss=", "Cismu/K4SlW8TFsJsgnUp3ut5OywmZ4qcAIczNT7zhw=", "KHCQ1AfExSk81yvdiBrOGkeFxRiJrJygU/rvBoUz6wk=", "AKn8whojS8IqRzwEkx3eZkdgAepuMpMSd8pM2rYqhYc=", "HXn8xQZv8qYtbsDAlvPAYj+XIsXRDWQROGuM8GYG0RY=", "HS2mdggbewp9h6V8am8skQIqgikZNK6NZGgU84t8nMM=", "ASEYnXNi26kvO7ooc36iR+hf9LPOq7Tq2sJvennTca0=", "A7oBvcfzG0s2JoMdXoKFKl2lp/Ry9JdWQ2LuY71tYQI=", "IWSHrE7qgeTYNbIgx/Hnt6MxLfXtC25gahab3siaNcs=", "DrXrQkvHLlsgd51hOKcpbcMztNmOTO3mmMHY8wafyAQ=", "FHYIfuaIY/5p1TjekPkL8nGHX6/sOqxoMfoXgRr8RfY=", "JZlezwefT4GSXOgFDmvdC0QOet+wDafk39ilquwAnzI=", "AbWQ6hRd9hUv8Ojsy5fwV+s3jT3IWFqBlaj8awPd2yE=", "Dr/tEnd62XR3NNgvt6tZ68hfB8PQVeuYfdQkcOAWvVI=", "LgO1Gf8HDjG60c7SXQLeGMXAczVYkPJtZDfJmQo+Iyw=", "Ao7Ui++3BTShV8C8gDc0eDD/b3v/7ak6ImYxF8MDgQk=", "IdVIDvIojPN2Jwg/XG/1gGZF14eDOXkhadEJlFqoecw=", "KgF/TKYnF/6dYW/Dt09CaiJmaiaO7RkMklE2ef9TGGY=", "CFzxIwhNa0sLKzTPBs9viT4KnbZklYVg4TEC3KJYoYI=", "Acqx62GuWpxPGx8PTPcQc9Bjz46m7LOjJrw/LyT8MKs=", "CLZZpzfAp+GYxR3gdDjn+u6UNpcVBCNnSV8DBeibuW8=", "ArOt/vlWAHupSeBEpoEVsKnIlagThudpdE57WywwffY=", "GlAqewiD3q+bJKe0Uc9DnZsExAry/swXKwV7T8AMr6Y=", "MEilNqKnWvQaD6WWdSyD7bGcRsAOQHJRaizOM6Qs6Uk=", "AdAIIWgy93c2ufLI6vGNKuaadZWj0uhyXnWz6cZqsiw=", "BnOJ+mcZu55JNCRXbTDWJU8bfVTmnh0YlsGxXuhcDCA=", "F9oEy1BghhWIpN7mDazsQH4I1rGWUDWUUnBWmbzcq/Q=", "HhELJFJs8ZRIoEtx+R+DTZA6CNOnZY4F/wEEzm3hSvA=", "CwootnJp3PskIjHHOE2blsRAZwjxp77CYWDiNSqCDjQ=", "Aia6Ijv1zIMbymBKL1WzJK0dSym4GuM8vXORrQ3KDGE=", "H6UG+ucfYX22oE26IetiJKzKxffP8UWUcJO/zi8/XPw=", "KXJMwpc7WzTE5T+5gfJzWJ5+BGeltLWhbVlvSIRPA5Q=", "IBhYFebVvUPXabHns6QjadtE+tpEU0qeQaGBp82QysQ=", "LLXsq5Si+viZhrVlVFST1dhknXOp9TEzthSvbYk3ZhI=", "BncnBKamw5by8YYnLbglE1xZhvvbzgo/2Hm8J+4hNL8=", "ARK/9HNmeaR3RA50TX/GGR4Wjv5sN/0L7rbmTTBZGFE=", "L6rMJI0vdCt9xQsBO+nEsuqNAL4XKDKtB6wOJo45Glc=", "EV6gU5FckjHWuacbTzQ3520Ir26P5+QqOAATZJjfQKo=", "A1PiwoRcD9/FP1g5Ti26ygYWTRDbr3VhJ2IbWiIYEjU=", "KbNoWQC7rKkQNjrgzexfYcrixSx+3j7AEOKv6sdIcQ4=", "GnO6mFuCQgnQqfMQkgeR+tkieyG/2OijqfHC+on6waQ=", "J0aC1jodap616iLgVYsUX1ubXoRcjJ3OuDvpQzCaMF8=", "JJ3mY9/fZoLdwSLgKqwNeTmPOOYInZLiyJLM+Un8r80=", "B2NGpJTKSZkYIp0vr4e2ta/UmS8NfUAjy7Z36kN21OI=", "BxIVTrQ7Cj6L3ZTimthZOeIg2vaTG4RGR0HmTpkmtQ4=", "Fbt+EnufyTdkJpKpLYZJYOJJ3fMn/GySr97dib78bDI=", "DUONiFw/zlsGqAWEAV6veorgXGAFLBCrgNgAdoANjhE=", "K/+4c8mwR2Ky42LWGVyAE9z3pf2IGJS33Dg8iqNKngw=", "JOpCx29zUNCOixAWZj/ao/hVK5Vk5botpFt2ZScH1sA=", "KmLqIaCt5HQLgIudg4tO8gWxGTtXns7ODaNFI8SB37w=", "DEl3Smj1J0tGjOoPMiEcyajKhkxtMvLGRLGrie30dek=", "CptNPTJWTYPCTU4FLcMHLP/WHL/67JVxUf6tEyRgc8w=", "IhF52EiuPCm6oN6OGa05nPAA3PzlcqwxD8ZL1NIBw6E=", "FwIpQ1JXmkPRnaFd7h/csqcKRd4lIDQ14jQGkvf14KA=", "BZq3iCc2AGhc9t4E+Hyp27zrGu/jf3eWY6fvUBnU2OA=", "I69ksWIr4Hc1rxmZaROYrWoDQCmhCc5DXxLBshtB9Zk=", "EJ7SHiRWrX+UoMbKbtlC716BMkM+X7pu2PSbIDhZRRY=", "JtnM+lN50/1pJ6WJWDONYDeHInHYkfGfZ/cMOeCJMyY=", "JOqeLbNYwb7Pfc19DkaXmmRyB4Fq5akB+wCmzNmR0P4=", "ABWpuMM/zpOuOXHRk6Qwvpjuyh0nc1l0z1Ar+yDHG7w=", "K7s2b3m8O6oTjXmparXNFIJr06hTR+VZVQvzUfKW3Bw=", "Chx2ZB7e0Vfqob9KrclWeR2eeynrFNB2VK8FJoa3Dik=", "Coqfnujs+K0LXNhCF68m/c4soWwHvHR9EDq8tIqyH8I=", "JtaFK1kX9OIpxGgk0AtERCt32OVm/js5Abpt4gEd6tY=", "GWAXNMMMsqRO5KMjs18sFx7Wfg88H87HCW5fAfuuaIU=", "B4lffwKfhMPxfjWbDukm1AJQVYfzhsu3EHC8F8yH0EQ=", "BYB+Ciskc/O4cTBYbHhoIo602VA78lzCsPNak54O9IM=", "Gsm6jrni/eCnmIaqjH29NiqkkKNV4HmCgovj5QmdL94=", "Ixx1lfdv6lgoZyr8W7tkY80A56BzRuJYivVjjjsyG0A=", "Lj0WdzECF85fzFj0A5Uy/5RuLv8rgNF/WBynjwBoZy0=", "CXQWNEFxKXWjO0CT+SLX3xeyvc57frAseDDFmARkAA4=", "HPXBpCgIIqWd7suCpkuqtO24eXfpjuKRObtRZxuZGbI=", "Ea1G4TeSFQz1eTOqlHbskYS/1fI95G8d947X6UzIEok=", "CCj7/AlRweoMDz1a8v5Xlu15Kpw8xAArQeehu45j2uc=", "AscgqEhucSIwUwTs86APmYVFNcT/QE/oLjDpnoUA/PY=", "Cb38lC+6iCTAo41vUl+RdjYNKIGqQlAo8c06f8PvcsI=", "HZVKD5MlDlWBxriX+9cvTyqUPd5R4mLn3MShssqC4rs=", "K4KTUuKXqyEG50+f5wL2ljXt8356sOGn+S8UyYrtVus=", "EtO5F+WPH0ThurqjQdHaySPfrHVILhCK8cMzaHNKkE4=", "KKnmxl0G7W6kd5W96bF3tVCTBfhTJgYq1QFQd6/ku/s=", "K9PDOuMRwvjUrYJQi3bfiQwxH8jSMvvC3FNfpZMiHKg=", "Jy0A16j7FGO7Yk8d13TtyPOgkjv5BZuuPYTaI3Z9aHM=", "E1WnlqvfqpA7gd+uMhAaEwaPUHBEBVLu4KzypNB9A70=", "BzS8vOQYCuFtSmaJublPKwLMfXTKjvFZLNFq/ioDNyg=", "B3jUphTC924oGZ2YmpBS4mJ0ZLYg2R57bT0V29R5nVQ=", "FrvJgKZ7KmVDTQh8UBhZ0SfbN3rhRP9jTLhXT+i/hpw=", "EqPn4ZewUExolDZiRb7WXjJtt8eq8sHA1Z5LrBDWM88=", "HzX4xEMfsNv0LZ0HM0/Wf5kWD6n34g2BH0uP6n3V0z8=", "JdW/GoY6CmRBz1XnyFuPIy/xVW53+8xtcei980m/37w=", "Fea42at+Bjo2OCFq5HEXbofuTOMMwkytGVh6IzMjIKo=", "AZKe9HxzIrd+vQ0aQPnsTUHrJkG/ujWpy6e3CKU0yco=", "GE9R55Htqi3qeREVEke61LDoZNeo9njHcIrGXFHju3k=", "JgWt9VYtUFX/soTfHsDU43Hu4Flc4UIqxTWkEFl82GY=", "BubUH+uDLC/gB+G8zIFEJYW8nq4WEri8PSpJJcI5rVE=", "E3632gaJVc3ijbauXngLeuHA1jPN0RO/D95DRayclU0=", "LpeTDrQZ9zU7onslh5dT/mTX0YcCPOLeS/nnDrpum7Y=", "E69Ak2IIeGbmLWhg/asVkgdAW/nHWp79kyFzah2BJBM=", "D9L5VASp6S9G1XyAUHN1cklmJkVg66+z/y/RklnUfWI=", "C92TrCGu3zGCb8MBL8j/8UOErdUh2YE13zznDkfTgRY=", "CD6meNWlPoqbYBkGvvvvI4EaYTd4i7hz/v1VIffZnwM=", "CKmQa+bpq5PL8blPCQ3y0C32xsz/Y2TC7WmG1h8Wryk=", "GHscgs+viARJM3z6d/YY4+0ZxgTmX7dosDM9jVNeqkc=", "JFAF+BTjglB1EUMRf14n1cFz8MpOoqgbG48+kNf+xPM=", "JapaU+xecfP0f7HPjqjHV/q2mmEnT7Nuracd6vFhTbI=", "AcJEou0ZInU7Oexrd18HytkbFM2bZXi2RJLCzEsMi7k=", "AWZOXIYSFsTLEM86O9Ua+g8+WeriT81+faqoU9RsOC4=", "KvABopbBEeQeMnrSEu0wI02ivq2gRJ6h0uDwoA5CQHQ=", "FgIr3WfSreFfZhooff4jkVQzsnDyjCTmBm5FA5rtgTs=", "Ey18pfk18+iGQmitcj6HgN82kWOEpUuBLHSnSaJoJvY=", "IL2rmCnkjImpnQ6LDWm3mkonOAiAet5OxduV/RhMTzc=", "KNtJQ1CunIGrUtcZ6gX5jcKv6HvBr+VWFh5hdyJYqVE=", "GfyS8dLB3AQ680J7d+p06Aq59gQeDlHRsk2cufP7PtA=", "Fr6nEmuPByq2yGr8qAtgbLkMfl/QK726Hdczw8uIRwU=", "H8V7FopbrcoVpBfrtL9b6yj9CeDf+IlVChJvWDPx/V0=", "GtINGj7lWbYzS+S6kR3slX1WaZzzfde5fSPcvGW9mv0=", "IXNDCmhCBh8Cc5OkQ7biXlmj5bzSCJWt4PzXvrzYiIU=", "EWcxcwQ+FRNzYdsFoLBnFHoj1/MANoDz4VNLGD/ifNg=", "A3yAr17VHBwiGB8+dziAaYRJPrmYrdBVVu/2USkln/I=", "HXC5YSRtImLKzYwJVAQFSLY/vSXzA4KFw29rROm5/18=", "IYREinu4DRdtvj3nPzg6kJY15GEMJYZLLGMlIYa2xEs=", "A73KayL7gM+eezFxkOu7n2x9PJbBv31QE/NlIaXbp9A=", "K2WHMxPVv/pE1RDcs/VQSENvTuqRoQDsDRr5Uutkskc=", "Kn/QLvENscncA8nL6C6FfPBvN+oQ5+P1ObU3eMonRhY=", "HLiAzqGSFThlcTVl7kJVznLaI7PSFC0mX7whlvuLVp8=", "FmKLb4P8NrvB1gApppyEPSdIT1lKfjuo1HzfpUipGlY=", "JvqbhOhV8QaeduA3EE+Ihrdg1JGb7XmOLkuNvgCA8W4=", "Duhsh73w7NUm42psSsn8m/BbkWGFbWWMG57NgNqeloc=", "CKUXmZOoBWQFUny4K29hmYTGPNEV/+06ZzT/qFJnGR8=", "BHqmHkvwchrE4KLykeYhJLzCrTlJ3Pluh19F337rVDc=", "JjpRHwM+H73G0oK1JxKgm/XR/sIeqLv+LrHvW8TyEUg=", "ImUgv3MEhuLYyFm0SbvadjG4ZDKiwQDdc4bJsfmT804=", "K67ycQelKFR4jwxalA9aTfDRjTi4k8uxFXs4an01Y1c=", "GAIsyhfyaBjVTmDjALXJSdnJISL33lZRpgz3DI2l/FI=", "B7qtMB1YRg0ebtEPUqvxvXhcrvhWV3f+2U3WfeZxfSU=", "HkdhBsS845A6WqxuEQ3yzBp/cbQTW+NmL0sBBH4kimo=", "HgGd6lAo0jst8GPCEEZqiMP8Hr3tzLgEXH6dG7bnepg=", "DdVfAGVZu2dHslTSmnP16nF0xrYGfnMKX5qZCBhjCOI=", "CZMIWoAkpZjgyQWdO5GfsuvIG+QIy5b+OKSKlSwCkYk=", "FD88v5jkCXGyEVST7gbibHiTeHv8+xOznxZYaex/ubc=", "BSX/KPokKRuNAzsCE5V1T6Aw1JcxLMF8qv0AhSTtoH0=", "LZ/cGM0lhrn0SRQgF5CTkgJQlRgtX0DVkR9wjrBc2FI=", "IwmXIC/NbwUeG/Hlmp0BGI42IdYT/g545t+0AO+0P0U=", "BEtWRp/7vJ0MDwdeIPOQ0w0RmBp2flB7gK737WnnFx8=", "FQfYi74QshwjqUVV0eTTeapxZy4AJFA5Pq96I3NhULc=", "EE1nUqdhtQAmN37HmEBPcRUbPPap6hvpPGhAWUgk6bY=", "JSdjBc3q5MFlWN5g2nKUFEap/SImqmBNRLv/ErHg7CM=", "EPPO+wVNYwvX3Ex8q9l5QNymg9rYzDWm0MMMvZgSBRw=", "DkBsv6OExrJO0EP/PLHWiRuv8Fha/E/OzHzM7ICd8D0=", "GPNgM/z2TxvaDBJhawC2EYY+/biWbbftNTTP2kCurw0=", "Fl0CKjTPEK0yVXI2NaUaNboqbbB1ctuhBtxWymyTfFI=", "IjyMmu0wWz0YJltW7Lekz8SxDli6oTZYJ6U5xHgZQk8=", "IQP+6UZ0hAsaoYWh+CIe5FEaK1Jo8ayW17KMiYT95tY=", "HBOWQzu56smgKr8jkJc8FyPsXNVSl6OHqSgG947504Q=", "G+/uJABaiNLJrpImFp6JgQaZb9Mv7LcrDLTezxCfG5I=", "GtxJ8fG0Bd9yemTphnXqCsL8dCyAbw1ZUMisQTUPUYQ=", "EKDgyrdtsLagB5nasfLkp073ORc8+qstA+riQMnIR8s=", "Gpr/YtbGb9/tDrkbbE+XTB4EfAsn70mxDSkzrxrz+Zc=", "Jhln9oQJldr3QRA0Um61rHJfleIfw2yO0ZGHOYX5XLQ=", "EzgDD4X80vrgnrAW9CVAhuGvL4j+fb4p0YPIntUoYJg=", "AsU3RdHw5mSZ/xCed3cn51DBE0kUy7TVK98WSceRGto=", "J0AQA1RAbeTZTrhXocXfHA6I2LC4LRDBJ26n2fYqBdA=", "C4qRU9PWQ/Cp99wI8k1whj5PFQ0cMqyJBaYiaIfJvO8=", "Jd1z2B6okYycH/abC4ag7TgB7RqkBZ2U63LPVIsu6h0=", "JT2BPPBfL/HH1mIr25+q/yd7TQMSpYiKnc0SiRrRUm8=", "JSMyLS0qeMxUyUS1d1K92NLI5i469R4CDrLBXtgw9fY=", "KsnC1g1FaEjo39R0mc29TyN387SsmOEOKuPk+DsAcbQ=", "Kk418d+DNEL5zLjHVSOxrIqXFhdPR/sIMNlPm8Q4a88=", "Jw5/axXywOCSYUfL95pzMLZ20XSstltzBSLcywlvn9s=", "GTPvddS4YvInRjTh9aTlDOiZ8VIU8Lj+rrssou9SztI=", "FlEw3fd6gtuEJ4oxhBEJ2kEI02S73GrLsbD6eqUXXcU=", "L8H+Ax3NRTjV2LE0DQ0331UF6WW359xMGYlbn2/O2mw=", "Dh6tK+b2RVnZA+rrbgKnyF1UZCLncw42Ch5LzA9i8W8=", "CpgzYL8yOS1d8wouSyJTWk8WH9o9BbGlBn0njiHI5Uw=", "LifmGChpNgfBfv+bseXtC67veC6HnFIwuG1qedcp9M4=", "DRzqJqCCB+UirOUF6DfKos57EFy9BOfIOMGs0Ab/pT8=", "C5WNq8moBm3p5M74mryC4zlqA1aDdvtEzN5MOMsqGUQ=", "FvW0LYj41PeH//95a8+BdbHNzjByYd7IbPIDSpuIu+g=", "EraK7C2yYuCmHw/UuXawDdvPdUbvJ/R9dDWiiMK2xjo=", "HSI42Nl2jcY50Gylhw41A/P4HvhjMAlEyHt3Yoq22E0=", "DRZOMvyjw8jaOuMyqDHMmpXnXUgzriMq44K9xreQ2Ro=", "Avzd5tbqvX8voZI0+xV2YbdipcR7V3OaYgANf2yo7zs=", "DxM7ix5U9DSEV0ZHgSyjd8gCoVkN9eW4+cjCGQjvvjc=", "AwV+qJMum/fRpLrYJB4U8eYK/RO6TpCvtHLZ3SnEK94=", "I9vLbstIB3QN69yCX3dkVxvJPzNkWCXQ5FyIsAiKnxg=", "AbkHVKIFghfNtkq0XiTC4pQjvDp2+CiVeZJ+zfY+2sk=", "KNuACuFtcDPI4QfhmK6qu/nQJxx02VfGu5UUoPA4+pE=", "Avl6Nu+Tp5BMvb3Dbl7zdOWOrze1uUOUc8vkd8P6sXg=", "G60dljemrW21y9Gbp7lVpFuegInRaXRFoTB0PgPtPK8=", "K5b1IN2oJRqHiyi/ltKBhVucQyILCjJ5F5dT90DtroA=", "BB+X92xgso4P33l0v5IregmZ4ODkDGVDeK4ShDISkJ0=", "E7XPV0dQV6L1+20ICTEjlzrvlybL2YNblWFsKu1ViOA=", "LKQ67VrqFi6Mm+kqFeetCvhNRPPS45i190kfot8S3u4=", "CJ9rHsi1HNHm6mm5ZJUgpvDy+W6hHfJwqwxdmttcPfA=", "BPUQz8flKDcLq7jtfFDDTGBBdyYneToPNxHRMAtNEnU=", "Jg4SxH0KtSVjr/zdXChi9LrVt69O4DfqX4Fk0PE9EFk=", "GmVkJHYOdUaK7dhRWzER4WzA1g+NzkUfe7NbEt7Hcrc=", "AMyFDpWcVnvtIAWLZ2n8J6bHDPcvIiuAh56b37xnEak=", "CIlHkQ6ztD69hohpXGSsAg4Z0LvodafzoLaZvGDxjKw=", "LCXCNrtIA19F/eWxeBBWVazp8/mvsJBx55DcS6vchr4=", "Et/hvChlT1ybplhldpyeR/K94Ned292iFwSQSykF2mg=", "BWRbaPmaVk/wj3ReFBO9g6tbBELwuO+qKphqbPsv2Ps=", "F88+yYMbTW6tZA2RLkG0xy6cJZEmv2MQ+ksRDkOGTHU=", "ErFfKP7+XW+lGaucxnp4xX3XIatEryhucvu9Vommb2E=", "LaRPchBSB3nL2s+qsuHvAe3aju22/m0Df/r45ZhCoAs=", "E3/3Mj/nV/Mq+hZfEViLQDvTk9XJqWHNL32i5dmolMw=", "ExgQX6n+FUnwTvSGecc9Rrke4L8ntEURld6UXIz3iv8=", "FAikJZ31KkkXdZNrLC1HahIXCMMS5jXvjR+EPDujQ40=", "EM8g3Vc0wYiA3sW+RK4t3MT0R/IMrJjJUZPrdXFYXQc=", "J4f+RiO9MmTgyLWkcZdKwf6x43+8OpyKTqdNYBC30I4=", "G5DiEHSQdUXB3sPFnb8qax9wMli8A3B+M9tYLUWrFy4=", "C46RKl7FoL+3eaCAG5CGPt/ZQpp7NjK7UCL9vEBjbPs=", "DZmCN4zZqDcLt6VVw03zGD7msNir8x8fVHo5kwRBiNs=", "Hkl7z9XJXN/WMLCvv203bymkaNHNPs3lb2lAIh0kivQ=", "LWAkAcq7xp3/PdVS4nHuwppaSsvJNWhsz/mhUHZYW3o=", "FwpfRRj1hUQzBnGtKjYfLIA8DTVfPhCleElR8qvvpwc=", "IbOiPDpVPUAcCFAuykl76Th3avZx7f5Ex4SVas+Yhl4=", "Ik3Ul786Qke5xIyaw87lMHSQ6CShQgTtiMKxFm6OR5o=", "JlSWWjvzySQi+1TmdqyEAbqvD2jUJmTjAGJKN1MC4O8=", "HVJfQQX1G2nABoKGcOd4W3Julb4WDuGj4plneCCDnzI=", "KPiNCJ9CHKK/5pcnD8DzT1DsQaHt5TYSxS23RHm0syM=", "CC5iEVPuNDJOn7f/PRI/yVYO+a8PoPlI2yTRyObwepw=", "B/hXgzdSOGex2UA+nKYa2ZwNfVvN5PGdh1LhKk1YBfc=", "LlLzDdBZMa231+hSVYSbBiuhzy641ZIItb2o411pgZo=", "FMs+VrK4xmBboEJhqLEXeRyvJvfCM7sYP4P3LvTI80U=", "L9a05siSYJ/aIUFN2HEt6EXqswW+Yn3002yNMlyb16w=", "AyWJjIQ098oy69c/U987GtsMmUCmnpGR/ZlqSpYVe/g=", "CPUKe1hNwCK4XWoWoNPf9rin7E3PXsBm+Z/EZE1tXUg=", "KcW7uOshT7KFyjCkPP1xQdnOuKGf88lw8rv0ybrp4R8=", "EmTL2ewAEXUhHihWp4kB5AiPHrfq9ZNJmeGZcwfnQyw=", "KKDngZqgJR6c8r2r9k+tvVHclBZTOuM/fLl/0XdohQQ=", "GpvmUcQS/ubIAISEd8u2fkxS/CPlGt6cSPavMH7GIdY=", "G/cKJP5/yJRv3eb1VrPtSwPDMAXL5/NKwRKW5bDHX20=", "L1bIwDh+XkTPSSGr0zsVkMrQcZ6TKjYZXFE44Masg8I=", "EQnbh7doT0knsq/u/wBgivXyEZIOuNY446fJQ7KT/t4=", "GFHCmAQCW2+cacgIkQNVkKUdEwMs1XbTMsqJIivHV4c=", "CQnkzcC8R/LfSJgQa1xA8lxxN+HVrJqYbJ9m/V3637o=", "KuPpDiZQ4obVkT1N0ecdTyM2WXAbMZqiKOFq+fAQ4H4=", "BqbAFflRc0QfekDU8b3gTrYPvE3HL9q33YHsVXI11TA=", "L2q101zP6eo2baJXyFlvpv8w1sRoFqO9PUhMl/jSRGw=", "AfnGAwgYLrbUqD+ScrwiCodF2ckScFCJm/ZCb3q1fN0=", "L1FMQSv9l1TmeY5MPLE9XkxLKWCdPqVhfe01vAHXmdg=", "FMQWK5ye77l5QbHxM7sYIl0oKU0JLLiRevyz4Iq82cw=", "GZIf1iXGbsZ+zYrz1v8OCjy2UOHnKz/JiISwA1QIWzI=", "HIUq78kpZ1PhJoc5rBXSxtId40NsgW91+TuN6/N+tso=", "BL9KabGqTzBK+qHdG/YN4fVZ6BZ+3drB64itnQJ0X7g=", "JAp5HzuLti1dmq6A80HLVp/j/nLnGD2OWDAWXk0SN1M=", "FRspW0JC4MCf73vF70Dx48hVFlQYbWLMZj7k8o/152Q=", "CG6z0wvE2AZkoHSglzncjEl8k89+ZXlUsMv3Z2Fl8j0=", "F6qJkte5AerefqzZWo6JOCopKnEhqw676+DdYmIsIcQ=", "GlszRaTA2HVmNldge1x/+DL0ibI6PEOWIAhXD5brjeg=", "LwO0bZ7u3Nf49M8s9xDkjOPzHRNk8DNFsqeWSwHmNHw=", "D+9YPn6OEC/rqHn3vWAkGHCgKRcjqjVKNSWeCkAFDUU=", "Lge11wylg89Nm6/6zQLX2A+l5SOrvYlQhqNiiLlp+mo=", "JFmdv6HdH0cU1YUkjPI8oTlLhYr46QTAUXuu2/Lxdt8=", "AKgmr9NwvLZbZhiejZhnd+YTdziNhyfkB7UA+1KR+O4=", "KHRZUIcLwYSK28X0vANBXwor8j6QXn0zytA96QcIHjs=", "IZ5tzaWQ/IjUBWc9LLRxD4tXR7Rt2ZFNG+QIFxTKzlg=", "KWaSB3tC6XI5nxe6cf/t7dlRhf9yU9nR9BdHxvJ9vmo=", "LMxfDiBJ1CaEGGLzL4Bigp+12CampIPdUHjehZ+cvOs=", "BPkVpPq8irIIphXdifogfTZ3ALu5vAYdB/qQpw/v/aI=", "LgS3waqFP57l5Pu1zXtuYMzqTtWSijT05Z6p66h5Rwg=", "CHAN9RE4s2wO8r7RK9eDQOxpsEouG4ZRCANjkbS22zo=", "JQMzY5jxZb3qjUkp2x3Qs3EEFv1j16rc7EG7cGLCR4I=", "BWM3haUKnHdXOrENiTNBoMwt8HLtjquaKZakelJ72u0=", "C6QITkTFDhQSpMmC3A2KDUYiUTt8lun8yyw74tOQHhw=", "LW8yy3YUBt+p4D1/+KQ7rhBtxFGcYcOZbMnMzY8wfIY=", "L5Wcgwc35jE5WEY3Ox99ADyOa6466i7bc0kSRPg3Noc=", "FIY69ZeSrbG7QJAWZDSSF0mNmZJQzAqFjbJ67VT7qjg=", "J2I9EBsfkiiZ+cV4Ph/bsedVKCbk1rWNbfjZhpN83II=", "JHMopNnOgWA+N+pyzF0ciVwh8JMFMBvxQRwHmGAqYmg=", "GSGQmqrQPMeKbPvtbBBW49k6JaVJbK+soSr0zjJMYIE=", "CoXANYzziLR9FNQv6vvdQ5LfFU9km3IT4pzxAa7QDYA=", "AbrARzSlkg1l1nqu4EFl3mIb61b5AspIOGD3B3U3US4=", "HdFyCWazIxuwCwjWuLrGx23uVFT3hBNLk9jHCrPu2Zk=", "Iol968brKn82vuHn9C7UsNN61pZTXYLTnM+76S6GwI4=", "KtAbtCuV0ROzuRrYjGmjPB6U3IVRK8UWjucwZbOH4XU=", "LoK9CgU84Dr5qpR99fExeRUppX+DYKLNaX6qF3xgALA=", "LS2urqqTpfnYtlKfAMTG1pHDvE77/I58LwiuPkTh9Ls=", "CrCJFLLeVzl5g7rOCzJ/mMGpweWMdu8ucWzDBXJ6D3I=", "J1h5bNHBeO0MQzxPG2sZ1C/6G8iEw80czKEHyyvJGZg=", "Bj31sDSQFue9pHQeyJjHTkow/E8bWftxOoJJkjEeMPQ=", "I3EwFlVVRnU9QavWnm+5HkNEt8BYOASO0GQc7cX8Zyg=", "Jr38ColJmOaTt+IFnWpSiqhqtX6wMblrU/6LWtt0wHU=", "CIlxGPdcyOkRXaxYG5VTy0B6HeE1tjJUG7c09TmFKGo=", "Au+Osseyb3pXaR7LHhWkCvqbOlVXq+gRRupvbUlgw0Y=", "JU6OX8EbmSNI/Xosn0paC1hryq8SYDZYslkQ9jzwiwE=", "AvQcIbc91Oe1ENyhbntLQncwHaX7vVnbA9OjK4nFe3w=", "JT8Jzp7P0q7q6YuhspgGvChx5fxnv/E+MD25lhjh0KA=", "BDletlVYLQPyV3XmauZ74Kr3xjzv+76pImsEsOeVv8k=", "E3ESNcPSHddJ4+Qb0EijK/oueW4mty4FyZnm5hJuQCw=", "CDx1EXUQo31DtVE5Y/vQ+fM1kN3MKX483Z6kKt16F1s=", "JsybVxjYTmBlgtNdj9valExlJd3NdIjP8h1NDYI9zqk=", "Dol48EeSmxqUYBSZY0qNoCC5pG0LEYfVRQTtijRNVuQ=", "KxFCOvOaXRW+OXQ5tcpQqpptQSNKyr7SAGJHaI9vqAU=", "IaVjgQQMcC3aWjGlqidc5pJoViXlqne7xDA4JXO0ArY=", "Gahp4Vs/m5ZQFv7KLLgqLxTIAJRbpJ23Sq2Ok0avB/Y=", "KwHForqhb5Vp1GcAmEZvBb864Jeqkwdxt28kr6a+UNU=", "BYYUhXO2tWYX+UYC/WyGrUpxs/xno1RI1k6upTJYISQ=", "BANS4ZgJ3ZO8eixUm8GcsAeHLgWZoxJ6PncEQRiU+Yo=", "LWSGuOe5VJ6obPBE6JUP+jaXToQuH++HZWHhNGxaiTo=", "LqnS4bfQfJo4lVZYQOJYQ8nevliQRPMFwbWHLHTlpJ8=", "EuDcQQWs2GkrfOoL122jSq649tAOz4S08GInBBOoCHo=", "DanBBlbm9Cw858mApwydeT2034MHWZozpJHyS2NoKQ8=", "AvNVHGpkg4faYpyWYz1cyZNg2bia7CPBisdq8hsRqFA=", "IC3jOm/Onf6K7qNK8e1cdAkzhsilU9Oj2kbhNHMd3hQ=", "BzctQQVNvACePpH5AtV6IT8ENXXzQn41dopaUkgrG3w=", "AvfjWku+lpmUmoGSYpQ8l+jpOM2ZnNkRqe28cW4kVPo=", "Kie4SnQi4puMxzv1S/U1sBFgbIGbS6poJLYSMDbXP/E=", "GVJ+kJOzE9XSY4yGNJmDn/XY5fmOdLMS+gxjr/cWGj4=", "CFcaa4tzA2MplmYjHjxJ7SMdHjVdk4lMhWK6AzFH8CU=", "LA8yd47f6TLZEpYcgdiOmNT7ZMrqLMLU4/ITpdKhue0=", "JxCmPoT4vzsV2gnmm8JMVn+EpFd2ELGcxYGRsrFFPqA=", "LUuEQPFodF7YTD45P3W9wLD7PxSOTud7Ul68JYqVPdc=", "I0kB/z7GXgpPYpv26W6vN5rqfICMqe55treWiVkXaE8=", "KKUppifPxom6G7M3IHJRjHcgtFCXUznoeGXDa+Um5eY=", "GhryYEc9g0iaakZt3BhV/cboPXO1xcD+1VSvEcbO9es=", "L9WU3BSZfo4BI/OvFskonQiCZMwWqBGejwKrcnCVKSQ=", "DTVk5EcW3owC2Pgniw0vgZZYI0vE21kUf6Ol3CPuyDM=", "KT6axEi62kI3fdiwLVrlaV6Ibg+OQ/AbOCZqraPPqg0=", "IYbpYd8HKLzXtmfTXpXzVM+x7hKIrvt+CyOBKW2uzbg=", "G0ly7gOyeHonIZzeq3rNtdzkS/g2igxD4eO4yKf0nnQ=", "ARBa0mZR1axS6BfDLYajsQ8Fc4/OmWsvqQXOHDJ5Uio=", "Byt3CnDaskKsMNA/XSR3WVz1Ibp8kUeNcuRTWFae8ww=", "HjmaQhlqgGEHnp1h7Jf/jINxlbuTYgaZf1qTAhtw0nU=", "JPUMzDpoqz4sukU+xAqHlqPFlzXdMwO8+ttiGK77fWo=", "FP6S3JIntC3yP4paCnovULwRnwHf5wi5EY91YWcUvTw=", "JHE9hZUXNsd7ZpQcAH0XAoInGVjJj9QtaxJpanBlkW8=", "Bc8q0Fx13jgjj2MljI384NG2mN7ef+6pqXsmPM6BXOs=", "LWJpXHAIoR0Mh0tAOVppX/+q6m5r/Oha4VgNxIIYqiY=", "GeRyJ+dNVWMSZ3D6W6YUBepvNIVlw6ra0IMLPvXXdaA=", "IOQ/9YA3i6/iB0prL9UMdFlFN/mFZfLWXtjBXlyhCEo=", "Jk5IQTCawarpLd2ctNlz4jdAbVDShJxwkb8cG/XBJz4=", "Eji+rO3U9Ts1tXivHDDAd/QoloBlj7Jq4bTAsvcQ5gQ=", "DZBHTCYqrBkT83RZ1PIFXa3pA96bwC+l/HwTfM4F/jU=", "D1qvSCfV9A4AI169HNG59uvzOIOD5pJXO5XK5PZTrYI=", "LN2kNQ81M0dzzYI983CX7pZ8KNYtDEXDTQzuQAiDSJM=", "HAyMLrtoYOZNxGdVp+ByeVvCx4gyphi7ai1dCRG312g=", "Jp+iYGnbHPDLcFvDWEwBULhWQtTyQ9XmjXJAuOjAMnY=", "CbRDsKdnZXW5ptPwA2Cfp8e2ImNBrIOJJYiB2ZT6kcg=", "GRtGl6jilauA+BsldD/hPz+2mY6RMemahvIr0z573bw=", "C0iLaodfI4vDJPBCiK2GXIV36PkGqXGtS7nZF3VkVzA=", "J1kosl5QPJyVwBsYpdMAgbsM0xw2zRcr3h24Mof19eY=", "H94FPdhykdfhTw8ue3RhtJ9g5K/DnP3N5l1w9lw7Am8=", "KbLDhoFunT92EA6PuVQzKf+IrCkZmhgTWNwjGqHdPgs=", "BJh94+MSGBHsPBBCEAXhM/4c6cKqfXxUom9CXNGXZ8U=", "GaI7qXQmv6gbdX41qjVZBQYoZl60lu2HMtQJlC+24Ws=", "EjM+l9Hw4ygLXi+dllYbLATQAdKzk3kahh/cJsG392c=", "I+SKW2RtNTiV0GkooYHXWtJcladnLzofSRfKA7r/Mic=", "G2v/QjMX0sJyGWWXKCPKLpO48rsKUiRc7c2UWH1ZY4I=", "Fq8POHubqUwLptF23zBwH/N4s1JGgKr9pPfE30sIiwc=", "G/rZwakiNO2XxRrH3C2A8ukIwJiyi75xLLdbknl6IQM=", "KbtQZAc+mmqux7/ZTUj+IgfZDqiWJTDziEQspNleYlY=", "HL5FbsP42ISeEP6jZQmsw2R+3D52X03nSJJk9eNAM+U=", "AIejUGLb1zVjb3bO9vqztBJ0l4HwOzmxgUlaYqrkJCQ=", "HxIZFF/wvxXZZF40eHmnNH+aal896pqb+UlRdNIovMM=", "B/k/tBYF08rhtCuS1SeyznzvFK0rkHcCr6E9ds4C+Iw=", "CuPeim7dWJq2J2fpLzwZ778yEVZ50mKaXr0mwcfTQpk=", "FbZojod3JLQc4I+xdpU0e164hEQjxxqY68wYjCOIjcs=", "ExzcJS8Az+SM1ssbFTRLb+yLF2wcpVhNdtb59q0muxM=", "G9Vwz4eLPcFhbKMr9V4LP9iYRE0OcNZJCex4n/Eeju0=", "HlpU5x73ueq/cXwB3Zm3Jiw7Q9HWlgCUuOUI0eEfA8s=", "IciN42CzaiT7ZBAU/s6s7pSFYjPfvMvdHp8PNcnn/M0=", "LvOH3BASrpSJi4r8mqVKO+H5GCC2GrhvReyzriHiOsM=", "KDkU2pfwNjSZNq8RV8U22cKHP8PBVDr9v8HAxVzG1fQ=", "J2rU97ozlx5Nsiksf/cE0VoUJGpufXbqefEYkGbdQsA=", "JMp/1qIBTZghpiS/B5UOj2T15oktSOSnHNT2Pp4sY9g=", "D+jzcNJJaN5N7A+uWRnY9PZmZz7K54vX4i3CJ2Nkr9U=", "Lwu+x/aiVVEt80gSLfS5F3h3Ws5YnUZX3MEiOq+/JYY=", "GAcy7m064qpIZhWPVPTYuYABPMZx1oxppy1ZVWeHA9E=", "BaCwuha3sGMdviyS+RIShJdKcDOmm+MEB77GsVNZBwM=", "KQiloyBKmhRPZWXlYbv+mktmTtrrpBBuGlesdykBk9s=", "GMhgpdJTeoSUShB16ATDLsZstZeZCKjKjNfy2KcCnA8=", "HvgGF7AlvVTeU2HcL7Fs+5DDZON/eh8H3bmrKSr8DpE=", "KrSVIVzN/aSYUQ9tXb/awUKUZOd4iiKf6uVhvj1iwsU=", "JR3Ac78jAQoGvqJVYOG+PMssOOZ9ZOrGgK6mwZlSp+w=", "AiAcNmKlloWlEeJVVkNWffUHcujBULzsCUOorz8QaEc=", "K7kne4AhxdNUMA2gkQHSTHKoQvl2J6ggZeXmeiL0Zfk=", "FPXuRoeOYFWFs97T+oubf9YqIBe20vMO1hM5zKQ140g=", "EUV4ZotZUi/H15SrzSSXuqvYVfP7pQPV9eBIYEe/P8Q=", "ILwGo1/gfNUH0N0KnaaYfyKAFwVQlu5ozTPqs3c6EUY=", "GEgB9lXoL40yuU+wYSuqTsmD0c2UytpnI3ZwBR1frF8=", "FATV/HouiUB3gVj7LTAzZIkhR6ZL/uVLJdOQarWzSQ8=", "JR30M15RZPy7rnO+uMtXuAnXHLWdbjA9sFYLDB7nng8=", "CaRb5J81xPmHtY10nHjGkIJIbT+Hd+ukED6scZD6rVc=", "Lt4ii5uWsh3V4ebqJgqH+QLABR8fIDx4j7kH3wDlEXc=", "EAoxGOMkisQA5qqw5OaxDwfpbeWCwskjqZzRTkXW8gk=", "FYctuh8QR6wfrqwHa1dROtkv9xtqaisy8nrc4ISJThA=", "H2ijXYHAVzOlcwdszXlGpAOdoi5ClZUgc35KaEMoP6k=", "KhZaGisBirL6TlgdfLVn2bFRXbJ+pxCvNoOokZ6ZooI=", "Bk/5S5igWIqpJOlDymJ/y9LvhUxm+ReuUm9xn7QMZ1k=", "HINJ+JjL8tH+bbk2xTvTVktnO3LWc6qjn5aR4IKD1e8=", "LkYoqGVdL8hKMvEOCpXpLQV2c5wHBQvLAVjxVttufFo=", "AGgxbecf7YAhM4CodXs6nVF+fqHkgAoixRB1WkoewVI=", "Ip4yzflS/UndrIusyp7AqFufXx6LTrvZlexbgomlQok=", "JsmvaatKfggzXN/fM84QKhTPr7Ba0ACvpzg/Abm1uJI=", "FLxRQFZpFVGPINUUmMpg9uXkhnj5fBu1jhevTbjyMtQ=", "Iv4Gu6zMWxi0qL8syMR+NRKRus7lxSJvvQzbMIc0M5w=", "HcoUA3c1gRRLCDqpuXaNtagZAmJt4NgdgPU9ddJHrwQ=", "BBUujKMp6JKkUDYT80cu6Ut+MCWlktRiX0IMRcVqH1I=", "E85+3J8cfS7VMwJhUPK7bSYfN58fu0io1VbMWteRTjY=", "JPT6NqSL4B0LvleFTUg5nYHsA8OU+y7sVEpjH04csd4=", "JuBlmvjIOKrMNScQ8UM9nfnM78R71cSHoLPCmgHlWew=", "Ii+A8zJ/9zDIylhcBntc6UZyRwdgG3pKckdsT3PngY0=", "Gc06ZiFuhZ5DP2Tk+fPirZxY2ZPuFozq5evtMEmrL4c=", "DQGqgj7oRsLLaVVDyEmYAxAfwO8iLjwrRNhoDop2GI4=", "LheQGRjLb0+tmsDTh3V6p3xyB5JOF30IJuvMRcdkiLM=", "LjDMSWOQaeIQHLR5xygehxXOXzTRfAFkMKn6db9IStQ=", "GGlNGP5nWLNsOKxw0TRMbStwJJ25KnThQEaDsvAN7lw=", "JZfvwRMp7j4Mi9QLSnhoFzi0xSr05V+1vlKZlrVr/7w=", "AD6tjLoNJHFa6p/1RD0l7mQIkxhub/bARd/JHtu9HJQ=", "HhfkWD1o8OHnI01BkV8vo8e3wEzCr6q9fzu+Bxzxyiw=", "LQUJjvKCjXHodYg39clz7Je3VHvfoUM6VScWjun51cA=", "CSIMpX4t31obLylxYn0adLfBuDet5ko36OHw1DYFGn4=", "Iu5cbTapgLekKPivyZnrCYaK3FK0/M/baLP1+6UY4D8=", "G3AVS252z5vPRBEgPbHBnHe8DKi++QeuiktKrCcIQsE=", "GirZqDSk1BvA1brDt+lFMQD1jIYF/REu9reiW6p9+4g=", "B1qgb0Oic0M8+O4ZboV35foohEWVsfKzb2Rz/9o4OA0=", "Bw+ITV0Ak/91+wnOk0yHMwCPmU76T1VlIPEe6Lzt+Co=", "B9WpMBIJ3g+lbZ3uRfhICxLTOnO+AvB497nfb5Il3fk=", "AQDdSigzsSf9gA0orwQlSgGIUyGM5WWo9hWZWg8kZuo=", "Fkx54pBiAuc7z7gQXFwQgpOXvLAInOA7r8Xw5ifg2DY=", "Kd7Jv6KhLy+hvJFY3B09HrrR2En61Y00Fj10GSP4/aw=", "J9WQyV093c3UPjxA91ed3mRfM8ewzgPVXgeXgJYlf4g=", "DDLnG+AvqDAtiry4qyxqPcTpYudZVUAcHmpmFX37llw=", "DOzVkepPPP4MfT7fUvT5PWCjEmQzv5ueR3ENKYwx6dM=", "BwYnoEIf3oRCFvXyR4mz9U1E8aBhhKqB91qiJzNfJk4=", "EW9SMqvKusioufGjrIa/qX/ihYEews/XM/Egb0SdHeY=", "Ko7K7PE1WFDQP6Lxp5BM86K6fTuuMKrXo1z7Sm19vsE=", "JS7oot+6qyZcBgYAs/bhnyTkkd3TcZUhH5WRjT05uRE=", "I+1ec6QiPfha/pSP3vK24NPBIKox4vG0yJBU1SGCWOg=", "Dd71ENLHujLkMx3bqTqmiLufuGFzYlA3uGukxioGAP4=", "IznNXLdprPLa+1BzvZiL4Vplv4rQbDioLTjTF/D+vo0=", "JvtKEByXwGrMmZFQSD1EqnYrWFxCK/jcs3r7/fB2q0k=", "B31YdNuiHSYMsC8oDF/fePuO2eCsramYq1y4M7CdGFg=", "It2yvryM0clG+FItcyZwIyhRExO0C0qegStprrYRMiA=", "LnxDxiIuYyP2gsBcVx9qpio9pkviw/OBaY4sDdrck7U=", "Ge4OYPwtp6KVNxxmfOhQdyrNu/oKnqt6fJSlDJxoLeU=", "BNRtMsExynkljvLFJWWbgTjA4ZnOWWjleoLngPH6ebk=", "Ld0lvTfeojOGoDD0vMHUOCY1ptx+o884iaXo+spGvYI=", "C+Pp1HK4EYzj0BqS/BaN54VJNHtEUmiTMS/V7D0nJq0=", "J/qPI122FqWQmi8xiW3I3pWUeYcHtHfzQ7SP9Sjkm44=", "FyJkEqsvq2Ij7toLhIMzgWpN1kleKcpHzouW+Mh66iE=", "AIoqymCeY0QIbu2KcQo1Rpvc5oZGpDWmkYJ3oh0D1Kg=", "J6EGGe7DtSEbfOnDGN9+367Pe8hAmNwcWCMqwlCT41o=", "Bt7y32OOq5iZhlOTVj7IvIGJf+DxrcXASZdV8lSX/EY=", "DIa9WwBGe5hWO3rRs2KgWFOKf6oRCkOLnQ7HvoxQwJg=", "AiN8OHDKUcDJ2vCGUkcHp4vohF30ceTU+z8ufzDZAhQ=", "Ku9MFKUUo2zhr6nyxfHt6NAFMOAeKnBNcElM/Twpgs8=", "D0JfgYYa2oVvAfzw1e8Qis6igXNakT0k7qdbVYM7Mo8=", "HlYvKjqDvhMh7q9WT7GfV67Jxm5syP2hiZnVuqC0Yw8=", "BifY9MGoyPjF4ethdZiVSqgUp1Z4LizYW3no4edIxwU=", "FeWtNvcZzKg6QfZ3gjiMyjgMJZkuXNFMZw/Twxew6ls=", "DMjRONCFT5tiaXt3kdqWC+UA41Kc3v1PCxjRbF51fOI=", "F/9VW1LSi+GzxGyAlG31GeneJH0s+NgXUIb5ddJMHos=", "D9XdV8LO3odmcZeNL9KJqgoCaTJSt09/3ui9QE5seeY=", "IDFEp3xy6on8r/ObFB3vfpOh2h+54it9DGczvXLwb2k=", "GXkyBSTfpFqo7zXuu89vYh4chVtXBNi/dVvtfar3IdQ=", "CJtmg7H4Sdu6sPEJLKBIgPi4lNf4u8uVyt5Oc26iiZg=", "LC3Y5mEKBJV4SqCLuWYfviXJCDlrXD8r1REJUX+igWI=", "K5YntXnsQBkwaIbh/0ADrrOjMkm+XMa1bcNgexfkJHc=", "F49wqZUBpuBb9Mp5stbaRwSfjJiJNmllGTRN3ZMRdPU=", "Ik/6D50NV+sMfXGOmc87a6AbUjVI6gyiOj8VbAQIOr4=", "APLuHivh7OLNiu8dv8gmmX0wTYjN7lVe9np5l1nDntQ=", "JXV3QKsUypN0WnYADiQyjrGj0h08vtGTDdG6LL994jY=", "D6a5Y7xlvZMFELPKbhrmLBtGde33nueafygOrmSW8W8=", "DMt5Td+HC7kqnLpfhZ+zzD9OsfERfRTByu83vs7Q4y0=", "Ej/G0wbxf81aQwnU/m4MwcoA/CPqlEenxraMf2ulAAU=", "IhYhcKH4ResKoe57rqSGISoJgUqVV7y5/HLPkPCimWE=", "E+OFpc0vval43HdA6SfOjUIsnuhhxDA2JXJCSE5Jfjo=", "E769gMICJyQBfY4+uEwmmBDOz0f59X4je7S+aUEKeAM=", "E+0pFQJWanAztMRgckUVahWKb8hPS6bwJGwd4FfY/xw=", "L/oGkoU2r5HHrDt3FPIE4mxUEUJ0IXkhcJWm5U90Mkc=", "Km32VekmxKoCl0mqp8mkChD9VaNoYkwUi15SjUMTGD4=", "J9hTHsYSGj7KdNtSQyP8EA21AqWAuKTPhlHxv2ubAjg=", "HqEEpE2C++G8HM/UYmzqDAZpNCKzhGs6K0qhKjsOdH0=", "HWmjhScgqIdYA02VTepgLlmJEUpGZyUbDaWRVBKsX/Q=", "G44jJxD2wc7v+cEIbUnNjS5kf2km2pE8teEDN9fz1+U=", "LUDT+Ob546pgFMaWMNv98xafiAZ1dP/JIQ99pZnE+z0=", "JOHC9gsc02EBdwzvxDNKjALwDMaW32T3bfVKb7bwUIs=", "JAjy62selYzK2/+ByaRJE6wMnLXLy0tAVAF6uz24wE0=", "DjxuzSgbouFqo32s0qvDjrB8E1Pa2W6H0U5eoz/47N4=", "JIx8+3ui5xgZv8dV656aMGzQ9uMhLiVAkPAAbZ7FQ+g=", "Jn/c3uz2nXmeefaGMiF99RIm2M45V01ytK5POdIXIe0=", "K9kXPvJ2t9SRHr943RU0LrJhYDwsmvz0rYMd6fo0urk=", "HMCvM9B+ULKt2jNGcjAGJQ+rrY+j3bNlwdhYL03GXxQ=", "Ih8rxLfc6RlfnKnOj96u/LBUQMIN2XVLxZwRRHyuzrw=", "GOvVxjsL8g9F0jj9DKtd7I2/GZa80bNInzwkmez5Kwc=", "LzOLxaWG8ndK8765Kqks6OWKXvoZ3ciRvkel536fWks=", "BVa5w3hBRetPL/bgyI9BmJ2lkH+McRiuSSk5v+Tp+x4=", "HsEANn9laEU4vGlWgF7TcFEjijY35HAioylMveOLIoQ=", "FkWindRSerkaS3mMcJboMgc8i6rG5duH4mwhW/RI+E8=", "IqeKv31bNip0PtUu8nN7u93Tdemzv7QkCala0QWsk1A=", "Gpkh3q0mxVqvs6yfPzWsthpJ1fGB6ANlQIMLsYaG6zc=", "DrhkWw0rjww5J9RkNXTAsaWIJyRl0xnhX8xsMmIZGqk=", "DkivDLJ1r1XeuCWjTKSJBKR8MbVZLEr6kHfWDl5+plU=", "F9+6xaJvBv/5Z8/vWXptoRtbyJTua2LmJqYuhaPqS2Y=", "Df+9AW/9K3lSJqg+29s8Wm94kX1/vbvBs2MQJ8hmqqE=", "L5SNX3CFa18jpDONJE9rp+fr/HUOFuvR4sLROCUJQxA=", "GUyfdhXL4+qg+IXFnkILuJ3KYP4XTqMh2AQ1MBURcTw=", "FugaBUAUPLvmYseucmBR7GY9YhVi+zcBJAy/u0sXs88=", "Ee8MLYgTH3FeR+mklT94n+x43s2+7TS8jqpCkn6m7uI=", "CHbkWk+GKQG/xiClWVGAKh0dXD4UFDCNt9VIQA9mhTU=", "LnjTXh3YZ3ak3a7hGSwFWqhnY2O/zzFlMX3MmAF+bHU=", "Gfblibo4TbPDatrkvANPuaRE2kIWS27yiQCaLNfRWm4=", "Cf7ZCx8Q+E9nOb2xtLUIlXrM6trOaHqnNdyfarFEBP4=", "BV41u+985e56NgMiLgkAXdUZKtzXDcM3IXFBNyIfSDE=", "BejcNZ7pjTu2mQ/ZKOzwVvm7c24NR87CKpbnysZamCg=", "DHMil/iwwnL6x2lE7paZMHUqe9OUPHuX4Di80jFdKQ8=", "FnA/uLAslK3jFdW2KqG/eDTeJIMQiH3BPP0T+2wqELo=", "KHFaxSZdeoEq9OOeQ7+ayABZY10B/W/kDz8eBZ1/f04=", "L2g7ACeZTglece7IR1cw/iJ7SApqymerFZPOb4N7yvg=", "CFTZw75yGHovGYWQ3s1DlDxaphQKhY8hWVuaCNqFsyM=", "Hj1ZK3Gkc8hbIQSswdjbjLkQGjzOVcZoAaDTeUl96t0=", "HrJzd8+jijlnpx5pdyXBlbwdfOBH6D0OBp3ui5Wppwo=", "AEW5/R4PEVgBIyx6qvtec7wtZXxHsSL04+owplm92b4=", "Anrv49ETDpOUthqATf4iMdaClZEN05JF8eHeZah9umo=", "LkxfoaQgZOVW/FDdf8p7SGJeTBaUFUh9TfBIKpsd9Os=", "BXZ8so8QGaOWJ6GRlqfkZy6CRBvguQUjx7m5903TMV0=", "F+RD4yqzUtIJ0+A40TZLJOs/lF6ZpoCVAsVDnIB/tN0=", "AXoMDYPOrY/7cJeO3sG/PErO9KLNz9jDNbzkJ5NRPkM=", "KLdJsqm+yzRmXjjzxJt2fyBzikgaenahm/EDAAiiUrM=", "H1JS62KZIscPL8G17F6goOCs7kfaJsQENsPx/8ppA1Y=", "KTJMQO57yF0zoFbD+o9E1qdyTaU8zts+VswmtzNYqg4=", "AFZ+m9iiuUfXWzdqmhrxe/i+xsmr7eWCBU+z7PeGDN4=", "Hpa6tu1vRVUPJiHAra10fC/JmISF9hhDVcMXbVwR6NY=", "CNR9wjsf9SeZLJ7dyRJZp0j2zXwfYYdKCDb1memVo5k=", "InM83TGBUPQNidGsFC8mdQgJoLiIyFdDr2cQUM9nNqI=", "IWgXS7nEW+Luh0QRdKJP1B3mv/Sjd4AwJYZMXKGSc0c=", "C0j9q6iFJO+NBJW6Y+hxO2WvSpJntdYgg+e4cmBDoeA=", "GGWGQ/y2NkRSDA+gLc4jKTWkzo17czqbF6hm5Qs+yKk=", "L8lM2lI4/HhYcbypeWCyme0N8F9sayijg0hl/Ul0vCE=", "GlSpGondfgzodTAwPBLvdiRPz0LDjbNVE9ZcbVmUq28=", "FWENjWS6ApUvQXDq9Conz7LRPwTUZzU3tyUQxcTD2iI=", "E1l7Rwdlf0N+5CCHz4tYkEKyd0Z9igQ2z2bqRKZmEhI=", "LbuV5RFOdAAovF7fWLLp/H44cdPxatDDhF1elhqHg38=", "LLOj584WytlZbquS13L2uK+0PLZJKyw2PsceEfhsUvk=", "KG6LlGi9LTktrV2Q72XSjewn3nFHzlC47f/spdcAIKQ=", "Fm52KnO1GQAddTc319kI7yJiN7B3y3btn2u/zOmYkxc=", "HcW+5kd9fnh5+i8zuprc6Hilf604RefJ6vS+VKuET2E=", "Hxb38c1h2VY+BkyGtQiv7EHWFKvHs0u0UXS0DTh3FVw=", "KN8Ezdf3nLBvvwROYxqxH635aR5OpfYgn4dRr1jI6xU=", "GKpkkAR6tSEF3B5g9Eh2JGG3B104p8CyupVkZSZYj7Y=", "AHargUOikHkhR8amRlyag73fT2U4jK6DV7xr2UAKuZs=", "JhYhepT0BwU87zsjTMEay70uNEtAO72KJvghvLbx+N4=", "IpaGLLmhRCSjTToRCA1u1b/hvE4DAewcvU4mDYFnVoQ=", "CChCgCKimZA0BjFMFZcyvA/aIno+ekCkg05RPz75fFM=", "B3H/nzl0ad2m8gzxhB5wLBeAoHGbP1kBdbOU84J5x3s=", "DcSJ3PYauhEEkl65Q5pPRCKNBt1FZ/zhREllp0lWeXU=", "EERw+Skj07na+jnqvffqojtv8Rsuu2SmO9uRLUOGX6E=", "FKSQzgnJKVBa0iPi85cYYTWqZYayfMnM1PeO++yZOm0=", "IGiTu3R8olBEYfskovcurkzzMINYJfuKyVY/7Zp4U+o=", "A8KnOOdT81sGjGrIFxJEwj+9TzfIC6UIYYyACs9iZUY=", "Ep7begEwKb6A78dAAhLNevEwgQDTSlae82RrUs+wbhY=", "CHSw7f7gXYzdrInntWL5F8fs4ewuJi8ib00VJKHdwVg=", "EKC6snhs2jBTfGlrsf+viYB4hBiW975BzfMK0lF7Kq4=", "C6tmHCoX++AiH0NbqQUgvO2Sg2TKyYThemxypH4T/Cs=", "IEIBbmhsmEBXooqirhPJga2N0CrH1GYwBeE4DFT4Q7I=", "H8KVrHGRGlmoHQh/ln8Wo6iHc5187mY//11uBxDPSkI=", "BZIml7BK5gjMO7DZ00XK3q9PopHeiI6bHdMsGcsah3c=", "JxuH2LiVxuHYZLnNAwcp5SO8kLRpzuN7URRLs7Dkuds=", "JKpAE0PkcF8ikA/uiSzKJp0MD/q49VwhxnTtude7pVI=", "GwcGjK/he1W14A9wN8msN+8CaNXSt21yccYXAE8Fki0=", "HjW60xmgNsxqIJTyob8tGYSit0qvPlsTpu4wyQCXyzM=", "KrkbmoXOaee+po9PtbH6CQOUXgOcTdvgXv8tXnVPwhk=", "Iel5+jollNI2XscLWz4N3F7bjij6fsMHqrFLVHhY9mY=", "GHz/12xfspeVUj6+BlycIRXnN4SsaxXFlv3WhGnRrQ4=", "GNL/iCxSs5aowGj4jD0j+dEdn5HA9/3p72ryGAoAc5I=", "CoeKd95hXoPD1DDxHzJreFwawRTlmcJOWtwdn7kbMfM=", "KGucY4FwAoi8x10CDqCcRZV6YVV212IKC5ryYJ05r8w=", "HE5e19uW21IFmuLacJh51ImhrFAxw17htsQi2QgMPxI=", "JxQWebuSYKaTuIB4T/X7xdWUV7lmMOClwEkSCSpNKr0=", "FeM3xl+ljttqdP2+fN0ZAbXQGc591BRKi0nroCvwhf4=", "CCVnkiGMgifsqJ9RFPHn8JHYilV8abKpVv0tyQyuNjE=", "DAjRmvnDCjGs05KP+1pX3l6DNnIE7mcgnuftG8pRhdo=", "GRmDmtkWBMNw8jfSoKqY76wpJG+Twkob0PnStgcJtvo=", "Fb9lsCuS9AufDqiT3bsFcvSTday1lYv5RMd/9sNWGkE=", "Ei4C8uAWmAmyLe8AGsx5eyAtM1r3vSzwMuOnx17wM7U=", "EgdRAN3bgJhlTnGGBSEff2oh9RdtOAFB+zmXcwUYJGk=", "La27uP7PXM3wH3PQzGCxXxu+8BimP1D2jQC3LYrfCHg=", "FDNOzgWmMas3Xnz+e4n6DYCS7AzuJMn6MAntzWLqi3E=", "CaUYVtSexlT31ErKV7F0NlulR52HFKCfD23gizTjlCw=", "BI6P7qm4KFKNvGPNPYEe0Fzp3gGPSkZHrB9oW7j2cVs=", "IEum8YGT90f/EJgJVwIuyqj6TBPn+k6Jcwp2JTybB/Y=", "AHnhvhYi7cV0Lk+BHqLAN5v/T6gref3l0Mmg0XTfEw4=", "J+SOq7DvOyIwWrcg7kx/QU6NTb9DYMgdH/rk12g/Y3o=", "FVcb7Mf1RU5FrkFqazV2J0dnIV9lnJG6NUNy2ZmIHVo=", "LmpFRev3wuRK+RynGS7sSu3dvSrB309RAff4zdMWZV4=", "LeGfzHiAACexkyzfb56VkghgbL+KB1JEV0koZ/j2vKU=", "Lhyo79GHbiCfwtYssURG6PPEvdU9Y4LKhrET8yCdVfI=", "FUs/herti2VxjnM8osp8ivA8+PI778TXxhd6wA6602g=", "KeWPOVVdnd57rD3xjY6usqWlBQOGDSDFzQuios9jc70=", "Ay0yAy5SEDrXmPs273wGgVBM0thqEsfZN/9Rjle0w/A=", "KB3gGR0wr3MQXjncF0AV1l3H/xLSCIjQLOxlDhokWjo=", "D352r4AOurFCgWRdKQYH6rsGK/Cv4UGRM+H/3PcMgI8=", "J+pAW9/GVXpN0ziivKmBlUdQH293pYinXAFNRig/dbM=", "BXCvVD7+/f3atj+wXTHtytOVrII4FJGoDIJcYhx6wis=", "Anp5fgAUMCR4pBPO3npFzYlLCiKcjon1brrsTEZpK/4=", "HdDig6jvfQ9JZqUXaH/FMkNVSo08fkHZFxmza6zoFRY=", "IAZERpWYdWCGnfbc3iZz5bc+5bzLtDoFwti+bFmXkkI=", "JxkmOS5fHJRDev4sKWm+pP8/bYPucTlACIMdJLsbbLY=", "G2B+0vEwWA2ajCDqJrM7R41uHwDMgvABdpNai1TKv44=", "C3puM4CNIXqeVcI4cc/f5JXBDWK4uYF4SwSH5j3wPgo=", "KKx5DUYrs0WrgM0WcEA5Q1mbee3vF89wI27LHvhyy8k=", "L410WxtHUP0vky95EwlVFcSYvjFCEBgMbDB3IxImu5Q=", "Kj7yDmAULxfS87gu72E1B5UjlW2LxoQJLuy3p9Vtcb4=", "CBGbFLg5IuSyJGl8LGU2z3ctBnSJ1CZyuYjLY4xxoPA=", "GkuubJz3PqInOaJ1vHIsjMg9kefd/VEQYUpS2EznMgU=", "HWWa6+Sze4iL46fX8j42LCUARsCdUyYxLY2UzbOE0b4=", "KOL7kr9tpOa5ZzBHnxcHYFZEWNlfcyquJAavTAOWn48=", "EPTsOtbz7TOHcpmQRWyWhXhu3o5uFLfGYxHUe4d4qmg=", "KtNm2QQZEHhmUE1NNDRuCjxZXebgqlHIBScq4bzdwtg=", "AvHcKaBsZMnkPTN52w8ujwzY+ANRck0xPKAq0kxtrIE=", "IAhqZyw5fmXLN8+2TdqwgHTxc/N9DkoXR7fwIGUtpk4=", "DvKGH07Jul/sdLoiwLevnUWMPNj5DIJcHzYRDKLukHY="],
      M: [["AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "H406nS0xqzLZvbY3UXDbuon2+PdNFuT9AvNnXV/iuq0=", "IwxpQTlBb0BCLXE+E8BWxFw8Yxs0aFRSOXDq6lijffQ=", "IGOkYa0GMVrlmSpToUu1mDZ2JK/CgzzLuDr5LKD2ozQ=", "DFdOYo+EtrqdF7nSv9R0fgbdaM2iOD1kzjZZJwmMBG8=", "J2Qo2IBAo+D0QkJNL/y40Zvs8/tsoCwbXGG13cU865A=", "JL32EBsvIjF06GnWrsvo6lsEoUw4/fFJQ5PMb9s+QqU=", "GA/KGEFQwONUtLOkoHWCTUto6CdJQ/Tdiwxk7KJdxo4=", "EHJtz/hymchTIVmXZgdjPxvCrSRFPBurJrcmuC11brs="], ["BgfNj/m4iXc8nraLikNmRp1HDNfGAEEGyq6VwQxCRBk=", "JZFYC3PntdXzTZ/cDPf+Pef2oYolXkN2/ePrMd+lHXk=", "CTz/EhUK7LNGXEyZ8ES+hdzB66IdQpEywiYN09EupEE=", "BZEW2oiggSZ92IggT8b7eQRsMpfMtl+eD+DVC020TsY=", "LJSElzc1FOfZhG3qnd9XVTN922YQQ9bGKM7Lj1UXO9g=", "LCcpgSvp7UMudXCRMxGcsKFOG26jHBJ5t8Pkld6vEI4=", "IoDW1HGPnwa1UamIQI8FFQcORV7WM3fpEL4If7eb0ZE=", "Gxu6ElUFrpZ1vOx8mvV5xcyDUzydVVvjmK+gnL+V1qc=", "FwEyV3FtPLrijhwnLLaqooRBNgSf+8oFyiAVIwMsZNQ="], ["HaUkz/YLZIVtwfXd4P9i2nsYLaJpCPa6blkK3r+RtAw=", "K7RWWJO2/8V5kTnNwVEVh0nCxl20hnKrryTFs4E8Dis=", "JQgaAPwgrjZrH+fqawnmKlH2/Td/YINowSuk47+Jk18=", "G0NxnNELYMVkfAl9H6hLjzwSycR1reE7OIx+xHJAvhE=", "It0gHsurlKLuOTeW/vzKY6pU2aGaucfyCgvtz7nRkfI=", "C455g4zTBweZnGIWIed+acD0M9VDt5xmjPN5tmI7rIQ=", "AggtVkdljq5kiTbO++360s0FOFcqphIspozM7Wj0MvQ=", "J3uuL8WXpTatvpwkvI7oFzHt21dMalFCwcWkjFH4LoE=", "MDVMnynJIMBemdfMdHUQ529/pppxWUopDq5yk8WkhEE="], ["IvM+ruPEgeZYAbdhpygykI8Gb+Idq1+l7B1Mbpndbfw=", "HFznd3aJPUgUdES59tZqTaKclXB96DJ1bHOeq46HZY8=", "Krjt0i++KhzTzppCEtDvsoLMrCivTYdvyUYgMHDJIL0=", "JuSRVKzKJEJNX40p9lD5gk3oLreIcynLyDpWrgHe5KI=", "C63Xf1FtT6Mh0QmbweUZCQAVka2ZGfCM6XGK7rK8pNY=", "I2ccXR+1VgY6ZLX2ZDQJNtxf/t1L26ouliBXBNpYZPU=", "Ag1yAszeJJAdbOLRB+eeH9eNbJOYunpJlvEWre8U3vM=", "HYZJaZXxQmTnoFTMgiSQA2h3XD5axrX1QoX0pzwhca4=", "E2lhdG00/RlgJRc8TXm/iz0dBSkcWEko2XJY/V+0+04="], ["B1+E6ccZu43o5hCDKQ2v8ZqqQzdFTluoBCV3h0cPL1Q=", "F1UFORxhm3VTD6g+UTGEOB5gPYRJ0eBwAX7o7ApNJfk=", "KcXOl3EMFXigmQ2GLPiBut8Q5Pa95ikZnoA80cQmvk4=", "LK+Gz/YFIczF7G4uLIO0cHu5D5SGRL+qj4Cwr81M3hA=", "JPknk9Z2OLSr/fSM47YqtdDhslDcJ010by99BUQYW2I=", "AoCd/iTH/XzUm5eycVD004o0C2Dwcz/UUwzUJptIEeQ=", "JnCWiBUO0DX5WWh+33dH7o7pRrdwFz2+UDkKuMCMX5w=", "HlrkwpWtWhfgD5c/E28SMKb7hWN2MbMG03BfgO/6wko=", "IxDiM35NU8FjXaGKJyIXjVWvWDWRvMMX66hC3yR96qk="], ["IIS+mlfprbgDA6jcr/1Lt3rbaBUWizah02OzhCVDcTU=", "Bu0dFN7fdjowZfJ+ekbX+/INK06GoNuGaSoml2fVd+M=", "EyRUSlQXTPezzY/8S4YyDyMZ2biMF3m4mxkWAY8/ubc=", "LpI+pG1JIkfhLgp9zPZiD17qZim3Uys68kaAk5iFljM=", "AAu7u4fszJHV+we2xVCIylFNaN3ZPPMcjtLSzH8jsis=", "JgEKP1KVu0SBMQy8pThKR68PmQXkx2v1S4cO8P/vocg=", "B1GkpK8kYlXOQSxLtH+jSlG4Yo882QIHd3XI+kiOdRk=", "KNI1FhnMxvsxrUIG4sBkv02bIpKyhGPlPkdx8QZw3b8=", "GBXk97QKcCeHhkCmzcSyhUMAz2/UlTwqwsd2Je9ErgQ="], ["CzA0SfG/S5LSy8Jqs0tCFbbdevAQdHpwWypuM5iIKSI=", "FAzdozu3p5srqoUd9a1Fnn31abnyw9pULTuNW3azVs4=", "HRiyWqyYsoLhC1o6dM5cqhaaXDC65Su6KA7VF/P4L+8=", "HsbDL1E7jzDHqrQufZGuy+VK6xiKhPjKRr1+l0G5o4k=", "CJvushw0bLm8GCqitw+FPxoiWNVok85alI2cZF7Lybs=", "J5BkOmYDjM5KZIiEfY0tou6oSWH4E0sb42lH+ANSfmc=", "FZ4l4AMmp28lwRQ6W+b1P6UczzaNmXTMbZPM6OuB03w=", "JIa4hDcNSaAD/QQegA8KiYq2G16UeZdGHuMoQkHzuqo=", "ER78E2qd/g68/66JQ+Z5zA+/Yv0M4DtAn+zZMqgoGxA="], ["DAmbxoJDU3ID+XJU8I37fvwJ3o+W1y87Pgqt7UXhi0o=", "A16ezEZMtDHMksM1boqYVH6EPtEyTB6XEXn9Gtn9UaA=", "AvNekh2uh/EoTAyK5zfb3Ek2y7sDoDpZGFUv5WUnCo0=", "I6csJ/T15upTJdWzaPmLQGk7LbHoyj0JZzl1PcVngwM=", "Dgex0i7tVP35Zv/fvOu2U7Xaw7KpH1AnKHbvsXFYviw=", "BfpW1DHUvQliWobTYjRk3JC9VB6kF0jyAm9lAl6p0vI=", "LW8+DphBPV1qEQGyRcnnEbsulW4npYcHhP1UA7OYZ8w=", "ITF2vBoEk5/n1rwwaRqr1hUu0k8wm/85OaDZHVTGemY=", "CloRSNrUVi6rGBYrORS2TVdT6WF6UVTpP35D5oYGh+o="], ["HF/ZBg1ODZmSZEKaUATBZVcL0WdbCfl3cIscpI5hY4g=", "Ep8GyTDt02/C+3BEpjMnUaLjvNvnVtiDcWzq1rxwY8s=", "FKXOFgMijW5vreV8HaU2ZZukbRslVm8Swo3ry+3FtPQ=", "FDYX7827wNJ6CR8oA566irs5OS4qRihQsfnNhTL1B18=", "KIXy1Evg7P9X2SpDhO21vr+1hbsj6uKi6lCAa6uLe9c=", "BHFdtthrUT0AJYnx+VIvfeOxqL1wLBZ1We3pfaLAB20=", "CIiHlmwHnS5omo1te9kT6S0yaVm62lm5mmU/6q32xGc=", "Et7UH4BH2j5sIr/tPsW7UtAn5WAEjbTA+Wyp+oXhe8M=", "H0fGekMlZy8XuL0d29gOTp5sYkGanCBMx+iCGJJDGq4="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon8.js
var require_poseidon8 = __commonJS({
  "../node_modules/poseidon-lite/poseidon8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon8 = poseidon82;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__8());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon82(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/9.js
var require__9 = __commonJS({
  "../node_modules/poseidon-lite/constants/9.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DhliwjL9Cmu1StiWKoK5g4z+8Z0pClX8SdbevQYc0vY=", "AeH0XP8+dBaKzNCpRTb8pjFxKJU+tH2NLXm4R7NVz1E=", "E2fuw7IMt0lTYY/ZJhBHdV73+Krl/+lvyPfZoC43vRo=", "L/atQFM6+irLeMm5FlDXzL0nSwn3jBAEefOk1ylW1wY=", "FSyMPZ5D2QrYCUgxp0r4FR/c2gsY172DdP/aaNGl/HE=", "JBcH2yb5bfUCNk0mcSx/Rl0KxVl6MJVZsHVAY1GiCXc=", "FaTkcooZfa5jA9DN0rbR5BFKn604pTC8pv0Gyh/8H1Y=", "DL/WPzY5eMOH1lbpPxHjNph6aHSMj1TzhYh+ZLEHVZg=", "H7WUR0uDNPmupv5eMj+w4Kwn0olZIaxk6T5STk/9JcQ=", "BaxVNh2pMcG0xWCqjbq8hiS6IlhxvOIkrdta+QFnaus=", "E1+DMUJSWF9+ARaSzZrP8232vphQKfIm3iVoA+pwTXg=", "CmjyYsnhTYqe4Ra/kM19ZePfVhuzkU4xTj9D8Wf1wEo=", "CoNgqDfUyXuUZjPDUymLd9aJG2znjoKjvTn7flEZPRA=", "E2ohvROxGFfg92cOEtIykMIxi9rIMBVMw3MwzK2aP+Y=", "KmCYm4CS+OHBywI47IW71ri2WTJ6A+jhk8FaVNu3PAQ=", "G164HxQ78ybaD065XU9FyBQs6mQNM6yvyN6rFV83NF8=", "CJA89raEgmc3o0isqkUuG6n5NF3pEfI0CrcyTQvLR+A=", "A7i3F7oQA1oSrk3ED0IQsPBSmug3dm4aJpUiEFY12Bg=", "BiPufBnqvRMRU5iJPoJu7iEdrqc/gPpToi+M5VkGAnw=", "C8iyQ2mrdmR/4OonjIZtTUW8P5PosG52kBu+W/INtcY=", "GjJ9X1QBkOHJyx4x2Fe1xRxcrZ8e4SbERnC3gtRsL1A=", "EIfvrIe/pIB6ykEKnCl9IxhMBbtYq/1Do/wt1IM4BZI=", "KZcRcwTfu0ZLXNSkGIqk9szVbenL2BPaJwrX7mmegGU=", "IpZILpGfvUb3pRgVXnKlWWVZaGbzKx+EMzkPPh8OQGM=", "IVLV8WTOCfaSis4lZr68YQmk9iBH5HR6BR4p3Bh1Jdk=", "EFQQmGGzNJ5Bkhbxu+gvSleCOnessd62xI+iZ+5dMC8=", "F3L0ApVAQyq4xpaLNznDokHNo63hPs4uoKCxV9ZcLJM=", "AMKWr9suA315eYeGcceKX2AI2Yy/db5OPsPMHUToRZ4=", "DshbIsYmhuUst5qymgGB3I403fMWfR41NRTsho5yml4=", "FJ4kNcINSKPsVsTkXbvFg7hb1kMRoldv81JmiWLCGGY=", "HUQUDctFl8chSm7YW/8aO1+tM/18UwaZu9YQ479SQN4=", "A8+wVw+CSFb79BUTvgHtMnHhw4oW9hCoCXzSehMl1NM=", "DyI7OWQj7cKdUeWIcrLat+o6rolRe8QZV+rHnOl2E3k=", "H+bcLm6Dq4joQzekUTCWMzd0bM0BwvK+EACAvjKllSA=", "BHMQ67RZ/oYMlUUXJJRA02fG78W5P3DEELx2+AiLSj8=", "IYWM5poBnkzUYJamF5C/fgPhDj7cGimI33aEmK1mfN8=", "DaT4faGW2syWT7aSilHzrO8EIDfbdB8xe02AqBz5io4=", "GY7uqYHrJWtPpD8F+k4a7JCOV2E+79NQJjWAgOMpvBI=", "EZZO/SHqB5NAxmrZL9tiuKGO4IqZkvEzpBfSO3jLGww=", "BLB7GWBRgSL1clzq3AwfBgkovfD17ELhb4wpNId7QUM=", "Akb1+7X3GbCJbge0wj/PHSRIe0x3WYPOpJUA+GN3Cew=", "JNeNrt6TJ/SeumeVOfhdCZ1lgwYJOMsFLc5QElsBzdA=", "I96TJljS8YH1nXI0pn4XR2P/eQ05BM+z3RCvivTYhls=", "DE9UMdqqmU3fXz/msd8MDEIoejjJpcTHWPcmOOO9tAM=", "F1mZWJiVtpR9OG2Dpeb1+vnGWI1SPHhGQzISIz9k0Es=", "AtVM7148rRqARxvG7wxuTnTC5WiGox15JXsnYu56tRc=", "FTnNxp/ZPy6lDdEuuwQ3wj307Nopx2rrCUN//b8Bx3g=", "I1mkVFKCS6l9vAUAhruRDBLO4KkI2xwoCJed7cjymUI=", "CIDl2iElsIQiA7uY5fJK4mIopa9abv1UYfY0pEdqFfI=", "FhEPxsgWeTC94jDV35VPEHz9DaAFruROxf9kKHJ2TBk=", "ExDIRLcNalhW9tGGaeUywta9XQHmox6ATYGi9a3GP98=", "LqhoIXqZpsvnm0QuIVKFPHMw/Y3nV+t1VXZYef5Cziw=", "KcUEJHHZCe5IE80aNujsoI1ODTgwCfF8SjZ6h3o99L0=", "JeNu2g6rV2B16IraORTClEIXKgJ8bRdM4N37sBfVHf8=", "LSEFjsRGdNhJPnAqreW987aR4/qsBCcInoZ/nthWvHM=", "GNF8ODXsq0S9uLZ+/irMcdOenTRD3Q7RHZUEVAmnx4g=", "KKL2Ow6UCv0seNAN4apv1pU+bWzMOqMgOzlhj11pj1o=", "AmNfW9m+uv8M52FOx4Q0GKmqg2N5ECKb7/25HiPrwQ8=", "H7jocmUlJoAYhF+MgmsOTVbE6cWOqSdS1YHRpRcCuII=", "CH4s5NKuXJPqVhHVDDEyAqgMS0NTO0kHf7Vp+DfqH+U=", "B4j6lTLPAPE8gX847hurhfvGh5mM8cFK/1/B6rEVp9o=", "HFyFxXofdYf40vzvwdTpjCdBoBnv+9TFAzSwwVw4Fc4=", "DB+4MrfL4OfhHo7cK6+HSfbqBjeyDpcqYzFdvdW+FHI=", "IpdYoitS7DkH+UoRf2Y5FkUIx3v9vGecGz+Ha0bK+Ak=", "BeBmyhJX2NXtymWikh+1teAeOi8KKjvGYix5FVIZCio=", "KxqTWk/xbCUAvf7iCG2d85J6NY6Oq+dfanDX2yWjGRc=", "GaVZkxCAiOA/5/vCoBRQnOmH9Cd/cpuluSTSWzngZpo=", "G7ZaP5pDda2SbUTBiNz+UbWl3Wp+4VKqbMzkSBPpXbk=", "H3IcTQ23WS+b2gH9H768jldFLiGNii4ZFjBn1K8SjTc=", "K9MqAomUmKlzOCpNQCZtrK6JiphHwrM8KtMLzcQlR3Y=", "KFhbBS0iKDZQqROdY2GwjOlNF9fI9twdVPWFiQZuSjE=", "A+s0NSYQInvrJvjt/kZsv6NH15UL7kMecWVke/HFzN8=", "HBNH70GNZXq75uTAGQEb003bIHq1SpuZ8HxARFieCYY=", "BKiqOxgmPhcTY+k5aEehkz8ET6xfWxH3VOb+r1TsR0c=", "EnRKBjyr6S4uGPAAr+8pyShYWgOvrDsvTBcUEgOUQjk=", "EK9NOactLctl7uq/ykCgimmydBKXBMAhoBOI/4Zi+uc=", "EDjGVrMy5Rn0g9VOUiKzSzWvEpBtE2UtHYxrD1CbJ/w=", "EO4C7RF2gEt9Q2luuHZDtPtF8B3WWInltlEo94HTnZM=", "HQjM1HVBV1xgtWf9m2cF3ogkj5zGCvI0MJjTXZ5PbTU=", "Brv24y0m6SK6rIxivPheyTTL32hw44GM/kndOkxwiX0=", "A65gQD+TqYNwaIEA3Nh61Mce5SnE3MO+Mta8BiHUI1U=", "D9D3dtJn3DwBo3fSF+M6JVw5k3rCgaOw6stYsQEjk8g=", "LUqzuF7m9VvBfQUfzvc5Forii35tWqSsEqLcwHubpvc=", "LsB7P62+KW+b0fzRdY+V5rki23WCBo121VIYQTHggy8=", "CmAT439WD1QNvT6XkGACAHd7hqV3wtLYPsfNE9sxk3Y=", "DcvDy0qv4Ixicx3KRMhDASJllQ4Hlsc9j55Tp2fH6Ig=", "GYw3P7xrpZgCBFb2JN/JBvKMq5FbcOtVaPF1+EI1XCc=", "KpUVdw8wU2OOPAZPWQHaeswlEPsp9fNgf4rRJWraB+4=", "LUFUc57Yps+akuWQgS8V+TATFj9XuAOXc8+GNI1TGMg=", "Arvq5McW7hNsTO7xlOeYXUZBX8EwQwplsk6fR1Mwd9k=", "GStbCDIHZvRb57up6acMDvxpr+wqdeTgcebI9V+571Q=", "K74OC72pNrMFgp46dKgt8DDU/YESqn8WlnCHawKPBwI=", "CWNyLY21MvyVzyJApXDNehNjZt/1RJR4RbbUh9x/pio=", "FgEMDteje8qWgqyFj8jSxK9RPwLQ8X3TBvBc1X3GlM8=", "JEhhIph+Fwd7AmuqgecF5dDLdrTZLdP/VLu4E/PQnqE=", "KNo1qFJiWCsiD3Ji6mjDgVc6kYwQ3Rfo5WTrbaET5cQ=", "HTGWqmIJCFw02y8OKz3Uu2u2cObKJNJ9kNyO+l6BY4o=", "Dlb+S3umLc2g0ve53oa85hZteaCgw8aVNB+9tAe5pQY=", "FF/Udnat5cOAuQvwgCD678jD0nDGvZf5KhirlPlz288=", "C2cESG/dKmM7+eQKXF5AkeLUMMk3MGqzBFs5uLdOMz4=", "J2dHmURzupFSJ10Vvq/kK5JN5pcoEHiYtHAaZjbfPPQ=", "EmZTJMn8jSRsFRjgQKFeOhfA+D8KR5Vx2PYaR/OYLSE=", "AojFiTJ/+Xgk6qPf9Au8ycpz9p5D7r8kspzVP6ERzI0=", "LDs/Jm8h0h2jPkw5ABx6cD5rk+BHNXhAEj8wck/aM2w=", "HQiSYPU9m22RJGDGqdn/nfWmORpJJzFTSCalV16KdyU=", "BSImzU/yyF3D/Lv9yqDsrXEloD1TMiPIZnBA+/z3Bi4=", "JxL5FxgEJzqcGXP36H+uKL7ZqDP9tw7ZPcYnSGWGk1Y=", "J28veB4MnKBCSppRNVk76Vdkp1nCMRmdtdXg53bhWqw=", "KyH/w7oWPqYbfAtxfVGcZKrKuBlX4mjhdfRodumsb2I=", "LzwraHS4FTG4kKYDvn42zqrtbIozYKho8YvyNzYojAk=", "BWchFI2aNwqOgSjuABeGlfZuxQY8ZmD/VUkTOUzV32c=", "DhcS/ReY27Sil236oIW7mCLS0mk5g+mcdqVW515jMT8=", "JsmEbHyguCJ7bqp2NM+qbEoTv6RxDL7+gL7+URnAtgg=", "HruetHmmRNJfU9qz5tyggznw7/3pt6rXo0dIUH1pqK4=", "FhH14q3YzP6dCTvqHVXqxiZhqayXE/pMcIlZl0Qbuog=", "JGLD1VVWEa7qShRrjaUNMMQZlDwapgDlsTvEejgQ9js=", "DzduuefeTEX/UIois05V8P/aAmgmqYsphnLYHIJrYpI=", "Dn/4DD0Zoq2YyMUqXRnRcSUXqmWCYpGubnXgUDyLijw=", "LrE/9mq0mnOqrXYPW/JxMW8/hTjFJqGmT6Zb07P8LU8=", "IqQOUw3n3dwfhCyUIRksY1tDpssfg9id29PFbCpRLts=", "J0C6oxjAL94WLJIKYkWw8iCPfQ7hiYI620e6/91e4h0=", "GWVSLM6L0ps861CM5AQx9A1UtZwEEeXKQn+MHHidKbA=", "EKDbfCsJadwlBkevC9sNmc6kKF/YqQcXwnYCMqkGvn4=", "ApVIYnGto8rkz+NyHm17Cs8hvco8qg4CCm2I6tHyuxE=", "HQAgbWWpJGbd7yLlWDZhxo7jE8xAoBwJDlzLEYoa8T0=", "ESIiYFBSQj/W2iHZVUXW6Wh45ab0P7Jmbi/cWTeXG8U=", "Jc+v233zKoby/0SjKtey/Zpg8xpE5bWtQjrlKw4/8u8=", "GkKsozB9+EqB/1ufvsARrJ/a89nHPN/pUBH3wax3nRU=", "FPtsTg3wBjJ104DmfCUaKa5jgCjY5gcqbk/f9OA5pP8=", "Fof1AajAfJ5D60qyJEkUtlEpOAeii8Q9c6xLVkBEUmQ=", "LWS6QGeriY97Q0QJMZ18rd2xQYL2E+RmQpGbQ8ibgVk=", "Jl4Z4qK8/5SJy3Sdr5t3JW5AjxgM+vBVBuEaAtbUsUI=", "ESDZEWpYTsrTI8uLiCW55DrRbOWcXou18RtKuOXuaAE=", "E1wgD3wUXAQv3JStW9LkZhsNuIndw8JKIH9cfECYA0o=", "L502XZtfn//FSRwMw55rmtFOTYeUv3bma+yil03Gxlo=", "K7J8Gh6EUvMXv4amOElU+GCaKFAEWTxS/c/+fYWBLfQ=", "JF8o2mmGNod2lo1+XaF2PTi04aW1OsO0V7JtNdjMVTs=", "FgR8P0yiPG9drKXQHrxnIaPRVspMNeAISQODa9Eok74=", "Eymd3bnid7EiJA0IZWFk0V+NFcx0g95wh+itlpCcBWU=", "FZDd4p4RQkoOf31LPg/H5BLQkkY8+VRbfGImCrLUNLk=", "Gf1guqJIa/3//8j2cqtky6QLOU8oGDZsdtBbd+keKzY=", "Jlgo7fsDkdhggixBGbOc7uwCGRZT+VxzksAXJURO6Ek=", "Ajvamjwui7GyJ7Em6ldPl+x3k82AxiykTPiy5BUTK7E=", "G3cMgEv7kYsZduM1eriEZosNKqQU4Aft4ABxRxSqCdM=", "HYTqq6ZSHrhmtgB0kGnmZD2qgPfeEOwnNR8TaaNynRM=", "BzoKobpMHh6YLvAFORg+9kj8RBvoirHcUxWgy7QBybM=", "JawJmqhcniruZ4nyWSJYzfXKjHtXOeJn8SA09wV5f4E=", "HB8NwirVTanyYyG3k+AUrBuFMAHRVutZDm7FIuaFDDE=", "EDdJzK6Q5DSh2WExn5bHROBOwPd8jGUFvCGhGU2mwUs=", "CTxHydrV6mHIVmYg5PQ2w2rQDQRrJS0iZNBtmjd+nGg=", "EtSKItRDcRsFu6c/58v14HNN9+00WH+F2FClFYwKJ04=", "DRSH7nv8pG/rztuD6dxzwz08CZvzwad5M0g0+J99ozQ=", "Lrqx5UT2rUUl61WSFS7LRvjg9wzFTnOfWuTEiUXlNKg=", "FyYBELwPothZplpRm2ecqxV6ZIXlBiyvo9noUjVD1GA=", "FLYLsbgTUzZVt00ZSPr9lMc+HgutK/Pny76ZfEDCLLA=", "FEypsYEEtbtanSHXO9lX83MllTmhY8eBlyEM0WyIZkE=", "C2mFQMCrInNLrVjkhRX/hFIAUSFfXOSRXYBEQDKjukk=", "H0WP35KkwDvOK/ad091OJr/BZjwYd5m7NZWNNhPiW9o=", "JsDD+fKr0ZOSMw7pPiVUq7J+03dIHiolUnmNyVKgrNc=", "AP6CW93hq6+0gOmF1vqPTHrpxnNfm+CmkkKT0roRRcA=", "JN7tOYhUauZSCmwgx2WevSpfS4KBgqMPUZVnSZex9zQ=", "C7vNVVwYSq4IkVgsYdZRlRMroUqib65bykz6DvcckLg=", "D5942F3t43hDevvsP2ukDI4/Z0y6pR8vxTVVd5zpqk0=", "JpzS+4wDk2qm4w39CcNP94bIOZbon3BsOc+aZzp5yPA=", "BApe1VwVQa0UMbLgpcI3DMCrjLKrMeYlBfeZsKU1U34=", "CxDbUtaaCDgsmw9g1TxYYzMBiHfsh5BnovlUj6A1thM=", "HmzFxAkNLZH1ZyNwZMV6u4Dx0YhqUJyra8I+gXZ6KqA=", "EE+ZZraokhODGcoDfUKY+uT61dCc0F5uSBS3UuUfVws=", "KdlvUw7VzJLJBNIb9WDIKSO/ZWmsuQq/udaMSVy7mBQ=", "FrkXokHF4qGUHXRWZtit/t77SPnP/HVv72ZnQ56rof0=", "KASdyHA+futK5ct+7J0LlhTzPwO+ylSmfXKc/2WXH6A=", "K8I2cUrv64ZFTPlyZ2xkagcecJWdU4caI6J7zEpRS0Y=", "DoXj8LYt+sBN7+iTJrHxycV/ldwpnvlf3OLdEwsOCfI=", "FXb1VlDg36gZoSc+ag+gTB8a4Y8fhB2vCtWiNXk7hi4=", "Lm0fmE2Q13i8DgmQ2+a+ZiWK0ASHEpqzQ42pDJ7DB/E=", "ClIWwkA3gITXQQzHeIAcWQORxvYAqFUU3h1c/S4p+pU=", "Fq8MbshXcUuennkyrIprGwH7QlMuUelXxzXgJAPs1JI=", "B+84KbIehtzbw6oC/SRrj6jn5MIVeO8FhIdNNt5JGqw=", "Ahzf3Ksf/awrrwFd2tfvb8GWt0QugrNwoRh7SE1dYtU=", "CRGqHOYI9CNP87nzXZvlRvXnuUvwol+LzLNTXr8cWEY=", "HIYesBxLM17P22MgfFFn8vKi271MYE35c5CCxduRcTo=", "Ayq1wAk6/AWdciZRUgJrxnS2mISJ+hki0/ahMObpjAs=", "Hbt8TjCzvbOiSOARjJJZwxt1vrvais3i0RQxHhFmuFA=", "KVchmHsqBy+Wghb2nhSvwQrHzmhwoc72ILnjFnEh5WU=", "DYSLu1PqjHLIygqTNxEGHNEcOL71IE4Zh8bgAWzIdyg=", "ElQ39hBbVzKcBFN2vpgB8VAIg4SRarV+6Q5N8mBTPkA=", "Fqb4XPBwqTQ3ad+96M7DDWJQDVDuKUFnsM/Jr0cHrCQ=", "I+S6Fm4rWhUG353U3HTHow37efSTreOL4hwKYEBz01k=", "DXpXDVwTG/eAMcZsiuX9RUuphV+rkur5yjedCOhWQU8=", "IXk9RqaW7lBA9Zn0gr2YRTVsAuTCsHpkUKEAVUNmWCE=", "BM+fEheLqG+rEcEtaQ5iBgNSX/ffy1YG0PZ/CnJQ0KY=", "HhyHFK66fnVJ4IR3tDZewtvr37tgGJN/aA08+ttbkiQ=", "El+ZyB211+dL4MbmtEdt0OUDwccEs8fT/w7TVvmlv9Q=", "ERvDIVs7sqXRclf6c6d4UdKiTkgErRrG5lLwhYMmzrI=", "Cec3cfrqAGXIBlPfqov/QC7rC+NmiDQ4Jvr2OfaEsxo=", "CWT2IZRoEKEjRp/Oa1RP9hzJtzMDO2MgcNR7yUdPSww=", "CVMr+fEQUfhjpOgGeXgrBzLWY5RzkMErApVJGKGOR60=", "HRSAjFRYOmIOZYfCS5k7GDig6wc5XDCFtEnTE1vjIvU=", "CbiM68y7KgoY4tLnmed8q8tKIxEjwwPpjNiX/61ZjUQ=", "JP9as470V0hEkwVMm9PsiUqFZkkakaUr14g0PEKdCpM=", "E+6uoimMok7npzFi7Doh2Be6hvl3K7aMBGHRFVNdrsM=", "EWAKNstB/eLdJqfNSpjNi+rgoE5G2zme7FwdSQIFEPA=", "LHaC0+5Ow85+H2fM6b3rpKH2afBNn3pL7hOzyX0+qjo=", "LZsdskawBOGFsIyVPcCvT7t8fcZ7I3jv9wdQey2wbLc=", "F/FAfChy04ELdHS+vjcR9yWDzJWDEwG04+BqPKligxg=", "CJ/VgFXSBgK9vCFxrkhf9I8gUwEGWTK8nVJv5U0pfwI=", "J3nq9TcQ86WEio3/vkC19EKooTxRT/l1Af3KCA+zuvw=", "B9bD3bgHuGNMia7zVhXac1lujuGoyrSdAi8LyoeA7BU=", "GykY2gub7qaagLBaFR5oFyLLZvuO8ffdgpOemRzQIeg=", "GiGhQJ3fypnjwJh/l0UIQPlYUkr/6yjBj95znIGJyrs=", "H55n45eRldNoFyJnpro7RIFz4jefJcqhN6tpZHFNH+E=", "B+V5MTmbzEEZ2c17IZF5PeDuaUdHFrCACKn2ikKHh6Y=", "Ce99Surfe/WTxaeSeenmVXjRQxXfne4HQBaT0ZlZlII=", "KF/jsV9LQyadTMAYP591sLT+af8XCsZBsYx/sQXS1xE=", "GadoK/7P4Y+6siMBJziVwcS5qZSHfdd4ZG6d/WTyTbw=", "CreUtEM7XQyp8/kjYVnue58RKr5x06TRk4UgLCCVAdA=", "CP9k9bueP4voFXMRfgEcgD9p3GoJcNwFEYqxBxoomAw=", "Lw1FS0ngNmFx2VFCIwAC1w+QyMNwR8ayWMB8DJ0DiKk=", "F7Rjxo/LpGHhSeVu2p6NsaS8XHuCibDNQobetck1VMg=", "LRqDrIMuSSgN+UseJ7q2X6qeIaYKSO8PRVfAP5t9EfE=", "HhgkEVYMgNfUxIDk/WW5mXEypO0p+ajcPYgiCbY7B8I=", "BLxcGcuzEpQbobcx8JY0mudiTso7g76IZHCA95TX+rM=", "DxChMZUIwJqkQn6nkHHaAtzkoXReE55pSfmSFqzYMFo=", "B1edlrq3k+8fdAcT9w89LPSvHSDqVg9I5vjATfZPIHc=", "H9i1XQooz9AJspizDiJqo9QkM9wUgxjJnE4yrxPFFEo=", "Kv/VDGrrpXaH2CSu/6VcIX9jPUaEDJKMA3PKRkMvpzE=", "L8FjS2ncaXtmj60+iciBhqduQHe/bRFA2OQo6ut6OHI=", "I6U+UUqyYuIuyn7nIkl4GMBk+PdMzTMFA9er+oXwFdM=", "CG6pjopO222FALygPVOgOiL2m28TLJnsr56VD78myHs=", "D0iRWFW00ZG3w32F6KXUkWSM1OU/WAbUmajeh+4Q8uI=", "E+C7ldnTB4wQ7S9zH1f16eQMlWN1dOlakz2fKnqlbFs=", "K8NbDFszXfxvGpNi5bOJ2v62XwzltEVIKA9GwW/1H+s=", "BbLdzIaoUEsAgIrLtKZDsWnbKwf8JcnMMThGfKdQtaw=", "F1DRpH2iEdjoOGwZgJW4P/ZltYmsJ4vKjA+gG/xoPLo=", "G7UyHpXR+6KyLPTXXi6iw2Q7he+78aOyzUvg59EjiA8=", "Kk6K1N+idlKDnOF54JZMxNRzL7VTcJAbMpLWY73kHs0=", "GbmEotWgMjuVb64JtSm9z0VRIsRD7qx/8VhLzdYyeH8=", "ERBfgYzCcjKoRF/4ht7YOP6YADhye54rM0NqVcL5/Ts=", "IiggVzL+a5rygbWytf2i0H9RhMVV+1Kn9RTGwbH6gKA=", "ILTEaLuOKcGG5/Rf7u+EvYV9uFZDqnmLwmRRnapGP90=", "FLzS/Vxzkr+dk+SbWFW181xxfUzlETe4dRuCg4anpfY=", "Fhyybm+kjbsFpcO9q0oaUkRp+YuNEBgfKEgCnHleBXY=", "JtU3zNjU8+Yv0PrEHGokyUEfTW3cAydrrCYXaJU710U=", "HefT35fRGggRBqS9Ibl2A6dq3/FlzUCsdH7UnmHGEfU=", "KYAPsAIK4Y1O/Y+sHe9cdgevNfTiI5BKzGoU2MbRSsA=", "JxJx+FD2kqNQP7chJLWDqB8/DqZ4m+Olb/tJd2V56yU=", "FmlL83/kITQLGGy8gX0LE2+XLJNVefLaMA2PPGY0gfw=", "Gcyvg5vN4/uXZOV7QPi+A2wdCtbdI8r0Dwwt6nZLRTg=", "E0W8Y76OPobT6s3MTPFCVC4KxmD291/jTTx/NFOCPS8=", "B+cz42pjscVORTBQrkMHjIahgDubwZhPg22p5b3ibPQ=", "Bn34X8Rh0eE7CnRMT3iU0xJtQAwPZ0EV12SgegU/ZDE=", "A8ICXqTuLBmy+Ni+CiuQodL0NFNRXsBCV64fxs5TNK8=", "LL8dx69Y+prbi6MbGTCEdiTMT49nzdi8o6knbB8G+7c=", "ASA1pSGbkA3trsMvYsu4WiIoo+cbU6/U0v5rPJZPkfs=", "G4xxPJDWKzZzgsDO6+vimJMVes1W4QdV0QaZko81Ba4=", "FEdfdY1dsBot4q3UbEBdk56xrwqza88m/5PkhgVB3VY=", "ITd28eD6yFX5WMsgqgkNT9R+cP0Ok291EDf8M8+cQSc=", "Ks9CweyhoJPxAZjdWha84Wv4shEHckqUr/LxkJBuaYA=", "GRlLaLiYR2WWqeLUBW4VyVpmSCNKu7+cpZLMLFNwM4A=", "CyCh2aJHABHrL4GAIVQAtYPLux/Qhf1TvdHJIXzFo7g=", "FKfR1wZe1vatcqDvO4SNdgNPepXS2ioGQzxsQWDvnIo=", "GRQkFuOxaKu5m6vBfOaCHZWimjHZK/dKEiqO/nmfm70=", "LNFXHfsyq+bl3+yDcfgTDPd1ZqntoGzItkZv6eGzxSg=", "HLHrxLQgUodugwQL3ns4AjD18UX5QAtdTXE2phxutFg=", "BcSrcs3R3pVBlolmHl5zXhWz/8rsof3IZp5z2KbLyW0=", "JMjaA82PtJfk8EUAabXU3rECtk5o1YiXckg+jQ45dNc=", "DegZWAVwb/dMslHPsLrZueP90FnQGl/HxwXWCXH6SEA=", "MEzoyzzVUZYjUgpIg9NXkiVtygwS3B6FUVelnapFCPQ=", "Dza1hphNGVmnnDig4GRQ7boAPa63ksjU3zB8VcnvqLE=", "GoMl1VSAZGrH+qOt3ssuwO90gvEKCZxbRlZ1LiRVGGk=", "LX9nRNBhlq4IefQGgUqr+IkHNQXe2oRmUfr8jCAYWuw=", "CSBVB9/DdnLdlxHXv0Ln3ikLNmtd8jZ9Q3qC3J4IZoE=", "HCLpvT8j38P3Pcc8kTHhaosHaBj8iCNCXMsbcyv1ST8=", "HFl2IzdQB4QR1sk2gNiHlZbfr1+S1I/U3ZTuXSnFHKE=", "B8uGxpc6u8afidJI10QUfiZpCmG24x0Q6YATeHnkJnM=", "DDyYgKgkhSC2Ee5N9/3MFqZq9F9S6wEEV1eRB9zJnTk=", "A5KObeZtSQy6Oh4+NmUSORmTjv+n/E+MmzG73uHkea0=", "A0D3iFc7U2/h5Cx/1AnTZxJHI92pxLDzuWLgE3Zn6H8=", "AwplvV23nwCcwbP6wc5GTEwNVDOFJS2gF7EWFG/oDYI=", "KkKoAt6QhdksO91AhjcaPxftA8CKK8YbPkPgU5NX3hQ=", "FUmhyyUENWmbOiRn+DkBEoCURGprulJtVHPoJBtQBKo=", "MFAWRdf2fW1OH2S5WjRKhbxqb5f7Nh52ksls/VSh1BQ=", "HD6jad4Y3NwzePYd1WOhqvJWmC+snqCZSj7uJsH10Ao=", "AE8tJDclKg1NnKTBsBtmCDxwEoHCM4B+dEkQs925cfM=", "Ey/lKeSqvQMEEpYkgFYslcj7PEq63pMm4dh77L4TkqA=", "GfoQcVa5YYhvudmewTvNjQxMVE1CQMH39Dx3xj8USFc=", "LV+RzTy1UtrH94Q/YFUr3ob0Xou6rkhMa3nM/zSsXuE=", "La3ZpprRRuZbur+6rDN4r5xVQNF7m6GbspxIyF2/5xo=", "A8kAMHTkUCCSErO9FiLaYccaug6KCUp2YL4fRjjqvIs=", "C6kXKScfa4FDeL8rhHSQ2LBrRsoxzFxPx0wcsEtxzxQ=", "DuWD2BfxcFrHrAua4EIVitDV7zZywdE9x915SqhPMGE=", "EUACalq9icQBLSxDpHi1L7tG7Ahhzls7fBz2n+XED2I=", "F27Av6WLOXYpCsFFlUQYxXftd6uH+5+CKBdamtjm9fo=", "E+WJnEbBT3AE/Q/Tdkds00qn07E0cP3FIy1Wo+WbR+o=", "FnMM52b2XAbLYR+Nf0/D1TxmYuoSykUCu5aIc/PhT4Y=", "Fl2w64hf/tX3elV7PrIe8tSLSnzGIgcJ3gDmHNn49SU=", "DEKCeMIXwefnbjEQ9+GyapCV6MjLwHoXFxTpr+4mcPk=", "LvGDQkxZCgpdO4pjnzfk530Q/p4SMncYuOzCtAoukr4=", "C7vgn7v9p7bgbK2GjLGjifulyime2VRTUcl05hL1/dM=", "L0IAPsyrO/8NzisiqHaaW6GgpvhUxzp4hEO8E+j6XqU=", "BZETqvkorNkVTqkpWlpp+GQUnslvBAlnO+hgzcHt3tE=", "H7+q53vAYPu9A/+uq64s1NMnk2PF5GQ3g9+5pdWUaCU=", "JbPO8dUkxIFW6aJKoNLCDtMvtptN6+HBLeUNskbjyAU=", "FebwMp7U5E0DI/AnRLT20DIeIE/TjJnMtyo1eEuUAm4=", "FuR/ZCvxPOZsLCvKAaJ2PXBLRt4NfJncsrSAcHwaO/c=", "HZ+EjLnf24HK1i3V/UMVblfEuhlOMrQhqgfengqHAOw=", "Bw4gaUb0yywqfFx8DKhP5T/9iEJ5JZ6u7uAGJ92YXP4=", "Cl+RrtEVlQzmNIsPDwAVaSQ8hABBuXTk+96sz3Kxnac=", "J3NnR3ldI1WXBHpXtSTdTB7Q4/QnmCFbqFBWvqdlVA4=", "AWfB12R5EGlTKC+UXI2MtyFg9jEEcKf1Fl8VctbCfqQ=", "G+zUV9IboJSATEfDpohzS9VDsubXy1GuwMqJ1sHjw1U=", "H0M4b+c55/nGP73LuCvM3NQXM4/qwe7ULe9xUNSiE1g=", "LQkcNYF1WDsyy5fFgWjzLYOmjJm9+nwgCNnEVLDq3hY=", "AXJXxbyNrVfvb2bMBBoWBjUJANzhhMMSQmBlNG29sbo=", "C0rcA8e/0xOQLdpnjC+iUVIqkqf8bktH1PH/mOofIcQ=", "GvhFJEQawD+i2LWzkafDcfLZzwagkAX+puO3CMzOLLU=", "I+yvgShjNiUaH8xd1EpKuf05QKBI53HuRmiDB0Slqb0=", "GHvHA8yJPiy6Ivu1mMDneMIEatvliz/yUte2Ne2ZDCA=", "JgsC2xEdY5mLavCagZKPYs/JfE+MuiboKP9cBXoOVfM=", "LwIyqZQMTEzdDkTjxHhc7RT/E7X4cc4vbuNXQq0FCs4=", "BQrcTV1kgH9zDQ9FDaVRdHmjeGo7ssjeJFNqfKXeLY4=", "FquPaCpAg9D5mfWBb0HMftvOgsDVm8yqicJUcpRA+YE=", "ESf7LwypzJU/ux1Hk0dCY6blG3fnLDixFH74ZUFdTaw=", "H20ErZfy9LcQ+R9SJqjFXsvBwlr05MqLdsxPrSTuxnQ=", "FBvlRL5MI7NiXvqIbaZeZ1tnmQKNOnpt3h7RSfqklng=", "G/eF+YZxlLReIdx2sgAyXOS9Zkt842mRdLKMD7MkOQY=", "JNm+fDLH4zv3aBbhmjweSoh8mudNFadxLa6AKGTAhlE=", "KKSB74UVhRMg25z96BaCai6vmUrvilUaPQAi13IFrWw=", "IFc8FYpJxUcx/tt8SU66fMoXl1y0pEjGiLxWSVkHJh8=", "ChWxVlkpcmQe7ylwkE3j4TNDdu5kv3bbS/XnyFQsIcA=", "GyvEo/P0SO+/ohpOQdXW4JtzV0c5tm6sJ+Zaof23jHA=", "Gnml2Doou8TBE2AAOBNehs5hiN9N/5OBVTAVk9TMc6o=", "HhXn8R6jZ1f9z8xVjnxr2MfLhIQ4iiyVJY4hJRZN9BM=", "KYoDvB7dd27DNyyCznPESz4S6VCcEkRZ8V2d94OVOBY=", "CsrtGGvSG2vwGITC6A37hGmeC9g7d3DQO5GNJKASkxY=", "JSnE/7bDnP0apuBIAMtZuuqjHaQ5A9M4WyqyWGSBKWM=", "GcR8Kjcnjxg/O1hCcRQTmz64LAuJDEGZcGrZRDkfpqQ=", "DScBvfpXz5EfHNH7Q1/uBoyu1oXGNjgiSd2az0XUyYk=", "HljjbgrXtLrSesf3bTSrSXSI0WYaRE28B8ucchlAnxI=", "Jpiy9m+xXzsWp+UMvYNaMfu4PgtlmC16esspccxYJbg=", "HDqONzeFZRQHGliRt+sob8yDbxG2KcEsm2Gnam9tvi0=", "KSfOUXMIZHP6RF1TFyoFqmao+dmhafaFxHqpibng9aw=", "JaoX2CRYDW1TMjZBKkiapFqjibPT1Vo0XTVmOhsUO/E=", "D88REtrMMReYGdZldKXLje1FAD92Zn00wdNBU9j8qZQ=", "BgMtblDQWQV9RhR3mZ77Ssq9Gp2lknMaQEiujRmz01E=", "AeQOgZ9Cb649uwCSan1lVvMNhJNMyr+Z6YdjUdFxa14=", "J5CEltCQb1JMJRZTJRCYz73Je510F+Q3cQ4af0uA0Io=", "AtsYFPFDXNB+5U+MMgXH12Jiy1/F2mBYNqCNR/P98TQ=", "GTd6Rdal3gB1HqkBGY4aCsxByoqZ/q5e7Af+UjPSibw=", "LQBPyC49+am4kyGCNFiDJ3DsgPh1iVo//iNwwKqlz7o=", "F7g2JWp95BPNz5OkxPj7a3aXWx7+MK7vCsEqg7NDTA4=", "GyNKKNq5FJ4s05uzT3lKhd0SXzM4O3eEG5ExKMuGo/w=", "FYhh/Xa9iliVDAxV2VeMnGw/8a76iIA/MncK2xpvF6Y=", "Du+AkwLTFBWEKFYYsP8uajc7G+DbBoW+Nxu2AYiKrLQ=", "Gs8+528Z3hV5lnaNr6/mBOGFuyM1a24lkgMutzLbpE4=", "L09V9Xt3HswVgTUm1ztSsvocTwZVF7m7+MNlgEDhILs=", "BiKWTKZaSLMNQKn9To+nV/1zfwIEWedKUzzqVYKQcrw=", "HIyzSbXrpZTj6W7gQe634Jb6zUIfeJvX32rq0DDP0es=", "HvUZ87gvKARpwep7JVHTo40+UK0rDFLtAYV4DoNHBpc=", "Bx+WbFu4cRHh0PA9F+KIXd9Qt7XayZ8s+ch/JaE4M1Q=", "B2j5SozIIi+dLrNquurjs1GtfI/QdZcbyV3mwkIv8qs=", "E2+50IkXD8s0PdHyzyVEaBGMl60slRtrP+STPVpPqnA=", "FCBK1S4X78yNbDspzlIgpeqMaCniqdM/ZG3yQhLCyoE=", "GTSaVvFZGPHpxsWHzSO7P5M69YMyLdXA+mFmzxzVjG8=", "L/0VQA49V68dUDdV65fTMYFKrprdR2S7fpUYFuBrT9g=", "ABiA1AbwQ1K6DnDR6k5VMC8jkyfh37sP6fp02UfAQwQ=", "IZT9BKbT6AoE9TI1pfRujiIl6ZxTAXPMKPsVd6Drqk8=", "E4TM3eV3QigaPRF8DbyCXLfRt+K1fA3uZSHTFdYNihE=", "CrgPZ5rfh4np9oYV+OZcreEsnBnosJb516WKbpFVr8k=", "G+OlVwbUgUSHJovxAZbugACaxp0m6qSua4KZ0/on2ms=", "H4p4iUBEZCd+P6fa0UOOWlXbK1O0bxCAqyWzG1OKzdQ=", "JjyFxYKC9lbqYZP3JkGqLPme5PfkfxvBuyLEbO+tuu4=", "AQGQmSZ/8e1yTkY1c3AfTC0HQzeyf0dAYNw15yzNGKE=", "BCm+vEMNQGLjhzNhm40/3dXCbQWyA7qbzV+5BYx1Rfk=", "CgPhE/dPwK7j5Ublk3v4xWHBInT8UAjMYxgKJgBBR98=", "BoiIczT0g0IvR6k5fkVmbJ/cFeUI+9T6g6XnIr6SYSo=", "HKtzF3/uyoyGNgF0W0ATjYGwwgkzSqxYlRcJJ4zPfD8=", "BYnhEvQ8l5qzuPExp5CaKE83hng6kgUnH3mBNQCCbzo=", "CBodebIm0C8+3HnWdWsreNBrdnf757/S4cc8WwVc9vg=", "HRJrI9omvSYqC6RcuDt4rhfvzxqluXR42QhD8KYY6SM=", "GdAsyvH3KMNbiFkuMA2vjGy6bqpzNDUusEeIXbIvl90=", "Hn4h2/ZtpHt2tOAlu9Q4plTWZe7M/5KOKd3QWHvavew=", "Fpygn2HRAQRls9agTqbzI/8hJrLFE/Rz4linOMNOhKM=", "GvwdDbj01D0yGTNEY0BDvTzVnsPJ6Gflj3yDSJz44bs=", "IZ+GBL+i9a69GW7OIfuqK16dWmKFW+2oeBr81mg1fu8=", "Dbcdm+hUgTOiYF1xO59QzHaMGrKCQwOxQfSy8nTG8Jg=", "E2A+XNIMEszxLaT30E6VVc2mROXZq9D1QX97uMbCRUQ=", "ADXENWBEOJ6NjT2EYZJDtX7DDOzDuox+5m2O2Yd8QNM=", "C6aMVq8PBF/uGyJm9TmAwxzuVRh/r5e2EtzZMM3bRSo=", "I/R1noz4KvTlGxoxIz3FJ39TqiQiQ12iaY8bZalRV4c=", "EgEoebn1nezh7Q4DsX7JSmrG8pGRV6uX3B1f7G+k8Bc=", "GRV5elS3A4M2MQ5G4vqgtIuj4aLUK4tYe6uG+AuVlOo=", "GQ7Rh3fOiKqK2F6OwjnYJZvw9R7YmWM5dZ0EU0KbRCU=", "JOBAgcFRnqw5kEOdX4bylnaF/oa43DekRE1fvyq3AbA=", "E0XNq0dRD9vn/Dib4EJWM144fT8k0qpzJvWTmaEMhf0=", "EZo6x4A9+9pVZNyBeKecwe/3hZespv2Vs9u/SVJRHnw=", "GXs1ltO2bK2sbMTYjC2h3jNllO5IpPLoLO79nIEme0k=", "AVdAy/W4DAWPZxq3sUsuC/OxWkTcpNZA2kBFPQ68yxM=", "I9pkSUPW+JCjRCSfDUmXAoOAEdxuRTXEeO/IoOfqGvw=", "I0T3ahvo9LukjZ3sAvqItu7gHRxI1+N9chC1qORxKB4=", "Ltb3x7QYis1WIwIrRhwmcgVO+PaaBexY/I7H8Kj8YIU=", "D1qRnoOhA8xipzUCgZ+hY0lNkC186t9hPX4Pe1auli0=", "FoUG+1riFwMx7kY3CK0BJMUN2obBq0ZPE3Edt6L2xOg=", "BlBkriwoRrHoxzlCvbHitALrl6OT4YpgC7jtvI0CmvA=", "FxD/lMB5rsVYnXoEh+4HT/pJ+ICrsU2d3dJznuat3is=", "KvNVTJu+WVs5YWZpyhmEwsFD0W+e6e0xYim09aCgEDo=", "IpZPw0ebIOcLPpgwbsML89USgFa2+1JeEA9oQ2bDiRo=", "Jd4LTNYcgZQND+qH2TietHPUafBBXu/YG1bSBI66y2I=", "H9V12hxTUtquI3sOj3ZyPUSjQTtJ4BbqEmNIdjEO2zg=", "BTO1avMpl2NQZFx8t/opweDDtdiA4l9aUndNBW6WWKw=", "Fn2IXGRb2c+0otY9VyaAALc9iDmGFvvb5W8jG4sryCU=", "DMLyQ91gzUHgSyQwyWq+QPIeP9EJ56GUYTGIBRa/hvg=", "A0FxW81St16Exg7dRykmEcRwP4+Bq7RfWPhv94l+7hI=", "HMxtgwGsFLy32Muf7sIo+cLuve9XePuI5pVxN08sJIE=", "JtVM/NUfHXbIpvZ/N9/ky1Nl4zAX+0zU1arf6mcrO4g=", "JEUxNECiCyllCgDi76dDLszNIYqLERpn4OwoxVm+csM=", "CCh81wmbcYpHPjotv/c1Tm9WpU+GDRUzsooMA0B1WLc=", "JsJGKDVqZ8CkUM9T9gRT3vpYD/vsUpXaxvJth8pnpx0=", "HRzz7qnW8jwXIgcSQTZ+6LBVYKevGoJf54hYdpIJGqQ=", "KabMNA3FCTIajbmaHkpvku0iUYcY4FCUaiEbmwsDUJE=", "IrBHLY0Y4iB8f6qBnmRqr/7AKDwGzMsEVUiZwo3ds4U=", "CspjfT9xOT9ctdAeCDd49Rm4Ie834TNdZdFLL61VVWg=", "DMBs3am7rFih4WLvXJEO2fqYYRY7W/9id2W23o4elxk=", "IcVHco/JZMF7ZaYBdtoqGoKS0NUD3BalxgUTv4iGPEQ=", "CFEt9S2KlDGbzG2qn4FIU+S/WPV9FvV5l+th1qGb/78=", "JcDZ/rDAKmS3U7ylfMaCSKXexBSb4rdZvdtTtvdZPDk=", "I1LTlE+mGixO1chOwxj7uuBesQIHVhLCaw84Zw5pmV4=", "JLs5Pe2z+BFKzcd82i50qX/4z4nXUfv82fUqQodEF2M=", "AzugkbxmXiaLZajyJ4qzET+MSum2oLrMtLhAlpo7Tzs=", "IctLRF6KV5xzQ29uCLaySHrQ9cRwbw3clUX6YuoCJLM=", "BKklrjQmDf3rF/XHk+S2crj1wNpp8Wv7KUA5JujX1Q0=", "LfQmZ2EKa8ZgKromdGJmh3B53DRaefbWc9ZPsn1/9Jk=", "F5k0OGpkI82zoQlQ+2XRx3doEu4ZyBP1pnICvfNsmAc=", "DA88wGQ8kFPn6Hoe1ZDeqKcObV69kHVDyVYdpO6fz2M=", "BRqFje/AQOrwhHvFcU/KPWN3VwnVSGqZXpMzYYT+Cqg=", "EKDak/XiTgLh2jtwPuzpf9Ogj0OgR2z+/XA3LWJ0+kc=", "LXvrQGeEC2VFaTX+gI9XzJcbb++34J7JEzYQPi+wcrM=", "E/G7tqhQy7U2oBl8AWpGcj1zh+mRtn1YqAZcPk3BjFU=", "BB/ZgJcdSJfl4/QvQ0LbEOUX9jmFX7ryHAuVkLI72Ng=", "CWNpJ/WzSdKQBnAp90BQyXUO9XJpFCSooKAWY6RcUDE=", "KvNucEAB9gI6y+B1djf2yw+suo4FFbDfXrMXod0OZb8=", "L5dVj+b2AEEJrEZYYJptLNGyLl3AmaLqEy6ICH5yzKA=", "I8xMD5brkVJEdEClXjo9C+GryDg02f4Ic/ydcUsOJtA=", "Kltr2Iioo2V42GJfW3flJ+oG243BtUeW2A+xx9spO5A=", "JyIL438iPILvMVffWWt8PyG8wD3oxKuNfx1bqq9jjww=", "CbktBcBZCMXZqvTo0jRIH5aEBmvsD0eKb39B5HOPlMI=", "EDaG2E9iCVcs24KbeqZ5Yr4BdSiZ3bcXgx32WcLi9gs=", "I7YnI9WO1cLGuoGDg6zTlkzzkkMojVkaS6CAOxW0hzU=", "GIcPQ2zLZaDh3F5oNySEdK5S/SJrF5Ihu/5z90fq4Tk=", "AoaR0vDDNhSLW18cXcBrQi00BxcF+aM/ryYTyQfzMl0=", "EZH8Y7edhe2spqJ9iOktQNiXzArQUhNuYLW9Co5WAoI=", "FmgLgvbnVdi0GdHjAyA0V7VHDY36IU0CNXnLbB0Jo7Y=", "GA/WX4xzfn4H+9DnZGwVQcjDTwvYoeFiOjoOODykIjc=", "BsesVN1A04kaFLSOdCoG5YfL37Zd/0qVXanHHRUiQbI=", "LGXJWnJXE3Omq3oYt/Q5LBrvKW61gVQdh2urbDv+ba8=", "DZwACKTwchTCT9DnM4ZNfFf04TwEDDGSO94+kohVK8c=", "EtOgTzQ5v4W2UlIho/MUomY7m4TuKQ5IEWnasrCkjQ4=", "LHXvX87iktBd7np+on7r6Hvt/mWCZE26D7URjP3yVes=", "F8ATMLtXCxyplw1YcsGqq4zaJLMw6UosldElSRaCg+M=", "A1+iZbp47+wbOJ1Q8YgBkcNb1AKXfFDSUokscP86Zvk=", "FGpkjkcViALh/XtuIRVh3jzhDfY0c8JU7S45lHlvOyg=", "BcLy1zGPkfA5irVBxyuavkzUgQWYvQr7Iw/Nyijw3Jw=", "GhS6ySa8gE+qsK1i+iE1g4cilP8x2nMG6KCS6wcKzUc=", "CIPNbn2+O7KTINsdoRdhj/n3YXE7eweBT0u61xYQ2J0=", "BvmNK760WtgudiS8Pjh6Gw2Bj8yUzp2W9Oc+gMqiPlU=", "DC7JjcDuZ22GLMBbCefXQ4n2hE70Yt4zb2qLaT5WjZY=", "JVGRz6gzzWqGKshp5SBXXo2nDaMOyXBlfDh4GnsAJkE=", "JjbD3h3XeeVXfeIUs+bGNRcR6cwTSNvFU74cjWi4sGc=", "BkNwN5NyGPz05zzpszi6ygw/6UjDmM+fy6JawC5lKVY=", "EAhVAoQ0AXTR5HrFoCd5MxHEKGfjtxiySkeJrPt9bck=", "FSuZFZ6H3W5oGq7zi/cpVBm7h9tfn7DL83Mg7HJtRI4=", "DTgq3psoGi5ybLlttU0m9DMliBh1O4jiZigPdNjcqAY=", "D1ROJFnmpjbY2iODTjF+qa3nsqB8SrlMNo2jVs2ITm0=", "KmEir3wc8pRrM3NdKp9QIMxd2GaVKed9AGnbNkzLCMo=", "K9cQY4+gn6cMsKq2vN5WysrrEaqb7GiMAz73gw3QzQc=", "F+FysD8lyY6WgM0Lus8ZM6lC2DTZRfuYgPrpXSWUk54=", "B1msycuXWu+xioM/9MhN+DRu9jxOtn4iCxGw9TUMYzE=", "Ip9B4VOkQJ+iwMfHWBGBPYpxkw2myLG4gnqmSL3Opjw=", "DTFT1tFECqjo3AvxBYZnoY5ZMa/iT6kKwZEf4yLT2fc=", "GYpvF5+SukJ0kPuQuM80VfafArdW6Y6wfUYBpSx3ozw=", "KcK+B+MNk92SfoCqScRN8Nu18FBulmdtLUsakVcLx+Q=", "E+dbCVrSGsnRB7Kn8eYgiJdCQFScC7Tn2DzkYwzavc0=", "GG0eJsTkFciqswXxYvANindUzBp6Sl8vMYt0N0ZcqGk=", "JEYuF7Kz/zkS0OQfF1DP8WmAa8FYZI2oIuG8n2ISiGw=", "BMj/O5oXT8BtOzMC/1fFEK04WAw19OO1r3niQFVmK8I=", "F0om958m+nxMJoLOwU2nCu1J/nx1dw+HpStaZyQTKJ8=", "F5TID6IG6Zhi1+GnU9d1T28XeVgahSAf1Gpb+3uqlS8=", "AltGMtKXcGZ9CfecM7sqilr2akSdbTn2/b5jyXbhyhE=", "Ea333vlsU9vf/QaoXWMUXw3SOVBj6NMyvkLqmco2hUc=", "Abkot/KTvqsDI1DdPqTEtIxKBP3/CCtPVC4JTZc6OZs=", "KBGHv5ikxaa/kCAwksauy5/C5WGXT3n3SBqm0pkYMro=", "JHFozY/A7izJ/qVhvE4BrT6leHR1b52dc0p/vEXAALk=", "Iwl9dBJeBCeOX9DhT1LuGTa5AcLeZKBbK4CZGh8/Geg=", "LK/f/2QiI5OZdTqWEQ/qqKFWJku/WQE/HYGVowg45kk=", "GlggKA0cxm4su5kyCinYDnhEV2N3Y22MwipbiYOLXoE=", "BDmvGRyCR3W4a2rpzd7WngrFJNLXlTvOZdxU4RZUakc=", "BZIW3OBr15ephwmtK5DBXR+feBd/CtZtUACXJe1oZLM=", "F0U/2M6XxgB589AKopvoubkMvMmiFht871LFmcYobNI=", "AjoayPOgfIbpMYTF8IK+UamPcGttFGfc40S/4mY5fsc=", "E7e/061RkZDUm+snsA3zCZH61AppTvDfEuidYXJj65g=", "A9N1RhRyKLX6+VuggLK0AialiBBGMgi5s5Vm8HMWPf0=", "BfO8+43ckXg1Qwoi5Qz7UTlvFSQqX9DH46wVOABNGe4=", "C3VVj5JWf8HsVOmVSjPvr79RhmpYlKdlUtE0lSPPZf8=", "CUFRg98QMdrSMpfDNO96JVgZt9dDZb5PNTqItCfZBpc=", "LcLH8ZtQJDFc9bDHZUb5Qy4GjvtQ3TfDlfuHRHccDjQ=", "EVpawUj/DCmQEiC/W5y9PV3pqQLIxu/QL3qSyx1O2l0=", "HseJQusP7RaPvlW3MGdfPd/KtpwSLZ9soi98+nIoC6I=", "JLxGDGlyV7swVStFrTcxOYdzniUHnChC3N8vl0+btoY=", "J4orKb3lS14dD4chbeSPUdTfooRVXr1/5/Pd3CNNGls=", "EPXEsCr1CHd8TNPNDGwR9NZ5+zsNelJphZO/UM8gPLQ=", "LWlTJPiFRFhA9Sa3HlGfKVz7Cm5PJBRflS2Lr4Vy9XM=", "GBE1J1NkNLYx+zd3rHM6slDdvpcdpQ8T+mzybJ4FvR4=", "BAcw42hOOR1aFmtUh+8vpCqe/BVGKc5BPJie/iyHhZI=", "Hrsh2uavTcfYC9K7k4mCwhXKEksV4Hl4g68qgK3sShI=", "DGgCLrY8s6c4WbV3tZsX5vg2F2xZXGof2hJKBezvwQ4=", "CI9KmvXWaEdbuqNWEL+sV5DhA+9TuaGzq9u+KT5W9a4=", "EyXi6E4oHKrof5Bd9xnrZlFz/ILPzkN0PrPw0fzMmLQ=", "Lz6joipW25cMu+2q/p2F8U8CRWiJtkq3EkskeZeO0+4=", "BVVkt4Maz9j0bflu+BliKkRiv+goGwXpVVdZgWfunzA=", "CMKemiLsfwJEknOjUTaUm3PeZoNOPwFfRokEOqs0EBU=", "ISplSSxuKZJIQWDl4vb+j+x1gSVmE7BbjNQjfqWW3aM=", "IOYpu1tsHvB++i/B+PY7EqqSv7QuOOSDNds63yZ0Fvw=", "BAhv1sISixGlqlj6Kosl7V5Xxbaj32U0g5qBcpnOdxM=", "BlJFz1kUjvPPkj0oZubx9h6lTmoOZQtquMm/lNzx6aM=", "C2wbG63ADmDcfihr8bdhmOYaBjz9wmMPdWUGSvF5+lQ=", "Ajo4Kd785E3igZ2+3c2b0XzBzCTV79lDRTUtFTyJgJc=", "G1HVC58qHOA54b8zpDlfaT4Sy6mqXOr1/AxiZepEa98=", "Ctori/BpsKhiK+hb7FzBUCR1vMmVpWhwI+oz06lJOC0=", "CDJiCjVeExpHnRY71wLi6WqrNoj4GLVK03h2SuGi08w=", "Ad189REC6osQSNPfymSTCNWfZfTzcL4Acmz1yOOnL8U=", "Is+erdlYCTXwLNiniJeMU7tM14CyYseqC+tn3vXRl14=", "F+O1YFUW2xG2JRI0j45/IGwucf1Xp72f6Wgyr2v3IVs=", "Gq0cvdGFvForvc7vVw7bmGUg65K84rJlq4hkxRrEidM=", "KNXs7Z2eVRXQwpuADjM79mZiqLW5g5hW5AlCIt+049M=", "FWYNjJNuHu7tsQQ3xMrlRNvBub4P3WOf7/0CRqMT6IY=", "H16PP3Fcug26bxJx4cyJQLNzBSRv6mKqfhbDAcif4+Y=", "A7w6ExvOpbL03bXNWPcaksVJc9pn87au65wrKx7TJig=", "EJicIYFegV42lbHobqwK1eaEaPNwZhQtBC2VGvoBNgk=", "E6FHlr4sYr/O84msy1CVKkbHVp4AkgGWXxMiOnf+/4g=", "DzBxSLdp1aOqDXC1RRTR3lCY4HDauYbALNkQBcN6k4U=", "HnIMVCuDGpeIYOyogK1SIhBWWgZYhLgv3Zq67T0iS5k=", "E2mB/E83pd29V6KEOOsAPKf/AQmzScKzEURHv+ZCDV8=", "I8D03KeXp//u1hhbYnAEWulg+A4f+97SNJ94V978xeY=", "DK3sNTLu9uQ1ZWQ2vffsVoU+3y7MHcqzPlhdf58z8hU=", "HT/QzdypZ0nA52sQlHR/ZugiuwehoBFQbRmOuAuDFCE=", "D6S/V1HgXLGHmn6dG+GMDPsHCuLlQ2UDe/FStFrAhe8=", "CAHEUApRG1+bbwvLbestCJij7p2XJ88Ce7F7zteZImM=", "E7JXyLcZTwzPzYWbA/dFHN6DFHmBFawd5Zgcy+6ljlY=", "DI6MsTXdOBEgCHN2oDw4bmeHEADaKxvAK+lRMw96VnA=", "FldirIuuZvPzgH3ZJaQzTocKm4hWKMt7wLi3y5QcBw8=", "BCVDVWwyWljjrHU/SlrsQNPHOSbp47CmK5KluSDEfMA=", "EIhBN+hmAL3wb4HXkEXqxsNPWK1oe3mchJ0tEq+ysAU=", "JDqpp9NHjrc/xcEQezm+zZgIxuXkVTOjsmfOphKjvBA=", "DVbNT1grVxmjMBvnhzFCzb26w5AcM8cfSQop8ZjPg38=", "Ab+3nrNyZNZ8ErxLIU/XKNat+E0CoIFl7MmChoYS5QQ=", "CCs4A3uWpH9U/qVPT4UUMPfHFnZstYwU89uO4dqnB7M=", "HZLvC2fUapkd5gPIKRejK3sJEUCPjIqyg702/Bxiung=", "HoW8yRky+coHs1mEpBxL/cokOhUUQeG3WMWkwK5roYE=", "JeMPbYTamJ4NTQ24TPV3Oe2dHzVMjjqvzAG0eALFejQ=", "Ee4N0wjGXtyIzirS7eyim2YA/68wn8bF46PWMYypjIM=", "GPPKdRiP/1J0IkzeNsLYUhGwlMIPU9njpDUYluPRocA=", "BbayHB9wgDKRG24NxOV9Ho7cvdFEECsoyGF+U7EeTns=", "AOt5sHvL3y0iWBd7/RW6Q7xW2TYuSfE9ACOU9sY18g8=", "HZY1cc5zE6FxELF9ZNRQAbNtILSGn/zuRO5XjSPWSI0=", "KMRRROrc40X4c3i0MrzzDp/bQOL/z2H1uRjjrULM8VM=", "J3ZTCZOhH7flIi7g31Bb5eV827Y1L/eFPmaAB3FL1xg=", "IQpwBEVqTH5WZC55QCMIQv1Ut/vbjDN8sUk1Yed4/o8=", "DMHLUZhqsaD2KMEtfGZWqdhJXbkdkOXa6PDdJk2fGbo=", "E9Hgy9ng9CFibI2wndJN+SwnBojnAklSMdBXx2dvsd0=", "HCta1Fz0GBYR7aZwYKBJDY1q480bEKFXCwC/C9Oibgk=", "Je3BHTtebpaMqaJ8NAz5NQdE0okg9XYmh9LTHfrhQjU=", "IwyOesP/Kzna66J4gRnNWKOpCpwkw+2CHq/Qg4PziaA=", "KTfLM8kwrEvnh7bokOZ/igjMksFR9+Zz/7zCeyXNCx8=", "KKOsZ3tvGazmnj0GBJVX/eKpJHbBmeHIGckHzkVoEuU=", "Lew0Hu11JKJre5G6swAyM0cDjAEgbg94A0nlwsokcHY=", "DoPJ9oxf60IQ1jOCHMhAvR+8vth+/96fI9RAPZuLA+U=", "ES+yEYVZjnhb/w8PfkghKJIyQD+ysxtI5+yQIt8reXE=", "H6piHwwDn9yAJMvd9MqBdYHG4/Jr3ieLE8NM1lG9h4I=", "BOPSat/LTvfMMi7lV4eGBupbU3+h+IBEXGR+jRLJjJE=", "GnDCAVvxxd+mN+jev491njCfRsN+U18MZEhplepbkGE=", "Io9g3ltfOuilK87ez3s4MNW2h5/tfu2VIxxnTAFsf+o=", "Dk3cUS/fg5rEi33bA+dl6c9eMgdFVypdT3AJfBB0QGo=", "H45XLi4LSPm2vcR0IQocjfZVyl4Z99E7WomhhfOjzqE=", "A6GDITFRwz1sWLZjHK+gwFMA913rn/lx+v01RB9crHg=", "G32pgIKASKdJjN0rSewIvjutfUMnyXVLXj/WdOAsgoY=", "KF3Zw73nw2GhbL8Uv7C1p42PTORDPUHxOjcuksNeIbU=", "BvlS1m1gzRiUnsCKXCA3B/9FLj3zLVCk4iHnKnk8ugY=", "L2hD2giPZ16nc6A3fs/O4zyWAa2luCVrSfLCJZq4q98=", "G+5NnhaKxganPXmpkMWQkAASqv8DKRdHVTeBOEwo2AA=", "DIyFwDINaRGrZaUN6ysoJdPjOSGkZSLlTMtrgG5V8ZI=", "EZ/8buSgAOyLa9F1vJlxjatlCOmZV42F9X/iKUYSDVU=", "MA0OhoHxF/tJGCf6EhASBiVOz+WnCwhxbRlQtmNc/wY=", "BPQkwmRxkGCG2tLeVFKzFIqUgKZE5psNLGqONXIHAYE=", "Ku6ghDvm0mNwBnLEJumCDBbwlv3q3ve+scQjwE7d3lU=", "JwqgrlxaXd9oW8QytHyZburZ6x7YmiW+0rs1jLTttvQ=", "C6T0L6Q7AF4x/i+/J64d8Bf/bRHyfPlSQ2ODrJAb0X8=", "GJrJ9Y0lmR0QymIzsa2MxYPMHCR5lnkEqAH5LE2wiBg=", "CsfCA7WwbktvVt5F+9nlAteWYrPvTBIvc/ejOD+1KvU=", "LtSCvMtKfIp139MaRDt00eTvUiolBmA0TCGoMgpHjP4=", "D06trpLM8HHc231nJB24IoagtTQ2Il2NbQbDCU0DK+g=", "Lz7kp2cVs7w/63TlKJSP8VLQtpyueqow7T0lS6iTGnM=", "CmZsy/pu0JxX9Y7iljQHI2uOvhk1cp6BFomzmKnde0A=", "Kr+LnlUzeci/aPvGemfe5aIt+XOTZzFFIR0P6fXvyiQ=", "Hg5KUqL+AR6vqs6D1UuS5thXY0tFEBAZWOfYBobuknQ=", "E+5z9lJazFIKCYfBYeUZVyO0eF17pqAxyDV/1V6nVA8=", "CU/ywkz9KFnvZsT2Jpb83H7bk6uSEnymInpsAp3hnhE=", "Am/dQJK+NwkvoT4C0Ds8k9q7f7e7rPMSk0QGGQlVbMc=", "Bgyw6/IJBnkAmNJg7QCnVwTojjM4b0PichVIiNVv7+Y=", "CrD6jM0oCATFN9LgmuxMEwaxp7R5xmI+kSg2TZKX990=", "E90i5h/16eM4f5BIgDfgbEjPnse4/ECy946DHpd/PRM=", "JMYq8h1hzCd+0+7La1PaQPgkpryGGfgwpaW/hoRsHUE=", "KgJceIjLDsaiM4pL5XGnxnvff33PXAd1t4Wixeo6DGA=", "A1wf8HewFrgGnARKK/XMCYA+lO4BEMF6W75ZTLsnDhQ=", "LyllBb8TU7I6ZyeRpO4yWiip4bId2wInjki3yP01TRg=", "E7FsPMDKRwx1vCrXv9bL8LZpx2K/BBEBAJnBFi4mqac=", "LTyQC6mp1UlPztXXDopArLaPR6C9JSHzgT74MfaQ9a8=", "DOnl8x/rCo0g6xq6iQCDzDCSc4v8GW4Q24zDSzHxry0=", "DaQTvGxkpS0Gi7xmqiUXwyPOLgDsNlI1yrsiNcMsk9E=", "GJeuGiPfD5n4wc1NSAlYuVnTJ4FuannYP2TxHyn5om4=", "DRFt/lNiEjaEU51oQYJadkwFPe5ttrK7XTWWZ2CiMtA=", "IeJZUumPlhW2lrTNxUA818xDKDWo54rHJ6ZGdLNOQxQ=", "Gj2tV+euIFpI86AkmExNoFAbVEr8Y66igwImQtO3RSg=", "Gb0++gpgkpUe5xsxPBts0rAW8d7LW1HY3BSSfsdw8YY=", "Jm78QqMM0E1nePUKP71cUdvPzvtutAD4WnoniuGE44E=", "HI2Q2F72S/S+3eYJlX/03QB6oF6yotBOB7AwE9fJC2o=", "AqwG1M29MIR6n84URyrjIOHzYlJocifggvITshnnJwM=", "BSLyybCHbSc4i4tSpRAC5f4GafM9oHAU27jAqOKehc8=", "Jr90RiTOV1RhxGYnDDx8sJ71wLg0LYZZhf8i0XtHI5s=", "I3UQD4aPBuxhTg3tbZn3FKGzFZ+BBJPIRu7CXMLfKFQ=", "C/RhFGtGs+c+Dt1JNpifQEzqH52aBYKXuUzerHdYMlw=", "Dpg3btZBQl4nFvrv2O11RLFzxaOmaTYgnkr2Ka5nccQ=", "L5xNlgVqE5HYnyhyCiDQoefLWaXJOoff5gabX07KJxA=", "GS8gC/O1VbuseXgZuyG5kLcp1lpNKKJ9bT8A8aAqojo=", "K/iYS1YmrM8Qt2Z/T9zNt8tgWgrjTW0gSsHLyAy0kSY=", "C8ohwSRkJHJEsqGf0w/tZfjjq7+DNbSSBcH8wfaqwao=", "FAeNTuEfRjRxpJUWw8hfmiZvjED217H4ax0ZNbCfFfg=", "C7igTs+fmOFpfTMOki0Mir3gAAtQtapXxYANUt9N4BE=", "IVJhIcBeCaCr0spu/ltC6/fpEVOCIhyqrmKKM0kXsDU=", "APakQ7Dn67C/d3URUS9mxeW74ETJZl2WEJAY2XKchPQ=", "EAknUelPtrXkm+oVigFL2ZB4VCRYrxS6TL2SWLis0jY=", "ApOJkD0NPCmhc930UqZrSr0278ZCywtX2PEIGdXA9fQ=", "K20g5sx8qRb1QmaHJBedjQ/wdBw9UfdFReITkRIXc3Y=", "KQC0J3+zoP+DtMWPrHmohh4wXV6zE/LPV9uwWTkDZVg=", "EK/cAGbdqbZL3UO4bQ7WK5s5OAB8xQ9WmSUCQM0u4ak=", "MB7RVm9SIOF/vUCDpXv0LBLBWmZHroED7conL71fjxE=", "J/GDMinDpZmGhpA+gkuz4+ELyWnxNCqw0C3mNf3a/xE=", "DE7zX/n5BtC+pInSAcIQxTq71HoVGp5O+9uSICn7ZK8=", "C6Wrkkavcjv/RXq4IovgZISvPjVF27TJMspJEV+VfSc=", "IcVyvUJk2CHF4q75kwBkmciLMkXO6Vk/AsJQFJroesA=", "BNHMR5UAhxkyb4EGyc6aSw3eT03gHSQpojURsf0P0XE=", "CjeffW7tynxPB7td8tjqDdh/Hu/irCJxNwp/O+JwZc8=", "KNrvfTekPyukQGXyITkS6rbIxg4/dWD8qZC+D/RjlyA=", "KQbomWRYUE8sBE8FPErSTTWw4O03OyfgLlI1o9NPZcM=", "Jgc4s9CnRvsGEtym21O7loxVIhOy+aE03zQbrz4TecM=", "BfF3roxu7IuXEs+gQndmkOkkv0IkMAEe8nr4LfCrsjc=", "JoEQJ/RF6GwZLorjcdLoP7c1YcjP0Qu/Wymnf1ax2V8=", "Et717lnBtKlrUKs942F1ZAy3A2P++JmV80km7oS+UU8=", "BptYpqpBmUoRzH3TpCj2xM5iG1sGeT9elbQDTi736bs=", "DbsWL84YEr8qFq62qsfxc38tJ2YMpM3255Eh+/u2xeY=", "KHuoSqUIfYzJ+JRQ8f45HMOoTyiiSyYc0dzasDmjCfg=", "HoeKHy/HfL4jKup2g9RtiZbeu5ywavADhJ/QmenFBOk=", "HI0e8kbddfQt4Txb/gacCNavmUPNfyM28xyJZFbLovE=", "B08aZ4ywKUiDVty0d6iDA9De1fLV7OVHafFavBmUU4w=", "J2blWBcqxwsfPdhfTIBRe6bhhVa/UdIPaHtmnngV1H0=", "IGNjU+KfrOuu5fBO3kL8Pq0NB3J+3nqArxxQXG/11TQ=", "Ee2XWqPT+brB4LqxIwQWcfjbaV/gdgH+WnHg/MqRa0Y=", "GBABYEGP2Fjz5P6NXWuA4u83Zhi/5aVW8kvDJHCZxEE=", "KryhjZs/JSLiHuV6HGY07BJ3TQQeZe+EMCJM8x+WDxQ=", "FmJSQVM8WCubV/bglj37uppwJhOdqrMXT75xsNlSLI0=", "G9PPG9MSSrqmJ4UP93pneOjYLQfKJGVdlMWie1fHgLc=", "CE566KUVu+b9g3DnwT59CYNcN0ntIcKELnxGtL+tTjg=", "AQW2T9sPApiHMrWOBtuACy3wmnGltaFlrSAR6/SKZEc=", "BD7UNta5r1Z6rH4kIGE3+qCG0YjoREyr1SNJg5BLzvE=", "JFHLel3sH5P9Kz+Ll8Sx3S/OfIfQqSyfaZvFUAMqCns=", "GPN8Yk6W75xJTS8Ba7HtlW75UfO1dCCkbHFgvfqldsE=", "G/hNbXDHSMzZgcIbGdVVznw4QfNCIMEHl6929i4liYA=", "C/mwUfICHziilOrf0IEfBcCIUnIL3HSeH5picg9icZo=", "GfH9IZnjqsiMfM192FjRWMLvEOgjbSzWanCj8NGHmIo=", "GvnWOs5tt6iuIKBLd2+jneNLeVOUIxIUMX8DbllU7qQ=", "GzotCNHDdjt2eLnZ3h/uEM2oCTf9fXTyfW5VA4b1RD4="],
      M: [["Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "L+Qp24Bo5huCYk8ldmJzzZ/mNo/wl+q5eqoJvkxjDic=", "LnUIZ5QkOQgzZdIf52DH3+yeNZPGfeEqQlXGsBZItpA=", "IyN5halrF3/3wBSGqw1gPSmZG4Mkq9awfbuW9cIboX8=", "FczshXslk0/9Qpr5LJENsx0A3Bw/uDdFox2BMepbqoU=", "FxAq0tmAQ+VQnnbDMeayLV+2LQdHYIBqpnV2RmDrVtI=", "Ck7Kq96dHqEcgdr6jV1Iab7nrQv063g5e3G4+YnPmBI=", "DsGCFkj93ESKFRKuzIrDdxSSOYGUD1VCc3pGjU2IfI8=", "JVpJOqS+zZ0TfrdpQcQSB4TBIz9sX99dZcCDKvVD5BU=", "Eg9EZwMBsUNSSSlNmDPVngFoKvTIZYcZcnZ4/Zq37y4="], ["GruVtuMyQ6BQ5WO1xP0FneVRPsKJlKb2DlfJjTvI9YY=", "CltgTJWLyQBxrRBhixdyWZ4Mjd37ZBEx/vOdqlijmSM=", "JOgt9Yc5U3krrKNFt8GfYQOa3rEZBZK8oYz0+QfBpv4=", "EOM0nu/ToRJBfhEP2egyB45UtfRTfNAYruPfu5BUFYE=", "FlrevgDHugGUmQGMlvXFhw7KVnnJDIQ9lScYSlJfzKA=", "AfuBIY/u7fTn4OM92Oy+YtZca31CM/MuBzVx/4YticM=", "G+KAL76lEAOq+ugv9EmdEVg3exCPiwIMgrhGCo1gOvo=", "BBgIHejClYNVoeReKO5RuixmytBINfT72B5pbeY5h2k=", "Hz6TerKfOojG/kOGmKcZilIJqmrJ8UExnzuyAef9ZxY=", "ARPpaHabDqMst7X/cEhKrMlvE9woJ6jl5hFpXgeX/Dw="], ["EQ0hOoNkeKowG8H9Tt04hQfYd0Wzq/ulvygq/SH3JCo=", "LN7gxjWk/NlUnw+RtPSptiiqcxni6qCUppOzi1z5okI=", "ANYPBYV1XUhXe0ZXRt6OKG5JklFQ8XhPKftrltvY8Ow=", "IWjc8hbYNppibMxhRTI2o4nQJRnzBS6H7/nMuKopnEY=", "A1MN2WLvI9wW95sowfwd2v6UWL4VF0y7vzqAbeX2PO8=", "HO3G1OFHZ0HBCZVX5Y5kLEKJKqNuLQp5P2cHgaIbDb0=", "JpyME5pPYeFr+q6ei7scaYCMkHEIOwoznf+eSQS0Q9Y=", "Dqe8UlA+IDnSd5EuAi/W0N7VvGh8b/lxlJdvOii9MMY=", "IYC56xVuszytGqdQ6g+j3b+kEnKW5Jf4bmRB4FKiO0U=", "GM0UcUMK2tMeRbUpSU/Ip+MZvS/AYZyZIH36zbZXu/c="], ["GO2y0QW7U7dorgE3hQ3C0r9tEwOh+O5Krfdtj4GZBYg=", "LJYtfVSpjDqCpjjYyCRQgT9CBxoXxsBfRwtElY9X7xU=", "H0lekwFDFJiNrOXk6Gf1EJ4J+gD86Hkp0eDs6VpEk0U=", "JikD82rPDcBV9hA5ffB5T7wwkn7xhcY1a8M+XDH6758=", "G36SKz3VA+ZEGtqWbIs7p7kIyyuYtfvh5ML7mCRVuqI=", "GoiuL94SujLl9OzKzxHCW8Fjve2qqIJEdMrlhp5ewg8=", "I0B3KCaccP5xKwIZFQWdyNwhJK5kjiy1Sfx2NivCuX0=", "EqsxhibVEcI9KLqp+1tYAuCrlePLF67bqiX00ITP2lc=", "HMadjzTuh3g4lQ4gqdTEvT6ayvPWk6pkyuBPqiJaLh4=", "I9D6ll6SDfxTC1JnCx4y4tX8KCH8kYwIRKADtxQYJa0="], ["HlPpLfbFPs7EwN5bB9xMmgxVRfKrzB+r9My4SgpuLCc=", "K8dhGF9Z77e2e88dPlTaANrqBn/knj8dkzTlRwQ4tFQ=", "EkMx4Oyx2YCKHZHvqpiVCr6TDEb+5aMNWtB5dqW8AmM=", "AEaIdyTykyGJXC74vAz1Rd93PAS6oJfDUqQWU5XMp4Y=", "JHRgrUWAoYY56tppuQTJGxn31Dh0NXB2lsQLrDv73TM=", "JlQSpOO1Vgq6UC0g7YM97/cHt9QlujwJ87Y5K28fQzk=", "Aq0G/J+BaEVC4EWKrhnAp8GL6U8d4/zmo+XSM1oB6Q4=", "DR40GSND1m/BtlkctqOwYCsINaQDxyJ9vL1y/YAAxvI=", "C1ZReYh+4w44FjHY5d01fHDuLrtBBhfSMh9thTf5iXA=", "LqazKvN812XXKN3vowkYkCoh4ZspFACFT1Y5PFbWlGA="], ["EPy4F+EPafcHTmTDk7gHzd3zPISotc/jP0S3P+GMDjY=", "LkUNH+d3PJiJoL5V5ERTvMhEyUtW/Au4BuuZgqxVNCg=", "L0Ifz1TXfdOJMM1pB2+bqt09PxlHNxIVpmyJTWN+ibk=", "EydggdsBLR1PS33S2KL4pRgNLswzhUzdNfnOsHv0DVM=", "FE1b441Exb+PPFc1M0+xoHwTcC2Grzm6C0Ig7Jp1aKI=", "EmkbWZ0y7cSK6Zx6c6vVnlsY9L93P6EFHKvSxJqqv2s=", "BXilXw/aKZCbn4UMPXS+ZmjkRErGkXZPFkSmJkmCGOQ=", "EuOwSSSyz25Ae9JrPNR7ymHW/89++hrqHC4NikneZL4=", "EWKlbtO7u0tnYKFqMAunICEwCG2k1ViKcJJkI/+MJC8=", "AzQMrLBNWoVhTqzEvjNSk4uqP8cUwldaqdhfc5ETxQs="], ["Kx2MEfxlLFk1Q7b5gAu30Mk3He25bwi7vM/9xsxE25g=", "JcD4fJRvN140H3L2qN1jqU6G9K0YJxW8/L8rKN9rSg0=", "BUOyvGbzstk9TBiCA53bN8cMC0N6wjrFu5ho5t8kSF4=", "LdEXIYU46KywMB60Ct+iQ19b/6gCj/Uvlqmdd/6ScGY=", "JpsGsx6J/xMtrrwgDv3IqwaBNvzmXy/FWh3Lk5t/xvU=", "INRAHLv5KHfs9hbX0oVRywrsVS+ulRjc+SGMOMGgvJA=", "LuLaJLf45wNftzsIw0FIM/+jjhSx+qwZioYKV2fS/u0=", "Bt2J+r+SVGhHucE7Oja7x+Z5xbsN14VAPz/0m75hyOc=", "E2D3GQNFcrWUEMUptipiqpRWVlRZfkJ3nzNADx0X1lI=", "Ff+CfgNMAqkHZ/AVKEDn/G25g+SW6gUZwP9B3qgYBig="], ["GfRz5AwFZ21fjVHhEzbpxlyzKCjDl8yBJfHcZntsrfc=", "C/5vwI4qLhuJEa4GW5hTiPzRBaSQpKuUOyVVjPPQVLY=", "ID2e5kYqWGkU/n2/wb+il3O3+bPWOupBIMYBEpwWZg8=", "G5Eqvy4WSa1INMpbKjgxzJwgfU0I5L8nSnncqA5S/iQ=", "BiyqPJ/Tm2mGT69wHcikWIVxyzG/1cnDxZ39l+mfcBo=", "E4wDouzqGDy48mXuzX6TJ1sLuYKXwVRachl9xt3ZM18=", "EViZWfwkkykvtsUHMOdJlK181tNTPDsApX2ugzzHAeU=", "F7n6zb50fXxRY8oA47C4JdAS7UNXYE5xhXUNZ3xrNX8=", "DGA9A/koYNqKaMbcsZJNGkUJmupQ8aNi7bLyp93+kP8=", "BdVvDIRNFpJIUDE15N65/9YynVTPzu1LlH14pWhoEUc="], ["D886TZxsM5LeG9/iXPuGgX7LgMUb4X1H95dQIB8fzQE=", "DBguQ4JXxK1+e3nDto1gmE5QesWXy0fcMdkTp6VA/Zo=", "Aloey9fniT9kbzXT4H7pl8lDVHN4hP5sJq6BVXYNuKo=", "IBNf8mOGf3CO4CdRcMyXiGicCIspM6Nhx3XPQwdI7x8=", "IOFg93KZii99AGTH76FYhOvG2LcYIc1TNuLfFDQcle4=", "FQ3xEpG2gOO6kloEccf7sw5wSrS1VOpdjAe3CyuWICo=", "F1cgKejolyAtDmXCFyxXHUuRyoVuetPxGK2SISe4cFQ=", "Cv8VZQuAW/9vizUV1eKc+RS3NJr4kk55YAn4pPG3Jkw=", "GpGPwRfZpkReNj7lgz3AFBEDS5U4TZju5HrolvkqfWc=", "LlYYQR7+owzH3jENSHJZfQh8HhIuAuuxF9sMLf8E/Aw="], ["I7AtAP4mNIiWc6fQRzb+Fbn2JlKxwGJqGa+NYIXXCCI=", "L/TQuHmKgmZ3k1M3MAg8JSI9WJzdB5Ni8ejC4B1UR2o=", "HYl/YOh/zlzu2Np/L0pj/e5/+dzxecCOBenlzdgjisc=", "C6bUzu4hgtPyqy5KOtCPwx9/TMD+yRrVPpK/ito+J48=", "Bc6UuOmmCyiUdxBGHYfHdXJGJmro+l068+qBd2tbjAc=", "DDRrBGrwPLkEjCk1PhEH1rdeWQuy1CLqg8CaXaG6DGU=", "L7+Mxux++zAQZCPy5nsKqUAzYOVuiLbFy67DSoC9x/Q=", "DQZOckSe/BHR6QuXdJ3jkJSQuRK7H3L1QvQdYqsthHo=", "AqiODDVhdmXzzC/HfZCvx6jRABxx3rzyczygxxoZ4eo=", "Fe6z4FQbzwENoMR62xL231QLl01DnJPhnqTQL5l11EY="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon9.js
var require_poseidon9 = __commonJS({
  "../node_modules/poseidon-lite/poseidon9.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon9 = poseidon92;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__9());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon92(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/10.js
var require__10 = __commonJS({
  "../node_modules/poseidon-lite/constants/10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["B1KvPG/cyvOGgnZoXwppuXSeFwaoKRe2TsLvhH+ARVk=", "BpUD1BfiX0Vox4WLqDNDAcD6GcGzSLx+GKTBrOHRVBg=", "JcGxIfM/TPezCOxGMPJ7YD0iqoHKNZXoAcX6fZdwoJY=", "I9a1UUW9sygnwUVq9Ne+TC0hPoJcHS8Mn/mbInN1H24=", "GzV7zj7z8rdq/CtYBIBa2xTPa/N/4jV8eap9azKsrso=", "KOxawIgcHmQmukmUCYlKbzwnb+Vonyw1yQJ+gJRId9k=", "LJhiUkrIoHtH0hHJxQTIsL05jQKKz2kOS47UAF3Qbu0=", "H25vCsSut6UjQ/MEGAeLQGRM1D4pDaC67pKJHEwGWsg=", "A9s1F+Iz+KdtIbL7I8hfp8rMV3dp7eoJquOUB7mvL90=", "D8Mz3KQYPatHnFli6wXuS3morG4Mzp6bCiFCJHv9CHc=", "Hu0oGXioOVwEKJuGGXZzsPK2XhoTUmRSfiUKXN+ZrKQ=", "JWi99lEQNDQ/tdXQIeBS0wgJVP7jV9yjb6XXjzO1vj8=", "Ha+t43TmMlHeypcFkdpKKFpj0Rz+ZGYfrdmgAd/4IzA=", "CvJceBq/VvpM1oM1gOl8emDqqX8dwytiLold86aRWzk=", "E1AUUct9Pgzzy1d0H76N1ZdXyTZ/zEj6Ed6xNUJ8XBw=", "GXBF/NzxW82yR9j79shcgPLQZfkjEIVZoXMNccc+Vs4=", "GjkNcoE3X6wkm5hV+MZ6J16P+KCoIdGzBcTNsTE8hmE=", "F/Bwb34S+wItFflCl8e0WUd1Xl6Ex7mVdlm+HeZLc3w=", "Co9fA/GdSXmbb7plDAbkrvJR/8dSQ6jXruiSTVY/fkk=", "JMnmw19PgZ9bwe8mV24W0sfHIGoFmARKzwwY/FBC8OI=", "ACQFynDVFVDcFKv+4Y44I7npeQcjMNVHEzoUsl5GH9U=", "HqtM1W8UdLJw1QKUViHZPkRmPK+PHTHYaxVuEH/vOMs=", "BmuXUPc/RWHt5Vk5QH50tJfU3u9Zi4c8S0ofMq5CXQA=", "HuPfpZb12HAwpsnSfWHdF1snEXlAgjXxO7P4TqKOekI=", "HqlLmsb8G94p1Yk/3LZg7WH/eyxltjikBG6rIXwCquM=", "ExOINR8HltR1POVk51RZHLG64Cot1Uh4KBrG56PAac0=", "GkWgF/2+U2GaKdjTHyfkCPZL4QvwXOFskK89HxOIai0=", "G0oNaOVDErn6Z1UMXA/w2I/leCLd351Y2dIhUFeqlK8=", "HUXTaewDmZBbsCndn+C5elztHSnHtaOdo1itImaR27A=", "JhVMnFHfgFl0W7LZfZqbjMjz09gT3Er0FK3OHWmSDo8=", "K3SK09pDxcuUEsxkMTyNRxElGnCA7FtZIG56yMcBcw4=", "F6VGj9seX9rNnJ/Qp/X7dW4F8vL7QQSyy0jYMP7RN1g=", "Jpel4iVCEj8JI7hrFSmlQF74Cd4D7kEpsrruXLO9lOY=", "CbB61DNw/Ev5reYQ4a3dONnZYuhNjdsQnv26aZFt1Ik=", "BpwZS1ufIwG8SNY2PI5a+kp1yi+KAJ4VrUyhGhfIGh4=", "Ghl0rUGMs3LVVeya8PNIuXKc3uaB6w5EebkLtyD1Qsk=", "GKnY00zyxjMTip656ymCDIW3CYiVgm7N8uG/BA3PAoc=", "LgVUg53XCkuZmP2RUyf64UaF7KYj1mJYUYbS8SS6i7A=", "Hm0CFsi2eL2eiQzNctI7wmeUith/qyWupiV/jLcBKAM=", "CSCTKmxAWx7oca4XOUlzHmFpokRC2PjJ7XnMx6JKSV0=", "FCxC3mq//1gFT2pL2o66X38Qzzn76vuNOa7zDohPo7g=", "FBjt2I5k092tA/M8oJNhckRLsHEtZGqLzmey5FHuDYE=", "BcXc8r1eBOplZU+0c8TUaS6ZWKWZmr1+XN1wbLfggrE=", "EURkMR/foR7sFm0gKu78YB5NFpWeyTap6PGy+X/TXd8=", "IbcTsP2yOPOwU/bVlsrwciOyqdH8ynWDIaHZF1wyfvU=", "Fe9nyuWDilC8Zxpep46HtIvJjjzXv3bV+gMwk93JdYE=", "C/iJF8t8Vw9os5Qp2P7g/P5YMwamymkzjDSQJv5mv+k=", "GIHwEppkt/hhCF9rNmnc71flaNY0l5gngHcLS8O0N/k=", "IFXrcypy03ytqD8E73QXhTaNZI0Jy1AUJXVDChEOic4=", "GbhIwzs4drsWiEbROJfN5rC54rKZVDlbOZRqT18m0AM=", "AeGXlyMpZM1fJq6KLgS9ez3BvaJbVB89SgWbSPyVLaY=", "AouN146HEuFySGpLJ4rI4WaxmWVSx0vS+kv7y6ORNFc=", "H7HP9zGW0TTDA1naFaUwsaV0GqDgV4ip1PsgMq/w1YY=", "I70zAfWb1lUiX4XEKpRmvNfGSqk2N+4nrv7N8ogyYDk=", "Dira6yrH1pROKH3HyDMBUxPT8r6rol6kwdxvDj+8jjQ=", "L10IVI73PWXChTF4y8vIpwxIADwNE4bbcogmDSmlLQo=", "L1XA6W3nSmH8l03w2oWxGsVEtchUSuWa12y8A4ieebQ=", "GIhfc5qcPf7tOc63yO73f9Y1rVLjKU0+EmqSpkxaRUM=", "EmfKzpzsPBqW+9pfIN8wnfiPnt9WhKBb/KyxEWeYMII=", "KkXASERI2jGyU7Yy85w9T2xq+OPjmd3Tk7ggzexm+QI=", "ImAnnDMlg6NgEZc6p2JtToHWOClnhoqWQ6duU6KyUxY=", "KOyCRGrouyF4P1TNTa8H4nm8Dq0E16MTdp9mLI50oOs=", "FuE1cN7/s76+EYlYsthkcFeMsRKWm8bu86EyG+/aybA=", "IojoO+t5RZgHy3dAjJu9vdB35iAnmYb04vCz5frKq9U=", "LbWwbxECtyzkmUYITXXyEJrZcHhagynejiJaQQ4kM4k=", "L845oZ6hFfOpFwQf2yZ8G1EDtYh+XWPEju39xTNpl1g=", "LGXvBVso+0FwfDJKNqiUxq2fhi/R+X2lRFnF2wvaVa8=", "KeY6JMkSNdwApncLnlcjWMGKkGOjQGb4tvVmg8/0j/4=", "BUIRxWz5ze5kt9qnZ3/p8jXitcmcXYtV3iDZqmEscsM=", "EI6Og0M/fLFyhyODft6U0HMDKrZuLg+225eHs5VZ1zs=", "D/m/tBkU4ZmlU+Bw7tlDj/8DPNMUdliRSanmDVBYEU4=", "BpE7wuNyMNS29WtEaX1vgEGNfBGh0g2EhOlbBn+TW/A=", "MA07dzuaQe+Bj90SIC9JnV2945U4ioHFzjvDzItIgJk=", "KfmyiXIf4wAZN/bEh7sw40KzRMcd3Q+VfQLZKV+r5ZQ=", "FN4Nu1Cgqv/7OZR2LRSWz1FEk1C1386wZQZn99t/M/w=", "BFzx03Yp3ukon8vkgjUZ3rhX72bLOcxmMKOsYVfp4O0=", "Hn3kb90jxq65St32y5mYVjItOtbVgDzviLZpPtE1kKA=", "LAM/3FcjLmhavprrGKWVDln2ZlmKCpAyr89Yrqdyk5s=", "EX6uZf/mY0JBJlNI2YRyB06Jyr49j59Vy8dN29mEPks=", "KYjoGptdwiyLPHqdATREIvJIM2TBiZlryrB5kS0lmT0=", "Db6lkbZqJEj7+4htELiZ1lb92+pOZmwPFEZeCcyt3/U=", "Ht9CS7bKCKyMTN/JjW0/0EAA7ExqhijV4rOxJjI0dV0=", "IUMGwBBfNj1SWeIUHpe32kG51RFQSNGshIP8aIpwNLE=", "JC4AtpML5YNapQJ0k9OxHjEYdyZacCEOASFjKEUv3Jg=", "KRVNASjMZQmJ2ruMoLGN1b6x66wPY/pHvpbjgyASGXo=", "JdItVNnILXz7icYapiyhUFBqK/q10wDbeE0l0mCCfQs=", "LyPwuimfXAl2wW6zuIMGiSYShzkj7ojqotuMwQEI9cY=", "C3Q6iRO9jn5wnmgxGjWF77CWcIMVqYEgOfIViZ9ClMA=", "Jk76AJKVRstOwwpiHDxvZhMlhyhk/9+E1a22Gvjbs9A=", "HEnXZmOjWDh3YtII3IVADnrPG2X7sT7bNG3x8qEKzjc=", "L0ByXR61GK5FYu4lygiz5W2sqlEb34LQmfvu5RELaC0=", "JlG785IV1tZjKmUqzm/1EYVVrP99TIvn7j4gb0TufAA=", "IZjzsKP70L+rB1eNQNf6A+UHYbqPHysBhhPWWwkfPq8=", "GNTEaZ99AfoA7a3EPI4fENkqT325bC2ROb3W+xH+pAg=", "BZ7bxVNJHsa5QjPVO1MopdJLbkn0VxkLz9BipYIpV8w=", "EpphYUtOnkIeZmfaqbhf4UvqqCKzlU5VEohWS9KxRVI=", "Liv+TXsyNN9rYmiL3LLIdnWX6j97d5L7RDd+ceHsnxY=", "Afg5fP2OruukeY6YY3N+xUVy9qNV7kfNuCen8g3Dick=", "EX25zJFA5GcLx05/06b+mbh+F4HSrhkdARxtZOAtz4s=", "EeDM41to3vfe1VIvQ0xIbyh9sLa648r7Ix3PlRWY+J8=", "Jb9K4wxE3fyHAOI2mu1/VomAxtSOM7bGNzfIL5QrkjA=", "EVP1wW1WCKF9z6L8xf+S0KQdD9E4C1jS93wFgzmIb28=", "BBvtOcKa+3AEzumT/CImBc3f5kH6OglsgBPzi1zYW38=", "BHzVxbDCpgSumchCVA+jfUTmq+w2V2maEWuE/EKtXT0=", "FU7yXmcUhtuOiCGBozGCba57lzny62yPdIowZJqkGA4=", "G0g+dPQcJlj6/QgbnLdwnfKImZRUSWoppJLu5577liI=", "EtuINC0BS1b9v5Pb+dnAghlss04M7d/soKQJBOK4yy0=", "CUQmP8rXY1p+jt529P46+yBc+DX0KpXAM23mxC6lqZA=", "LnrG+p3/r4Op67aWbvVGTkQpuYt4uPFBZcUBVGlwtzQ=", "BLygehW1hc0neQdoyqOC6Z0Uz/j6V+L9qhFaRy3U7BI=", "CiMKtIXngUaP2/7fMkE6pADIOeqFWlDxkWsDxnYcA0s=", "FiHcPIw9uG+oMFn0o8QSmK7I7ZPEnFO90lhzObIW7HQ=", "G05LxPAo/e0NqlwaCU/soNBQlPr+vWYZNI4d2fzhaMo=", "GnOeVcpkTpyg/ygGIyCXfZc4s1cof+bYcn4Q/0RSx5k=", "KSgA6EUqVmbNArF1aVD4BIw2eiQ5reo9lC7jwxhc/ZI=", "H6Nx2RBrgapmTBH1DNQdJIGpFDmjnA+hMR/8KMRITdg=", "KnhpQbirYxpFXx8L270+uaGc2l12xGO/9O8SIAvWzfE=", "FSHzA/1BUJ4SLWt2YdYskR+67u6CH6LhHinnDIQ/yFk=", "JCr3oQfMe9nBxbJTfl7reUxneCfFZjQYu5osnc7ykVc=", "HMMNSBO7/0uRdAzIuiC9Bq+p0hfqASzhLRTgJxMB530=", "I70pIrQlr02L21h7HMCMzf8BCrAwQxZkiZpKMjspc18=", "FQ+rWYbu9b0f76kqq1ACUw2fVMt+ZWM81cMQVV4LOQw=", "GLQ8sGS788g/wvFYrnhaq8cw335cauO7yu9hO8CucHo=", "E7tC605zeHBgiJvhdQGLjy5aKKEYHXd+KqwcmTrNZpg=", "GribVm3/NqlfgFDoQ0lHQLo0zTs10LfJe9LXBe+EKrs=", "LV/ZDnF9ivjVsQ9zhExspQ0AWUCvCVRt6ONP+ZFDX7Y=", "C4NtDVgZFCGNsOk8hZiziJcqR5s1yTPMrZhKC2zpS8k=", "AuzfsVD6Luz0w0x21W6ymkSpQAOZb+PH+51k1y01Ljo=", "I1eNfV7I7TGy1+t5RWTTiQJf79AGUhldrRIrQApRlrU=", "HM+4tNk+XgjHxMTzBjVwb8nfdZN1//poNaTBwn8iJ5Y=", "HAy3NTRhZLqTMIiB1Tb1iIhz1EQeMIN16Oa3OKHAz9M=", "C3Plt44NI/d7D9/QAXOBkcMwKcBtu/b0EHdPJC0AI+M=", "BEcVwA5fy5nENRicHsJLPOm4MRQh9bHzhISrdpLGxjI=", "HTs2R7jqNF6SzChvG8GLbqOzqFUdC/GluVIUzyMQ9wA=", "EES5FaM5olgqbn+2pm8rl71hgvmUatoeXT92TOGrDOA=", "GBPbIlHj2QTQ0wu4a+LXxYA6krhzdd/Wj5dvRiKlFTQ=", "KAgVL1aFv+V3yU/KnXCWLloI4Pb82Nkhgt9/s7Kzkk4=", "LalAoejImm+YPj+Yik55dZtcaYe6EfP1HZpT0/0dQBE=", "IPsdhpzRksh+NCVOS0jyIvmXtFJqPT+cn+31HNFnAmk=", "G9Se7qrDkn0ZgoKQZaTbQmmMD11f68/UjsO8EFmVnxo=", "E1ESs3RIBkIxG2sUJwTyFoTdAk4K1VrgJyisMiaJ5m0=", "LJ4kXHGDLGkKfKPbHNqtzdfN05VwvtwUqHrOX3Jv/qw=", "GjGaWrOyqelesMEaWhK3noVpKRhqHuPrKHKthr5z9WQ=", "GhI8MfmdXqVbxC7jIrfAcPTMwfwmvs6fTz60S5BROAg=", "CyP/3qBlyOdeoNO/2Wbf8TbWYCr6lDKEOVkP8+IA73Y=", "HIH44BSrJbjtecXhvb+Gn7G+Hq7dh1p1OWeARr0aMxQ=", "Ab/AkvRwHUyu/27TJgXMDzVD71I4WL996SI2M1SsM3A=", "FgaPyJsziP5b1UGnLuvyl2idHm+XiSXe7VbyrabQH+w=", "A72dwSHn6YtUlEG88HO1ZNWp1A4wIN5NGnEDnvJjAzY=", "HQu7k9nJJ6YJ7/dsPKlaxulOGJPIjvKlRPtfYpXacsI=", "IOni3IiupFiD4T2yBiIuTCHU6OuVQgLyuQwhHKyWycg=", "CmnewM2KOZ//EZAqNK/poTMfUa0Tp+5ace/X64WU2uU=", "CGfJEIUNLyMPfloDs88NwDJk1bbyZhEFtnXF/0FXXIk=", "FFYD+PtaDPVr9xueb//4MSfC0Ls2jeI8afx6lMhExAQ=", "K4u3bc6v3UoSvh/JQ3udQG/+IUS3vkbZpWpBDRfadcQ=", "CJvFzg/UHZCxqmWd54NG4F6sfQVPH6X6fbkcB/s/p9Y=", "J7rXi4z95HomTLY0gbWgOI8TOcsh8swykF2C/rTpP5M=", "BwQ+5wPSsbarhkH8/67NEHvLzANKvP1G/pZ9hBf9NyA=", "BPXM30A2u3iIkzX2hjP+CR4No3DS8H5vhU9nBJ5UwMw=", "FbH/4SFH7nHjQBszNeeGgcU0vMWPqfgKgTBQncCCAlY=", "EJsFSO7wf7uSMOkrTPt0QYc6RO29Jl/BUtZQGHg81XM=", "DwfFiqclrrcxtq8IfnxczsWjeWrXTIcqdCb763/s6H0=", "HRNC3c5uRGn3CpSM4QkQjTsedbNzPOfJojekxeUnRRQ=", "BjW+nn6EQ9OyiG0VQ0TSQ9qpV4yCo44lKIXE87sTixA=", "G9SSKsdYwPTFC7MDW37UtWGK0LcUq0aLXquYjP2MKVk=", "LhoOb4TJM0K01Sn4gYRVSXbiHsYYDFgOSlhjSnt0dZ0=", "LxWJvloSdpikeDukhyLkyakIjHye3Zqt+RUrndg58rU=", "Jz269kXxGFRmv8mbZ2xhh/hBW5+i4d1vxkNfCj7zVSY=", "HBG3bfBCOFzrbQ/iac+hUGlZGeBHtIB71umjzUtOCiI=", "FqCYjUI07LCQ8J22veea81OUybPM/GoLtETfxseGc1k=", "IV0CVzCtoXiOICTM4n8qU86ASpOi/GBFKgz5SPsDqLM=", "LN/bCEfegJntipQYIrFe+ekfz2QyWvIgLeQurJK73yE=", "CUbb6ZmN7FQdo5qdjqVEp+RJ4mpPmqh8KMfi8RiWE0I=", "D5WJgrQ/j9wsN4XErD5jHVyJ+5TgxySnplwcMhi2fkA=", "GFAhsZInSxthlSrSGcq2Gsw7Nv02GIobjBLlbZmMXoQ=", "JNVrTVK0f5vG3LetNT7sknwOfUISoubeDqxEohAmCzU=", "EJjVj+e1NSPu6BUQsIP9rcoAS1SUaMvSAbCjHIt+HRc=", "JKmbxISBBoOQvEgzDBE7eSHM/wKK1QRYOXbn4w78PIg=", "Eqf9Cnpu2cDqyjRlrlV88xhwUUb3L3tOSrJJNNu0xnM=", "DUKt7kR9aupmNlvwHltgfFKEgImoRdH8/66fR+BxaxY=", "ANXRCd4lefTlyidjo30TEJMN3e9pwgI7Fn/+pUsMSqo=", "Lv5+dEovDkUGk1B3MdnASSoHfRlKAiEAIqzFnn6kadQ=", "HcN2RLvs3CT4W3E/0Zr1W2/K0xG3e1/jAwqW1TNLuDM=", "JDEVVo2jZILQBACBdqdUJ/2jZsnQe89Wx7D0ghwmN2Q=", "KskQbl2C1OIAslewsiLLMJVzJ76umDT8QoBGoPWSbnE=", "FrhSlEVwKH1uAsNaYwA5JjWCDOSIP9CTgmD4VVXGwLU=", "Kd+kABYbZh9SZLQVhGDUd28+hit7gjURlDD3Z4oqKnQ=", "JZCKXPscIQ86/Nbo1jFzptedznU1rtxXqu6ZQybDhrM=", "FID1azpo70Hl6kTf8lSq3dvxnVDw6ZCWX8yJvcO/NUY=", "LBSQ+TNeFNv66sZnVZX2sQgHvPo+Sadu/JAy9fU69bg=", "GDPwzl3FKdNXan+0gdj3D6biFw0xwQMaJVzYAPyyYrE=", "JtNkYaHJ86NlNZDoJzVU+B/VHMQw8lvuLMz1Xi52JzM=", "KQJ/D7OBMY+OrBSvJPduFwfca+0nEDYiVvFtvaaakK4=", "Ckzejz1C7Uj7Pap1iQNvSZQXbN8HouzD2vtU+dRdmwM=", "H77BL+/+CInMSjH8rn2BnOxIJ4XhkN2iU24sQBHahwQ=", "GybyOMe7hjZ4K8DuSKkxowknRoQBTOcnFABdmLjYxmY=", "CP9N8MAn6IgHuLblXmv35kP6YMZtdKM9yETsHDRZjuk=", "IgfBMY6VnkoAKtUBXTgbKZFd4iYpphKhtto4mrhvvCQ=", "CfywfoIZNTm3HQoFLTl3mWoJ+EIWvMHkbxGshNXXXvU=", "GWn1wg6A8Q5x/0L+Wve+xH7nUzFTZ43S7zPx6R+/mM8=", "B7ZdaodPVwYoJHnOMj82vyO9+8NHaeEaw07ySU8r/4U=", "CemsTFG2HOraLIYeJ2ocBmXxsGkULxRPgMRmSaZbxCU=", "CLdOuQsOWzATNHUV+8/pTY/qz9Wu+5VG4eWt9Zq0rPc=", "GTUXFM49Lj6T7JAVwC4PoFb2js+NHH+rpRneoRbgIXo=", "A8ShW8l0iBOc4cuSj0dFBa1bx4k6U7PPHJuiHVGwBBA=", "DYt3c98zW2qc8piwhyHWQCkKCxfVBg8CIvJjx0F9Jcw=", "HhTCEvt2eWdq9Qw3EbGRfWWZ9iBlK4vf0kQlFmeu2c4=", "IYbMbNxScSkamxEbmL3lDGKigEPZCu9lQXG7cOQp+t4=", "B2jb1LkHS0NUZ5J9EYc3jEsXRoWu7KNXiN5mXygSoZU=", "Bj9aiIt7zT+K5Aa6QOESB74BNhitX4Ecwxf8HlWMedo=", "F4B83C5y8Fszcfzpj97l81U+tM6S6TmNcC+TjPnudB8=", "JfPdC+O9+OYyr9y9QxvnrmYBVJMER1ylgNE3QeKn/ZI=", "InSkXi1pBkvOZ+LrZk20Wu9PHZ3MzRV73O73quFF9tU=", "CH7nk23rd6l7jXRz9TQ2zz+xzoXfB6tooCi0beqEFwE=", "Cq7A915TCH25N6l07esy6r62M+zhGA8fhDeryQmd8b4=", "EM3wHoxhJjtEbD96EMwp/QHtkfrZiR+cb8t7XOQ4upU=", "F2YnqSBy+iu2TdXf+cxKDVvtzz8iyR/pkcxlaKT7VM4=", "DqsOFY4vZyxop6CkgyjiEXmkF+sMZbG2F2ROHFLEtCU=", "Lt8eoc2X0akf55AeZMDy0S95ZXQdpafH+r7iXqw7R+4=", "H8BxN4Y7HTN7tdrBitkSN3OWgKae7V2gvzUGL01MrME=", "A3vf9oAlvdy+1VTOrD32ap6ymJZteTCK5BTTQieq+GI=", "F39olXugfaZxud2RnyQz3+XzY7dKPBYWlIHFfFtcB6M=", "BtR7mSHiUCwquwE407ECiwK4X49CNiz0NnG2Cmnp5go=", "Ex1Yy4pBp1PnZ+HpfO9g0AA+ScjNHw9RAchhsXdxXaU=", "I2ynYjXZ5pRyyZhfhC5ibzOz/U/V9UOBCgxdIUPtTJw=", "L+f4WleZFlRZB/KgIgK4Npa2TR9h6BNzDOvAbQaFN/I=", "BJUjJr0m7+1kY31PwPeku1KOOjQSYBJViOdaqoj2LXE=", "AMLftXe3ja0Yg3u3DI4pkPMjJbtBj09mJjorY/P5g4Q=", "EixoIpO0iS1RJVmR+c+vluJRQL1rNzN+p9+tXhJCMoo=", "Ed3FQNShEOSCokVRErpn/7PKPuVHEUmNsaNyucwj0UU=", "L2vXH2svOvPUaIIMgKqtcu5Iozfx/j184Bu4kkIQahs=", "DWoW0Tbud8NfIW8aoMqeCb3CWecVhIzgR74FakoJ94c=", "LnxgE9G+YqeLTAAVRl+wspOgfUYF3KZCIQkJYWSyKyw=", "DWu/GLfraErexBJxNXDTv7Nv0PVp+zZHT2lLEbKUi6U=", "EkA8+Id65RC3MUt8datbD7f83i5qtIEhKI3ATVtR5ZQ=", "FRs6z0zjKX2G6COnIGfHFxc4IVDAgMo/gBK7C6L+1Hs=", "KhOWcCBjxi4HxRK51NGB1x2ItWgafkf9EUz7aC+vT5g=", "JcxJ81CPyhhzpvhbZVC24QQdkM5TXGONK1I6Yd14acY=", "H9GDJ6BILDlHI7FSyQVEcpz0BAvM7ZToo34cnjB2g+E=", "CydWbOAr1M0ic/1TEzbA6/5lpbDaEjyzG7yJUz5Rizs=", "Gp4VPOgr8qb6DXHRiJwktfER0mLILPNFD5yoBgjsFf8=", "B8p5TVrE9A8P7E1p46PNH0csdEbk4n/B+kzc3IYFrMc=", "L9r0THB9gonak3NTam9htmSU+p6eeC4OQQQF77r1BK0=", "FU18fpTuBqQ2/fWbUBt2O+jcfxKu7AdSt5F5Jn1kOnQ=", "LHU7d3mjkJ+gywaVqfM6ZzUyv1zzlPQLuNtexft6ZO4=", "FE70DfeiYv9BeV0JWQES1j/q51w1M8CrS7muQ9YSAag=", "IsaNbNS7GBY3kSdKKLozsNE44UjW2AtGnW6VGX0WSIM=", "J8o4y+iy7IqSe2+gEemCMj5W2pMsJNcwlRd/5/iql5s=", "A2mUwWlz6gEkQduueS+z0GsTmt3XzMDA81O+M9iHPqA=", "JC19G7jtNlgDUDS1Xii0MTjFbH+pwFhpeAVqp33s/To=", "GUV2VHAnxCJOnPbedipRacpcGKxduQEIvXYCG7mwzvI=", "DoI6oRYk7lcfI9oCHU15kFY/yYmKfQzmhOU1/sefzdg=", "CChYpNsoORm1bAvAi4k4ZyS5CGikuhcLscz14RIgXEw=", "AheCJnWvrD2kqRN+CxclMohKpnDxQtpolWnbJPWw1lA=", "J0xhTC45LO6Ja3hQqntv6VK3aBlZ+/15E7Q68PWFi7Y=", "J9NVcoldYe93mUWS/HUlH0QOXRIBMyUgSThe4b4lquM=", "KzkazJyORSs18xyRvH3ifgDT5iVBPSf21gw50Ax0v3o=", "G2MgzIrNmMksqEmls65S8t42hHTc5yegBp6XzApUa1w=", "IoYHXmqW8aVfum+Es8pJdOhwFoZK7WJzX/DUKMCskfQ=", "GKraFxgi6OHcPadpF/7RY6Uju/ghI9yY9MCX4X4R3qo=", "D8P6tF1AX6cV7jrEonnHADiF5SAj5uNuXXHwXPXzA1o=", "HOmVCa8k4EiSXqrSbSlM1VXNEuHWWIF3fs2mlKXlKjI=", "LibBfJIRY7W7Oq0j/63UfdDcREm5TJDqPrTk/vE49yc=", "FRFqfJLm2dRvt/tRre5ahiqi+nYsaQmRgErqffXP0/U=", "GKJqCAD88oiqfpjwRzFyEOZlbIe+kDvxmpLnwqSZw5Y=", "ItekDn5MHnbb+8zhYBwiRpt/v90FWj+VPPz+60eoXHs=", "CudxSI60vxB82jBC3aNJWJnsX8Q3khUI/SnVvyGAev4=", "FxBOBECoEqM/gl/lfamd3hPBvT4Q3o7JZ6Xe7iNM1wE=", "JoDkr8k/u+uXLYQvGPo6NeHOgizgKmKcNpbizbKJSl4=", "DWT9qTq6XDhOs5v8FEvqV7E9EbJ9iTI9KuJ0j9VPFtk=", "CurMY1E5AJZG24lBQQyBngh6vGAXCbH5I/BOpntfWPM=", "Coou0rIVj+ZEO8OxF1TBRSHbGTM1YWx4Wgc/ac8Vvzg=", "B7EzogFznuIEyB33iyChPgD9jAo4aUJ5TCkYeqtic7w=", "EY+8drf4YeAumuW6UWlgyRFCrXxK8RVj4a3/l/hjzrU=", "J1S0/0c2gfMGnt+r4h3HX0EjoMytVZfUJ3moEg9U8CI=", "GQNgoDZmhxSDdnX35Z/fFfpXY09NsMLCSoDSaVHB3cI=", "Iiki82cLX2XPNLKyZltAoYfzwwPHa+1SAXBzoKGNv1M=", "EJ6fwgrPzs89R8BK/fupJvMOEXKl1QbRJBgYrunMfFU=", "FiE7Qtyd1MnvkVAK3y74cIhReHN03O7k1FpmRaOmmzA=", "JAI+pooqKwCKy8XUoV/NCUK2fOlSsOGgOtF1Bm91WSA=", "JHQExI+qBubHKx0FC5Bfo+vXdFlrTP5rtNV6w4BwhZ4=", "HYaCMeLfEz3AISxiSBec6hfLD3HEzYJ/U1OAYjDYkWs=", "DDFHSVWcE0iG/BK6Eybk/9wzAo2OrNNB9RDx3qK+N64=", "DMHDO1MgyRG0fu4DxNluorJbzSbjcR0oyxUsvFuH0s4=", "BfTDYF6gnUtzeyn+6H4cK6dNMyvBnm0+i6lH8Os5maw=", "Bb185EGjpyeGMS5jhmu5hq28uEewZHb5jGt/i48EJFc=", "E/xMDpUCge9OluymA1UVL3wLM14PNrwc3eXzlS3twTI=", "FTwvidZoHn+U31Ebnxk+KHaIT67hvTrsJruTSToGTwM=", "Fvz9bd0kK+jNSYJnjLq69AEL5Hl4dk7k0U6VLcSjoRg=", "FVQ10CszzkW5w7bz8QkJMPwKn6mXiJJ+UEch6gZoz3w=", "Bmn6fUQOOgbbb7gMh2o2JFu2k7t5YGRkIWIfwsORxcE=", "K1ffk6CW541/FOsReppcXvadls9FvIB+Vdib+YDorHY=", "Hop9GaZ2syY/hahILZXQ8+dr4LblyawQehL7nmVchxM=", "Km3gve0rvitYZoAfiA5H5r+mkAWgwYWJfHLvtWvZioc=", "CZ7Toq4/D20KZ6H3m1WhNb0GbMMuWUKj+iVy3hNI+EA=", "Hn184IRlQhNWXW7iG/Hyez2AJ6L6qBBRfvvf3KmX+/c=", "LnA9+9yG9Vhu36AiHIG7aJkUMhC72MZoR3ZKpPY8Zbk=", "BQWww9+fkpWaQfs2xy2Fu4JtVnJ5j+dIJXK19B83GU0=", "JtH8kgq2DX/E6CYFb30Zx4J1CH/5EW41b94wKED/06w=", "KzQ5wWsa8nvXpMjZ3caTTnufXhCq58zkDOapN1BtUQo=", "HkXYa8GE8OCGAg3q405Tqw7nEjs6EZBHXG4l4G+DIVQ=", "I/Pi9JyhyVQ0sDQhVhcuZdvGyfgyHMdenxWmbDvLCcA=", "HYwuUdtZ1ulu5p9oSA0fjkjAO8h2zXkV2Ii1sKEaIaM=", "Hh3DVGqGAyzfi4v3+UpEcwtmL4pWrYYuoSR7oqsPPSs=", "EUfoLADfReGC1Ba4M4/64pkXjaX5LY+fkVPGleeFlEc=", "C+lEVrmgPGy/q52KNLQR6R0gyxH1Yk+us/ePOCR+kLk=", "DEvZo6qpI/ZJuc0cvXh5V0smb/L3wMBjtcRNa0jMo/c=", "BhmMH+QS4liHEVtU/4frTx4ocdTPN3lpyhUf7V17Te4=", "HukKrmimvaQsNKeX1NMfeWec60G1h/YZ1iDh9RCLg50=", "EapTYLWGwhRHcRtJch6fT93GtsmLV7hHctb8a4vgF8o=", "GkGmc5D5IvEM26qgzl6u9h1mtnMIJeuYok0lmH6Hvlg=", "JKKZfIMvulSWGJJq+8rQDOkgeIOT3xKPilQW0mIxYVw=", "BnA2yvi1fapZrUUUdziY4bIvjojUVLwfjvDILMk6J3I=", "LxjoU/m3t8SxtMPw0aJXCwNf0rQjGlhBOa23oRIhvDM=", "Gzh0FEkjlDvrZsqLeY0LuPK+f43Z3trG2R/FueUxhqE=", "DvWEn/RYoR3EE6LYq+qYiMYiQcPCha/jobFM9xV0w/4=", "GWo2ojF1P/0MCUZC4n2AuiAaVJr1hP+ppwqAJoF8pmg=", "LgL8Ii3Vb+ZWijRa3TwdV3iYo2GEfli2dXbxLjA0qMY=", "I4O76v05HZaq8Lp0gUZ4Z8Z605Nm7YxDtCUgxikkUsE=", "IN4s1c5zPqAKfxZ/aGrmcZJjcyHMnw9KpyFHkGdqP3U=", "HxvOM0Oa+426sTVLRqW5zrGYC4NRQJXWXlE7eTUamQc=", "BXuN6djtWTtdIUMCzojuCPGBLvU87G4FuuwWDAVNZ0c=", "Jnd6y9iOkyslUveBPmLzaKuLHWJraFUCJToQyAUKSlU=", "AVick54uPv64y2wQNHaHkQH+x6Uwyhj+S9Lwlv9Er0A=", "Kja3nYfJY7H0dZDsxM1pFCNGpUrki8P1c633GbTglxk=", "Du2HcItbAKQq8+beWNTN2vIieL4O5jRPKndRMv4Qeg0=", "K/hP7WOhFpW2OXJ+GBEawgg9k2zmS9UaMt+p8bDnEyU=", "FkpgmAdZQcZGcxnCNyRjw+x626b225pYrVmmePjxijk=", "IFB16jVYoXsMUa46EH2JhgnjzV2C+N+MP3SxtzsIlz4=", "Hx48dvxp/YrPo6m/0K9pXBDCvNzm2PTR97dtUEGbQ3Y=", "AGmYKpslvXWBQ5e208ipB4Hhczvlf3Vz8v5E3TVhjFQ=", "LxdYKUFIG1SJIRvv1LwNykPUQyzhEVOg/nNeVUdKI5M=", "FkUx6rOAv4H2MT8y9cJVqbrb1O23dn+ZDEaw/b6fspc=", "Ax9GqLRFX/EhvBhKHDVR1FB6F8iIkx8+mdNWqaBu+Kw=", "ETNNuqb39BQNFJO9GIx3Yo3MeCxf+C8ev0HKCUgVdBo=", "Ahix04pv0R1lZqUv4TbiyC3iKWmOVBSza+iZfwYOiRM=", "Lv/KNpzzT3QkjjeuO8dCmRh+FqdfLr5ARnBgUA65PDE=", "B+VBOPgowkuYs1ETkoYa6cWHZVD/Dud2Zjw5l6jxoRY=", "KX4ft9pUl9Pb0HmKFG0vq5rFsOeQbYWII4GHt5UAH7E=", "FJAWpxf9hcx99/A5ymsbiwalvb2jZaM7sK4iiQDlOzE=", "D556IhJL9Q2U25Ix1jaFEi+S21JorSFIulNNyFO/xU8=", "GjUZpi+mkrNxbRG4jp1iqqDkO88Dx+qBlwsdgCqGe4g=", "K7Z8XWxIz0WKKT1pstHUT6fCxgiOe3+a3s4/hz3t+5U=", "H6cT3eOQPkHmjwmsLzTJsSN6RF1RlcXjYcW8ox7fqXI=", "IBmqkq33teeV8OU5aC5LObTjK7ZSDHERAq690MFRaEM=", "IlO5Iz0EevoBjEDEn+n/H5mUMqnH3wZiGyUEpG8SDNo=", "HOoIxJMo9fBTxrR8u8lVkiS+HYE1SRGhiSapjgR72uE=", "EjrSOWakLHKXEwlPw1LkZuJkavmtqsIP2OWPMI0nNuE=", "HvWafiZkd6ZEUn6+zwu7z5LOX4DSKA2vgmYZt+vfeaU=", "GewddNfzZy+bxmvprED1vnAre6yAtOM+zrWS+G1d46E=", "JCZGxD1/KM84yayvjGOxsz/wfHeMKuaMVdSJOpJ6OkU=", "DiyKYEVT2zuBmA/kDYAcrMz7y9eZkkMPy1CwSkLL6bM=", "LnfaMnyGm2P63zgk1xiYPyzR9/iuZMiPXopQCjQFau4=", "GRyjvp6sxr5ICLwWaNgUSZdCoRZ3kuM9cNNbX9CsJzY=", "KibhC3FMjJLEIzE2hzYBiFC0ig5d55NrLPJe7kZjGWQ=", "BaprLiW3zkwXBCcIGgEZDyNkhy0B5R6WmxTZhJMMEPA=", "B6yzkE4szYesXZ17a3t7vN44UEkzceGxC870zzL/IIU=", "BaqcpfIN/BBMhesrzYDf57/mnULRukQAvPDYrVOhjAk=", "BBGgtusJ//vpZodmg+hquWUoAYaYX3L6xtoxDoAXXdk=", "HhZWgqVitt0pzvhQsnWev4Ysr3HjSLQgJ1U6sefwzR4=", "K2XpKh+R44sufxkuvwvGDNIk7HwcZ7ENHl9jT99Sa3Q=", "IgjqfR/GN2ex090ef8/UsTy/qssPn1MbNrC8dNNkgR8=", "GscYoocQX91ty91uOp+DN5Hnw0WJG2q0dg5uK7YgWbQ=", "CYCQ9yPep7kn7cNqjuz4RjDJLQE4+Q3FVfakiXH1Dms=", "Hb4A+qM0Ov9y03swImAUO/tdTlv6Sgs9CmIiPtZrTW4=", "BkLDZRgcouw+Qj1s504UUGikP4jOBTV1ouvK9xiGCZg=", "JFYR0NgEeiTbPXgTG97cZ+NF774+p/bHpPy9PGQiRus=", "CR/+PVGVJboIDh+rVGcJstxioXk+OBHsUWHIALSH9U4=", "KmF+1YhyLTrPSQCz3FAVckt8jO9FjPnbSU14aia2nk4=", "EwKGipqztqNsztD4D1PxoTykNuLXwPmtqQBAr/ugqMw=", "HZA9r0MAdVvgrKr567RBR5W8P7N35ZA/ie6bPvrAUqs=", "D2cXkuxri70JNqu8A50qho9SOgBQ3AEi9dlmmyY0d3A=", "EEWkJBZnqM04B4BnlwsC3OnDUFSjb6Uc2JLV0hM88nE=", "KNc495wHs10t93LVYtVDRt16Qb0HCWw2wiBDIKZ2Cys=", "LSRbXBwacy+Cg0Ru3n6EbzW+nUnLTz87tOXh/NF4nVE=", "JaSZyhkHY4NR7byDbBSYunyPLhS/mfC8K4uGu4m07qE=", "G+P012Y7lJQCMHuCuCihX5Qj+b4RXKmsRYTUrHUpa90=", "G2frUfrO9YFKMM9XlKldStEVFGmtTYUdDDNm7WuZMgo=", "Bq1pIB+UjkdJ75CVcH/cZZECLHjLb6BH+CWkHdPklcI=", "CkuCiFSNX7Pd589LvRoIgeXmHZmx1S0Pgug3FQllQRk=", "DrSpNC6J2c8PSCxBzmbkD/fH2PmtHejR2NSKmLAFTJM=", "GmRaIjRx4s93a+G/23BgGF5aWKa2UaEqiWmtWg362X4=", "AwLESZ1B4ln/dh3bMFo2bz58KwHEZXd7zq4aZ+a0EsE=", "LBfgt/kBuTYwydqZuu88XC9aZE3OpkRDV6EhvCqkJ0w=", "Cw422oM14kPcf9WcwjZZdNDg/6JHxU75YXqA921Blcw=", "Ep5zPB3aLt6NOW2F/Wu4tuYTmfIxHAkzHH7y+b6rIrs=", "LN6n6xj2FGtnxDfzfBP4Vu7QHV5GTohwRHxci0vvxP8=", "KtTwIWAzAY59KlUMLggkMmFPQH+2AJfUUFzPyzHWd0U=", "KqxPVCVoNbrZbuwlZkGhD8RNDWP9WGD9R1zoGCdmkfY=", "F+JRMsCerY397WkbkIG1gfH3bEqG8v2cnCnSQz9NIos=", "LtleSTrJeaCRu20o6BZy7F4fHjnxY+X0uZSN5bS+MpY=", "FhzmPVlt5pRD1/VC//Ns08EQwzz7tEXJzztw2QgeTwo=", "GT78d+p2AQVHxbzGAKEfHVqAvdd5ams9mg2vZqC4pLs=", "FEmjipOM7jtW9QXxuiMlsYbiyiKoQ18kHPpEPGAA9+E=", "IGDs+aox2zEgIBgn/N9rXufxu5PVUBh8otu9SkIFp9I=", "BI283+L7bFCWjoJalYNXZGd5VGyTNAdI7y4FeUtIqx4=", "AwL76bE6Pu2RqCOwtNPjYhQTQISX5sPC+knZyKo29Ag=", "A+gZJaP9XyUIFTLymGUH4O2RJ2y69M4IYIF6x7uDjps=", "HFSYeRONQ0zzFDUX3ZvyoyIiTXa6Wz5N40t+xJBAdEA=", "CBIMfsNW4WlF2U5V6DXufi6R5BAxXc80dfgtJw0W0O8=", "EwZGQAYzAFFoweFO4nq40jjYunUUyQOqpZHc3nv8GGM=", "I+m03T0fMMN8/fs6g9ReUk9Uq6HAZ6we8azggqtDR5w=", "KFs4qrogw4sEWfSkiEMSK2RzFilWJHiUcR7HZ5lPw74=", "JVn99Y08IgDIPtH7Tx7tVowiSMoI5XlIBtGEHzoIGEw=", "DjPHNiarHtdB5HrFK+Tp9/eRO12B19oar+IDpJ7LmDs=", "BR1BI2Mkl6oyQleuUqUeL8H5uokBqSXcRMDcZ3n/VJY=", "H7q+0oIIF4d4JBBSsjbwvHrpiT0kfKnNBWcumv9hMUg=", "HC90E5U4vSU8PdRaL/uWFzVQpRzb/ip2gnI3+4W+7H0=", "FXdn4qf98lwYR1Wy9HNp8s6STlra7lo3ONT5QrsL+VY=", "D98efIaJgETds5f+tI5e3p49JPulQg26jR6m0Q2/R/c=", "B2noTtF+bB6sQLXgDM0tggQoEBsshLWI7kCkQ6yeCLA=", "LyoPUN7R5qs09g+MVpBKUW2vyBU3IbRPGzVhiQwC6Fw=", "Cx3AT+ddyzbeC/4Vyi1a1b8lOK7RMz31bhsthhko4sQ=", "F67Y0RfCd+0NHYiLNexL09wLgjsq8DfTYj6hA6IHiyQ=", "FTFAqmZYbO4jGo8/2GBZdubTLd9DH/M+4FufQpwMlIE=", "Kuki4R701Bt7hNUquDX1vIAnvOneJcHOWwu4i2oX0ao=", "D4GCQ8w/rst8c9/CHClovmO36TkLrAd3R7u+FnoFW1U=", "H2KDijC61u7U7eKrUoZttRVRN8zjJ6J/S2biIEB1AA4=", "L9l5V7lGDTQUAIyuglu2EPAYxbUzCf/Sbzns8ef3lbU=", "JpLRHmRpXg0hA3S0gqRyZ8wA3y0bkFVyJ81J/DfsK1E=", "D8qniYijUgJof/DdppGwNbTpVApTCMluJYI9h4eloEA=", "GnQrLM4hyD15Q/5rSSqbiPr/OZDkiGZnD1Kh2zPWkcw=", "BzpZ4snBrrKiu4mx+5tk/EKhv+/x2FtuehY7jDv6ggM=", "BMYE13s1a0hdIVqf335ew/KWSPyQoYbJflEhQM/F2WY=", "HTgKrWODvZ9cS5+0sSfgdV0RmOo6lp7+XjvPEtFniCo=", "DLB8vyAZSTCI4X0Wzp0U/EIE9nDWuOKxtQHR8bP9eVE=", "Fm62rVhV39PEXiffkVSFPUsIdBEsRIn/eqAFDkH7uhs=", "A3KjvrnbNgMbfwxyuvHlPpxyIHgLJHrtgu4gee+t7tw=", "Bb1lUgTVXMa2OQvBZQMBlXpnb309YBfGSWrQMf1fezQ=", "FEF5GZ26E1zF+ekbdogPNCpOdLjuZhwn1bZR9FZWAhs=", "Dm/oyWzpjzzJfBGZO1CHtV895wvtYycw+SKZs8Mroco=", "B6LrWIY3VRfTmb+r5MfOXAPt6DbESsK1G7PjWqlXbU4=", "B2TsiWuno3T1/VocvtiivmK64NVyY54Xv/rSRZDDuJ8=", "B7qexngctHT6TWIpCPCaAXZ6B4XDoUrFuikyjE2l9PI=", "DDJbSYll43cCQwEtr6DdT7A2pAE/L2fzUPP8nnQEkWA=", "IZ3TyjyY0WEzk4OMc8iKbGUCyiOzyFtbiVmilpHjQnE=", "DrK0X9UY9U4bDUglAm//3XZIn2JgOAr0Ddq1/8HFsz4=", "IwW4tav/3FUs2WlW6/pFajazXSAL0+Q84WXrOHEaZ+o=", "GnyxHqlGP2OQq7cHmHYVzr5ZTPIy+16JFEB6Q65XuYI=", "HmfOBSTRB5IIqU3CVIPZ5rdCjUDDYwW74Ik+GUolsyU=", "AP/FOahTd4lwQy2GMbwP2wz2AgtHJLSe8DEZDcS7ESA=", "KZRcnKTDnUVUDANcEGeKPy9Ryty/GbMy91zh9GtZeK0=", "GctAEyPb0/2L4dqVTAKR1nEkh8aH3ZZkpLFn3AGARFI=", "KF/YatshkIzERBJJ/QBcsa3Qsqv3Bsr/QhknUGYZ3Eg=", "L6q/0JtjqBwc9Nv8ZDI9jBJ65VLQAzmx3ExZscx6tO4=", "L8dTnEBrzib75hUXubjv02FxEMjNSyuztKKzOemFfUw=", "EpbNCJ1HUOVcHAHXaLXo8h0rwfrXa4QpQPKT7AvCrJU=", "IaDD2q9X/c8uiOvU0dGkTqpGWkDPYLB8wmVJtXeh8ig=", "Gs+X9MrMl9iI5OO1rQLdmo7lEUdeIemC+hzlBGdRGrc=", "CzVWue72noRH0YadEobg0VSCES0j0OvX+LvWHENd9hI=", "C4LPXi24uIsys3l4sRdvKmTaK+pxiUAF9KyxzmpoS3A=", "LIrRrMdjb2WhK/g85orJKr3p9FHsoVBRQT82u1Za4+c=", "L9zEZJnPsRAvVUCAeTZYIoySrkntfYFHAK0eE+tb74k=", "LI17kyP+MOwh63uOC4gkj73HDwR7W5Fm492KYL0qjQw=", "DR6/lzydJqZDYmIOZbDKn1nJ6XH8l1Bjca+Uid6T6Rg=", "G92SkhahBbE1HGBHtDxT15hmoLZT0PRnAjPp9ZzWMNs=", "Fiq6JGdQ3NhWyXWppHOnySG2JWmSApNLCh0p/9A4/pc=", "LmgdsOdMO2zEmamvviIpyK/eKTLksVIoZ5tUD/ReLqo=", "L8wjUTR5L7SoHaDB/9gITLjNgJkpPDoSlQSAjT7jm9E=", "HrZmGtu7Chd0xs8WN/oeXiQ5n2aQpVQW3vMkHO7OdKA=", "F0BFxy9oSIOLKginoBF1YJew8+0lTP+rKSbOFZ6fVic=", "AqBXXwnzKC+gfptc9VOJk/x0xO6GIclfuyyi5fLcOhE=", "KC9irrFn71lj2mxvqoZxEjIlrZGyJ7iGtrmBrv2soMY=", "G5q7uBvP9fFwRjLe9tmJ5Qz9vuHSSYAyOOrCRDUdfrk=", "GPikZp+vnP8R3Rnz1zw3dI+0Ym0YM5wHegblxcgQutw=", "Ia8N5N38RJNo21m+npJBGFxJyElu6G0Rdb23pDEIaoQ=", "C5oeyf0hy5Xck8CsGRETWzpo03LObanUVdgKeAsV+Lc=", "G0E/cJNYAI9Ew+YId9gQoIHZCETzZ+PdCnu5zBGNxQI=", "JLTvtQKFdYiP61uLWdQONJj//OofNQgmNZv/t/1PMdI=", "KxHt7zUFqdrWAAYH/8vdAniMe1gCM5vpzXTSuldiARc=", "ICJ5cGCWzUL5BiOcQMZxPovYnv2fY3QSmd/1N0Xe6N4=", "IH7Z9/9XuxfSePgzthz2ePUsjjIcxrzjrwgEp8FZIF4=", "BQQcCI1OY3QxsqSbqjdyqbBEPzFh/kZRWujTrAsOVR0=", "ABt8e8FWgiWa0IgdzLzgpkoCWcWeo8XgEvmVNPwCN0o=", "HsGXEWI+vEnvTYVzJaqd1++1+jzXrVDz9EzMqZEoyE4=", "Bssb51F5wZ+ImSDqkxht/5I+LCFMUKFFUYg3orAcqQA=", "JxKoIDl2kxfCGyJaTgukXfY8r7SCEwNmTVszHSIhjYM=", "HX0JaHOHNNBxCuhRN340DbsQFCjXIAtzGt87HCIPOwI=", "GAUCuuLaA52F9TchK63j7bVvs7alVn+rHkBhuG+j5m0=", "HD8aMp8A9vcRWl+ru3Ome910ys6sDlpMzyWuA3PpITo=", "C4iAOL8eivouREufR86/KPQoVNGpFgjjnbzahyvelgw=", "KgNucOKYfYVFPtej2aaNV0rfVurhIU3HdLqhBliWLBI=", "A/EavVUeRNm2oPRED0cAbpjNkAFFnJZy5vlqkuUCPTw=", "Hw+gS81jt6K/3IcO+7NpZvVD4jXJ3Vs3HF6lwmqnuc4=", "AVTiu9eWaSuJQtw3q9lTTEhrpwvHe+IedMThU4Hhy0w=", "CgUls/lqdQeJDn9l57WTiG0YyxR09duGUBpNsfugSwo=", "BKRzky5ST8DmBNXunPO6nvjVtGOhN5/NfWrxTb3rVNw=", "IRUNEccjL2FWKOc5L2oMk0jHARWhoHuIc20ErrheD40=", "DHGxKo6KfY/StOqbWH8ccie+HE6XQNs2z3x8Xo8xMIc=", "LZTNvgT393xa8tNsN7u4FynZUav715H+4Ko6MjIaxmE=", "FORcXisJ1tYxzGDFn7XCSwpXBBqsZLSoLbC2NgD1WBo=", "CrxcXISJeAKDwTnDbd36OfiO4GAWNu09bkzBS7Ox3/U=", "C5N7oVE12+9zZEb7SSMgbIQDpCqADCbmKEqTuyM9XDk=", "E4aa/O+DCb/UN1JhADG9DRVfD40Rv+mnFURS4r8IQFc=", "BtQs71ri7DTkl8WWE57x1QSgzaJA8XYjNfAtzVjDg5U=", "FVQwjMcSTMvcBP+xu5f+HoJ3s4b2XM8si1YU40MDGjE=", "Hk+8TD5PV+kK1QvG56ELRo/PmgqHopDEhziX5JeRORw=", "CNLKW88A6Xad/IaNHIbyiOQKMcqDloUvOXc2mvJNcLc=", "H1u+vkoYhDSsaZM/uN9QULqJBwh5l4+kt3h7+uf4O1Y=", "EaLc9F10BEXdHoLviIKYE1Vaz3aiGQJMpwAlASQKDkM=", "KooS5osfy6EOCm0ahsFKENJuPHQW821izmIXz5Z+HGc=", "BFKEjTwMAP5g1yE4BlDISc7Sz3nTBEgggSIj4UZkfzU=", "KkelT1n/InRVl6z2AHVHWRE8p9uvEdnAj1B8Rqmqyb4=", "GFv1dHJWLMpF+HrBsa6BIq7FjO24MSgcUfN5nwfnK40=", "Ds72SJ5wmtXFh2NrO92ce26FdCF1/4br38U6tYjW2NY=", "Fgiz4mJP/CwAkeR+kOWsPJlicTxqE2g/1VMXI8uziJo=", "DT9gdGvKV+XJaDcuwOmHUQpkfy59NEFbo3mJ2vqUxgo=", "CY7PBIThJ6pnlSPK0UjqInI3qNn/ndjY85+1gWLDvWE=", "MC8Q4RwT83ZyI7xQGl+d0TD+UXtifwJI94n7ezCsEF0=", "CSRxf+e6v+lUGzOG+kBFWgF3xpcxuvIsCYLPdieImeI=", "FzgpZbp75wnVTXDKPhP+yiOyK55uWpGKnwCPR82/qIU=", "INMAENl3+dkSvnlzd3UXiqhB2XISiqqV63sn4WDC0rE=", "BZS9t4s7aZk0SWCThqJR+hSsU2w37QFghImsHHIcBwY=", "LO7GwTwRu9R2ZIRDIMz97uQC4K8uyAaHlsfDdTMwr/Y=", "J5+tqD+DDf2XtyiOZwRZ3AeMds8GN6iYPAYX8ntLNHI=", "Ap1ZOjESw79X7Iq2h9g5j8J2/PHUYqaCKJJzhTP7RQ4=", "BxdRgfBVTab/6kqGDAMSS41Qw65bWaFn5YR7oz0ZwFA=", "EoDLe96brBw9f1V/J6Ws6tbkp3vl3D6CIQh+SmziPq0=", "GplJWNRMND9ZSJBWuM1yVJH/VRwPRJaXtUbI3Py5C/w=", "HwBANOiBDB8d5Qe37thCmDQSq4Rz4rAPx1WT604/VQk=", "BAX8x7dZuMow6Sc4FO+zUMHlJULTOPJMR/2ZqUIHgAo=", "C4clRctczHPSILu+Af45lA56iSmwhGAlQSMIB9r7PIs=", "KBn6zKLNbMFqauoxkfgzwtNynUd8c4NepVO+WHPOJzA=", "Iucl9s7PFldUzhpS/7rqd02OSF1my6eZcjJTsmtoxT8=", "AdEi5GVIYcSz92w7xJUpqMVzx7DU0+ecSOOkv71izRw=", "HtT1ZNFH8/qjgzagmFAi1TfTRSG1Eck2C9zRsp+JovI=", "L62ZEsTK6l1EBRfw5WiGlaTRaw53s9w/2H+GnIPludw=", "K1qFYfDcWG1uO7g+1ewySO0MCfmzA1JHHysLgDId6uE=", "GG9NY7AU3oyep6sBp5q+W5vjgI5sqDRBMvYPVZWjPVc=", "GuXpQPxdEpXTJFeoQFgcO4u9oBFbZvf3ykKYJPruTRY=", "FK/giArZL4FikqRSzQEThGMtZOoYOZedPWfUBa8yd4w=", "Gshp51S+iwcaPunGSvSQlkObmPRLFajG9PWui3WjhJ0=", "LcKaGjF0mbQ6Wkuhs2ysFQj3lbzEQxv7DqcCjvL9Mqk=", "LujQOv5DwriFmfCjW5CSauZRBjficzrA9pRtkI3lExI=", "Jm2A+1wQsmVeFBd3CXBARzzVpN7akiW4UlyUg23VHrk=", "Lk1m9lWUg/dvH1VoLR7bVsjD4U2vtr6zoCOQVE5Swi0=", "EBI67VFCWA3GdAjjN9THc3idk+R55PtEvXMhjPPbdQA=", "GVJvJbfr4sRhOV5m+Gb/uAspktU4gxAPDb/GfxMqWpE=", "LnfZaoc25sOPtnuTWlWDK1EaStjYZiH5uzEyIt031lY=", "CfLGyWnUjsKRV2u82Rf9YiwrmOwhu/ot9dVzJP+7Sxg=", "DdNgBYFxsCMmyeTEYYyOGUmZ1sRIAIH6c4h4w+GxHlc=", "GYpSuCgsrX66OjgAtZp5SixwlJ7ZZshrop2bzDfyk2U=", "F+uMjoAD1rk3g+Z70U0SqUVWhM3qTsWNdqg6B7Qo3Ec=", "H7nBYLCXl+nU7sx5xQ4mWOwQ0POOzvwePoeGuV/fliY=", "AgLDtklaivid3G4/v01m1z5t0T+Kq4kxdMDK/XjIpRA=", "EUun8SwOGjsSwrUpG9gUG9UN/HAARlCEpwH0exV2MIM=", "AZrT6GrYKjdlqmTqAi0RF+HCMMAqaskAN4lXKPgrM0c=", "JU/47J7KTT+ybHLNY6fU6Ym7G566DYv893E9q/f2TgE=", "C+jJta7jfvqT7nm1/8AOi3cnQsYBv48jAlKSWtLJpwI=", "DHF3U0GpiskJuh8mrOQN6KVjMJMTNqvnFdLB632TG6I=", "C4M+yDBcLLUAK1m+ueWCFqJ6tpu8cYjkMCEx4g/une4=", "F0ruMcNrgaYhK51EYGWviACmDMpeqhsW/shcLi/5dOE=", "F4Md1AbHeFpTZNOTknfanrW23/Hlb6Nf8YUGxksqi5U=", "Eh4cG9t+SjV0v9HDpMs5lKxJNv9UsHyqCnylPMCdxEU=", "D7LKXTcGb9cpJHiRdJj4eIvuM9PtSQRSWkFFvONf/xs=", "HBMc+KHVRAM3+hPllc9tQsMBYEn/rAmVfmnQtFAef/Q=", "Bw7ksvepCt0TVfnNvDpVf4SqzGSGNLD/SPg95PdqWFY=", "CsBcmxPR8oKBBTsSrxmHdvPJE11I+V1nyTFLLEjuDdo=", "DJWhdr+bN+Du+SQmzPrdKWlUwLynlJKSJc/cQniWFXQ=", "FmNaE1EocLcvqB5GSEIaIhDAspv6GjzJ9BRwqRiERF8=", "DNwz6xnyEBe+ikzws3trEvgB6lxM23ejTPF2rYW/pu0=", "DodkWXcBCb0xX9ky6nxpyWzzFONAPQ+T/bOv1koVBHI=", "HyagC/1ne/5XuHnHHLxUypE6R5HUsE4wQ3Zwlm2EADc=", "IpoXaSyM8zdyJUJs4Mul1h7V99u1ox3WA+rfoWW8z40=", "Ia5xQJQ5XfZSZ6y2VJ1YAhnESb+Gwz6095PgdHpkRfo=", "KvvdI1x5Vlvi9uLNsdUnvVaa3/7ODLOf4IvJ0OwuotY=", "CpXBGvPvegxYXr0gaL36sqEymCGhe69lpqB0azikrFY=", "LtgiQBpIWmIe4LBPb3tQrfeW0iXj6qWHvL+HxOwKGak=", "EPUiacDEfj2KTIeLp3sJjRp+kT/NWPihvNSvtSCuAbU=", "C6tJANwhnRpzexHGG95dpq83XTZAHBIej/6FNdq2dII=", "Dw+FMPAxDLL2yZnuLcaUMpqVeUayx2HIUF7OzLL/Ijc=", "IBXLjzKszqsUTZaBNuh9Z8wlF1KpNkt3WYiOsYAKJUo=", "BmAZTYguN4oWe4cM5wleWtEZ9m/5dGXcySnLAq62AtY=", "AxK62Sdaxn8rs0YQv988aYnonvGL/rOlr1o96tq94Og=", "BcvGjlsFofw+eEVp7zJQEfg52tOA6OB3QtwK9RSASTg=", "I+ZoithGkLL8wdFm+mchEF02lmzpo4Sg9lmrAqe74B0=", "JiAXEweNNn1oozzm67gqtVtsEW5TTIUEP+RYz00fkSA=", "KtF3ROB5tw4xde8MyG69cjjMzSgRSAOEmMR8czuu8/A=", "ACJ7JFay3zgB7WQEdGQlDoGzvB0g8/t5/vNNOPqjl3M=", "GTbCWreOVKlHp0Ut1lwEc59S3zJMtIHrmhMGc2Sg/dA=", "KqnTU7ivrr/6u6jtCSIKgSHvjNYa0sIMyk/o1dZXcto=", "LDfehEXOsObhZVGgglH9R3pXw21JNwj48VAzRuIk7HM=", "C2AWtBMGj9gRlgOsCuCv35QoSRarlYJzJYSFcxL8Yig=", "HC2kw/ywIVrvgudfZ7YttX9+JheS+2kZU4K4q1ZbKBQ=", "DZAZ4Ge4ot1IEpmskEoUy1FqwN2qF3g5WBdwonYWBB4=", "Ct2PLhKZliXWZefsgEwlmGK5l2aZeidUSY8cEMcI9RY=", "GwTJT7oBYPrxppriiQH25Y8mUTfE5ur/AD3DTMBq6aI=", "GbWMOKNo0b+0neiqsUU2gSOBfhXQa/HYh8oh/u5IG4I=", "JoUSphkVeb5MUcyLuLncrNRmP2nmDyle11BDD29/19E=", "E9JotCwzhbaMVPK8ufckV9ftkTj+38hRgaBIly004bQ=", "LLCplEjjiOBPXeTJy6Uvl7nEt8dIbfMjbI+S4WIAlB8=", "HwEBMo2J2Mk01yyjbIPeDwye7gbKNsVR2PvuolXNGM4=", "FCYvobM/euPXZmcZkA9koThxA+1LPh2ZX9ztZnYHILw=", "ATZBIbPW1kxMzbEFhLS8aw90e7tm8w12TQ5gp5bTCl4=", "L/2l7T6hiEfs2Pu7lR6DYoRi4VwkY3pqX8RDzGRFAys=", "G2qfnHwJNUu48gb5/kqcqOlcbkGy3ylF0u/t7TGZ78M=", "KVQYJ4K4qcKqrmdeXYyBo43J0upkYvXobQgXcL6/0qo=", "DK1X7BuIBZvabUHZV/FxeL64qTKim2FiZ1pv7n2uFXQ=", "Kdb2Bsr1qteF6Wd/uqH4cVsTDpCKp6XW2I4Is7hxZJI=", "MDpof1We1udwyahBFa5yZkP6FvSp7FwkD4mBaZ8vjHs=", "IxilqADeRnrHQGhI0iun4vKt4f5n3yVc1ionza0YgIY=", "Io6p7687GHAdOuvwDHQy0TpnYOc3Z8umfb/qxGHQqKg=", "LtTEK/BK63hzwvoU1WRlhTNVPQzINXz9LE3PVDsim+Q=", "Ha/FOh3uh9wGHhJDXJMq4fTU9szlfY5PAw63wO00e4Y=", "GB+ICSFxH2Eo4t+rVEQMIIetfQI1vspJbcYa6uI12zo=", "FD+6zIuUj/Vh1hz/IQ6K+CoKUAhS2ErinYQQ5NLcfhw=", "BsTgZ56LTRuCSeCbriI4uRYWpCCUxpvoOTlXCkdR4JM=", "FPfNqJu7zXzdd4/4eMjfZuKZfO0/7TCR+gslnHQzR80=", "IbQL2z2xeK+5fmyPUJo6VOSXDHAqPJbipoCjvZzRFZ4=", "AiM6+jRW9HLN/j9hDQYS8NdK2YQtCtCLgmkW06O0O6w=", "GVg4zXYsKgrCN8a7ER0nS/gJAP9rSVZoC95BrfyQEQ0=", "CYK4gCIWQi9G8pwJhZZxAgSLQ7U+PI0eVYss6BYn8NI=", "ARy8dBwb9I9wgPSRwm0RZ2aovFHZz7bNCBY+Vp5fVG0=", "BMJncL/TC+fwhsnHB/KeOKIqtlQf3V2UkdYT0/w21ko=", "Idor2D7oAXDUyxI+Mi+GxKovLr+Fy5e7GejXNAzPpVY=", "E4CqWbA7WMaNN39i7gs73AbBst8MaNUD+LCpXBcjm6M=", "ITCc7GEgsyBBR1upust6pQdXj8fUKLsBD8BvDqNtB2I=", "CHksz4jPbkUNE37XtUlilfP5zWN2RUNG+uRxf3mA5VQ=", "Cu8PkIbJ6UJDIgDotZVVaVpPUx4xn9DVfxiBpV46A34=", "Dgt0jVhWk2s/2PLrHrTCzSuLi+TWMYqCytPgusUFdm8=", "Fy+tMlk8N0zu8aQqu9cIVl01kegDLFF+RZXzBkFVro4=", "JvX5zk1yFF0+csQsl0/9/ImkjFEb12Cz2dsDubEFxLg=", "EOBTM2k0kE/217Zyo70spYco5RSalYKnLBwwnvz3pAc=", "HwGpiTTd3lHzANVC0frY//QRdHHKsBXUFGsF8d6wQRY=", "CHzXqV/fX7nX8EMaBGZiXNtC3GI3//539boUxt+hs5M=", "H5ro73HbzQ1IoSS9Jl03zAwQGMoLRee0N5awRfZaelU=", "FXGisKJRWMDF0pejl3FbAL0cVDXSaGwxYY1BKMU48Mg=", "IyL98nYeRffPJl5NYnJRlibeCLv15xrxcGnfKUl6WDg=", "LKiYD5/c2xs1Ai4C9r5i8ZNVykuerJsv3MN98u0CZPk=", "GoiBwzTzlCDUZyxQUPRdkoFCTrYVRXgqbBcEDcfTgEg=", "HzGaDcD5t0KePum+1XqWoPL2fLX82SscnNyXoV93Yb8=", "JBkzbybcXUmPJ5r5W019EhETfGCO7Sm1yVEGleGkZ8Y=", "H1FNIvZyy7FjY776VmeHeCCb0lfKEXtRQbKeBuS9V5g=", "KANKbJAc7ExWZ1MR3vEPvNgIjy9o95XTs1UZux+/Gh0=", "JsK5IRjNJwQGMkH7kZgGoP75gUyHsHHVoR78LLEQPPI=", "A9U56i3cs1h2OGF5HMQ00e7+cxrTJi7ahXxWoG2c+N8=", "Igb0lDZAnovo9UKSbZ4pkSG0MhDnHdeXD7QoMzfSQcc=", "DfJVmGB3cQOf71d6b227YQzuryBOqsegm5atIt5oNGc=", "KDqJjeWiFGXMoyE69YS39WQTqehLUkQxQ20LE2aVZk4=", "JqsmTolhEDncnP1LIW30Rwm1TyQY32ZUXDDLk4FORGo=", "IhDX8u9D4inFYx1OcB74n/3xrKZDUXkeD+fu1ChJPI4=", "B9oK/7R9ZLftxoLavlxtsiR0O1o4XQSiR01S/+ir/Qk=", "Aq2CgK5c+Ck2Bp9y5JAQ+NFkPNwpnxKsCW/UTFAf+a8=", "JnuJ+E9IReOSRWX88aVOijJX/oru9RX4bMHABW9G9qo=", "LUb1w15agc2QL0GLS5PyWr+ALTLVLaBUpe3u4nYUjKo=", "IK6OcVcPiuXmVetCpPJ0ZQImrx/hYKlrF3hU1zbyvSo=", "AgubKaVkR5CloxqgpyT7V482UFkN3RZM5a9ZP0PHmPQ=", "E5DB2VmRlys7jvoaNnODq5f0cUOWY16HkTlZNwEO8KI=", "BJc7Q2Px9V2hLU6rmFAS0yvYC8CtuQIWrtlXTanpfFg=", "JfemU/xarcSvD+U0lTvIgweiDpQdfGhrxTu+Mk0YTNM=", "Ek14EIIfR3gv5r9kp8XqzwPVWXdqJeL2neKDYr4YC8k=", "L28EkJ3DYNGt1QOVPBFkj3JusPYS9wOsHjeGA9MzCag=", "E8LPGyG3hiOPqpO/v/XAkhiZ7xqylUiCijdeS8AKG1I=", "CEwgDxDv9Zv0PPPMOlBt5QDtaOWbzlzd8RN+x9YaTqQ=", "BTta1ZAt+1yjbXay+YCQaxTr3EchVGofXx6XQWRPKRM=", "I71EmLTAyfJIgi8VtciLx6eNUo070+PTsnr2Azr+EmI=", "K1/2Gw4f4YzYTjUsQXq1uDZoPyjfHBbijAi8T9JpqZ4=", "KPd0t5NrxQled+tlUAWrh2eq0HbAmLj7uoUh8YokhbQ=", "DH9tLq1oN3JWWYSsgZ3CyDJsxNOxj2M5ElYhJiEoyEU=", "HgNTLjURFWUXP3a2funHE5U3VwN7Jys2mxS7XSKrZDM=", "HNrhaC8sEORA3jLrUXJtnbdtB7ZClnW/rX53jMC+4HY=", "JN5AZm9Z3pfe7/bTTIc7fCSY8CK4VsVR+0um/gM+Tho=", "D90BZtFcD0Jm7XKW26S2OQQM6qaRBoPuRNN7CGefSCU=", "AxjuIlTDiIzkU02QkESLeoYq+9/71EcNq1XJ+iT1CoU=", "B6jRmhl5yPo0Ab/pZO1dPz7vGdfk0LoAfzhUtJBMXzc=", "KEbxWhIUVvD3S1ByESqQ7MVqSNmKegfzDrVTQkoAsno=", "EpWtLeaOBbETAx3oVJWdmFj6z0SMoQFAVAeq/B/lBJY=", "J0UhDswlMwF6QzBfzRMHjWlEPQ3aNb4upQ/Ehf+PHIg=", "DcJ/CzX+wOD/jL4THH7kKiKNiJy4JUxJAMtW6nhJGbI=", "CXgJJc2xQpzBfB5wsLQ3VeLnBgKZTpddNMP8McrBmDk=", "LvieyuEAaiD3OapNpph7uGbWmT+onkovvMu5zijtWK0=", "D2/qsyFRVqw/h4zmfFlT28Tlqz0THulYJ1Mm/5TSmlQ=", "IEnBvLA1y1miNQvOzCpi9P22WBCPBZvDjBQJhXGofSI=", "CcUpj2aWg2sqZUTJyhwPZEjg5uTg1KjDqn5jWu0g2kU=", "HUjsjXhr4o9xvXGZTaBPeH3Et3kv4lglWvdCs0jk6mQ=", "B2a6PzYPnLjSdZPO4diQ9XNQwjUJbZ0FYzmS1HfvJWc=", "GIk5Vs5gBzRxTM/rxE9nA29RxlKCK8DCN5fXOpPUdJM=", "ADrF5qPANzxYN5vzjIcWXXFqygXhTORynskUltx0od4=", "Fx9LPQSm6vfbC4bbC6W+fURRtOoKEzO/qjG+j1DaEqo=", "GBlVo/7U/xnZDZR8LxV/BQ2zTIR/WfX2OsbAO1U4OqA=", "FeUDrmbNN7OlisZVSaod5ZIo9eWq3qcDUWm5gB5YqAA=", "D+64rsbJY3dLJ/hqVbRZTVS0swlV41hJDqFpc4+eYWk=", "DdlTH3o08aAB1OvHTLTqR3K5VRkyXSmJ/JMwNcaK030=", "IZ+1msIhdHlyvOZveMozybrjgwXhGrNIGuvbndtLLLg=", "H9YNwMR23vO2JMIZswVTc9cyE92SXpQL9VztiCMc4J8=", "H40H7z4Wy+uniSQZViEc+llUUoAfCMh2wlJdxQTFILk=", "BRV0FUjro5fRTmJpsyVmYV0JRHFVurABrG7iBWmPFuw=", "JTCzfS3RthZgOfKfsdeOkOkDTLbptlP+dCjXaPjpstU=", "FgLoadULKAlR7Ms85xcVYomA1kg5Domv9Q5VobvK1LU=", "IziHIXr2crus2HPxKFo2EnlrDL94kEY+3lSIL8d0zH4=", "GEmzqp5wU8jpUlKFiYCr6PFkLsZoBHU/Av9j8P8h1kg=", "GgBJeAiF4IJ0R6+bqeueZY/9Yqy6yZj2wagN3lrtwaM=", "HKnL+oCMqchVWUJa8xwK7D5ZNLarUaLqJUn7wudWKRM=", "KKKg8GIsKo5PFvLgNltytIExLY1Qh+LliuibNLjMk6E=", "IdG+7RC/+Wyp9hW97ZlnSnMxpS+zVmlT5t357KKAFT4=", "GHEU8ru6mpkyl710DCc17wG4WrvbW0fEHObs8vx+2+M=", "EdCjhndcbmcKNgpv2VfEA7Q0uhP3LO3DnRQIv6c/wGw=", "D/TvL0ar7yTKFdizieAs05RNEpYTG20tzpVN0R1yT2U=", "IDOOR7Ug0oFEjz+L8AiqdD90xbY/mKYwoAEIRkuyiSU=", "JW+g/vWFPcEK76hlxWUxaTl9VF8HWE6uZeGz5Q+2phY=", "FEujYZ1fydhPBjLfKW6N6lAXMpVzZhtpiAw4ykWuMYk=", "KYSYyN8x3TFTgLNlH+nH7VqvSklQpmE0vItgKUcqNWQ=", "GMr54mSjLbyiPaUaNRT7qS+2L3jswthEVXNV7IpDsME=", "GUyBKCjxzb8MTwsEhq+0xdlszCGLO5DQS8XxyGZf9kE=", "I/k+HEQRm6hWoQOAwjMxkbMQX1AqYeq92LGryAPASuI=", "JdLMmI5HznD6mc8YEFAA0wRnF9g5r1R+3D3pMZaawAY=", "HRCDYAAjzM3H2u6+sZeDqsxulCJtAMfKRNr9dVYUqA4=", "GUOp74Eav+ZX//klBPKokU8J391bl5kRBHvuS2mABM8=", "AfltsTkqOuXL/uTBhj8L3f2VplKZPI8XzhiGnCYbxsc=", "EtSBTrsxUzHU+6nfwu+QnNd7HnEmyeYlijyYIdZj13g=", "J6KtabnrVpe4W0MeuoXbsZhD88dRgSGqSVFaZe5VLjA=", "Bm9/KYHsxMRBXaYuq9MjBCSr/tNWcSH2VugZGnjF3fA=", "FuKY9gsmXwb47JIn5U6LvPK0gjkh3rRPBjySQw/EChI=", "HBCrOcsEzgK6ctmWBJrWiJYfYPjZgh0XFsWmov4KlzQ=", "LNfIp43Zmu3BjI1HRStNWy6cWyEo6zc7ggyovuyXCnM=", "IzkayfKcGpntb72bv75ytIhWm/miB63b1OMKOouXMR8=", "MEHFWZpR7aM6Y5jrMSMlGXl7AHJnAqmKMZx8y6n+0vI=", "BOZJCNefNe13+oGW8HqUjISFErU02b9PMO8JPHl0A64=", "GSUekH16kDv6e+2H6wS9kh3BkGLk7Dq8noK3+k4lvm8=", "GzloHCwSXK6NOMxe9vrCUvT4I3T9W5BZYU7ME08rKdU=", "IXpU3Wjc1T4zbOpJ2Jkl/RKP7mW9yhMWWdMkrmNmlrA=", "LAVL9vkXdgIN4/uXBbop4N8X1+Gv5h4R7ajK94dirzw=", "H4hhHWwCh85TVD2H7YGCukdfbiI5ie2jXRq3RidfpOk=", "IE1amCnVcOIDveSRuGKpaXnXHkgOv/uxPEyzr1Zjcc8=", "DqyVxoivqnc6zkhWJSeIFwurppphgQcdHRpODdMgtLU=", "IkWgln13esUWAIJWPVgVtE7Q/55DBcZcUD4P/rrl3S8=", "G3MpBUZq2SGrJDDL33cqgW0c7U3qaBjcPO38Z//l/74=", "CMrxpM2CbRnhwn+XDK0FstSZMbrjabgsMAEQQYefKJQ=", "J9gTRCPNmHskn0vtx3c/t7cxToyD2XJ/OiHQ8WLFYc0=", "CaLqN7PXOdzXCGLOYqiDfdJnwiop6wUO8kbt2E9I+fo=", "Gtz7Q2sjj3RhdXqWZdLcz+occ1LFnlrqqO0kuFML37Y=", "KiNU21Nf66CACtZll2HymqsxwUJxbhZ3lYPBfTy81wA=", "AQMbh2/HBMMpa7OBELh0dviPVyGhEyunG6DcQWhxmm0=", "C4Xp+2ZMw7TuU5k2+IWIWuVDxgb9oAeu0gJXyOTuNZc=", "GAZ70IXGDaYwqyTN9Bmv2gl3iRLVx26/2d9+z/YgcYY=", "A3cdvlwzQP0omRfW+smhVLbVXWNVevE9m+pxGq/F4ds=", "A6EgOBsVlnzeGjOTn8p4MMqhrx+61tbL1GI1khAfH3c=", "BAMk+61zkL2Yw1UyMs6mgdSxi+hXkxIY+70dOU1n94E=", "KUqTeKzPcjwmJm34m/8aK9txDxmN4WiJDf1zrPeGzZg=", "ID2GQEZjMs4MSTOWcxojuF93zdlYgMRX3ZzUbpm/DyU=", "DTOUgc9Sqx9lLsiWeol3bpK2qhIFZ5TJ3IVvwn7JHvg=", "FYvkIXdHB2ooqm9hfH7MYEXIzlxISq2hl5lLYYs3y6A=", "LaoXs1rC6iHto2uwbbQKf6gf5gzaVW1zEh2/F8igXr0=", "Gi95A71kPGHMXraEVSAvZhPJwDvDxZqM1/jRCwx3khA=", "HKeDX08cXzWqHgBUr7EUdpqCR0svn3cSJ/Ai+nYrpWo=", "BDqzyVtkzvp/l+Hoq/nbJdZMIhO/RLAbAAX+4GeAS+s=", "Du0WlAhs3W3YQALGk2USDMIxgoMibrfb2cEVTlvndKI=", "AxtyaqXdpFb/rCnNOLZJJr5XobbB/Fk6UOfpzThPfvM=", "JlLPv5ARD3cndQ1o7qt6SThYhpU/dYMr43XDfqmtZ1A=", "JKWNCHrzgabyewZV3nlbanvnNPBaT07e8FcieaKKO9g=", "GwTT6Sozj2vuuAkTgtkxQbO7PQMylEE6OY2iRGQnKkI=", "KQue4Co6Ke2pTOCKZ1IZHDwpbMLARO274JEXI2CyTB8=", "KgEtL0QVRckU0l0M0o+oEEzaKggIRcecx9DzkUaws1g=", "AdTlvBgM7cuO8KWdJUmKVC4yTPD3Eo9wfEM+rB7e1H8=", "BUZZ8BLsi3V7HSoXWp+mQ+ljI4w0ImSun8OaaddUYqg=", "GfwDBeHlsq/LhqdCFSuolasCSsWce1flNSJP+4B9xyA=", "IdH9DCr/zmdKsBZmGiFvBhW1ux8/w5henXTdceqGrWY=", "JpVtk/AXdtI7x/HjRkmSWBrd20gXa8uwPvqFOrCcOxc=", "JAMSDlpoeJW8vle1sR+6DZY+sMhj2Kq3QRL1Eu2K2eI=", "JmhPqblUiwiseeehS8KPjUdlAxLwYppAu8zbWQopjPM=", "IWlpwiG9w9qhwq25vkVsoZ/LlI3pcl/Fl6xiaWhxXBg=", "BtTlQ2LV3HzUie9GZxPBuKcDh2Bi7QNmpHWumsB3bA0=", "EMIev2QtOKrz3hWsSg3jtxq5eItZBKeDJu8Jmh65U/o=", "CkuOkbAtqUqmIaz/FrvdRPB50psgNKnh3YvicOfjqAM=", "KxpbUrXxxzn44WeoVht8WlZ/1Em2HkqqKWXzF3ut978=", "HoWKHtsJfxaPELkTDlHVpPO1Xaf61olimPFLt69OY1Y=", "KDYsP/ar5PsBdFDH3TRL1OCBAK/loJywGHcmWWeq/NM=", "IE4BfULmsyz/IJE2jjRCAUQIVHYaDNRjdmBB1+ONzUQ=", "GCMHqm4Gvxsgy+U0kToLVh4xAxbiNUDzXxvJ7kN+kqo=", "HuQArtK58e1nqBFkOMy3vbjReYaMH9am3ZSXdE75up0=", "KIWQrNMx9Eme/C5+iqJlbmTL8KaMfZKMIiDbZD251BA=", "AIY09kmz0lAiohJfXzANLM4svhIt9PHFEpbmtl//F5U=", "A8Riz8tFFp2c6tHQcVyM7P/sd+pEmiCIKur6Su4nTmo=", "GP1U1JhqLngEy8t35oEsBue44oylGuMj5W2QlHgqMM0=", "Abnv4EqAmkPGJMcm6SlL3NO9HpfL3tdC4hc9P+nkKf4=", "EJylkbk1DHGn8ohsblViizggYiOlfAeypEkHcckh4uo=", "D5gTTpB3Updo5Ow9zktiymuvgZnXjH419FGRKoD7G/o=", "IgWDSrHIpm3hvHZq3uGOr2iaUr6uhlmtTQtDe+wilSY=", "KSpsq6Bxuf2PtfDkbd5NcRu0oRitDGfnenY3VEvGwh0=", "DyGKxjqJ2W6jfWLqA4fBRd8vFJV7z1x7Wyy5MXqHF0A=", "ITk+Xy4RIRNqJfBxRly4WwKy/hJKjk6oMYGJGnELClA=", "BuItaUZITa0/StDaQb4R2iqlRR/H9M9sxYmCeKZ0e7k=", "HsgRfFWQB0opoBkUDv0cYntxX8Rk8desnUfwl5pMWcc=", "Dm9dLvgpRd+zkuRHE4vJTDK923JIMFWgVjREoOT23XA=", "Fpq/yz7pbX4C+XEercCp4kpHovn7ESHPjG2s2RpbMso=", "LR3NgljSxVlTXsYoYXiN6mDdQtf+4MzNIKauQhTSGZA=", "H4pGzsRlu6lkSW0lyvmjUb59CaYo/5fqxPzu17/tXEU=", "DdrldTAV58HzsH2uS+d0c5jJuYZnqhP4D3aKIgRiCyg=", "HZYSBGlyeSA/RyHdCFgkTyzGTFy/GkvxB3oELr8Rr4E=", "JhG78ZrduX9Ldhq8pDmZpLmNdYvHTtNxm/ZbFyY1q70=", "LJPFxbBX9SwLPVQzhlnwXRVm0CjBgWv7/PkANZO5gZA=", "KpJv0+Bmqft192/QKqmZaZmgkEUNEe4ah6Hg5lzSh/g=", "IR3O4P7j+Fcf2W8rXFXeETmAf6afvnkhZWP2xXCfcuQ=", "K33cKLK8LScY6da0x5DVWDS3eQbeLUzoswGsNdM712E=", "F7pRWTIaGA3e/pa8nQ+at/RL8uVRdLagkCm54/2D4Nw=", "JeErYyYhOWleUKHpa2SANTpt1qG7mAwg+R/VnlGKAw4=", "CV7KNILigFe1QRjabEWj8PWuU9Z77MT7DKLpbiQQFrA=", "ERKuuWIr0uADBt+nYIi6h+jZz+uD11a0CstEVOd+OrQ=", "G2lQfeg0Us45d6g+AWSBFK/A9Bl0prqWL3fafuA7I1M=", "GMNqIn8wuovoNQIs2giR1RsgSdzstSYcAkQzY0JoEoM=", "Ay3/ZQKtvz6uHtsKoqFCwjhyFt1QGsqhijVlESw87zA=", "Bn6bLfEORj/05l+iHRi457XFXSF5QSB4UNmEwmTqZLk=", "GGqMHd/Z+2cxJDpsGQ10wlgHYlT8TYUbtnwVyFXaaMk=", "JfEuCQSvcw7GiSASLo1+g+bbfg04GNgqs/UXllKs8aQ=", "KSoFO+kBPzdBVkVHJzKcowxQeBt/aDcesIKXSRTML4o=", "EoZ7tUHqF8UyzeFX6+L/bwo9PoO5VuYZlRzJmvIuPXs=", "Cd0qdXJqJl6Yq0LKDQE+e6LhWyYQBRbg6rc3+3AEm1Y=", "E3z9AFTbrmtjW05PnmF1Im5clcReWyVBM0+U39k7Ig8=", "DRRjbXt6/RGG8LnVyPjvVRvqx7stNrJUNvBL99y2Dec=", "HbyBAC2KXK4f2RBTLwikMjw1eBwrkBvXIrq+Cl9txhM=", "JBBXsNmXfqpQ4Euok3AroYLNsziMxjKQf0wggYNNjaU=", "B8p1ydUcZb/CypnJx3O8orrXtJg3C11Q4nWojLawYzk=", "Ffq280ro0ive3XYGEN1GPYgc74zoL+SgwPhgUC9tPMU=", "DPhG5nq4Fbe/slUAhzP4tF2Dk45usNvRnm1TfqpYHgA="],
      M: [["Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "ARoTGjd4w3dCM7xUCWQZ1GPTq7rhgyKn53pRGIFmX5M=", "KhirTcR3fhPLg1jBxCMVNXDRy5CVRCQ6vazUVHyOw6o=", "FuvXgsvPbWPDi4eyfbKkpa9YR6mmCInEz2qjGNaGax4=", "ArftR/rCddNPhC8JsB75QhAU3gQMJqWRWVsie6e8b7I=", "DF5J4xn7lTUHPwf54FWsyvPj8ko13LRsq2ffxkjvrzA=", "AWHkrlstJM1ji6XDK8Ixe/kNQE434APxBV2aluQG0w0=", "Ijx/xtJPxT0bQo7bjxxS0gzuxZIYfSx6awsUe2KSuB4=", "GuBg45szjQmEXi6evrcL+3TNSvkmIX9XMr4rbLf+cqY=", "BGGRq0HpOSnqUfGQ/U53OsjVCDMo1LLwSCjco+aQmMM=", "FLobU4Pjczxj0Awywrv/2OVFB+0zv3VEyGOIGR7KPkA="], ["AJgTyAP/hKNpTu2vSxwhcmFSddwYymVMeZpwRAlGzPA=", "FJWvA9yRgMiG8OG9r50Y4y5rDRuANw58vldF2vxDNSM=", "DZXoz4pmtWwy59EeAQfkHhKXEi0azEEzLxtJiVo8l/w=", "CwXxYQjEYWqXOwHYLlDU/J3NzOZ9LSH4UoFr0jTphys=", "IwtiMVswvEnXPf+KneecYg4Dx0exTEMvFwcV5YjWBao=", "FdIXoxeEdBBI8ybhVa+W6QtarnNPBneeaYhkA5yS4SM=", "CvmvvsrhdhzBfUS1HKZtHb3q80HoXxCClY+cty97VdQ=", "HaT048Z5CuG4nEEYhh2MoqUMyCpOfx7TxbqMuUS6Rok=", "KGCqUtwvlnwMGguUKsgeAhidAxQwwRqRmlqolbz7YVE=", "Fv8z1nyFEhvO59gc/xYYkn8ckrTR0hwqB7auGLK3ubc=", "G6DoNfR2JrDYJCaQDEkXCovinDnZAzeqX8EHZOIyGhs="], ["ACApc/f7pb0h7Vi/5xVteykBDUEJD2PxuykMHV2hrWA=", "EZNExTcH8AJDmDxtAk/Umg+K+A5YcZM+WP+Hw6H0i5M=", "B8IvlvL1VlPQTtxjFQVnp6BGCbC3nuz6yxSF3Ot7yHM=", "LzlM/T5EJQPDoiUSqkt2uVt0PHB2ykEVqfu7fGsH7l0=", "IGNRdQA3vckNTz55GGGfxpDCtYV/i/vYbXwAHkzyyhg=", "GszqCcK/0X9AYXJccS/Rl2oH53PlTZBtoWYhUgGlgTY=", "BeUsD/jASo5ePH6vodCQL+Y+NYmJNLAPQzOzj+YU+RM=", "LnCLqviUvFg15f6oEif6jPrvmQhtErCjp/P4W7ymHSg=", "CsI/AP8BW6qxyL6akJQ8PHLReBi+etQnxF6z/xgocn0=", "AhNHmPTKf7mSgBLJN/N96HQyuGZa7t83Pn/6b+DBPQA=", "Ahn14opfpSaJ0re+QyYkKAyUDJv5iDwfsP6Sn3iHPBs="], ["EjBerfZNrCSnkTpi2Vrv1F9INVV2xnHlb96cx8g0T/0=", "AKkr1qkZ0WBWFXhvLv6AdDylfBDsgM+5JnIrW+1Ai3k=", "D3FsVN5BkgxAGmLfj5GG4ZuVI+mGN6WxE9YczDC6AhM=", "ChV+JE+TkSXVf5yOZvfYjsD7PAW5D1JrrAhxvKhGd/U=", "Ihi+hh1STq8DuUILE2jpxap87+5y0ObvgHMu6dfm4sA=", "L5vRnQyMOIen/AFz+GPwdeZrGDrYnxNwSTBBbh1ct+w=", "FOtAHBCEqd3NXQCS5dGimaoPVcNRVFx4FwPAHOh9ayk=", "E/4jviQmG6W5LTY5ifWOF/zu1KhY0cYfws8rcdvbaTY=", "Ay+i8WZiLwV/YalAXJJWIjyrK6gslJVgeSF1WrAY9pA=", "Ku3b+iRXVq0eFlhin3R7jadZOxlcyVAyT5Xtye2kKq8=", "EjpgVWgQI7FlcMcPzfOujjh6lzaQueZ2G+IvmUHX73Y="], ["JceDrWbWofxshHcL1jf2IHCX3/sDeNfgOV+MC4a1Bfk=", "HH06ksqkNc3ZdFILtvtsrIFjTMm/TlNN93c24G12jDw=", "LNaPwxtn3EX7axb0K164nboq5+mqUMXxkVJ1qBiHGQo=", "HUVnwS22SNSpxBMkwDKTJbdqB3MPrXLvnkkKdIZ0mFw=", "Bp7k6yC0hg1K+Rr+F4Ezj1OqNUVi7Nhz4OYlr3B0byY=", "BsrQwr1DjE26LtZLv3UGbnMUhMNtH2c4tumGAen7SY0=", "Hg4WbXNKphTGtT209pEXmEGjP4EFQwo+5wq8qDum7G4=", "HIeclCjhlgfWR/XvFBXnb3xZ/QHlKvuASGCBhR+aUoQ=", "IVwM1OPxvbSCuT5XGHnXkxvpACPXoiDo+TshyK3UH/o=", "H0H8Z8oTIrN7eqAbYx/RkQUoH2xqTTf79o/BtfYoAsY=", "Hc42Bir35LAJj1WQYiztevnyjojUds3hOR6zBAjV0mY="], ["Ii3rYG8TzyjHOmchbYixb1lY1dKSuhDvO8LBD1oLYT8=", "EvuIoPb3SdaNqSUNWt7PCIRCgnJI1n+Yn9FLXJzU1Mc=", "AGYpLmTmosZGc67TZctQ971OHTtScPay6ZglkMP4QA4=", "CpSi18QJPGOII7CVcz83F21+dHuiRkW1FawqJB/92oE=", "CiJhKNodm9WzKfVfUsdWgt7zNpqxM1nct9IS7vyoYik=", "G12oOWY2FYbogQ/tAyQ1yqgKm0dtshKQR07Rl3/O8i8=", "L6dd7tKB23NPq6W3Dq9Xli+T4u6h09zuNMgasen8wO4=", "EoyzFQsVy8T6qxS/fWdu82grUsq/yNNBnf2YEJ0Z7MA=", "BScAsZ721C6jkuBEoJTL/DCO6h9y8qNCix5yG/wyxq0=", "ItHmTU7hXmDEWdhR7580lek39akJkDgsl4Z8RbeUAHE=", "JS50dGZ3/XWEzrD4qmk2vQT5Uo72AHN+mRP+S1aY6yg="], ["FhTQJUcncf2HCp6dQis1ccVJTn1nmCTY/hISF31fouw=", "L2xOCXu1hRvhK74scSwvqQbzELeASNaVtKrTAf/A0mg=", "CKHvZfUhKOs7It8rasowUJsK+K8veIju52bAwkhxGIs=", "L28UUC8g2Vip/yO2lsrDriSWdReuiy6Vktr0UYQLuY4=", "F860KhnebdMuOzjMKZDmQnO1KlYYJj7r+knYRRjqO+8=", "KtveXHtz6afiK5E/meQNleaJxlxCjCOXzSc5I89o3b0=", "FL/jMRXfKTZwOT4dyNpNaUesxLYCSeWxyMrjdmZc1YA=", "K/UjzYqjviDOfYkfhyensktypNSDhITehCrMeC/YvTI=", "AzuTpc8V/7r6JybyUngkoRr45C4B06fuFZsnPKCmUgw=", "JJ9Bb65atSpDXWUgEAbdiujVQmbk1WQzB1UZAkI/fMY=", "GakHmpiXojcHQlJ2eRK+17djWujKDt4t06QqdcHGuBo="], ["ATWL3Wt6UbH1tdCU29juCGzNz7nCf6rQgG6O9xjQ4rE=", "HAbHgvvAmAueSTsppeSgSu/GaM1CVdbP4gjp58i5ocQ=", "JFKWOOvN8m3ogWKH/sY3BhThEuEMA5GQwQOnXO0RtCY=", "EmQcw89Qyme8k7yMGe2J1GE+nigaUc3zE8vIERkiJCw=", "KQEt7/sRLrFANBWcWRYvhm1KGAO00ZKkMpNZ8PkDJm8=", "GouK0ey2y4iCc6kL74saLPwD3UTgsosY4QdOQEqeD0w=", "F+oZjzqyYdoAAVLyaw6w6+CIpwnosGoYo9whCMIJaGQ=", "BFqqmc4eBqPAIVCASpEIf1ekO3l5d3PoMhbKlp6HM4A=", "JU46zbx1rFkmebAytlqckdLgkqteVxlVG12mNbE+lHE=", "EqmWq8hXcCGseIDBbwWNngbpURGH8Krf9rtkDkMW0mw=", "B3ft702RUg/NSQoi3Faal+VAoP21J7Sxo6hU/jRrjn8="], ["HCAH66TRYphGu2lASsyEVl3l0kYg91z82fEf7us/N0g=", "IRhlt/nBx5GjPXA60ygPaXVjJDSa/IkSoZuD3izQagw=", "EuS1QI9IZBlRc56iflIQZyQLgqpRpC3i1NwegiWQgYc=", "AhhcekrYyyHxkAk5bxNKLD/WFNMF5HXd0Z8m9tSz+c4=", "CcSy9hrfJFJmFozJGOlvf438Nb0997I/xkHvAbzHHM4=", "KB7KFLvDkgkZ4AEVBFHD5E/xjh3RFxQS/15mPXSgc8E=", "BTPopFS4zW341I+psKnLKVKTPhprHUI8vFTQUzpyWZs=", "KEzPcIWVR/y5w8e2TPCtYuUXJuyBtY6wHBofjsep63A=", "BPpWIKLAV9xVKln97+UKkBBoGQ/cPfh2GZHKtQoBpEk=", "LSZAp07emvbJiI5faKhPrJKxMzfa2PxhUvqzS1VBmQg=", "Eho3ZCaf01zfHmIcPcYxj0e4YjgLoANXhJ2IQAWUY+4="], ["IvSdckQHfkH0CcCzU6/RaW46oV/9tKC9uIP/56Gochc=", "JVQuB8HBOXm7FPjU7pPat6PcdQgGzzfywC/1O0u55m0=", "AIS4ixzkWYtwHPlqM3mgKjFX1Bk8io8RV0WfajTsMvs=", "L22jhUUJEc0nLhNgHnzmbCuR2AkwdJL37leK401vX7Q=", "GAK5flS/Ool4Yyy+EOQpcFsDaAMl0m6hkMDx68c2LqM=", "AFTMgcfR1ZWB680msWzL3L8ZaNd/h6IIHRMFT1ERj3w=", "GWgbQkLRHiiqclMM8zp9FXGfGoiP/2JeBGUsd+4rLeM=", "Gr/ksc9dsp1AeOUom7FDSYq7vcmvVnIEcKJqPforqFU=", "HSJ5Zz9sq/ChxLjuv46ceDYWgLLlnX7Bk0iBn1s9WhQ=", "DyRtL7tOEhfwljH7yHcIJ8NnUeatjW+xaBDjOVFDrYA=", "L4DKFRsHe1B2coHqXUwfdFf42kRN2hbYFJu2wQYe0Ko="], ["GVFSOkJwxUQD3+Mhj9PUzO+kMRTxsZ+ywoIaQ3Rxi50=", "ErWgnh6V4NAfvNI0+tRz2O4rqXb6IoJ/+m3QPIslpk8=", "LBhOkE17/TaNRJW54wJ/mva5MTyPGT+SmsniTRDXo28=", "FvxI5V1k2DAQrVczd+okIjl/w6fmyIr4CKVm3gIj8MA=", "LbGsTCscI6AAJ/3PD2Y6+JbYdBW7A1sUnSitPamMb8w=", "FwwFpfilXVyf3F6COLNnvjWJF6GaKLTEfkbz5z1CoIU=", "Hrf25VICFcFeJ0NVsZu/cau/BKpCbNB9pTbLP5Cfblc=", "FBEadL0kcwyDNpnrQbOPHU7Rb88P7MFlW3byQ31KDJo=", "LUa0jlCQwMVqOQ3jc/TJogCNsxH+MQY89P7VRikRNYU=", "FfMOvfuLjuZEJBA5omtAjceo3nfyzG/tdUtwPqkt3lM=", "HulQxFoML0pLZGiKeTXtK2PU/ltBSvoFwaKEZ0QJ8WU="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon10.js
var require_poseidon10 = __commonJS({
  "../node_modules/poseidon-lite/poseidon10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon10 = poseidon102;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__10());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon102(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/11.js
var require__11 = __commonJS({
  "../node_modules/poseidon-lite/constants/11.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FRLfATW2aSWJ8HEUCmB0nPd1xkKzANovtK1cbiOtTl8=", "KxCa4DftMDYc9lRLL0zljzVliYltaohJSC7T+bZuEZg=", "Alhb7OBu/1U9SFR4oZ6xSeIRGuTh7LHWH8EM/hwHfzQ=", "Af+Jb0wGYvSyrZJnQbSB0DuBOozDQ7nC0rxIGccLLzw=", "GwyvAvQ0+j1M1PuxPTEWrItzhqWv1sZwduy8NwSqRdw=", "D8t8nxPIVRengFiUrIK1fAby8VOm9R9g+OUIaE3+W80=", "LcK99/Q4EuOc7yEOQukrSWiti/VUVBGCNUUE0yy/mVQ=", "Ba3Z3yDBiY2ka790WUQ4vrB8mmVjXJD0XAoI/rrRNmQ=", "IcraZkFmTaqZf9VazouIGRzcQZT727bKWJVEfIpYhZ8=", "GWI1BFiaYPBYsESJsVMyTRbtZmZ6BN9XKxA1kLhIvwQ=", "F3ZELYUKQ2oAXgLGR1ty/S1fhEUokMREFihI7h1X3sI=", "BsFpH9bS7pg5ZhDzyGjXCHTyTv+FOTjYf6zokjSgmpg=", "IsOroV86Fwob0RdhzCF5Snr7NIpF2F4wvFIniBST9Fs=", "H3exjwbhRYh3wrGMrk6SwZbAvg93m55jsGxI6QsCdPo=", "Imw9/npqZzGcHa3aG07wTkX2uAp43bC9Z+Nj5juFxUY=", "BW7746reaOaIarkumKPSimjKidL7dXBvaUagCB8B9iE=", "KWQGRR8gHA0JWHt/TgCn0OGUAmDUgxPegH/C3w91XX8=", "IADgtgErIPCd+O7SWwlb8i514qnIfkeCh3ALWTNW+Es=", "In83ZrZkLUTG2DahfDDOz/ZUtUSuhjaBjbjifbEkrTE=", "JARkGy9drZciVCvxUdSX6RmYBySbiGyXXyY4XfslSnQ=", "A3STrGTR3rNLm4NJDzUXDEIS0sMJJtTk7+5XuqZSun8=", "GOoHSI8CxpJfSwHQG4CcmmMl7MfZx5CSK2jOXnlBWV0=", "EZUr/LoGRCs8Hr2Vnx1MUfmC8h+ZThBcJXj8Sv/5HJE=", "Er4qMvJ6TiA1F6sgKOZblJ+JbFvs/lfiTArwT6xyBUQ=", "I+gJf2m75F8C+uxeJtxSOgIVO5756LucXxed/jA2w1g=", "B2P8S32pS629l7qTNhPDU07yFTaucIXhI8jT4jI1E24=", "J6T70cQ+CsFerJdODOLiU0TEbDIy7nExQZOMsBmz+Qc=", "Le5K2lk9dWZU3sErhr+wQa14WlZwdhH8SEX02Enn+G0=", "C1FR0N32GyKRdy65Ok4+IR9SEkM4zHDz0e2VsOnaM1U=", "IRbibHCG5wyAZgWhZxOX18BzvQFtNwqzzOfGlafu+Ws=", "CUGEkUerLNjRicT4sXtalzHlXy0UPwp20AAjo45O/l4=", "K6B6b4TS0twvGxfiNS3qvbXR47kuQkzWWXx32f5nLpE=", "Gq/vei0vBRa074zuM7To+joXdv0pVah4710ifSFagHE=", "GUNMyG4vU+XbPOv9LbUrQC+ibinBO8E/MVeG0Q6gHa0=", "B1UZwL16bm/kv732Gt3elNuEJ1gBk+KshRc0mAW2Yjs=", "EhZdR1zxxLr2Yrxs2HRPmqSRSh2eU0d7IR6FPu+94C8=", "C69DT1bLa70IoKWHE7lJtUxEHt5T7rDE+aakBHva58I=", "LilbBrvvdabXbdEO26Hrk7KHJhvIRW7ZHCu9CZhETq0=", "FGVnknGAysCncdWDDxQx0UzSRF9doWz5NEQuc2WEfk8=", "Ix0m59PtlFeRpSAT9G0C9fTkbBfDBHrK/qvkrQLLxEw=", "AaL1zkQGJG+9QqV+bVrjsiGSYeNkz8Hyo5KUj6+uHnY=", "AGYcyKOdYL6bPIvNgdkfqOv5rr+YKcJTOFz58OPnazk=", "H1Zdpw8E+W8ms7NiZfl33aCbQ7zImIkw27IHn7KR/LM=", "Ev1G2TXUWlyEia4MsCwvwCFLQNLQ885EKijXZKn7CCE=", "KSQVPc9HoVvh+mf43fAOxcgWhoyOkbAp9K+9RfxS7Q8=", "HU5h+MZFWAnhm1Y9FotLu4epJnQ0b5/WKOpdIOug/0w=", "LE56zsrKji6p/YSb5WLU1dlVhk0VL/M58rLHzMtOw+s=", "CAMAhJ8CK1ctYvp4dYO2ybHqdSDzzEJQq/qLS2AKyYY=", "GTo3+/02cdv+dZOZ0BjfZM3kX3WxdzMpTodZajBIeM4=", "JeJWNoiVfPYReKXwBzq33SjGvNEuu7mj8GVuoOu4fJg=", "Hg2RmAxZplJGXOcC5Ojec/nrQhfq4lFFZqOdtEoJ1RY=", "E5GyWNr+xZR5nfqBdUToqQf6eUr0pBH4m/V1LzZWH7k=", "EsMNX1k9SwuA/IyWfCpQxEgopBdRleR6l8vq1g0CaSU=", "IJrIoqu3DrM/INXuK0TvcfL7MXpMvwBMieVanjeqmt4=", "C8etCamLWd0Wd6swMC/fDJDlRQa1CExciWkaNk0mjqk=", "GnRizSNTo1cBWSocVP02N0fTAizYVIq4yDjIwWNAGmQ=", "DiUdxv3Xa9vr6/cICNBSUEIE+rVMTvYxWdBk1o7F820=", "KqqFdx6DVZmxPmxDwCKBZ/zMs4Cq98jom0YQ5Yb4+fw=", "LEKcNSGawDPKn/VDb//EnDugGk6ycCWfbpo/HD+2FBQ=", "ARpanjiTSlkSu+5J1QlWTJlL6dLj62FUaLIqcvwyTao=", "IqckAp8AnHW4pDWKp2NtE+rr03zHlYdJe+j/1YtLbA4=", "IpI2wVuxkyfSREV6MR1p8HAnzZX8FSqEtuADuEHDN78=", "ME5LiglQo5qylDw7aOtvFoUKjO5Fgv5KiCgpY1aBFpY=", "CDQXinXQg6Ex6tCUJLPj6WneU7stIPlAEIg/g3yZ+eQ=", "EFzEBey0CuP3nPW5vXan+XoD+aB2+KGiLBD0SSBjBJ8=", "Kje0tl8IyK3bU+jwJMB+R7KIWgZaNSpGo2FUnh+Poog=", "EHjA7ghd0b0k/nH65CbX1rlpfZThenJYdXknqGTPybo=", "G+SburcO9npdThcGYkoihgzaKG3sfDosmcC18jXtfi0=", "BoyoLRiz59u8dpopVZsdh+3QgiOE0tTOmw7+LGMxbz8=", "LYmJNzpVZjnjPymPsEmCSWmhooS2AFPtuXKgWRNq1x0=", "DT5BbArhKv9Z2N1c1dxQmt3T9jkNshZ0LFF/LfcVgd8=", "FLKmcYH72cgTx7q8nR96fx/r+fUSwSq9DfNGaim0m70=", "Is/pMEiUz3moTLsbbgtXfWg7Ak8NWoVdDIahvLQyvY0=", "Gt/ppk6AKTMevS+j3vKWH1yVX1lW1hs0wC0LBivdKo8=", "J1Gy2n24cbpf20DgvNp8q1sVe1VVFoIgzzt5adYTz3Y=", "BX+QpMCBMEGCULeQI28j8yCeiP/ivcaiQKgS87Vxq6E=", "CtdO8JdxCZwEDCxUZxl4PDnrr9XsKlX8g5mwSrkig54=", "CwDC+nYTtS4l5KbPYzozNVut6kNcu/72dSPjs7G3PvM=", "J5U4G+aU4JkaNp6ObOdeffGNOMQ68bxYjNxl7Y6He4Q=", "CRd9GMv/Wc5n7nbT0Q198S+gux3qZgw86wBqajAh3is=", "G8d+VxiCbvzlKoa4YQ2UgAdGR79LO5+jcHtoHBqFWkM=", "Ly0Si0LTIQLQV2EkCBfsu8qgPS+kXFyy+CwaDASM67E=", "IVv9JY68eTUqek+qusswhA9+s1ft0haZ1bMmG1diiAs=", "DmszK0rluV1Rjmrrt6B/tPwJI103pBM6Ub4X++n4J0s=", "Jyk2dz/Bo4qoL30xcqJHe2AeEBWsAZjcKICiG7rGVCA=", "JrxNQqF6D/yTeYv78uK1YcFadGDhr9nCOvesKm3gNCc=", "LQk2If1Aq3bvFv30mnkj0tEsAij47bm4aVloRhE2f/0=", "AnW6DioqTDsfXXGLW4y43MS7+6G3BktrODMNlQy6DoQ=", "HtY4TKneeIwjXH+/DDGlm4YaUr/yhHryqyJZJIeHnao=", "LDN8gIv+DSyrVEvZrwHwj5FtlLfOBymgjMTvue7vmOw=", "LT4JNKQ3FITJWN8el+fw85hLVmdTn9EMPo5xJGra0Jo=", "BU5CWqAq2s/rcpyunfGQfkFhMCKJRnyTJ+0I41dVzBM=", "AklX+p1I+UIHPvkKVMsGMsiaQz7LI20Y9X2sWv+F75Y=", "GUtWGpEzS9DdTq7PuU8D66uSf+V4fxcjwlNZRLL+aXE=", "H187t3pIeQXj05smVrkeCoIjImo8wMekc8/EpSx0rAM=", "Gzo6/tegghpoT8DQ+a2d+jtVfGVCv3u8XPAb0zacugY=", "K5Zhndw7KikvzrB+KqgMhq1jbqfW1Lq+jSlH4Gk5BzY=", "C6MeLR6Ac3SnEM2/gfBa9Pqtzojq0KFliwtIFAZhMXc=", "JdfVvct0uSt0pgTW+rOy86IorSM2Dk3vORkUboxE+lI=", "HKn5EfCwjRpiBZJc3nql/TiwYQlWIRUuir0BZUOA+ts=", "GpDU4JCqq/ZSBTQ1483qXepkUn5chB6pNYgl4hkbSLc=", "DKrzt2kJsLHhx/TsST8nUB9ebwg2noo26sQG8px4VOQ=", "HI+UKG4ykGnR6AtFeHyzCM4hSwSZmzuZUx0QP9JXfNk=", "Gs1DJx1LBJdttexCcA6D+xUTWfnyYKW5dwhz48uYqQA=", "BGy91N/ojGd5G7DFrHSbXN9Eo6h+hfx7vBm3g5ZHpwQ=", "K0sDz7RIfBoZ18BcoVEzvinJ0/MFHksB+k3Fc+7rwq8=", "GpoB8AQKO+phJJRqd+Z/06pPxv8h/1+0nIUqxZtl5cc=", "CeteB3p9ARBnOmF+WTaYMKzf7lDeWCOuBojmBxQpK28=", "DQBs58GH7GRyVi0hLfwp9hXF0RkFfODHIWIK9uRmb6Q=", "BUvI1lmzEAGipSn0VkCpmNyq8uzx/4/T8gb+NPqEci4=", "HKH/JExRBuqIBFEWCBwgHGMjaYxraHOBZq+Ofz+N2bs=", "BPJU3oCT8/szMN10I9nZ4XNXzLNKPBjpQBlidhDKsds=", "GPpq+TQQDNoBI/7gtWNraTaS2RzIMvh8dsBLsglQFT0=", "C8F1zWoK1UbTMpjSfSzhj/xplfFT9r8FxZwJpO7qsUI=", "Lit5KrtrYxDizVsYj9zPUwKNbKcGBONlaLFfNAjuphg=", "Ehb8D256yPDqWb94QPxyCzeEjm3LDHfyU+LNaDOqOvY=", "FTgSdQdBc1Qs0lC6fNptG+bBLESvKgChH88Hh0IdigI=", "JapWLE37CjjdkuAgtNb5snaTQfOB3pwnrw7aFFMYO88=", "GayeNUn/IJCUiKtyim6I0QoPY093F0KlF+ALwsx8vjw=", "E8AjOUYtCC8T7Mje1rK8smqABamrVe9pqR+EfnYL8wI=", "H+8NzY9YWPJAyJhgA+V3onajUmxrRfdUA+gUoLxiCh0=", "Ax2b4hJCSmQ8bJvxRNgaBub8nWhjegk4ic88f+5ePqY=", "GmzKB+8w00MUBHIU8ahylyi43+jA5VvqNWSSiwfeQvE=", "LTue2pbPGG+OC14URlQygZMbJgo/8EPGbPIy9JCcEqY=", "B9pYMlllvsJLTRLWBvtFY6I6Ew6Y7uf3dmpKNVi11q8=", "JlVXHCP38c0b5nuyTUxOfMZ0uIS5xY6oFl0pNJMNb/w=", "LlupXkos5cQz8VqwoCaxq8Kyy6JWxhcGtpl/61d6QtI=", "MADHlZ3zHuS/0RGMeuIpBtqNgC2cR4VQUBF5JjQryoc=", "EOE9CIHSewjPW2TO73LEKO8QhGebU5sFjIGhcAar4FM=", "K+KpOzcr5mTuv4Cd2HPHQSKss89auqbCFYcWAbiI9Ik=", "ITECGCF6cmzIUMCn3JGdKf+oth/2BjkLLrDsqV1EZaw=", "FNkH9HBwdUIgW/143ydL3yTYl4lZtE2+nfen5SEUp+U=", "Baz6HoV9gAHOMR/TtdnrOhyS/G5drCRmwK8LJ3gWo94=", "Ej/+YdF8vWYj7Uhq8OuOdtBN46d6SDxmKwtcuYzUSdo=", "JjaKopR0ZF7doeFVpc8N8e7JX06JVlCBCqd/S6cCevc=", "IQUOIGDc7rVjZ1Eq8/oR89LmvptycxJVsFvl/ueT+IA=", "Iu4NkMfXFTJqA4PHq/aCS52TavKWdWEpV0vHmvL+8KQ=", "DkV0Z7rowTL2h/wGI1+pKguyw/3h67vubvg3KfJfPCw=", "HfucsAAqVuOLc5E2NvpW4mo7TedRk51esJo0MqPiljg=", "BsX2BIDADKYMAW80qK4Wa2k0MZuBq0snvrRKEzg53BY=", "AShJBBV8BxSOYeVil/8E/a05SmmQ1OR6YUoAmZ5Ljng=", "E9EDAKw5HHj5whXbxdLUYbYs+lo6xwppvUcL5dgs8y0=", "Bj1lhEuIBdqo/XcbB8J4QExyi2ZesXICKXJmxCKpYYg=", "FeO/F8UoMO0yVc1cEUnzYYZB1uf+30aMMF0IIg28ijg=", "Er9d1cPKrRLgh15X4ZsQdS2WUeOl3aBcD2blv4+qPfA=", "JDw7eX6DGlUEauiRYVj+U2SOIek5QA+fXrZ9bAzAlMc=", "AB4o+ps0wsYVW4Qh7dTeWMmdHl6B6SNF9iMZq5bfA+U=", "KtHbpVBu4GQGSWNSe97NgjzOBJSobqRS2bQDNiPzhrw=", "IxN4eaAky8G0gQ7lTH+bhQRnNBRfM0p8weSlfHQMjYI=", "B09vpilylo4iGJOEVj1nUuMCNdoidUgbxsOwVpN8dzw=", "IrEKUlNxbRZaZwc27iQ94GJ2GTeO2/dRtGvaCxLczPU=", "DBkAQPHk6qEbT8cEaZWYloCEkXfs57/ve0RlE/nr4RI=", "MBh1hSya0lYhG3+fMc7Y4iVhiNMsMHLFGdcGmw0Q23Y=", "HA9n0F6/1lDSLerXoREwMivBJy766YuFyBXbazGN2kI=", "KG6aFzZPNpRqPSx7oGEv7z+sYLDa626XOqvrzlh6ePk=", "K3KUaBJuqhAfQjO6qgmdAtsU/jXEhYDrMWXGHdvOtS8=", "HzD3FAal2pjpKQYstI4KNORz6DL8DOgRwo8Jox1UFvo=", "JZVG+EGfoVl4qzYAhP4KEyKfwR3GmNuLuByCLiyDIXM=", "BuNhJBIa+soZiHp8pCjhLA7I+qr11zPsxpYL16pdfes=", "EPHOC/V8B3i/TeYKHiusiJLea3tu8vjekR9zFJQmC+I=", "F3/JUfY5/MJ0tO4o8/f/Vg1soNn5MPU9OrtV5tda0QM=", "HzQDKqRswI1oVVu8JGmmai77ojxW7D3dxYNuLpGc1hA=", "JpzQt3T4Yl9d51Gb5hhXzJ6+BtEGENyR2fTMVxEeq0E=", "B09DeCgUD8+xrgCzjCmlCA8ND+65nUaI/4hx9jSfPGY=", "A5by/OjNWrPSYB03+A/Zd1ql6fVrQG8BXZsJX+GQWUU=", "LgOvv/c/sF8y9QI5kH9IquGrqBCmMSSAzOND7GY/IQ8=", "KuiZRVpqfEmZfIK742Bm7x1sIthCavVNLHSXCzOtKpA=", "K/7e4+r3NAoQ/Alx7wAD3IfLmXzWh++ff4izDD3vJpA=", "K1CzmkPPnx2f6vBKHxADEeeJMqaAUeeSwjqZ/5UTmgA=", "JNFusfye45Ni3GYzjqDSdRR/inq0tizrJtw+KxbDu74=", "FTnU9heNoQIARjWQxu+xynMFu7qTXlp97JQOI226L3E=", "Cehd3LAr/gcJAh3JufTvuiynoEB1p4wb/Snd28e+dSg=", "Af5/d7osAYKCBzq00iKVk1H3zBbKx+HGeUYR7tBqOBM=", "HTIgz3zroZeJnnkv0rUWWAeoN4LfVUOMyPzuaudWWfk=", "E2S7Rv58ebyRVqE6jIa3fTQlOR9+0SSgNblBM0BFF9g=", "C3DuoPqVlxxStMkf2c9v+13pfmPjZAKPDAsZBLB1sG4=", "Kpq5a03jP4zP3M2OhlEOjMcx/mc+sonRWjdOsNBV0hc=", "LserTUOeItHZfv8lAelFd2kdKGmEQOe0EZCouODJhSU=", "HBtZ/5ISIkQilo52Fs6ucVc7BcmeS8smITEm/k27XeQ=", "H9+qTaVA5Q0rzRoqCXU1D5aeNJJYQIX33T//nYgUzUk=", "DMjvaj3CUNekyUu4kL55e5HwiGmpk5HK9w4u/99/CGY=", "CeWV+uyFBnAKQqWkEZDLa595+um2AcxlZ1aejuniSBM=", "BgR83A/4vZTGq2Dj/+ohkS8BAaYL9sLpY3G+VOY9c0Y=", "LkAoikpoHh/1MY+/t5bot/Cy+s+lyeaRocSST/+6SVA=", "EmFpkr9vr1FEyM5YNV7CtuIKfSXH37E0YLByJoFZaAc=", "CnhCXVY3KvmV2JMNSM1kWm5rRUhbTAb8OOBSgYtbPK8=", "D+nGCmTc6LRbU0YspuaL4yXYF00GdHEpWpg867HJoPo=", "LnqpzudiT3H6SQKXHQfNMDMZv0EAe9xOoP6kDvl8uh0=", "EEaQzwSgZm9JIaTvn4CPuaO+5hkt8ObNsVtvMC9HbI0=", "LmPEISpAIoTe3fnvJgvP56OVAC4iyaYVWTBTOymVlHE=", "I94MlSfU7eUWuVbJIAMVhmN4UQYVgVNRvFjTtdateCY=", "JUOe0XN0QNeeS+AJQDlJ7J0yoLpszX/FFY7JfJ0yxEc=", "FONQgOjakLF+crb7//4Sawnd8MDL0LIm31SVjmgK/pA=", "Lg6HygogkNmuGCTOyKOJ4AGzwK/3PoG9JYR/8KRdH6Y=", "Exng9gihL6Abd0Co4UBmuIDwtlCDHY9CS2rz+zYcbes=", "JiuC8dHQe7GLmSBZfDklpBwKYUNrcdJO53I8f7iHWvk=", "J3c9euftAIKWpXKttk9PtcIpc1slnAPUxDnsKuRot38=", "BaZRiKxtZGfgKNvkuUG6xagSQOgIN6UZFS1lQqX0B0w=", "AKKosHcZ7PsslOkPjgRbGOxFX2cyUyTEURnAMpGV784=", "Eswxamac7QKQvslnV26OKp6bYIG7Cb/aZFbc0/2AJaI=", "JaBbqaP33MKaQ99F78QEvtQIdJt9IWUDjXArMD6/EDc=", "Br1F2bE68o4wk0jRwGzxU7Bh4NsSbsWaivCVoxDChNg=", "L1X92i3I+vLPgwhnWMe8d6GjgpNOcWjDCh6dqtK5b7s=", "GkaKGLGF3DQqxrjr5T7yZcaRkXWeVT7rvmdO6XY7GQA=", "AxsPm2/8tFHyYX7pFc1tr+F6yZaJQXsdkmmGB+4AUUI=", "KPldbrdUfnq+JdJIQZO7+qNsZXaxnDb74GtEVezSDzc=", "BPcMNAsWboNAgK/ESuRE6h71aqjQhLIwHmLwjgd3Qgs=", "D9ch0UMFsv2bIJdXdfVObE6AaeLHH9ZjqcnNDRMIYWU=", "DnnrUT6r2Mo/xhCWUFBRCHnA0sdVt+Wdp3JtDVSUN4M=", "LjY2oPjDAU/ZY/8c/vzIRKF2O/st4jNS6lWqXde7j10=", "Dt6vNfRPM52vtX4wgMmcdMEH9h4+Dem4tMI0oyGnVYk=", "IOQ5E1BlTQRjtuoWzGjSxBG/jJfa8dr8SuYQbrs0dkM=", "GqC5q6tcdyWbJLpt8DW/hkx+bVc0gKtLLYWSbpWwudY=", "K1gq5+APPG3VFj8+RPiuH46qkyTmNHrp/KfCo68rla8=", "EQfpEtJtDEJTSWNS8UsmOjCgmyCtsx29T8v6wOTKk7U=", "Ex3sKKuw66Dpgh/855gLzKBgRsEvAUE60AoZuEV/gEw=", "MA7YD0kV/LXcjUIK2s3GtUF8jONdkH2VN2dW0jI2u2Y=", "GI4hHiFd7ZyGHToh9D8VeJd5OKUzW+dDJeBmnn7bVR0=", "F9MhhV0coDA9x7CygHxD3hiAu2b9azq/5cwsOo5qInw=", "FSjglvvSfg4JAEYL4ippt/gsoaoIpt7z81JWkUsFAhA=", "JxZy+7Upp98n3SDoiL8zH13e9cB/9OcgYEdUc5/VY4E=", "LX1QjfEo+pbaeRFsFJHW1NTYeort+Xsk3i8y6GhV9dE=", "AsEq4GSQNE1lhFUzigulV+Kh2tvYyZFaxALyN4mUs+4=", "Hvf1cdfarFraL1uU3hN0Ar6KgfnJ/e+UKP8/Rr7YG3A=", "GGIT5tml7MhRkteQOI6v7VU13DY02DWecwaFodfrhmY=", "A3DrbS6YKCzn6r2N+tvEa3S+6g8Fq6r2evFpirPQJeU=", "EE//+/8iWLHUosZh0tDL94luBTmO83MIi8hjJ7N7wQM=", "IG051a9eHlC0d+RsYlNCALwEPKmFzuF/C/0+aLyJeuQ=", "AaqiCTHV3lkxc06AVGyWa4uvitbCeVWN4WlrLospB98=", "H0qheEokA/PAsxLiD//Cn3fk0B5xLUOjW59ULWSUiPk=", "JwGgsJ54Ws2XEeXm/2IyvGSX6pemzrgtOUdQi7tSAuY=", "B+ma1fMxfBrOGbSny5S1CQAxn2RbK5VqNAVjVdOzAEc=", "IlBFVnDerlCHX3Wul3mmAIyfz+UwtBfeTUI6oCypj1k=", "Jg1iiT4lSr0Q8OT4vje1Ih0VKS/wCoaE9eKLXySVl54=", "Fau80uDEQkSSdeyl5JEdFXy23ARaWVQXg0vznFWPnyY=", "CXUfeTIYI/S/uTgEkZxk5crBkH0DEIX/jaqe/aleQZo=", "CLPYLPvsjME/dfd8OmGEiqDLwNzkzvjXLOOllAey4lo=", "GXa8DbvYOhom+eFKpDHiSnKK9Oj1zf19KZQ9/CmnssU=", "BPWdIB27Jj3QTSwvo5axK6CKSJidwkZLO9WXZTTrOOk=", "K7IyQ+hBxWTnrdLXtSjZrwP+dYgOmrdutNRqAgym4w0=", "L2a5YUTvbFyuW/0lEd0kVqHW41SFaavsfXpJ4eBHSYM=", "KbVp8vZ/HANj9gSTbNWcMplFPYIz55aiUHXEH6fhnUM=", "GqthAxBL1Q86ZetCu/kBeS556znUR1bK7yWSaKBtJ04=", "EAlV8+Vr0XpOr/b3m2l3QtBlU3GFm8cE3Opez8iF6iM=", "Jxs2PE9E9PqvoC2ydS3MGS9O31w5wXrVp7j0eQUnEeo=", "ECHqqPogC7DT1+9QLF1+7fKmyjbmOje1zt2Yoxin+3Y=", "E8aiAzIRcMBG19ROJfIcRwj1hATfbCtXhGL0rBgcXho=", "BmaRoCdU29Aq2igdpBiT/uvmhwg/TsKZYAyEZX7yvJ8=", "Fjea83wnTmY7fjwErQZe4wmZwwoF+93xpDA3qNvU8Zk=", "LgHPmBMlKlFxYkpJY9Vy4bbmWiuTqcmQ9qU7p9V3VpY=", "BaTsd6IcoV+ASu2HuY3D1fySrtecNySz6c/PXI01v3c=", "ADLzurBpq9SmaqmEXoSj6h05CjwrCUGXpVkcawwptLI=", "BWQWMoz21H09KRzXJZSBRDIVt9KQTHxWMbtLcug959k=", "FsBonUgoyTXq/ar6wI5NkJ2nvId2x2xdzGtL1JxyF/0=", "HY0j7R3WpT0sGPkVN1ZOtwbsETm6IkC3M606y4R/eZI=", "GqGiHjeEuXhD7GIMqJYejGLV4SuOPv+6sqTu2biljeQ=", "C7VEOdTG+BKnBYGrfB2lbZigiRYEjWtI+VQLRRt+Ztw=", "JEIbc+6vYxNLRsKWRsKyTdesuGChiLCKbtHQDLkLPD4=", "MEXCAS90RYkPefFWcGDDyTWWWs0OpVGmcfG2JeaE19Q=", "COyGOZGgU/7tqlKBCYr8Axt1VRBl1tAfbesExjECyb0=", "JQyyq51VeaJKV/qqh/fIKMlJUs+ySMxG2S7mC4xMla8=", "DyW2O17rwxmBIsYGsKWy3hXm9f0s0PST+WJlNpZC+T0=", "LvarxasCyEMd6PemS6NpnHnh3wyPLZ1ejWW3ktvDbQ0=", "HoSJd2aqneBWu12Xxnl73pPDsFklEjQCBmNTMrXCKxE=", "CJI/BbBQ5uD+wO/vTepQD/OuwwVNSysKH7rrNWOE1w4=", "EWh6wF4k9Q2wYzXhh123PY83nbOlwcO59XtyWx/YQ3o=", "J1WDe4BUmtq6R+CYCQdZEin1ppce4PM6yTD1vhOxVKY=", "CfgMgjC8WngTj5lSumtkzmI+EtoBlGA2Okn15e/AdsU=", "EEAJdG1hwLtmQ+ZN3+qi1PMIcqkkFlUqHftLddQJLUs=", "GW6CH2U4Y7FLcrGaBoqsQ0pgE1mL9zso7rNsQedvxUo=", "LIqKheJhhFKo0KnqWSvElaUGclIlNux2Y4afdYrHIMc=", "B71N4q7Fp6z6ZmeHVO+V7qhA3Jf9FnnmU9X6MritYZU=", "JGShf0NTp22RHMg0n13QLL8rLFiht96iXwAOua3KOW8=", "JoMSlOM49ERArc9d0cpNFBKlzEHJOiA3mF7s9ML75KU=", "Ftae465rIN3WLdGhPSedTX2nSyB7xXoVrJrJLK4uz6s=", "FrVaeS8bGdzOa59Mm2G+DgRXqZgOYFDaJQCkCUFfIHs=", "DUnjHifhxxwW1SSyqK2wpkhDrqXaL6TmhvGDvpXUFwo=", "Gv+4/YskPWLV1Kewe2JPmgRSeT0dGhHq07uChOtl+Xo=", "J9p7oQy4bAZ1jFXn6Kx23Jq6LoY8LeuPrnUl5CyWzrs=", "J+G+DbH91zbSGEQ/VtBph0Q3BNGMQqlvP9y3xFNvugk=", "L7HdH3Rh11+jweJd9nDBRCsAG5J15nDXPIHrYf4CgyI=", "D18MyaPU0wZsmRlP6yKfDjGDHc8IC/9C/x0Ul0+C/+Y=", "K80jWFQBsPf+M/42bOkuOs2IGKI1UPN1Peyx7CRAX/4=", "AFxVKgLio5rw4hyJRLnE9W4VtDjPNGUWuiFHNWkE8B0=", "A2KoooZaKy/pAoMcgETFSwypS5X8t5tl8UdTxYIitKw=", "Apuxg6aikbk/CYl0YQXjPMZpkHJQ/XBkho/TE4EPqik=", "Bgj2IhSHFXjtWKEtzE0cFSr5cOblBF95E89MQMpt8Yw=", "H4pM9TL16DVwTtfKg+/7UXV5AGyiLs10IlEcA5G1xO4=", "ITiCuzEpHbw0bK5Y+/3PA5eBUuFbNEiSqUxE4vCxszg=", "KXEl9nKLZfGJ+rYcOJYBa+sKly3TR2SRDwWVCNfoYiw=", "D3YCnMP/CGHgSKYB61KhHPG/xp8t1u4VFqRuSGW3x64=", "BaUG7XOC21GFHCJNUhPHzmoisZx/96f8zGI3rxFCuxc=", "FX3bb7bUJ7l7pp6HmPOVDWiI5Exg3+wKmLcmKpd3RKE=", "J3qjmeVcPly0nEvYeJ9lUTUdpUDK4Dfro3VDsEXpHq8=", "FJkJGujcVn+NBQoINers9LmVtTQdKcVI2gg5Hm8UU6U=", "IAva4+9wp1oSl5BBzeM6F47AKxEKvTecLSbL6pFntvg=", "Lmg13kSVcTDdckoKxjNbfDXor61qy7pqqxb0VZOdx3o=", "CeMCIiwBzbLEXlw6kg7dgto8uoVeFf9jSJMgm7/lXTo=", "CltBLMzOCjcWF9raJnvHg8oZzsBo8VXWlU0nnzlZzZk=", "L/sDS/K6Yp6tb4pgIuIzl3nmjvLIvznv2hoDMuY968Q=", "Hzqz+/X9JIWTgKtZqPcsxS3BqyR5oQ8z18W3EhxYF2s=", "CDA9jqbErwUKkGrrrkkuMgEOzmCbWyxusTfvXcJ2myg=", "GfCUXZ9xlQ9sKymK08ZG5PuemZOdwXDHNfQHFIx5JTI=", "GmIaWyR1i7A2NEY55CfAPzPSWvf3cRw+2ZmV2YPEw6Q=", "IYp7dF819Je0Qo5hw7eVY3UupvjIdjYdMnMpV5M5kos=", "Fuzr6+WN/1mnsLpAaTqkMbiZyndptEWnOH2xGAiJY/s=", "Ha7kbPy71jQ1+m+HkbNqT8ZZ9SNuiWpNRHqz2mgoD6w=", "Jgh1yh6Y6JXGNds77VANOTlAtWVNNpxhFW2ykn3l7Rg=", "HL9x4OvrwtFRlmrMK+ERFniIFWFL7Gb2hzWRTDuK3jU=", "A7KjIOrd9I6lcOZD+J7yJyu+vbHK7zKq2tsiqRioqZ8=", "By9TS/B7pVVCYVLDfiEMwdNti3zELh3WSoMIE1cYn28=", "F/5iqTqe+xI2AS4soQZLG5PYZ7Daow3TNO5coI0wSwc=", "LtO123rS/Ag3NPthRxYpRj1Glt3YyNzbHS/dRgq0zR0=", "Jug7mop8e9aSnyICH+p4CIA3wlxyCUJbqD6ZgRUzXBk=", "F1j95eLYuIhq4hNJQ0B9i+zrpL5RegHlGlGpwRwVEKs=", "Iz4i/4W//LV881B3/GyBljWQ9n40hKZ9hGvBz/LL4dU=", "K91zSi2KdfXhzacRSoxBi/UGQ5gEXcepqPMWaSgs6S4=", "IcLijVRzOQa9E4OG1/BbHMQvZgTfiTUJpinDUfV7ldk=", "A+w9tBm3ibmhOBHfosUYQNOgGWHl+IQUirP2r77Mo/k=", "BEUs67DNlPcWMmaqs2WzZm0qMp1jTsU9sAnfvjMQYvo=", "I3TnzTSS3eQKIaQRGzIxPfWk0dSD/zjEsM1JIUsS7io=", "GKrOFjmcf9bp0hl8XXh5WY0rcr1QjgXW+Lzrfz/GaKM=", "BB1Gn4W/reyWwH93VqZzX0F716iC5Guga6B1cx9WtWM=", "ELPBzqMC+2sa7v56cBiQzuA1i7Rd/NbbZPkN+WTLkuU=", "CG3/A50icYldCozflE11ulQoSJfRSy6qAJQAqNd6S+s=", "By5y2Gd/alH0wjhuLoMNZkjEUzpyhR/bo0pQg/AIAu8=", "E97dV0WQ82K4NcBRUdbXwachBixQ8URT+/zhKBLexHc=", "D3tzC59avDW4dLIk6/Eg1Gm8uIPUtOdX6OtSvCaVgIQ=", "I/Lf0CQuDdnd92tXVWPmmGjhPCzzmCxSd35sUzlHIIM=", "JkAyyETavLAlVFMVWItFCeJ3F7jpZPYEBNKpjoxECO0=", "KlBcaD7QCbhOoJ5wWxySVhh6SO6WBk0/CU0VqTHAnWU=", "EhlftTFOXcptu1MBoLqzdBUiqs2SYsVQPeygntO1v6U=", "K5Z0jLthR+9IYPDX2Twh5CqE2ipdJMB/LmmQF142ITg=", "Fo3E369v7NSISIH9Xw/rJ5mtsEHG4WcH+fhwHKNTW94=", "KT/fXpdBhRtu/dIWQYlOq6rk571LS5HXJ6gM6FBYVDk=", "EI1BIv+kqb7Uhtib+c5xiOU+AWGyM3vFv72BxmgUTmA=", "HTTvkPH165vppxjC9Yk/5N1CIgOjBvlhcHtKF56KgJY=", "LW22L5GUnxLdffCEbH1z3p0T9XHt0yoaOx5X78eWcEk=", "GLpzeD9m6PlmFiIfSVmlpt8GzrW9PTYvrEsQYRHuLVI=", "ChdgPSKZu/mQ7hqVtazAia7RFkb/5pbuBlvC6mUM9uk=", "D8nua1EMAL8s+qXmEituaMqGb84R3630J/t3DYwl0vw=", "KCIuCJlck+OMg4m9MvOdvMID0O/EARRHxUPQUWVhIsw=", "B9J6i7pzSd1xbRzyqVlXQN1BMTuTmJ3n5en6q5fOm0Y=", "FEmLR8S48mY+Qi9xcbSjwHPTqheJWzMbzNCfGJJ4iow=", "C9jndvO6dVOTNhn2BxEYToXBxrWWtyq7y9DR7w8Gf80=", "IPrfOFQOHkbaIq5Wt1MktJgwMbnI9RmNMsUNXyWwOgE=", "JpmX7q675Ytuqfnn/XnRhbrHFYUHOSinTqb1lN0uoFw=", "KH2RyOsNLQiC/Fdk2rVATIqP/xaF5932Vt68ezthkNU=", "CHjTNEp9FH/7TAR7fW36hahk3qpMFqZ1PB5yRUwsYwo=", "LjxKzKBhERLCmxjg+bWTV/fF3Kt6jV+avpLXsrKqZ+o=", "HiiNN8yj0LpVit5JzFIg72Ke9UNnmVlO3K1gVcW8aUM=", "Gh1/ZVmEYMB591unJDidURjRQg+Vi+A0j+127E9wV4Y=", "DxpsWH8VTLngkixcTY0nfmZnmsN+q1sn3f9mhhXMrYg=", "LXgnkuPPqEEc9iM+W+MN7A3yLTbJ0gfahd28pex0cZc=", "G/TcWbMcAcqd0tmnBSCsCdG4Y7TnZHHaAVRPBteKm+A=", "KavhTUSnch/+tSg2BmKEIWKxcIGBBuVE7xRykQR8P8U=", "AvSwIO32AgTI3HWrz7B2BRc8vGjE2TXQ9+ZU8QRpb6g=", "HGkqEhS7auLFs0grluxGeML3lWqCgZ46nIU99GBrmp4=", "JcuQNDRf00XHmCQGmluaBbd7lPvcJOtXgtVWItta/SA=", "FbplsyNlvvovfLDFIQ65AapAlonJx0v90lONeAJaYyw=", "MBoC1F+ro8Fh+CUKLn4oDVYJD0zsAjRIrhGZ/LxYqog=", "LpXG8qZ6E29RJDReOkPvIu3PqAar1zHJGkwwA/og81U=", "Ch3B2pDxd606vMs1E+G7dEDY5pXyzwgPu4PmHtKF6HE=", "Jv6xBTOouZDczp7ALoe3zTB1N1DRFWpSIHuCzmOpLFE=", "GQ6vkUIy+WzdHeS73hN6K4qnuoF9bUsdzl3T8DqEHUs=", "HUQcP8R/53oYg+BpZsiYDlhGh46XBx7g6Z5WDv/1iyM=", "JwKKgZaVUI5wiC3VagIukS44bbRtvg2AZOEciudKISI=", "Cia7/VCmj/nxYi40TiC/iQwqGYtqWL2CLHIvfkLuLFM=", "JVHjURwRQDXfSY4H2DVMBC3zGwvT7lAsjCCri8qCb9c=", "F8YgPesKgDJyBD1bqSe1mEwHjACikALmVTpiXvzwsKw=", "DepNTFK97CFO5OC4i87wPgYu4t3attBQsUUMC5WlHH4=", "BeZgsVUtNP8/YtvFsatn6OEVbfUGw5wKsdbasfb5piw=", "C5hwwtF7yyu4siWeyy5U7hYjYs+bGCQ8iGQhqQpkbDA=", "DYPvk79VFVBDTcB2PP61wKthTUfLDLPHkYDOVRhJmTo=", "K9RIRYmNiaAF9cG7v19bjphdSOkWKFpk5naoEdVzO6A=", "JVch4S+8giNeZKEGcxwSkQkgxxv+s5vmvIIpHTIufzQ=", "EbQZEO0zrgFsfQWaNzZX9Wqx7Tr6iE9q6qw+hle1LW8=", "FjSv4buuF2a3/3sRsBHvn4j/Df2INPywhZaKNYcMls0=", "F+mSKENZ6SNTbu1BvWHjCChTmaErbB3yL2VwvQDlojc=", "GYCMflQ2iMokNxnfwtoTAUcSew1EHYjf9TRD09fbnZA=", "KqGcFFSKT87hcMAZbTY+iGUGS/yYIiXVlGx+v/eUWXk=", "LmorAjrHZudIW9g8uroBahMMAKcxE0v2ZpLNXXRgYW0=", "BOEyEwl8skoqizgZAZoLZ2vLyB0v9Jr02ox8sM6NUSU=", "BDbbiLT2beOEuupzxQW4ccecI1JgD1hZsw4hjwcyatg=", "AMl+lWiO4H/6eQVngW4x1qt7sObo+dPpzQmpsbFqkJQ=", "LwTIxyyKABgK5tDCny36vYPQ1mDr615688YCTT5Xd0c=", "FQcM3Zm5tc3AaUaFvbBkicVvLJmWHhrplmCFFs/Qh5E=", "E0444YwfQrhXuiFL51zktdMxVboQ+YNOlfOpbiXi9w4=", "FxFikFPVAhuvoRGsIKyFFhzeyFT8FwoGS+dFRxq13u4=", "DQcuHI/xchOyeEhVekJnAarYvzUBxqVe8B3UshrPAX4=", "DWy6gYzJsPTiMjoHOGnE1LTl3ZX9BGEP/ieplof6mKA=", "G7fscgEHBltddfxFObO5GvDZXuwLUc4G9q47QPEKVN4=", "D0sZivKq5MHxUDWv+90wZHrQSGHePmU6dn76UDa8WaU=", "Jr1dTmoV7W4q1Mr4d2Ko4lMxWMaJ7S5rFPU39/ivSJE=", "Hbdiw+GLxsANroEk6xOSE1epzbKn2NWviZzlyKME70s=", "JCHy54gpR+BotZBJPfRT3SKjrEH5qB4Ej9XIARn/Ytg=", "C9nXFpfWyS43aFBJO6aHKD6Eg7UppXvWuPMkCUcxDNw=", "Jk5RDlp+tY/jfIkRlOcihzfiwKwv2efsQW6Eu0SDUCU=", "Gijv4V5bprwu5gLqhYgp1UsatxVM+Uu5SBcf8JLwhKU=", "FKIGZC+ppsvnjWmU1Ecq7C1m6b3P7KTPwTOFVmKgrhU=", "KRlfb16ylgXrtRNIrbcrhuGE1a8qVZeehdjDfV+jd8M=", "K+y9GqL8HWoMuHp0MroYBw1NjYfHxQhcxXo2hyzc9JY=", "LrMRx9lq8bu+7cgR3NDPOw86C5MtqrgFgO8Z8uyk3H4=", "BrE7Dsae/sDdqA3eBaIpguRQ2ktxnq3ALo5vCuipyL4=", "KVFWlYbEUuV6Ft7/7WZDuQcyergw+kPHYWxrvXszf6U=", "D4CRPWqY1o59IDFJCDQhWYeQvRf7caujvmgjXaMfrpo=", "D2xuvBUscUI1XzZQVhCMonUqk5ND9S1M+qGtD56oBic=", "JlGjVF1VoXm5XB1eyfR5AJTM7+mRtDSC06zMGl5rxBs=", "Gf/taXvpkL0iwzoxUvG2HZJKiPJaaCpgSBSrD4P92mQ=", "BRT1ERKyEx/3RGvcjmA1+KFWMwQeMcrM2uV6LPLm4w8=", "J7JQ7t6hJ4ew50xn/SnuPW8xAyBLDsFTveGzEK2KuWA=", "A047CSru7Pn8vgEiUAcbfYb1Dd/Gi1v1nlfF+Txx4ck=", "FFOqvUqzCc4R3wYLNpBvIh407EV/PhGG4eozab5Lkjo=", "EWgLGcD2IsOuzjcBPZ2cawlNy150wI4i8XD9p0TuF8Y=", "JRIbpKCt6ai03avcM3sJZF7mxCw/u2wwug+0V7yjPZk=", "MBDB0lzOZPbdNjVYkc+mgdxuLu1trrNo9meMy0Gwg1A=", "HVDJfi/IUBcEDMGS0ZnOlsrPpUGJttZq9ddZ/La9p54=", "Fc3LscUxcZIoHfYCZwCKnOjbhm/vPs3MzDz60p56sqo=", "C66GKS0AS2HeqR2rWt3s2EUuTcD2ZMxgDSy2ljt9+Hw=", "CWbgrntuUv0YGFJmxEmsoTnXYEg2FZLThjKiDI0CRvc=", "HK6S/ob5p++DugQZomHcg6oSoSZWJQv2zbkpCahRCGc=", "AKLLg6BUmIzuGnqEfCKMgAZobqYqbxPdlTXbokj8vUc=", "FBfQt0n9oFvIo29B8/cUAl8uSs8C9vYWBxS7TYbYp8Q=", "BSxacHI0QhNONTKAblfSg6FCBG0qgykdp5LPpUsjR4I=", "IqjJ098lkFx7+ZwGl+E5iCYJwIJ2oXHIjcAuhdtJrs0=", "HDiCYeB2oGQ9VHkYfLbtJDG14fUx+RzbUSe6+JyDxzw=", "CrJiwyFdkCY/AtnPGiNQ2dWrARShrHgmRg80Y1pVx7E=", "IaqGXNAkzQIQTaF2IVREGI+ZKuybU7ZbnP9jkLKKwsw=", "CwSOBa76D7LBkuxVaQ0W6mqWnSR1diudIf3/itpKC84=", "HPtmT6xIsBNy+G8QeGA5jAE8I2HcVnG5jxOFXBVzKuY=", "HGOXjYKYSo9bEF1ZfWWkN8gpj7QHTuFAYi6cvfOctHk=", "Bocn3ex4Ki0MAgKPyjdX+oXmHzOvz1zTWYZzIhZQnHc=", "DYkFgswhU0DTR2tQvY0iJh28tj7nxs4ZpBHoCbcxpWM=", "GEzY5n0zRrCx7VEyJd9PiBHyKyUhmsbK3Ai9J0RMWfU=", "Ea7c1JD8dwr0UbtUppjdvUo84mZxXqhbmQ8BAnkQAA8=", "KW2m5eMsIK7caadD9qReS7jV9mBIl7HMdRvEJqzg3oM=", "C6V2lw2jksVEdxWKvSWWi2A4cVjKz18IKIlU4REz+Ls=", "GX6dUSnXE+OCrlzmZs0SdviN2q591Q2/qwcBm8Ql9t8=", "KYUpIwyO/KEm8uXxJ+tXfB+N/eT2Ey5hsmkzcmzXFi4=", "CX7DLh4QywGfpbqHp44xtPVjh98tzyEGOcnZYj77UEE=", "Cmlq0ZmmHf+lIQ9aZ+95eVGyWWDv3ROuR3hSmT2XQ/s=", "IOaRECRoYVZSA/Kz/v/+aGZ4k82IG70K27BzBr3fTtY=", "J4kPMiv9D6vJaCv2BiDR/AQ0R1OU7BINdwiAQ1E6ELA=", "Gd9ht7jb6BUsV6jZUkYJrV/Fi5XZ3Lxqrg/lDlo/BnE=", "HxWaAJLo4TdT2aRwgsz9TpziM4j6f0jQNB4YS+7U32k=", "A++K+zbdur3O+ptD0eVVfokVlXblTHsaF3/qWgk7v8s=", "HM3/o6j5GM0zi4UUawV/h/hhajIVmEL1V0TM7Y+0Y7A=", "EMbOWAdwtJHgTPIiIc7OXscQ+dxwSKmAY/vKmw6e46E=", "FVFUNExEu65IiCq2geHkAvcmWFimpJmST5YeQkHX6hw=", "Fo8o0oonl5Ree057WF3KsZKx/Ac/aw5ir6jMkWF0jAo=", "JdmcCAqDbs8Kp+EpmnV898XQqWtYElR5abPwkHPTOm0=", "CVWtGrEHTbEoDHh1PqQ0OtBe7kLQuvvzISxlbDBexV8=", "CNRm1kuJSeS9F1OS5CGZIpc+r8v72WXLJFXtPyGG8zw=", "E0mSNCZ0lDO34AFOgns1QMA8OnMj56JaT4q/wU1JK2g=", "FXkrvipvhBR/AI+EtZG1g+ZGXLYjjvVAGJ9eaUEt2ck=", "BhpoW07QW2WEOkHCSyNqKnty/9BgIDC2O3g8HiOSMJY=", "Jdfw3D4KnnEJDHK0iwUbjY++2jk9lb2OnPvqoZ7+tkI=", "IwHAwxnP1VILx/lytmRmYRNbKsbNgrDo+/fIFKnzivg=", "LWmS8t97VryfoU5l0AcHY9+lxtcL8v2I5CitHfc/tSM=", "AeZiGpjGXvfr6ydfaW0REQ2DyoAxAUV2uqEOz9hBECQ=", "BpDljtokZleZoqFWaYbwWzw0I0CihVrnRqmqbX0L4ug=", "KCkkrSq0MdUNR5wtQ5QLRxNShQ8y/Ht1ZHpTcYnpgec=", "A5g6/t5I+BB9PEPY7yAFAHHmk+FPdYNefOOq/PIJnXI=", "LT4s890XQF+qnKvaxVnKtcS4jAU8z4iBYacC2dCDFNc=", "CkEYyxHjWvCcgKditmXP2RX7nMEFpkOYWejQnGquOzI=", "H08qy/eGigmcDPMOz88lQhDAqbbdlSCQAn9lrth8JwE=", "EnRWyc9LBMZOoygPGLSrnhuWQHYnBMk0PFyTyibb/i8=", "IvYGGHrekdzTj5zH/7zVF1NxPUMcMvJrtQ8aBo2Stw4=", "IxzGLyX2Fp1XCXY4UTJyTNWq/aNPlV8vtVeMjrb60uk=", "D8l9DmX3rqs5fK/DaWar3qkiFX1n3M3q0bIxXR8AjLI=", "KgfMQ0PqGziYKCC8nz2N8BS9K+WLn51VaqG3VRHMi3o=", "IFYSy8El0AtKJtWix0jLe2f3905cGjr5nStTsh+QRSc=", "ETuU+guzenziDnR2lOGcThl68/6wPiflXOG22ox/gVE=", "E19XyIiQsQkWSx8Zk0sOMHcAGqPDmbRsvks9RVhK7LY=", "Ev7FI6d74HWsDEeGLysYzF5fXKodvvPZB8kmJSUuJwI=", "JPhkvjXvYFfeB4qF0elqa21l9fdgQv5GyKAoAWyZFj4=", "ADKiiNJwGFvBZ7vCG/Q71pVXjPxNrE9ZrSat/wO0HfM=", "ASp6Iptt4ynPQNYd4VEY1gULmyNdYHRWXJOTjPm15WQ=", "BYtjZF45Y769tutjkQbE4WwP3vK+gmPiO4YD/iAEJBo=", "GaWvDCsAsdoHudS1Nbu73fBS/dCQM1QWg/xU+nzs380=", "CiUS//lOvQBXHQVnBNXNSj2LAkw26y8poD0KamnUcvo=", "F3df5y0XhavhG3Y3m9s1QciN/Wu+yjfSweas8ooA5aU=", "FEd3NRMgsTaXkX27ocJSMV/4X8ueXBD2QsQfkGyMLLQ=", "DM6HCI02nqJc8gMV23MjmzHfiXkVtws4AJ0IMRHt77Y=", "HINgQxj3jBh6gMeLji72a0iIKgkTgFg/PBSleXw+v70=", "GVsQURAu1pPiYob670B0afDCM+po+3S+W4uAHfT+OXI=", "JFT1O6T/HAmyplDN/MMnNRBcAxFrJUwgvYoZYoXPbuM=", "AtD+FUqFW9aD1GdsNgd3TFBa4zsGVkJeLdIaYQRcSqk=", "Gpwapl0F6QdjI3toalny1zisHuv0M5k+JzdrzcbaOY8=", "A4DG/+w12RsmgFLoV1By2lELX6l2QAIhET3wrcIoPgo=", "L0g1t8iTjm49Wo2FPNpeJMh5peDnp5tjqK+OPAI1l2k=", "EngRHbuqRquUR5SFaD5HPv30W+JJCDw/ZXYtre212rc=", "L20OIFkWkZzXxTgauSY+m/2XWqfPpFzp60tnmf+QNTg=", "CYe3lWHQ0kxfzWxr8RibE/E6oKr++5imwRMF5waPmhU=", "IKH5TqOdlnS+sOI3t02ScGuPG+/1j0IP6xoGKZOOpEo=", "BGYklE9nKBpggtMOMaLXgiXeoAv6Vf8uvWtLaku8+g0=", "Dsht9OJAS01MXBx/K3z0/8riuq7JbxyTtXGMRuMvS14=", "F6mIti80MxvCPFxm/lVV3Cr2gPkXXE6VJp/yZWQafCg=", "L5M6QAnDhAbBA4dM3pHsAtYiBnx8rFaJBAPHRAih78M=", "KcYKbufiLAuNilHPhyFdTj3VLCPIxROoyFwhIFra9OI=", "Hi483XEsasA5rrPU3KTpLeUSShqSiTqPG4tt0X3QINU=", "HMDPG1pne7Vq+pKNcITJ4x1PVGkam5Ci9IIg+yb7U04=", "A/X1PLNMpbZHb2HUtMwB4dEjuQ3/mOBEfIAQB+ZASGU=", "Jk9SNAegdrBPcuJoNM6L1FuMkNxKkV+lUfOuVtUNtQM=", "F5Axl0X3kyr8gm+MKW+SssD39rPP20v9x2PQofKPNws=", "AwmacqnDU7MpobxLqrt4RQHJA3unNsSYBvHaSCkQQbU=", "FgSqpBvOBy9Etq28wHV1QuTKq8rxCer3r3GOussJD+U=", "EO61mhb6E5Jn48Rc7wG1POfcqPiAjMwkj9tXKKeZ22c=", "Euq4z/zAbO+NESu+Xfun51U09kxEYdFi/LO6BnFZR+U=", "DFjgRlPYi7px6fU5tQMLk32tJAXSJaMLWnXaiuGcI7A=", "GxV/LtdAzb95ivCSquWDO/UuORsROYXKajDu1YjLpPk=", "DQg30JfO4AIDRdA402Vt4U7kwoM7uc0Noa/yOZ2kNuY=", "CkIlpdNn4M54oSVcmmmqYm7SIkh2PRkO2d0PPTWTQVQ=", "H2ooGaZ+IBoldvCv/LCUlu1/7KC4UFhBHQmm51b/6OQ=", "HGdKm5/bSfyWbgZLo9oywawtS2obTQa5b3XjFgXDjLM=", "IIRM1Heikh6OyybuwjHYxtm4RtupPbXv8iAKzOPcUxI=", "Co+mtlaseXvnl/QuKUs6xNnqfT1SEluf13+NRMtymGQ=", "JllH/gh3xz4MZa9U9kOw84RKS3TecJ/fdxVvTDOMgAc=", "HwTkZj8vmTfPB9PC/l8G6FQUuWDcd6GejW44xbztfUg=", "BtAg8D2d2RjJhfHn1c05+tY/ZFkFX4XhuNZcJXrWQEY=", "D0+4JjvIExkMRMOD1Uh0GyRNIT30NEw9y855eWmHOVE=", "Djseat+gVFCvunz76Oigi7/2u+wJnGjVdV8JYHXCECU=", "Ivt8AAQuXkuktRLvuQAiS8a81TyxIk88zNQlMx/W+DE=", "GTdd2Qnl7CbnJ0v7i0AsXVjKGTF1Bb1EaugN2lU6xx0=", "EdCVJGHtudJMa7CK/TaWkhc6ct7Ch/axk1PDu1QN004=", "HaCHKs87Ne2gmczJ6aX/JHeIm/oSK1vFS0vgXomHAqg=", "GnSjst6aFsFMAmucURFSzBF0C5udmba++fRMv3V7c3Y=", "Ihs0W6S0ncuq1J/lGRfZKMUzzeu0SwlQgAZKk+bO7MM=", "DeUp7zJAQRb8DdYEHIqdP3mAljFDw+J18p7GOGycK9s=", "HfA0F+cLyKWBKac/K/7UdfWc9pQLpIdXyGDk1a/pErw=", "AaamxeQd18oWIxKTX/pMqm4WgXabECkfpl+8NixX98Q=", "Jr5KuFXvosOVoLrVEzjiQoOIOXPQ3+sthYS7OUH3uS0=", "AfHH0ieYblqaMpusGaI/x99SYJNg02bgr85ZE6gJ+TI=", "B1hSrghQEaNCDu9vxNUciBDUD1fOTFRWngNJvd5k8l8=", "LmnKFVHkipMAkxmu9A/M14uKsOs+anWqOnzcLqlRDhg=", "IdHYGD5UMK6xvnc2IFBLqZTB307VUKh1Bf1oibvHCUA=", "EYZti7uM+P5YXeGdgW9EQJew1euIBxwnhaw6dX6lqXM=", "GOs/0PZ5OgG05KNQUFVaef1Dx9mzBfQum2du14VQhv4=", "KHThYpNYUOsrHnqZhH2+SLOXJr91oYqZiSsrttuxQa4=", "BDFk5cDWGK91H5RYrWEHzCwYtOJJaGFNqpCfOmZPyJg=", "HH+tdUdteWYxTaqSbhiKwDO8PA6ddU23R2WdmEUoXxU=", "AByvpgmGZFlpBzrYwOKdjUbEkRszNr0Vo4leENCjk3g=", "BZs5qEvqqzvRbmSRFNUHrKi0l0DdvEx+cJryUfflwAI=", "LvftFHVdQ+cepuum1HjkGXxTaMydf/fEJ+PJetzq+qU=", "B+Ji9DlHw+Q4C+1ZibNTaPbuEBhekR4pkYRXMN8qzXg=", "D1TvgNlmSHbnuenPjOMAuf2CkpJ0+O9LpQMJZ1IINRc=", "F7GaDNdZfAuVqdGx86o4/t4FZeNOuu58mVdpb5Kj+uM=", "I3JNsHj9QQ9JTlOBiGooSGGP/UqMCI/VETOwvnhEF9s=", "CH9gKRWc93zyKMnPE30l+k2EKghP6kL82y0KFtxMs6k=", "LJG0NuIiA/XN87HCGIYmAHMSt+gP/CxwJk/wZWDz9S0=", "CLl5PPI/tbDuvSZH0rx9TMkB1wdHFbRFsU+2SlXkO84=", "IUFD+EIRdK1w00Me/p1AvtNhggYz4nuRzwUFqJULO+0=", "HVuIVgUXF2ckqFMl9ieevZEwov+ijNALByhv46mCIU0=", "FMlXfAY9TfqryO7XwyuZoYcCjYZuK5kZdObmOw+Dj6Q=", "BGJzN1v0Nb7d5ZDLK6yI7+6Jra6MbiewH3eSSTB0uzQ=", "H9ifBjImmQOHsBfr6YX1XU9rHlulor/W8ic9LWu2qBs=", "BQIIHzsSUFVa71h8tbSzB9cwwbzRUa3sqlMwL8Lue/0=", "ELqmwxjH5qOjYodWrULspmqSvlH0des4b5bAJncuHLU=", "Ad/kUB6LLvQYThpNDwycx2qJSXZmNjCLAsZqyYI+3GU=", "GnLTIPrq8F4M9E25ML29ju0loJvBR1RmXn+18o6j/L0=", "JmszNAqL9mE255mbpHNFW9kPiqU/RVNDM57VtTILBpE=", "AkSOUuBpxrREAtWVc4IsO1cDCQIW1gfeS/tnjhNXuVg=", "KqJeRZBlUytlqyeAtjz28D2HLqdZZke/lResYot5oiY=", "ALHVTniYtjo62v7m46NrKquB45vzoVqbH0ebdJmy79c=", "JG9/fY5e6AAi1FNIpa7bqGEsPPRiOmJg3ckxlSUSxM8=", "AnkHrTafxLg3LHjmqznUo/qkRVHwC4PSSp4z4B3we6A=", "K2e9J3vcTAjHkIuxWtOXJW78YuAyUyf4GQx62bCepeg=", "CKXpSNHbFF4gvwq/1BnnBwiyAX6PixFwRZwsdnp+41Q=", "BJHJOBE4G78IDN3aIDV7vQF1XVDrhprFDr+3dbSVmf0=", "C75YEMM5UF8ZFlnFH+6sTW3YvIOW8wweSz2JiEA1lGw=", "A7BlvSkeKIoXfxYeNcNlLFfvcORuF0LvdQzmPSKySBA=", "EfJbhduEH/dkj/DjWsC2xGPHFPsrxfKIlwYIqzU6au0=", "LxT3USMhDPadOPLzK4M8rgqjEOdjSGEm0NNsKeaAFK4=", "JnF58fBQqiTRd340ipnazkWq2/FkINgo6R99i6XWtqs=", "AtdgqczZWPcj4ILIBN/CkGhgdnzDq6iLNdR9lVUaEoM=", "BCVAEz/CVIdpZ9JznxAUk0aVdh2kZH0zCxgHKNnbl8E=", "ANT81YYTUyaXXhIFfN4ZMkTK0VBMThRxFWEMOv+wZVc=", "J6I1L4xfiPZD1t6nJRsCfNOqBDZPrmDj5xT2hNBaiWY=", "HH6VXH3qPeFEmeGwDGRRKx0N9gPFSS8ddXRxYcIRLs8=", "BQ57y/2fqcHE0pQVsDwNAKUcK8zvWxxEHYMB/cczWVY=", "Grtqjq3vCUBwTWEVA8nylXFcPE6+Ajq8YIqP83BEE8s=", "BlYgORSZX3j0odXyVGOH736LUUl/V5ZSGZm/Dg0egKQ=", "Gippx2c/ByrrLsxedQyBvQr1ZcccvQ0zZ++nd56t7LU=", "FZliK1sLdfxmzNnvIOxVm78/UaSkrOhW2PaH9oRciSY=", "DrVN/CNxB0avEC3EF6NkX1sbh9iIv421yM+0tF6wOiI=", "GeGm+R6X3rGt8NJcuqsJofcgBu6So261nzLPME2ImGQ=", "IBCBUpQTpvH0nz1S3N38dKzxRsazL4W+s1FJR5yJHUo=", "IMOTWE4oV/V8I+/reCAYalBEDJNb00pKF/Klu/8ofxs=", "F5zwRhyYqZ9wxDP3T2D7pQ58L8m/2+UAoKUS9r6TaTQ=", "E4y3bTeA1ClCv+AEPWJb3U1ukcg75M7D2ghb8lDBjYE=", "DnBESvAZOcYqjKX/Pdzkbimx5FrGqrfTcpfezyBj/c4=", "FCsQ9YIEvvTLFRExNv7leVE8EmoWhIjDdsIa22KCeWE=", "EkyMYHYStfvSr4SsN77hA+7hGk63EeEfrncA68Y4f7A=", "FD/ecN1r3osmoIWc2lEtr1V8RS+l92tUJCa5+8lPdEY=", "JGlN5ToTmmQ17PcWtBOevQHLQDotOG1Y7HM3NswhaSw=", "FoYYRmIR8F6IobdxrIlZ/OOmNSy2R9RzRgFLxIb5wPI=", "G5vnEFJmJF5wekbiuj3oMi1KjnvcpDRIqwWnJ1505D4=", "D8LI4fVOFmBJ1f839rX615rnbX8Gn5j4/PjzZ8D7O4g=", "DG9YMyMGQM6OcK9NymdIIc7nIGkL00nmRfDY9ZaErEg=", "JFYOSvSf8IoiJqfwleRIkFGcm5l2rvo1FMCwZaBS40A=", "DWHwYXYmhCMcX0ae4Kwz9B0xSt1qedVTxkLc7jY+oEc=", "Gt+lf07EQ+SX3jBG9k0Ymnzb4IbZjJTLHQA6WSZdQN4=", "CfwiiFqwGXW6mqTIaSoE115Qlx99y3c4YpUFUyJyZRo=", "HAG/j4XIvMA1zOkprq4g5byV4dNhYOKG9aNzAyy7Sfg=", "LfvMSNckGmZ0gDqmQlO8syENs3ry6cA2xHl4yYQq56k=", "J7lF1DmNt8aNE1dqiSiqyZrKiKGAsxvphbhfqJ0KvUk=", "J3VyvwspAQY4DEv1iVnaIX+eaJlA2dsP2+ecGhVKf4k=", "CDHRuIr4VhwO7mlkvXIMN30ENh+a9lztfwMp5963FaE=", "EZRZyjOeXIobNlk6igkbvp3nyGGf+DqNMqVmwrFTNqQ=", "J+hIm8jO1qnyCb/oP25mT9JVOuhGMqjd6Fd0+GpxT5Q=", "EPtsj6trE116UMVPix+1dOsFQsBbm9hKr0rokyjW9T0=", "Ha04ZIFmZso6XR/LDf8HvxLTUvCKrdHUoUufqbKsBXo=", "JDmv0lQqnFZLhfpo/sb5/UjVTDmM3+FO7LftfZ4JZC8=", "K+pAWHlNi9clcF5lCHXaIVO4KdwkWXAIJ3CgNUZjak0=", "KScS7NCNNJvAP+YQ7CoOfZuDg+PfPBOvflc2W0jZhdw=", "JBwfdyGdF41NYfUIOKabbXApyhs20+s0igsaC2TENTA=", "IZGReNDKmHTJD4dUB+bedC/WR6dnlomXLPAsKGPbbgA=", "MD15bVKGfplCIa9RshIP84Is2KBjfJCW7+Lpqj0se1M=", "Hw8wJDIS60vsa/not5SYmrrdrxNX99gbefInMU6aqEM=", "DBJYGu2WOhaf8cM3Fsi6/GvpqLbbE6JYiSGCI/hQ3no=", "EUWd38D1krJkJpcGUBwEznvZmFR5eSU+zcvMqj9UAHw=", "Dys3FGoKBKxT57Ywhx2yUqHdhDMajTnqApYfk4te+ho=", "Ie/K5ll5Bna12RFLgdYEkOtVHWsh9l82Lwggjq++TT0=", "HhtWxvduPMJihLBKQrWgLFudubhCJyEAJF2758h2GE0=", "EIe+TQxHvPIKgV9gzoA9X7khbx0LR0p4HIXo7RR47KY=", "IMeiwQHjQnD8GLTwXSsvWloSmKJZLb8/m2mOSnkdkxE=", "LUiG8gC5nFf08JwMNi/TU1rpBqEc8BHiYfr0hzSjsH4=", "LebaFVG18dF43k3YidA67uRkAk/Ck2CXIVwF7hSST1w=", "ANkDSL10XlzXeaamtcS2JeG4ZVnXHFWhO0qSq6IYeqQ=", "FBwwhARNK8/pWU2mv4F1uVCrNrRDOn5huBW2EBpbtwM=", "BnwyQXmePIlALRBIujADAoO1B1U6BsprN6OHIABBLig=", "FI85/TWla8fSC6HIki5K1cIVZg2tjURrD1l+3EKh/gc=", "HdH9YIvkdk7h3OBQZ4md5T//xrAPvkdaLgIipjxoxU8=", "FbsPht0KN4ArEVqB1OP2j5odP+WJ5YSLu8X1pdd77vQ=", "JkL99d8fr3qmovN7M6Zl8WOn33DIatqth9+rBkk+xys=", "JccmuyChugjHOAjgD4Kb0/2VOB54yIux0/NH3H3FQ6o=", "HKWAjD1otRr8WG7UT0QYmk9NDlbLSWzRD13jaJZrhns=", "HNquoXoteDhaVumYSWN+3X512FVr/Y8kGhH9kDr0+oc=", "JVsG1IUj+X0tML3K6TzpgDJWoHI+wWG5h87wYod5SK8=", "HLP/IPdDqEXENf0+LRDpMS9h2kE3Q8SnnmerbDLbr8Y=", "BHoyI4Uyp6c03auxUCS4oVRFX8JIHTHDVI0eclSIZR4=", "CZWyEBMZEPAd+Jdq50LpXgpatJCkq+sw/ONI5U3MTng=", "G/Fu5TDJyUpAjy/9Sazn3eY1CZvP3cHuQd7x2Gra3Jg=", "ExB6XqKjQGrNtlY6Xj8ICaHGt+qaBJKFMyZidfpvUh8=", "LVYswGUAKN9uMMB72+wH9z7r52ahktEwpsc3/Jzj2zk=", "Lv0SteT6EC+9YL7cEgsdwCL4xDovzoZCiTaY31PCNSk=", "EQCYyRa1IyEeGLmF+PzH6KgEvLx2K/62wlyBDO1VIWI=", "IKnVIWyqwX21q0X8trRd/s1gpwgpH1yGq4TaIspZatM=", "BIyCVAkJTQViWd08p+FaCFlL6C9IjWb5G0OvZg3POLY=", "GYRHn/ymtko7lQNydHwbkmrDan3U9w5H4Yi/e0EN7SA=", "IJzsfuN9R6ilb4SEuU9dsgU1tVLBHV/azIAwX9glyPg=", "LammkrCJFbe2GTDwEfdrCb637c/WoZxIzedC6ZzUkwg=", "MC9Q7OSvoX1VI3Ck4Swlo7AVGkPjmC715xo4x0w271k=", "G0bggedWxCx4MVP3OmQFT/SYUHO5pzIVOrackpRwKD4=", "FRA+OYjQuvYmv53lTXWwMBotOSfGXXC3I5GwYt98tPQ=", "FWTnAGLtbDs/8nLeqA/z3FfKHeaIsd5IHnwHJjdq7tI=", "HlRfOIueBaRt7lFgyHBtqAz4B8bBAmDIXOBKw9Qe/F4=", "CIzUB/Blf8i26Kzz7isEc+UOcr9Y9U6pHspA34AXPcY=", "CLjkL6HEEERn1nx6PjhKPABD4cHVN9Br7tmX4LUqvMU=", "FPGz+ecgMbp04uAygE2nho03vexlx7TDMTPc4rGZCEY=", "FhnA7MoULtFC+Iov4LA4EiCxDT/1wg+2ema62r7vAYo=", "EPYgqGLH7JhsPufpLuQxyqTo0xgr7yIXXSlUJ5bJmSU=", "Ly9z85U69uzqhvXvKQdfxOAb3Ag8A/5u+JhCy4H1eTY=", "EkrpP9sbMnVANhlkKFGcg1DmmcEK54O47+wE9tDk1A8=", "I7uo/ZwdiIzJ8yaPxU7v314Y1gtB9XlBF8gA6pVk9Xk=", "HaJI9NkOAFa2g+Kokodv3Y7+R0+1EfRpVa0xRTQeDTM=", "L9gjRRHlSWbQDz6kpl388KaqB9CTI/mUM5tDvNmO5nA=", "HPg0UNI8X9ZOpe1gA+1lA3N9/iSe+/8tBfbMKFtK278=", "BzAChwO2OID6R6oLlIoqlWWQ+dLeAiKYwDUGNlht17A=", "Ku45pRZpwUdjCU+4xC1kkGSYX/HhddiCj04CUukIEQ0=", "I2pI/sf0hx4qD8YwW07TUWm5QvnoApc03JpfRQsKQLw=", "JpF9dNtxZYAOuwuwWv2M3Hm0cMHVSl6x3trYdKSness=", "IXJ5ydmtVov94ZlSJ26KdXAhmFssbBln3NjDpBmKOKo=", "H4SiZgL4OXCjiv36M150DiS4+5dN2diwMZx89tNJHhI=", "FCn8mlOmk38VFWIoMybZ+ZVKKtgkKF5WO2fSg45dwmU=", "JTJk5bRyWZOAf3mdawZtOFAjLs0Q27wB6aDVL4G7t6M=", "Hxk94FDh5vxVk544yGkD6gMlK0iRINCnTuKqIDtYfyM=", "Cxeen881mEAM6YgnhCH3pettWtw2kX+lFklTc5a9+Zo=", "DdPP0udKxkQ/EInEwIhKiQgBxgjBpTtQPrphU4GfkBY=", "EeT0PnPBjfUGaD2JpRG0k/r7xP7hTDSoND6wPRwZeM4=", "B+lhP1z2VRqX7NzCTYgQ43jJtUK7WdeUYaTCVJNXHuw=", "CPJQqrryt7tYoJxs2VjhPAuGyAbDPmD0zfBnic0CQcM=", "EHanhV87fR7NW9x8CGA5HFeuHq01COqZTDFTDinFokI=", "G1dga/1xq447LqnNMqeFadAOioNrii+U4WUUkAWiIEs=", "FqD+yOK9dVWWOW8dHPt5IQeWuFvTve2CvMK45tSmHF8=", "L6k5t4/TWJFguwmzWu3d60PBDdQMKsZHFZjErRNoiaw=", "L+xKp1Vj97jONprC0jlIan4uWTxMv3R0/CDlFUIn2R4=", "DhFY5jybffMtfD8yqX6OQVND9Uxil34o9r4wFBjYw94=", "DhGJPDLmO0KnS+2B3XHmNIqby1W/WDUzVYC+Hqqy/uQ=", "D8BwG5Q1swW2EMf+DGZ7M957vTMMqUDXHVzNtzMkUtA=", "D+5KpwqXWApzldZ6N/VTMLkIRw+4A/0ATUNK5mR2X8Q=", "FGdC9FMfpJxISAQGSYxlQWANKjA92NrJcbe5IHFO4TE=", "JvFF3FKDQMuTNcu2+x5w0MhxhJ50def5wIkLkH+fa9c=", "DjB6PSC9FjgeLLnQuAIEbz0zAmU18bK3wDqwdbaBz7k=", "A3UY46D9R8mh4zqRjDD+n9zk3QTcDpOBYtLDpUE5Tlw=", "BSDE9r3DdbqO9eT01V7nOUk4aoE8YHGNsIyj6KrmgLc=", "Gl7gkbdNzHw5YlkNMEJIa7Q5kQdgDF9mZLFFt+uMmi8=", "GYYlZCQIT7eXUpz6tAOyy/C2Ym1JMKvOF7GmTa4DYxQ=", "A4Z8cdPPqAOatkB6tGBTq0t0BSdvSD3JgxkEe5UaFW4=", "BtVjBQ9Ql3dORWQFuMQNH2W4oKneFOKwUgOXAL26I/s=", "EHZ+Vogr5ICTKKWNdHxtP/hd5lE9UNCcLjN9IusRwgs=", "EBcXZnT5PUggfiOWdNme45ts2JPr+5A6KkHyj/C1YzI=", "DufmzjWSVCR5MvTgPTETwuom5RqDMT5MFknM4iNms88=", "Jv+CxlvkN0/M11syOFNN+lRMsEIouLF/3mi/VKeR1j0=", "B+iKb85gHEjVzS7FlF4kCA+4QMWsdQhBRtS6Gmpv1hc=", "EpuMaehRi9FmNqsPGj1+Oa2iil3nnqX7oban0TVQuF0=", "DXlPCGvE5F7qYzfNHmU5EEnVw9P+6JRwMsQAaa7v9oo=", "JiK0+o+wciZTK3eekE7qRPb5CUiM9RYFa9gdr8/WCgc=", "JWMMjRBGk+el/kGuZds1/T9MY/j1HvnQlI6iWV8ViiY=", "KQI/xPM8kCjN+jAFADN/Zo3ipUOEemGbam3PfGRxG1o=", "LAVnLpp2PqIJuqD3wx7Fbrq7NMRbJLcJfIQbs8vatG0=", "H1AcAMG6iq7Rc1JL4vKyF9a2ugCsJi7lj/YiAWe6IB8=", "GboIWzZ5WlXb8EDlTDVucDIbgfrim+DXHXd9ScT0u40=", "GbUdL+eIMUJw4U0bwkjAkNqGBaQPdVkhb7hkgv5pAi0=", "E1Vl/dbT5lEZHX7RqwEEM3gvmwekHb4UYpurcTwiljU=", "IkYe17pEWWvzp0Atyu1cJHsJg1xTSoGrNlFI4Uj9Eyc=", "DgnDmTVlB3OXWkEbwJNxjax36NeHdmaoWsPaFYBc34o=", "CEq4UxRAKgtozTAh4a5nkLJ2hsaw/y5JSKrk7my1B34=", "FDtd6DgUgUvBVTvH7JvEdWu9250xhDqdr7wpNvyMv2k=", "Kpuc4m8LhyG+BtqF7hR0cnWAsCN82wgTW67uYQpGBSI=", "Cqs+py9D0AZLd2pHRupuKxibfgb+jUnr9FLKRiejh9c=", "Flb/owwDesRXO4oHJoiNmSKK2DJFSr78pZjCMYo+xlM=", "AUoqoqWYsuI3DRQhDatcXrdYsMkXjOt/8/poHaXJvN0=", "FTyT3iTgHAfM11I25OySm276DalsaHtdwSX2gYUFZ+s=", "FBcHvcdpg5jln0rQTsRPq4t/T3sgCW94Ag6Uh3ipD1U=", "AhOBJZ2c0YqDfcNPuVAXo/Mnhb2RzJGFidrkISr3uXk=", "HV0QwTIisXFteh3vazhNcnlIsP3rGecjsr+hKS2XVH8=", "E2/57bnAVozVhbJZqqVizj4kswpsRmCswLUpDTCg2oA=", "Lzq0QYuwy3uFlnW5/86MSI8WzdjOpEwU3gQy5uKIFGQ=", "LwNyfQiUp03JfmDL/nTHxzEbBdAgyoeHGNv1YduL6jk=", "BN34i+uRamYo5gp9qYF4HfsKXhB2KFskNX8ikSj+Ja0=", "CBhRnqK3H77Gxr//h8l4r0Qn57zFdt+lwVvE/J/tJjs=", "EVTRqjRFhcTs+e6TkMhGaNzpkjHA9CfoYprJBSNOnrU=", "AwQpjGteIUSumlCM1Mn0yBYMN6+kd7OCmv1J1qSfywA=", "E2UKWNyp/a6AbnZFTJSiGYvtJN821pSnpTMUdUitAjQ=", "B8zxnIuHFLGNKApMDKDozGjiF1FtHFTbb/c1gr9NMmM=", "GyhHbjTfFGtPnVMLb1nNA6vigb4psyRqUP7e1kcIPTI=", "HFg0emT9W+YtR4yp2P44Or6z+jDYdr1QJezwcBJXtz8=", "HMkALUEZWWr/l0MQ2lvGJyGRUJJQQSam/ztoQ4P56q4=", "E9md50i0/tRHa7LW6aTscriwSISH1lgiiVpSZ7NaV3I=", "IaeAq7Lvr85h9NZ9p7i9+sSUg56MOE8JBgWpTns5bag=", "DZ3Ii/OGH3Bbmq8fgt+dU4cKDT+N5P2LjJZc2vZXGIY=", "B4868tE+v4VehAqMhYo/LxQxauUgqxL+YTgcDS1KBGk=", "Bi9bV3gEpCP/Okc5Usr38FLyLItDjwDDKsiI0AyZcTs=", "JajDPXrbfd1qGd2DB6k12RSPLpYkdfJB7WcFG+w4vHs=", "BDFlKwPJQzOg7XbDbxlo1Qmsc7iRDfQHsDQ7ndA/tWw=", "IhI605kQhio6JTlzKePcFJtQKJ+QleciSoHV8tOZh8A=", "K0MzR0P8OMG9zHzH02zkQas74BZ03kSbFTSadcuTez8=", "LQoLyS4QnF/XCvvbhxvOwXimn9HiRBleLdrq71yhDdA=", "KZ21+eSfSs63YKSqw2q8N69y5QmtbSH2rxomfS/vxrM=", "DIE/beCBvyWAhlbViBGoi469X9pbE2WlT3k6wr1NwPg=", "DjJnOmi6lqqVmyXmVblCLZhxxtW2FdFNqXjRBBMvqTg=", "Gp6dw97C5xLalS+0zn9k6ZHMWQoKP88kY9zvkrXtw4k=", "FZrnLoCxtl9DtQdN3GZCN54JxGdp1wKLnWjpeav1lEI=", "JHmyEa2egfgYD6LUTQZ1+N42BG3yFuJU3anAQ7NNB2s=", "Bi+LMS85uy5fEaeG6muwUeU3N2MyndkExRmeoZ41R90=", "IpY8A2Vh3OyOHc/tbOUKcnCssuQV+zQ83c/Mt3kG2lU=", "BEQPsyNUf0bGc9DeWk+xmM/IuUtk4Md2RC+x8YmtI7Q=", "K9bgj5bHgB0+xzwE7HBuOlbhDpCQTCmloJZU1WzDn4g=", "BTHQ1tymLtLLR5zCSQIIRzznji1josHW3rahX37vSTs=", "FhHDjQfLzitRV3tkBzM49Qr2r4p9TpmSiUK2poc0Dtw=", "FIYE/SNNL1Qkd8egxzpZ/ZoZxVJ+n+tBZeT3EdBNhK8=", "D/sB60dSdBsFtRtjMcKxoDvK+tStv1f7Yh+P/j7sjgI=", "FK9kftNr5OFlk/ioEzUwBFlyHX3J666xyd4kULx9IZk=", "AR4qK/FrS3DZFUb+PpdBUY8U4rbuddWWQP1i8GBtbJg=", "H8L93mxawlf0BS8BIDNUB+Uzcw2SeAmHneDQI3Jv5PQ=", "BJ6JIEW42STXV+7O9mYCmHwxe6VbeQm1+6pK31apoHU=", "AYuExZ6LW9yeTFWukUV75KZjMrWGmpv0koEk4XDqpsE=", "Jjx75WREY+Eu/nFxV5k/1YdRzXVa0xo6dbf1JCAgix0=", "DLJ80jnqXW+Yis+0t96albDqqwrQzslsm7oOai5Fmvc=", "A2NIMeiw5zu0V4dJp4dfV2Q5FN9HiuwMRX9i6NFVACc=", "Ihypox6KEXiAF1kesGex+HvDWzYuEEc4Y3jYXCTSaks=", "CNXcz9LSFkwAhvvauRanVScVa4KrRTYSCrZUjcma3vo=", "HqIvgmRp8ENPnf5nSUJ/0VeBVkNhre6iVIUEWK1IJWA=", "FiWZed6eE7eaqsarigLsDvJrCxaQ5oLsqlSIZ/0WGic=", "JWFhM+6R53KwINTExZU8BajOogiwFiyCtX+dB6W2vN0=", "EJRR/37o+/2VY7jC59+DT3JCLN1o+TcnWcOjG1FNhwQ=", "KenrYdDOM8iZVLBTC6VXcfO2UKnKANC1K2Eg2kvZeIU=", "F2sja3eaqWPebig7wG9NQLIRn98ia7zE1W+TN+6UDfg=", "FqAz1sJmCbBi+cNpsG6+HtrDZuhTSjO2LQ7JGYVVIMM=", "J81moy3Zabqf2wOCAXQsgGJQfsrWLolHZY9GbyrLu8I=", "D5ADh3nnLpiAM//LH+yrCH8wLvYXUaaoSUbJl+Y0N10=", "IF9wuW1uf+10Sf8PcL5pjLW4BcdXPXcI4saOS93oUfw=", "G6icJ8CRz4X5l7oOPfu4S6ldRj0aWJgm+ZO/YNhnAGE=", "GC6i2QVjBWcTb4OuZxrGMVjbnvqucbW9PuCj3pqfnuw=", "BlCaiF/hFrlnrSzJmZ1EIQay8JZ7v/8CyEnFJyoQBIE=", "Aig/fTG8dejsPI8dtM04PATALa/kKmzIMgXAwWU6qFU=", "F/ryTSOyQLw6QwZtIY24odiShxRkHnK0G3T+v/A31Ow=", "CgOp/HqlCNoyYULmLH1IGPWT38UOFLi4NKuJNDGipiA=", "Bxza0JDdBs6kUETyWmrbUpcVlPPhYfYvQSngtyp6lAc=", "EfF2WJuCRPVVYAlqGEI+xDRR1umd4WWil3Xx4Fa647Q=", "JZ9QwToXb4UT2ndE/DGv7K4OmkECprv4kxeL7ialPQg=", "JoBwwX9m6CoSGfFE6XrBqfb5JtjWBrvmbCvHwFHqU4o=", "L+sepkgNbKqtCiWjtmDQFjtwGTG39zdR1ehqSPCu9Ww=", "JnqABMCkpltKwzuGWLG2g1ee14RkezeHcrS2bMTBifk=", "JdZ6dg8qF6lDXluk10hrznoAEPdx6QncOMtAEX5AEwg=", "HhTC0yCdQ+c/clJO/aOWDhbI0W2sbfuuc8fnUYnyDRE=", "HBJBDQmzNkNArFcbQLwddKm0KrEAH564nNyDoyZWtEg=", "J5e3nGekjE5SEOk0Avf3OdHk9ENmTmmB3xtCMqmRb1U=", "L2/ueArFpYza+2U/8lCsluAsZxP9xT7lMBERMa/S3KM=", "AJbYddd2QlecqRcIxbzO9hrNafyUHOLhJsOsOUylsaM=", "CckYsfEoThI69KQnlZja5cROXCAUdasIPaqicOQ1maA=", "FMCwYZaVvwdaI3lHvEJa3xfDW+ddRE5UKIo83IW47Rk=", "JtjynMQarD4OOeNUVHxTswYn7Cbk+6M72NYJeb4ny3Q=", "CdnwQ5S0svW6XC5Pg+Tw9j5MF5HvARFIyyGWkB3scM8=", "FwTECFg+kt62NlXDa5DLpqmixAMmH6IgG0/muhDc3LA=", "AwcCtk0KdssMnmUetXkmNxizXP5i4TZHLghhaTj/Dsc=", "Gd7Pg97ONQBTCYl6PrgdXiXLzk614v7+xc9o2QODKX8=", "A4xiX1Tk0uxJw4EcNwY6HRCMDVN2z5eUTKEHSWT36pU=", "DNcm0IWaVcgGMFbYNWrSm0ELHh3R7Q4oKuSE1rlMM+o=", "DpoNsUoYKC1DmUfvdBL+Hmru/MlrSsUOf0MNmAtH+9I=", "HTsA5nASWR8/5b3cHrNldN56A1ehvig1nBUY0H1c+YU=", "CXRexdJM8YN2lvWoZ8PGEpoNRMA32WYS6ZuC7vPb2Hw=", "LdXi6kFYjbewHMYRUohQEUrfyFE7N7F/sqRvKwm/axs=", "Cz2tcxuR7Uwq7rEEEMUabpJTYMvKsgw93s+D26p+TJc=", "BJmYspT4rru/L7vsaV5NLVapkE7gUchLDuH+yXmM+0I="],
      M: [["LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "D9VHhA86MKUzqZTR/bP2CuUHP0SE80vpUe4Wonb965o=", "BQGWcb2gJmcMf/qQgXlRBZY/Vs4yf894RR+6K9s6wcY=", "KVLBjBVVjymyrnf8OeUaOV8XOpCX20BNt2WrApBrJ9w=", "I1OmCva9YeXqwsmkJj1FH60HOAZU1HkjeNr3UuXMM/o=", "DtajvUgXTjcLTyZLN0iLA6Xj9MD2HPMtMVetPjuG9r0=", "IRA6eqIMjRVQG+jCNQTGqRLGEAxdiAhcwuQqUjAvRIM=", "L7IyVz6F1oxTbRAMOm6pFyiERR5new0c0PtNxMJ1Nrc=", "MCoIW+BA/5pwmtDHMjiw0eEeHRdAmrqjT8Rd4ptUFTU=", "BoPmQOYVTvc8PNax0PD9huv34pLmP6hM8KiDwvH6qLo=", "Hwnz+wf39kdvrJiUa3N1CV4BSyjyOgesn8cHcUSsOXk=", "BZjDjS4seN/kkHx06CMlyxkdUmCJVbWD5YJuvr0YV7U="], ["H5MFV6KEmYIl9fTk37z1rCEfGxLZGwVi7T1jKF16cUo=", "BMQGGCDNqb9HLfP2TWr6AE8ehiPQpPYULMofGaTCdfs=", "Dbwiw+VMkkqILCIACVEjnMJjdV38s4sn70+IDiAstfo=", "L7scWenomZ2RxA9NRCMxIqs1/8l17ftDxT7Qfb8NnHY=", "C49A0sTSjEcghSA6DkYK9zu+zsOys6Y/JwKPLKinElE=", "AowBqfAWAbtGQX7UZr5gCFlQUveC5GhX2BIp5k5r2gI=", "I86OQCk5zM82F2pb2DGDoNVKJO5sq+T8f4FN+/Jvheo=", "Dbgqu806G1b3/I0RbLVMVP4mJDcCvT1X5x984NRwpA8=", "LnA+qa+ZFhrPmUnaevsY1GLYW2cWVtYcLN7jpyOQIT8=", "FlEsFQwdL7cjXv0tTw+tX914+NDN5TpmvJAgbILEtZc=", "ApiqXVpEVlt172jfkC15HQHZinXoIu9VOxdhxY1v3zI=", "ID/SB4qyqPiLdgZUMUXuNNrqsq78oxvASkdgZWl8q/g="], ["AY6CIvaQfaV0Xuuc1KnmLyi4txCqhf5yn56nOj7wCZ0=", "EHdX6wwHmfeBMI2D0uBX74EG9rZWtF52NhgeETos3zI=", "CWaiG5YVryt1Y9/kG4ufwGA5US3JyOEZaJHrd/hWtgg=", "CCBGCBSY7uY8KHxvo+/N7+uhtScqd7upz921avpTyC0=", "LH7L8UstYEmmQ50PKfEOJuyXWsw+Pt23fIMaUJr1kZY=", "FEAi5+B3/yKizj3+mSMQfVrvBG0KHyy182GRqwTq5O0=", "FwQD1BQUj0aBuCE1UJUeI47cAJ9GsAaTzj2cWAD63Qo=", "KZfZKl6bxmyE9jXoy/CA63IOzUyj5Cw6uNCIYRiAhho=", "IUJ7Opos3x4ubGKJBrIeJCcdcsGLAmG+aMykSGXezhE=", "JLulgIanhUGo6/1TXBB8NpRteLpssm0ifmFRMfcdM30=", "Af1abrpS6eods4mh/I3T0Cg9c3wY6wbgkLb9LciOChQ=", "EnZELZODxS1Q/Jtaw0RCpOyOnNeu5tbOrMGm9SGq5KQ="], ["GA6STXV9C+QGb+sUbtViEuOKz530lXQyZT83D5Bbiwc=", "Ks0544kqxCntgShj76Be2nRrVbuXRpSk53uaGau1UAE=", "F7GGIdvWHfCF2kz4oDOV43ACacffTZjOSFH5Cry7NjE=", "AqQpwtBtzzTTRzDDr4vBmwSr1lJGjeWoW11cv9nCPm4=", "GX37ZBicCarvlKH1QtjDSuon//unBCAtUobWK9Du03I=", "D9O9t5ytkTQyt9OCjgctrcJs9JA9VriXYgByOEbGV34=", "Kbn/4F2yxS3dG/DlxTLu/nBJfH30uX2y8GJINldqayk=", "CioAbjsIa/UCxbFUDqrsFLnBW/iEccttR5+0Vj8BZJc=", "I3qeAgkIzQ7b2erodyNQ4Ocx4yKLiS/F9k/fqbnapnA=", "AG00nWGC7DDWjJvgEFh8cH9+HhdcDTJOat3tYzenLCs=", "Cqu6OdIg8wYE0MRN1Hw8cN47efW6pwo6egygKuGwgMU=", "Fu6YCixn3iT6GjQILxHHG3xFlmpui8aqGh28fvapurI="], ["L30HFdE5EZDnsUoSQrZ5nqwxQuIfCMoCwhdV6ud6Vbw=", "KXiLts2Ufqnvru/Q7rf9Vj/MLkC9Yj6iskQrVdmNxaY=", "EswnRkf8Vyu3kDW/wzMqTlZqKAEfad0IdPAcVrxEw+I=", "LvWEw6ru274rSxA6YelO1AqXKUFWrX3fDeQ7hFJJ9TQ=", "BfmmqNZMyhJyXdFREPdK7Pmd0w5Xp9mYKc2HV7dbdy8=", "KXnRrq/fl5iFYNTrus+m4rfz0CaUaru51Tl2ReboGCU=", "FTiRBS/KEpD7+DJA0zT9TOBd54rfqiyWhkiODEfOH8A=", "G4x+sE01Gv9Odq9/n6ERT+Rartr960LBwjUDsSJjnHs=", "LYEl2+9gK9lw0R+tfP4Gw8ZPVoewm5YKuSsU9p776lc=", "EJJIB/b9xOnlhnkuOs4wAfFrwC6EraXfUde9NyQ+4e4=", "IwkYkZtoJvqnEkxb0V0QwDbVZeEAtpajvnr67bKrums=", "HbkiuMJJ/3v5YSHq6dlVXvd3Dz3XsFYZGumrOKXM9u0="], ["Aig+2NXm+UcLP09Jp3EGHkpPx9rGg978wDSKiGLGznE=", "BquGcsk2BwoQdXrbRQMaXiki8PuLX6s6T144cvtYLtM=", "LH1Ti55tKy4G5y+KqrJtvd6tH+9qdAoR6ZU/jo6e4Fc=", "KORiDSEFNryqQu5Gsc3LIb8hWTO65O7GOe+9UfS7ZVc=", "AP4N73C/ukBnmu+NWiObOhtaUv6P1+23VK7isYLWS2Y=", "Iq4CNSCXl0HlxY+wT9JdEtyPX8tq0VIjpdp+D5HHtPU=", "EFwLJGZgxL2Kbxs2/Dz/hqLEMsDckyHLUKu5ihDNG64=", "Klq6O0XnnrJgaypbR+uQdYSuz7/AtM1QzaHOSFQzhZc=", "I6OyPV7fXLZhYP0lI7OjgxQikcDg7mZmgulGsdV5N9Y=", "JmNfTfcXIQfa1rfDBo0tQ4v79IZHEDn55lqchGKiycI=", "K7KO9C9fratqb/1WVbNlgN6wY64wgdWHuxWYh4WQ8cw=", "CW3UOoMqto415XyY17AfKi5ZNoB3BFk6xyx0ABOD9+I="], ["IfYO+xMrYpCZkLn5lPOBqcAqvDzLVMXI6MnFZkxpE9Y=", "HbmKVi/NGl5EluYSZKrV6jtFX0bqvYlXumcenDHlCSs=", "LzCADA7kYQEFadNrYGhaOLApEqAgvEcIWYhU9lgi8Vw=", "HjKx4ua1knOhE9YJZjr2swyVs2iE/l+vNx3j1WQhPDs=", "GxUjRjpFopgoiQSGgaQiwC6jc/i4wb8Wx0o3XVBgxmI=", "BSRu54VLLiDoYS2gIbMHmOXw0Cpb/V550/msbHn6YJs=", "Bs34BVQ5rIQkxDXn6b6j8K6T6rFxrDg+0s7bRg/LBMQ=", "L5pc23lkXjRUxhfXendP6vJO9gNFTAIHb8TJ11SMxFU=", "AbFiXXV3hqGak7N6338iyopQKqRGLKePfaLXwis31/k=", "KL9UiKUl9VFEANznIkMCh/6OTIEBVAVusPTW/mEJHPU=", "IYkb7jH7e9ifDkQis8j1s5MpmvDZgl25vnPnsgCXkjw=", "IoLoat6FhV1OoGV8St0gYlxtqpC8k5Q7Waktu3e2NoE="], ["HN6CrO5guEQk6bzuSaVGTuBdHPC3BGkgimdWNaxxVJU=", "HE3eB9D5TRqqgyrC9XEtQ4tOGAS1IJzlWULXr7JMZAE=", "EWxF5NiM6uRWXA6U2oROryd11fW0NdlNLT04tYP6eEE=", "GIIDZIBNIhGTR7coE1tAmVb3kz3voQWdY0uXfZ06vN4=", "DISdB7HZ5uy6xRf8GSN/9zQkoGePlGmbI/dpUq+kUUw=", "K2Ck1D0SzzEHbgaQ6TFxbEeobncow0stPLDLz5W7t08=", "AxYde5ThsEEfwB3PvXSKbfMVb/BFNrPdMQH3suvDgRs=", "BkOOiwIgRkA5p7gCLwa+ruUCxd4mnbgvkdiP4bcoNPo=", "FImLq8iBDLxiZohTFRGoRz7YmiJWnUe6WGwoTkW9CuA=", "AJDfzAMnpUFnLPwmx+E3BYPF+SFBdwkwEP0/vyear9Q=", "A44MLinHnM9GteobxYknauyVt06LuC5DhcBYVjfIhfg=", "KDMdDTHKhnWtR2fEkCYbv+W4SttMosVZmofzMZCBMPQ="], ["EYokUQohU/gY8KmWyH3pE1h4BfFs2xk52UBpQflY6OE=", "LPyCcS7Z1x/0/fY+5K0Rb6wZV5T42RAobBUu/Z+Vm+4=", "L/zLxAAx66/s/DqXKEvQ9txNRezri4mY8aZnvuNp7WI=", "CbbACjffJ3DOwPG/Yqaqw704DGzp9PluDwh5I3/6UQs=", "LEA2YWwVYAYzd3HB41X8Dy8jjmTL1p0Giqu0tYEWiG8=", "BBuQmmWNE2mTs/UJqenVATi6ykj2tmOZrFxknmjdOqQ=", "JcB1tB6i2CeklVtkadudQXYPr4hfLG6cCUB+uxxNwnQ=", "EVqRhnIzzHXRyQakKTDpPLnBavztOQzBRDXlz++06W4=", "L4+zcXi1JXWL9qpSfyV3Ph68+OFCU3lQDIJFx0G6P8Q=", "KaFNxLrApMUr8wqva5uOBUU9DXlyRrZHMtUPF2p8olc=", "LIncdWK5HY8vfaogm3VgUgtrxi7GMdtBzF7awfsUK+Q=", "FJcr/IXeA3sH5VMy5rxbTwjzntTripch3/xKWG3Zod8="], ["FkVnsN4Wt6VVD8oim6x8sHeVJDJeTKXnioYHiIFmAmQ=", "GLSbdz9XmYiOmr4/aIPXBjMzg1ts3TM1gLK0v0jzsn4=", "IAdCSxKa3iGUxz5uLJ15Ng0TYMT7uMXzEzD5OFWLOs4=", "BEXibib5FwfaLfXBiLr4DqL0jHA2FJgPp5iXHNjsYPU=", "F2gE7Bz4XTUpg1EkXTIjZUaDjZuYz0JC1gHH6OUBtJs=", "JbbmXpD/v5ENGf464j0Df49k2p/j30g/xPSXfKNqexw=", "L6KveXDhMffv46fHiIkKuGD3Z1HlW0/2NN1GzE3mYNg=", "DI/U7OXCBRkM9shC0Wg0RAeb9Jg11ci437sRr5VsyvM=", "DpkvREY+Lf0mfmpKHDMD6noRhiUu/Wyfrp5fDB9tgmY=", "AmCf+X71dP1o0Wo94IcsO1mluSgljdFGmCahkdy/W9A=", "FdxXh5y0HWAV2piB+Ui0DSDw4D+th3RthXWvAJyWAz0=", "BtA5tk6C15dd0ho3te55MI8g6C4jSJOC7C0XYZBYeJY="], ["GI/zAxlBEqcDRSfMndC03rCWDJwQbOEVF43XCH5OjAI=", "CzAN5bmcJ9MyCR+PsNl88EqGpR1NIDd4jg1POOj06rI=", "LFPWZ21NTIfZ6vXU2gjR6Y0QOjOI1Zp8DD3lHiYjqjo=", "GfUQFxUWKXZ2bitXpYZ0vFjhuivhilmwegfkqT4DgHU=", "L1hVqHajf3u71hBKzPyuUH6d3NKnIZtIenaxfFJbUMo=", "LA3kSKiN/qrMm88oULb/T3AeGlONaQmLyUCHzDWTCWY=", "DOWHBm6uDDRcM2jFPf8hcM2wgb7lKyQ6Hm3m1PgkUdc=", "LOqYzGSr2Sbflj2lfy70xDQUHLU6xjEbJWbtuVeYJxM=", "LHrkddkMR19zwNKb6IidDEuFNv7mwDiZhL+eTbsarm0=", "IyOP2hQXMC3QPOVGB3SWECkpRb3b1YckFxT9OWSvXxA=", "HGdP8urSfOAC9L78etXw9RI+WXk8D+IQdegZzlbOHoM=", "Jie+aNnNDM2jgo1RYhukCfms8J8anMUDop7DBvhgauc="], ["CD2DKt+btKJfaGq+2p8W6/UyY9z570MReB0Jkg0JTq0=", "BUGva5ZSRmIITRII1xtrKo1m2RF5dFshNnnCorvJSWg=", "LPLJksAqNjNP9dyFFkbufaBLROtUTuPA+tuNxe7ypYU=", "BsXfj9Yeyi+0kj8KRt1OQWo6O0jBDe0TEz/+q2/RU+M=", "GiM8fOv7DG63Lf0HqitTfM8pHoQJOq42zGgAL/uDY5s=", "BfbWL1RRjwOeeapya/FaWYNYPspAYkBUAKzKWMqdIjU=", "Kwnek8bjFIz3/1cxyOFE3rtmyoluy+QInS0iy9sJd34=", "Ajns2SUXglF095Y0XbKWViIjdg+xuBwJG3SmpKgpaKQ=", "KUXLheNFMuOiL8V2cDeXiTzikNAVZDCo3OYcnfiai9U=", "ANO+alsSvPG8cFwgww8yC4iBxsLsAOhXaFwFmSYqPPA=", "Eee8SjnScwGWtsM0+ZdQ3lu15PvKXWoZ63/hSr6EXb0=", "DHyduVKGX7lHD4qhQCU2yzuCJ22eKICCrH+DsQvLbRc="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon11.js
var require_poseidon11 = __commonJS({
  "../node_modules/poseidon-lite/poseidon11.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon11 = poseidon112;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__11());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon112(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/12.js
var require__12 = __commonJS({
  "../node_modules/poseidon-lite/constants/12.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["E3PHcc3xUSGiJPMw2EtmiO+f4AOKO8JqKOMZZXigAA0=", "Kfn72jyZmDYBf3bhIa86ylzni7SPqGemqV5bnbOHUzo=", "HH61EWogB1wWm3htnchqJO56JSW1ZbvCYiCajNpJBSg=", "IaVJ61VPD4WfYdaPG2u+mqNEmmI4VGu98qHDCMnMUuY=", "C1P/9wE0fRud+YtGF1gA4NMlCsbUoa+nGjSe0ZWHNQg=", "AhKaxHQkFcAg2yRzmZs039urujytRxNxj5XmNG4Vg7c=", "AdKPMF6LDsiNo3yCUbDI0jC2i+qUAaFfUSTWTFRUvCk=", "HtMB4C4/yTCZn85tN0TCNZZwDANyBwWTnWHO5FH6/5M=", "LtsYMpZuNOru4JA4WK/tsT27qffIAsg+5ihTDQ4mrhs=", "Ej2q3ckwxl/Ge8d8qL9BI/6B+9BQHo+JrDGmmHVth9k=", "K8w2NiyQIQrPZ9X+IdUxBOnVR40FcUHTsXJZ/tjkqPw=", "H6koyrWTggfomOYdmcfWFiaRRPeQCBWxcJX3/3bjydU=", "KcLxz6cqD7j1OmMehM/fXMGPtCbCVPWpBf0+gx/HyDc=", "F6cyrRPxtqGv9CZkw5C5AXxBghAnPH0Ei/MAqnvpxl4=", "DBjG53PqfrQ7mMrGZyLenRNUhMbPoITCpRLqGXemAmg=", "GVTFwjjYowyfG6T7lj4JGsrLw+17SY3PZgD1MLZUXkk=", "JZGrd4E/NNig4LewyqzW7xed0xRZfP3ni3SGnXTa1gA=", "F525+4qrRhnmemqGZ8e0sy9A7YSNjjO3VsmnlLWTL+w=", "MF0BQhS0EHwR/YOHBFhzjgT7jcTnRwd8DkYvUdHFlXU=", "KYcj1waUV4/ikWNYmHYrzryprEVjsSuQ4f7092+be78=", "ArM26bOLUExBKmgzCa6AJNCAKkXQbmSaXlNxmqspqRM=", "CGh+aZtSexNB+at/FxE9ng7KBEMlHvNfCpBXBPFV0zk=", "Cl/599RbPKm3mxjXnbQwfufErE3eqajaGjarO+BXyb0=", "IORHR2ATGSI1NfRWbNyGylQyTFZXJlNTrdfb9PJQRlY=", "AlTcMeOv0wToXJ74+rwaHNGkx7m8hgzpzkNsM6ICqW0=", "Ec1kktxSDFfcPlXjP4o4fLwe2joUkLakvOvZTgdCy/A=", "L5ixAmWjBHW7A0jUp4fPtmAxGaGk/hXDbcmGy0+MfPE=", "FT2BTk5VrXgrzO+ZjJdCUMBzRl73B3VQJG9pxYupifo=", "BNsRqeoBSu0u0I5GwGMG6HExdE1l0onlmWT5MNE7ntY=", "Dpqabe6TOfXecTXKMiL9IjDD8/PgHu3TYz5gaqCxod0=", "Dm2ORkv824+e5g+x8vMweZEeegc4VvrueDmIEcuXZ1c=", "Ajf+IVEYZDehzxkBEGriWqwW6YRvnUH9aHlteijtcoo=", "Hj09HuqLdhWpiX74Yil3bL2h2EiqWmgJNYJec/H1qoQ=", "CXJBRMekrsDdy7qfmp6eybzfaIyj9YcPHubhdBeftEA=", "EROZh+EUdGfZJ9sl7siPDB4CMuNIbNmgFL4/yM8GYSk=", "FSTlvs73LCaX40yAVeyBl0rwSRLXyh34PmWggOqWJp0=", "Bk0SmbEbGmu1Cz5ax1kqBU/XI4CvpMCSzijsjDHoDJk=", "Etn70nviTrYgt3Q8/FKWVny0gECRoYA92Xd4ip9Yjkw=", "CI0ibmnhsnProx1NqFdghcwP0NquFUa+8wB5+EtlG8M=", "FRJt4YchPrtA3OXaGrOtxYoxOZIMGUl8P0cRm6pQZw8=", "EWnB/nObxSjqwWpSY9It7kpmqZYfAe71FoTveSEmhZ0=", "KnAGxoMJT2+E0SKtV3StLwyfqAtslj4vo6Hq09dPOqo=", "JgfCLKmu/ozeow//BbBcT+x+2OkwLQ+VDNlAWulLslg=", "JFMLCG9EHjg082wrEevAqAnb392DF6OERlkxwcWMJjg=", "BjVOAtjE3peoEUgeOQwm5ck/wpoqGoSCSs5QRnyaplI=", "H2+6s+LqJ5HJT1/0PKEolDZAaSFRspXc9CysDYqwdXs=", "F0fKRbcoLvCZKPdkn1zIM3U34oNObIkFwa5pAI33C/0=", "A+/UubTUGXTjaITjsQVacFq07D+xyOdvguA1mRIApjM=", "LZzRidR7CxsyyaJBLbalmxtHXckevS1oXJazScIgtLY=", "AcmYJlCqzRpEntBGBb1l/XXOOT1CTJdRgU/QNUG0dWs=", "JD/+qoLzwDhIHoS3KLRZ6yITWYUa4ibBxtanuhsf/bQ=", "BlDar9ADvtC+0iutoxvqcJSRqDtVyv8wAzmIVIHcZeg=", "FtIMYZZ0Iot2f8YlqsZQuq4tDNFcH50BZFRwgrMJnfk=", "Be6NXWYdOfFb6SP6KUTvKynaP0gx6x5PLxwSMM9dFJs=", "I+vI/ED+7FJALhj4gerOv+RB3iVic//lUe7g7X5NrXM=", "KSu1nnpscBFq17fhGVHDuLaxsTDzW8bEKKlTPAA6cOg=", "Ez1C2fg9BU20PkNU0b1+w6ibjPlHA/3BKVDZ88IaY+o=", "H9a+0NNHqI5G/LQvM5eusM8HqOcUZ+YRC5TJD5MjdF4=", "AjsJGgwfCCLIFWdHqQfIp5uMH8q0o0IGIlEchn9513Y=", "B1/HO8tuosFY5yGpqmw/HE0Tm1zxt1LIfZb0RCBRLu8=", "AX47y6Cy0i0nzau8s2DIAg5WwBwHnLVQ4/Fp+yqaRRs=", "GUKZ8Pt5UagKzplKPqMSPm4Mty1cRv7ilupvjnOtGII=", "BvDlIpJKTPJdkBHUd6J0bHfozHcVC4e0LIwRjxRztRQ=", "DMkcGMX+4bV52gkA8E5abDbWXw/Jd5kyA9SzEcv10O8=", "Gr2UwqWyjmYTEOMxW2etv1Y/2waSa23E5Nk9BBZe0wk=", "JBQskAGnv/82Pz9n9KK9Eo77cuhG47oQNE/65lXlby4=", "GTG51FI8s/eL+89rHd5oxGASqnR9zXo684LteBJS5Hg=", "LOO9EWGgEqVyg26X6o8GlPk8lS0R/RGo6Pmknf+d+F4=", "FaCfo3MEHCOegUllfJi086ow0ZLIfAPM5HorJFPVpIw=", "Cx3Dj3SnG32Qnlzn/lYBdoc4QXpXhomNoxb1KJmK9mU=", "E+oi+TFrtWlNaQJP7iy5XuZDxUVJbfC9HCVJDjTQ8fY=", "H/5YvRSxK5+v3DZecIGjlalhTgIvf017x9/JdLCq1x0=", "Ebqx8YbNoDwB6F3+3UC8XUBuJMpYswWmJXt8dyvOJEc=", "FAB+stFEC3uOCTbHlnIFGub1yp/UBVtBfwDJYyq+MOw=", "EDfwGT1A9oLtliOnct5nnwQxhz6OC1AEofJCrJY/7nI=", "ILGL52DofXxhSbgQ/klqv3eg+EDuV+vP4c93I2M4+r0=", "Heg15mI/QmcRJ23eeiocIKYbkQv2/c0zs0Noz5bpWi0=", "IRw4BQsHxKdHxdxEk5zh92sIIMS18HpH6LELBeepnU8=", "A3L8LNgyAV4RnCoS02Iv1yEqSIfkvRJ1wgX64uF/RS4=", "AUON7newgly+9rD0EumnJ31OXcFhzpgW8CCuTRQQ0L4=", "B/Ls4WwSyXV6qmCVPe3XCcUT9vgzfiKWimXNULDZkhE=", "DFemnQlXXY4fUl4BLXNym8iWSbW8QmDXPkMkhIRSUQ8=", "HI0Knbd/FPg1MJ8tPGghuZIaNmRooNFe+zCPV85lhRM=", "Fp2gk+els5vwiCdwctT9WNgCFbacomLMLRKl6zDAC44=", "LzA0qyCvD9g6xgsCNmloZvglC/LXZbENbaLj7x4teHs=", "DjG0+mJ90OXy2srxBYZad3gVQ2IPPrKP99wQJlZYMHM=", "KpAHEm9n4WMdKVEvQzpqC8uMlaNr4WS+X6hr6f64pZQ=", "CAr0AhW2B4voT7R6zXm1nszv6KkramAz53LCIYO9wNc=", "DeiiNNIIhh67Bas4EuXE/dOeetqQR8km77iOHL8uu1I=", "IqryTA8eP5QWBqUnN23f+RzGsK3AYu/mQfluMAWvNlk=", "H09bdwnPWEvwcEhh6UI0zYkJhR47ISxkoLMFH/qi62Y=", "EpbUZCfrLjiBal6BcTNWXU9t7U63K10KtVm9V2Z6ovE=", "A/qGdnwfote060W0olWxKYxV0EXGlif12K3rloOhKb4=", "CAIoBavgK611MG0iZHjknSX6z7yv9kk2Q1LUqI2Sjzg=", "HVizOiqWOLoYDNNgKTCKLovn7Sc0QdXSgEVrLTuNigo=", "H4yuc1nIAPMHpiW2b/IVTGxDZOhcqOAZEaY0qkrWV6c=", "A5ymby/X+AwXFxpO2Mgq48O/BGLRRRqfWlh0iVhxe/I=", "B09+E+dPK3sxajg5lW9L8lQerySXZTttsakzXabIgtw=", "H2PPEUjA76ZW1a+FDNAqDYea14hs/K/h7FX+a/StXLA=", "HZv268BGS5y0dYNJSie0V2PXpiKW7MoX776pc1anPiM=", "B2SSh0YDsCGJLlwqA8cGl5vlV/1O4uBAeS2hbii8isY=", "BwEjOMXGJuJn921Cg4iUC5AOAIXHhRZtJ7fsiWCCUjg=", "CcKQWeIBPQzizOCyTjlGdlqV8EBSbDySJNKAGhvU/4E=", "Hy3gNQmBqzdMm6fqGmnYGyh8LJ+tkJUgWrIVgroOpkE=", "DFK6uG4lmjvYwGEZcCiHO4AbTFbqgDb/laZ/Q087dCU=", "LyYuBheGcMT/hh9nDHtR755ikhOmQiAy38smdgQmo+U=", "KvaqIzVAARRFNDXpcBDb5weGppGl2XLqIRrxLUzjhMI=", "GMrWVWfwMi/W8GJstcr1Z6RvqhItMMNzgLVLa10Bqz4=", "FFZn4ZBn3dvUJp22ynbQwNflfxlF7qJR+KythuhJhY4=", "Lrqn4QGUzSlXoT0aNY/JPOVNi9Pb7QbiFbK/JiOyGEc=", "KLhblZguvHbEdiZU+TLbAx/9U3ahKZtFuoBcS04HVNA=", "F8sMRzhB7S6x8aHd8CG3T3PzQXLgZbJMloTdPP/DQKU=", "JPRuy4WDypfFsBhzbSJ/3nw50ZeMpjyX456gZYjbB7A=", "J0tcQJ6pgJv38Ep8te5NMi0alahsHQlhsV1KJKcYXew=", "LLqJYNVD/ZhGN3NI6lW30EKzNIUk12EBg2ZGYn3tRHc=", "J/AuQW3XC0SQf5fX7LlFzrurHU3HPIoYwAz7H7JGmYg=", "KrIYZWkSKfpEC2UorXw5xBaTsbk57Anb7t8m83ckoVE=", "KRDakW5DjASDfOeZuBsOl5LB6tAI2S/PnKhnsWX14nU=", "DwPOmDZhEd4SzL5aESHJ+DCVGaflIwDjl9nZA2ggevo=", "I2sDcefOlyE9iutmg/AvRARKH+2so9FR7dMSGkT6GeE=", "LFDKtqhnsegBo2/7zuUhuDr7xYC+GJfcTFts1d87NQ8=", "DL+MjczYN9HbrAkVHk7jePk+hUjZI9iknm34G5w/J3w=", "HRip+wASRcGmoX980k7YILDb7envR5gw0K5IM0blS+Q=", "FHa7HDBgP3+UST0uAWvuYyg7Kn79mZ1ZCQxDTIiDftM=", "JNVl+1eN0lL1anoNXY1NHF1yfVI0rEvZqWAEVcy1rVg=", "DGjn6VZ96rjouVBRp3iEQ0OOD1++DX3kNvo8+tWWNp4=", "HOWyWlOdPhwMXc0evQ9O5xaEDUTDrhCaZp6s3cSjVhE=", "LTIQ5mQH9sND7vKPu3uuWfYm23O+xdn/BrqdQ7qE4gg=", "EYqzQndH7xpFpgnN9+cQKvrm1BE5LeJU07cvHUUK0vk=", "C0XHDShWx+Wz/W+PD94af8sUoqzOT93f5Qs5+5dCO10=", "LOfCutVggVPF0eQO4XzDPvF4PZsc8BU+SikYiU+qRrM=", "CFS9Rv72wuZICzsJmCFfVfTgkKPpngOlpkdC+Y3OWvg=", "Fcd+dgDfcR9Y8vD6iLfUNXcBBKGWB2t05vXXqWyOaT0=", "Kgo+447f2gdhu5swF5JNCTCUeLFnpgmeVNL1oiFyTtg=", "DowU/UO5rOK36Y4axlZZzTf43pQZiu5C9b5mWXZaStk=", "FjJ26DbE7mq5RmYTxh/Gkk+u2c/cCkWLyVtZ/zgeIeQ=", "I9FYSlywt0wABxxofN2stKYysQTeQVnA4AxTUtB4zP0=", "FWhbyQOhxMAxzgFsCThgoq4q76v6R9HykOtaYoUi9aA=", "GzP1DpDpC13KyxoVhkHWMxGXJFfv2UhYNLg/D6BCYKU=", "KDgMVc1meJTGOGR+aqFLhX0/McAxWrMV1qlFcwTyHcE=", "KdEIVB87RRlD6s9yOsxohqqxjI5EhYCPSx5VpzzaYkY=", "HUwsulnVVRvD/pdq5awJ5bco0wW72hk6/CWcmZMvlfA=", "FqjWmXBWEANlAzeqvl5OXd+ktxwbnbjMe4J4A1nHDTM=", "KJ5QwfCwvd7cmLfoo1vmLxT1bdXXNFv6atDS5Dv5LkM=", "CkF2WlNS7L4LMnyngnqfxklee2wULf/KAD9YODxt/2U=", "JMDUI3igyKYTwEAu3m3pvTUn7yuCzupgBuf3G/d2ZtQ=", "J3yuUFfVtaznLEfmDMS44RPtcGtdkepPubE/0Z+k1Hs=", "CjA1Z8v5SWgJBDiiPi/SzLin9xYiv/3BwWhOiVjDdl0=", "H37YwmeimmnZRQ3HSvr3aKiE5Cw34Ob7TUOFywJ6uUk=", "CGxLgwFla2rLinNQGVVqJ4pgMTBA8jboFf0i6Ec7vGU=", "J7Y/vClZR2Db/++NMP70mv793xUEvUh/1igtnj1uMzc=", "ALnApFYhcW+YSa+KPJB1t6uDnCgoge3osOWp5yN2bXA=", "G1ui+87ZIsN5bVe0li/SU/WrbiuRNV0sCo0iYEBlI5U=", "LhrVfr35MmA/Ubsd2rIE3AJuE9xJhnkfVMQDDKxvGTg=", "L4ZeHfEWmjV3H2FwRkhfj7F6/eOyuX0er6+9GGKsbhY=", "AGKs5b44DF5DYbIJuAvv3K0FIUa4adUN1YCF6mXZ0UE=", "Lby7G06gjjdphEvtUiuS7gH+zVs/I3nCS0XVmEJTYzc=", "HOPZADTf2hHpv32Stl+BBIPEiybMoJJ0e0zq8Hx7qEc=", "CGWDpZSXR0sNHrDDzsTx31lq7z22OP7hiV0/WlhFJSw=", "K5hNXJG3syD38pe93Wh4nvbKiM/tOVfSxeim/A5412w=", "CO3q+d3NJacwdRsyzUPGMNqDEQHrMQOZNW5LUt8R/Cg=", "KN85zH+WZyVpz4buNzYj2p8cWP8f1m2TDMI0p+lZxB8=", "Fa9qhMaxQurMWBN/s3F5m/Ov8XgEVcMtjTWYz7kbJN8=", "Gc8NyiJ4GpvVYXNJHr69GOyERtZxdWO9OoDMUqG+aWE=", "BODgtSkjv/i2exIQ8joRJ3M3mWzlAYDrqXd1YYsANVg=", "FasKX9orUZHMK9BIWjDC51tUC8OXw0NtLmS2otqaxJ4=", "AY6D96a79Ff957i6T8U61IEO4HGUGWn4e2K2xuqPVe8=", "FxsFOc8dboUZeJ++sxKStr5gw/k+K0UwmrVZqFTmM1U=", "LqdqFODRd/NV9oHIIt4rNxQq5uk3EkkiZdKZJHPaECE=", "FEKSYntkO1GAxxDrptdKB2zaXT/4NldumD2pt9k1ZLM=", "B60r83zh70qPrFtEMF8aXSEn2Mb/Fz7ELw5CHqU/fBw=", "BVUU3JsBSArle6JP1d0S8im7VZftz/yhRRVq8zJLDYQ=", "CwWkW7k3fhWXUH/eDbv6LWQvbDWOIz7LjtfldexqNKU=", "GYs2nwJKBWGvmtegz3rBBwQrQvkwG6/i4bTCrZ5G+oY=", "JT+CshrdqoZyRne61KTEZKxex1x4dV++xvRtnvc8LwQ=", "DvJW6dXp49ofVtfSEV/fEO12dOPOy8yc28tGx8+8dCk=", "LYkmVwsIAmAWTmtmr6+609klpGTpldeh0C+QxyZPezg=", "Gc5MNsUSEHh/ccuwgMw0Dy+3MswZFhjVJUALL9xRaJY=", "BZ35B8n+UknUhBg/LonxAuH5l4WFyItXuah+jYzfxss=", "KvwnpBgy4L072OlHKE2azRrHBQKVs4i2tcwxeahC+AM=", "BulgpbI4VBdCnfqJzRTXeHwHeOTFQh26LrppSwhUohs=", "Hot5DKLQgWJEhqz9YTJF79cQ56epCKIz7Fr+EUhHYJg=", "L2jXjfTgiyPJb6lZere6WheFMpo3AFMwDXkqBCHPOuk=", "Ci6C8ML540Vomy8tohCNAYzOMITuhdyD1Xk3+s8+VsM=", "EIsq9l2KK474FDTXNkbP9sJf6Ou4i7do3ENcqhkUMRE=", "DC+Q63f7KFXTm3RahdPJYMPQwe50DYd3lxyTbdziZgE=", "A9rdxZA949UwLHoH1MVGA5+oTD2mz06snCucvJTbAFw=", "AQ9NSBiIBdMSZzjSSXbvTIBZazxjgO/7I8s7PqyVQTQ=", "BnATF3CGWc50UV9i+RKOqaHP8nluGOuer+nC7E+eQoA=", "LdA0nw8O9S13YCA3ohHlxWXgCR4BBy7whjAFbZB/xtk=", "GxWVfYyHdAdt8W1J14ixGlrUaQy9gCJDf0AqayXrVDY=", "AqkqH1DEZYtofytsivtTI8m4490X/c1cQOF9tziidZI=", "DUyzFvBy/I4kY6SkLRaNbcBOCxN/pLVyFtHyul5krVY=", "HPD5v5DiB/Ogql/BCFOMZBxA4JUsb2bmAk+tvSJI4Ww=", "C4HAPmgGpJqKXt/D20v3j9S+uAZ00MiN3e71Q9NgCug=", "Hb0y0El2TWq29ne4nECPn00/KbWhgUjMjVdA5I7MnTU=", "FtUrv4OESLDkTCvwUinD90G5ZnkEOKKZe+nMZgEDrZA=", "LI74gNV4jlNZuX0b5VQwXgz1vVXCk5kSgb/lQBueNd4=", "HwB+8WfJuZ6UgAfdgGCFcZK53JkhJ8I1rsRqKzI/LxE=", "DNM2g+wIIHxWqAIQ2ZKXMdIDUmQ5SEGytvZcYVGc2EI=", "CvGw9w+Tu49Td9tlF8RIKsk9369gUeaP5znxYbQ4D9k=", "JNA9UiEY5UTATUnTiv/qeJ5J0usv3dFxYT5p9OsHu0A=", "Lx8OS/mtzSpPGu5c70wtPyfJtIJHlpUwJQJ6N5QkKOs=", "JIpBLyh807NEiTChA5qzIoGVj5mi7sDC8aUqZbPlibY=", "IeN0tF2lXB09icbSFz4RRpmSuBvrLT1M1NFgONy6sjE=", "HC+FxC9qMxCSygM7SuBqtmfNir7yS1RY6xDlM0ZpSmU=", "KetVXd1MdKuQMQhBJ7/CUDbxd76O1i0y7TWXPT3pTnY=", "B9MBAd9xHyU2SpVacAL+SPR+wKfArNVLoMtVHJEuxuM=", "Kvrtx6ZXlByed+co8gLVaOStEjD5HTaalhtNzU4Vo28=", "La9CamXTfMgRJcPRzKUnyynpRRvgpay35PyBsq+uWoM=", "DHdOgSeVIO7KcPins9d5m97oNxqfz5AtQ1M+ZJx79I0=", "AwghKgpWysmVYVFcg/Adw2hL6KN6JRl7RnrN02fuAws=", "IPqUR+kuT2gCXhvsUfEV+2UyNaukhPoNq5ysSqdE0pU=", "L09kfvRQzcSzlUrRTHyxw+CNFAVJvDbIL3OSk86LYkU=", "JabQJCK54AscpeEVa4e0zdpWy7s0H4K0pj7NQa/Hm9g=", "BWWDTHzwPI5ULxwyiABrqfNcVslUcLuGuWaNAGPQlcw=", "JKb4jV1wkLJKFRxort6fNH/t/6pYSqQxstDpDaPNT70=", "AUsNRN31zqV2y4LTmcjkpT54IltkbSXJe1BOY9ukzOo=", "JR0yC3YDwchrYQJJMhnLH3N+T/m4TO9wUON0VujwOs8=", "I4wr7Gz604jUd8VcDd6rLTJoFV8zY7ze/TzYrl9jdms=", "EzfXeL8PC8ABrZ2/mZk3nMCN4O1WdWhEjKPAw1Vdqdo=", "JprjX36zhK0ZZbgvjJ6LT2XTzs/XZ+1ECKAlrHupdEg=", "KwHYeXz7lhbjRxkhthDceMZK6asv5IcBuu5eeFPqGJE=", "Gsxfid/CSgNFgVb/exVrIvQnB0aQDXE2ix6K/ppoTNI=", "CmbW+Rn33OcUTsj2bOzo2+3GIyfgQHq9x71xBg+NW3g=", "F5eOeaVcwHfUvJKzjuXTV6tKbGIUayqErNmvUJVOjKg=", "Ecu75mu02VeBNAgAmEOyyWzXsC/UtEnbGJXIM6ZK0E8=", "C8eENSnhPb4wQhCSKulRWi+BSOr16DvQaGES3GRvyTo=", "I9ZE+rAdgGNh3mZci8bpctlljSmjXpYgi/U/j7TKdww=", "BINxxiALkjsaCtPwCDENvDUOHjxHDSTTrSPrQePZOzw=", "ISB7HUekusUro66QeMJl5c07EaEmVH8hROUBwYplb2Y=", "Grhu2mGmvJYG5l9FXDxI1BNrA9jNzmledQwlcQRWRwQ=", "BHG0HGQYtq+t8MlRc2mwH2K6eNVhlBxL6qHemCdnZEQ=", "H2erPXFkbAOc4J7nIyCyrXVf+9cYfrQ9WuCFDJI85vw=", "HXjaVaTAw/147zS0MW7d1/NtXY22VRvNvINrpxl9r/k=", "FLNyV8H4hSrtRIA2r+WbOhIVm4mvpeLss1BjqpHDt5E=", "ALkEseBoy3cSu2Oxch2/Wt9bZxfmsN6u//HyqYizpaE=", "L8EA7LeWk66pHGEYtwIJ+0RcX+rk9tHFiGAYoO/kqNA=", "Cp13vI9DAjO1n2c3ucAZeuzik5o7Y8WsJMrTG8xwB0s=", "H0vcaFiCrhFJr/x0+h5MphTNlJnXUCemynIAAApTm5w=", "DdEbG+/ikxEMxPa1wN5vrjpn7axOhLI4+suKRF+3P9M=", "IQEoZKRLZHnUS9seLpd2QGffaeB20eHDEN6Sm8weu7U=", "FCzqk+WUnAbDfayItmTtNqi/4avMtLMUXQCHQQpc+P4=", "JdB04x3Qk9Q/o6OmtcBEF31Dznc5rLnlgYroM56TNeM=", "FSNo6N1y6b0/APpHrQGXCWWZu1uj9jQBrps2ifWvuUM=", "IkRQpvJN2EJ9jW+d2YVjAxPspX1XR57JjtPuvjoj5Q0=", "CO6L7RpTOBEzCKMs9LjwpCucEiy46pN83B4xh4VUyBs=", "BoRx90V1hnDK2n8jAUDgmssKz8I3z38x4GNVO6sVbdU=", "F9zu2ahhraKXAxj/i53BMHShET8wdu193uZ4RWYtVZQ=", "IclRsoSfUTNtoS4ZMMuyzUB8XKC9+c9uLuiKjmzzbhw=", "CusVvdM9CceA6xq2hI3LwaGKXGofJQzuh89QbUbDbjY=", "A35m4L97fH97ALtcBnIVViIgBEyUv3iMQLSAb+hqCOs=", "JwXSl9tKtpOmXUzHPtgM6sOm4Q1XEjcBpSdpCVZHuwA=", "DfghsaOH54+OI4jK4ClOiNDC3/gRQlqUCmDgKFpxs8M=", "KVn/ypRkJ2akbNg0DbCOya2pFdI1QGiK0fJeNKmuOv4=", "Doa4ZVMGu94BdIF1tW5myjZBD3WOG8Akc+QlXYgSCkM=", "CPlNwSB24b05AHBeiAJFphSe04+Huv/aCm9LFCZLX88=", "KWjkdi6p5u5QE9lrq7JQ2V8wD9gNhtIswJXelRRZBQY=", "FVbCZloOdMwFb9RUqFo/vstXojqHncHMlbmNm8SXAY4=", "DOhqSMBdQpvkgLnLzCIPOinG7IZb7RCgeDXG/mvuNOE=", "Iea16aWlxXFW37jPWoeF0hF1mcJHr2/rV3u0TnUkU04=", "BETGVZ8VpdbzeBvDkuiOisWC5IfWDeEs28NXyWI+SsQ=", "F82wg9shccdiEZj1G30YkRergOSqq4F2VjQuGws9wfQ=", "DE/NMvu7z7J75BqUkuxVQllpyRQvNlNRx9I0eP1os/Q=", "A3pHoY3qb8dl5s5s571Z49EQOracv5IG0cL/TsA4lXY=", "LBS6sXp4ugAVN+N6YwNXq+Buy9vSr3QkzhIl1KRBS1o=", "EL2M+6zVBf/Veiv6p1etPkX2PvN+Z91UHvB+lXmE5/k=", "DyoLamZIa1X9gnOkU+9iL0wdTj2XXDTVOMvYRAo86cg=", "KXtOtIQ03FNC5MmiYsIAMxSAoCEJFjhjgFu3D8epJhQ=", "Is08xVK4MQlUtiti1PepGGTmts959V8kTThIBJRqd7Q=", "Bc9Jbq3I6gzLNlAvRDyZs0e/cCPy1/vOUS4cWARfuyo=", "HgrosILTcmGQpoePS4iJ4LYpfSfePxg6qanyyyq7kNQ=", "Kygv/vieHDqQw1m8fIATO59jQhXDDB24KglQEnk8fBs=", "E7rn6DjGOKQamWGrgVIPQIyZIQcNmgKn/lv9HaHa3Ew=", "DNwyDurXC/DbV5ZbKfnMoogm9sRNgk9/Ei5DCqTnRs0=", "G5TtiR46c+G81rep+jNrSFpag+UtXbCLcEr9jUgTZlc=", "Lo12WnD9OVM/HEVtsStCDKwNewhr8ZWWxgzWQGsHbGc=", "L2kiD9kgm7QbDvlCv+sxE3CI/5ozjtKD3p7DqIUOlr4=", "FQbp/ewUqdwD6xWdAR8Lq6ZS2zZLACDzSF2kDvgHnr8=", "LkMJOgYKWV3BMhOuchHAQbKdOUAdu9Tn/LA0GRRJKgg=", "F0JusCQV8daCc1OCRQ78dqBcagIYZx7E+j7y0DmA2yE=", "Iqio9HUpQzy0cay7ztqbbdTp5XEhdFuGV32o0QYXHj0=", "ENBmrwTncI5RKjgjEL2aEMutdRpyHGYO0PgH8Wk9aCY=", "EyLKvSG4+YJtqEgW81mfIKMyS/R7RKvso9jmomv2TI8=", "DpAzKYt/uoEGmtcIpAHMrKcTwSKnkHudLuw57B5YNNM=", "J3oGnT/FcBJJASoPwtltcMWLjwu0Wh05MgUdRUHJvos=", "K2pNK0RkZRbgUR0DWVuU9fMbU4yERVYqX3h8t5FiON4=", "Hpt+iX9jbChqx1khgRNbMGHPAt5etMM0TysyRvF0Wdk=", "CJ1Vdr8Gd5QOyFMeM3YWUKOO2uZptz7l9wTAGDEEWL0=", "EdkctqfJHzo3eKRXv7y6l3so6wi4UORyYNuz0gWtpj4=", "B568M0qjd82vK7BXAXt3atFQresnrZUDHB5tbkWFuaE=", "DuzrZvuv4lUiEkZ/vX7ixTUkRkLIfFTvrtQ74ZNE7vo=", "EYm7GBV1keWCY3J1E57/H/GAIXQ5ur8DaafWr9pTrwA=", "ChBOG8Wu9bozYnc7FdFSo0u2b8rVFpBh5MdPQvgILtQ=", "Eq6rxV8KCnOUhEByQy6fEJWnnip7h2XA5/k3IfXrj+s=", "LV+n5EjroPP3W4LRVdK/tGfBE2FTbWHPrB6err+fmWA=", "Ebw4KtbzmYrhJ2F2Tic+jlfeUkQAiWTdwc59iHs+oV0=", "L53lLhFk1XgkQwHcD1LAnc+3sSSZrXaKTJGvN/H+mZ8=", "JKFg3Ts/GQcfIxEYQmUV5/df0/1NmEedhV6IzEDyoUY=", "JWLasBly3NIwdBf4NWywluWlKzmJjXcAyQgv5mGrWqc=", "DHH8hUTYv+HrV+uLGTRIJfKADncoh0wNSu7gnTf8gBg=", "HDjO5wnqV6VDPvBdTz2P6F0nWVq1871bHoGKdrF+3Is=", "FgIhOBbGDMIA6LKu5QnaTeiVLKb3dfaVGqF2psx40Qo=", "CaBGxnuYAlVNMVgh2hw9EzgxGsqikYIiZFVoWzpqGgQ=", "CirHOjtA8ujZO4iOFa2WlaB9VvAtFy+v3DJume2UR18=", "Jkl/HLPtg/YcMnlfVGDiMgoLBWEX/i1IaL/LaRrMnSM=", "GxqIa5V7W3rzYIMzw02hJMaOE3aX7gguIdbp9TSt2j4=", "Ghzsl7PmN2NhDz/unl+IQxPWbz/aGTmF//+iY4iotTY=", "JOtYZcI5P36dbaegRg+f4KERLEETcAf3H/xT6Q/SzV4=", "Ba1zn0rnOF0YrpYZkP247T6AjeAQjK50PXmVojI5v+0=", "IOpN9kPDGzrsDIwstET/7A8jUYQYJ6ghA6Nv74HCtaM=", "B+Qm18+40O2PFQ124RxCvX0NC+ho98yAdA0U1rbZheM=", "DChBcBOaPTL+uJPi45O+IvxXErSxNOEXycv5HAbHoVY=", "GY6JLgtulpQnefwjrIbtPq9caMefj4gTON37OBvKs+w=", "BPcnS0xGDMDV141jkXAKtwaxiNaky8vcxspjHGF6QUY=", "JXogfJrwF/UMJMgobpmgBvWpoGaZf+pNY8vER50VPP4=", "L5GV6HeSzt4x+CfdQIFgaXwXSoSpzdB81ptEQ6RfDIE=", "AsMkV/HIpIEI8cFkkejaHnSuH7WYZCrOu3bQIQ0K998=", "DRYGLqmltRhK4CLFaOiH4v0xwtLxMgrNkVuE3xzXfD0=", "JzghtZ/CP1hfQj4WxdlXHni0KORGrarnicFZhmwVqao=", "KNWBOMqOHh9BAUbshAF5b3yr9J1B5Z9LiulC3G/grDI=", "DLurSiKWPtUBUK436K6cwTk1X4PeTzjwEXlzVjOuP4U=", "Lym4OftXWSctFRmhffAzEOua+rElQGk7eByTl8DaSJw=", "ISUF8dtzra396mNTs4uFdP1S3oqzy+MxD1JiqUlqV14=", "BRFxftEEGY0LZzh7V2sCC2tkXZTyBfcAXrsEFh6glZw=", "LNF6P9/xsu4VO2VVT8BqTtq3yy2HDBzawOllHCFZPYA=", "JCHs7WXkD1vXt84UerCEWIiFPOnZ6QJC7w7L5N+U9Kk=", "K3uxwTpgXgYiYnGxVn2AcFdrcfvPvg6KDObtmmC+S2A=", "IN6TsJsQ9vQNKWDzrn9wPUr/fU4qMJSBY1aT/B57V8s=", "FfOdppR9BwADYJARG5RjzTInEvX8DbOKgJir1NP97UM=", "BVoQxbLhw9Osl4U9N6zHrDIBw/abp3DJBzblmRAplIY=", "D4b4WFfy87+l+kB2eDWcXkvX9o5PjkryIxTfXqFwywU=", "LVdoDe4QTraIfHc0Xsp6jBMQIqRHH4jFTU25v3oY9HU=", "AdJecXDmuSsrvO/tmPfM+UwguXpUZAjZYuSPat/e7VU=", "Ed3omANN9dClChBn/jpbbp1Ua0JoBD9ZmL78qYAnHgc=", "DZbkUdodU1HThIZDzYKsgqkdKX26YQ4ZaZLQgEXvxWU=", "HsUOLwWvi9FpVWErfdCiKuBG22kqNA8LgUtHLOvvx/k=", "EuelZeZF4YX3yeAPBq3nFzbZkAUucsl1QNeTkSJMgqU=", "J31evzPRR1DOyKXfSE/Ns5LbeYFVmqNQ4rpws1ZWMq4=", "InqMXGsfGiWdX861fX3INCVzF6jBuUIJw/uG/ZSEaok=", "K8xBSnIMhaQvbtFL99Hiyn06pffWHE/10b0e7c7An38=", "H3hkpynnD3fMG1zYbBk8uqlBAHCGPV2jd0LWZeLeMYg=", "Kt1TOhwUtK0qTs14A5c5GsnZrIBoWEw65p9WqeTXLr4=", "FhmNlYFAUzShPhCbBNnR9WOKffJ4MA5WBZUI9u9lRg0=", "CgYKJZnraWtD0nXEPqsLOwS0YcxMQ2z+ixdI1l0UM3k=", "MC57bAq79PRLHXmXka4MyFcAeyijdIeYlly0soGCKzo=", "K4lxVH/xcoGpOUPd7LSJ9sCR6WzlBbe6MMFI4DazCWM=", "IfZ8QGeAV40eE8AB6zak3CtWJNw/ErPkpqAlcLPoTNg=", "DK61BBuFMqcj2caKmQwIOQmrlNqGXmcxIPSIRqx3v7Y=", "DVdqXdrGk5nwb9XiR0F923P7R7UzQAvHmjXhjwpRrYY=", "BtzE0g2nIE5+ist0BLa3Gc0VNq82FumUiHsDMSVhTVM=", "DQroDSwD0n721qxu3Vf6r7iK2xjLQ8s6NAUskqig1rU=", "AiF7JM2eVzyPy6RtMEbYMMz9vo9p5D7uMVZkxGX7a1o=", "GwN9Rleys8QTb/g/LedGofMU3KM+4rkqgGY26FCWlM0=", "K+fYUmaJL6TUl2LOZO+EV1+ju2IS35lLqfvU4sNZH0U=", "LC7Giz/b5LEMo0rR8cnuUpbk5BgTK/2C/Lr0NyEN1Bc=", "A1auDud41CfWqEVFvyQaaE/VYt6pLNMLC3W9mniA/PY=", "DqZ7zQKpNe1WMRlPBpaENPyYIt95H/b2rWxAKgvq8YQ=", "GIu6RnTC4aK40fHbTCs956wvVy6YSASs1Xnzwi4OTOg=", "DYIeYFBG4Lfvxifh8t2EF3pm5il0u3vTynnhQvcHQu8=", "Gbu0QGTayTPRB06+q5kXkMY3pKNMM9HJyg7MlVmAhlk=", "Cz81GzvM2Wu8o0U7q20QvyUjgKHjs6woZ7IU0GOwLU0=", "H2V4OKTd8rBjmWHJJhnur2VgJDwBFRUlh/o7YzvHsUw=", "FzlmsDI2ySGxtuTk53+6Q5A/K2i/g//SsAspdMxPTCQ=", "JVrfzPTaz9lDOT/ZCCL7PpIpKxUK4iBfnuO2g3xofJQ=", "Ktm2R/osXZfWQRpWhO8YMSzt9vaf3vj2iv5DREJIeio=", "JsgVr5uurfCYyL5lqbZpNtiKkPR8h45G1VqkH7I6APg=", "IVMAMW2Y+zvCIM03nLz0tUEz5hO6QvqLSJhGZ++uEFM=", "BRrC4Deoy4RElzgEDLXZK+wev2ThplE4x/LYYqr7u+o=", "Gwz6TJ97SuycanCaEG0Xf62P/GrDZJFKq/M2J9HeajI=", "AIT1uAzTgGv9QPfRiL3g9VJt7Ep3vKBEnxEB8AqtSk0=", "L9aAPlFuhzfEW/L0BzaDHr7Stufn5kPg1MZ7XlEJnRc=", "Cxf3MsbZOKx+hbzPmo3UASctfW1iOo5Z7D6mfiqqUmw=", "AbP7iPbKuA86+XTdSWyfpfkF2poHkBe8UpkIDh1dT2Q=", "Ixn1cnmYHQoSsG8vdUGCav/E5RpE4ZkPswFd35oYNxU=", "L03CibXn8jo3Cw9hBTvYL+TL/H0dEdE/KJ77o6PFQSE=", "G2ebc06rvm+MQq0Y2rVN4IHInWjHCKgfj+YUOJBMKrY=", "CjRTwIhC7zCAs6907o55m/ojZ5DP2gAjtYjspGbxkhY=", "EcidL1SYp4hBbQBCzvoNVELb5V8hImCVBFFoE5NE8KI=", "Cz8smMowYfYnITdgUG/nb/3YjudVZDeIg3wY2/+2jOE=", "JXXHH7isq8XLUTv2bb1KSUb04hp7LxpAYpcqCEJaA7Q=", "HewJRN/dyc/7tVwZAvhFcly5LglUV0nePxoRjUGAFWA=", "JTK5aotQgozGGd3OgKLpkw3Y3sZYj1LtXD4ZgO4DBkI=", "AOs+By6fwr6prqA89F60gcTmvWcJH1n/ofRgL8OZ8hs=", "KKbnRm2rH0k7/KGZG/uIbC75IHcKzKvsSGuWQiaYYSw=", "GLcq1sNyu4s7Us61xl6deMBIFONxO6qBMj8qGVaVe48=", "L6mOSHlP3UzbqOEdDN4YzlssydDbf2WqG2yGCZGLLGM=", "Ai1tBau6tAOxMn7c4zAk/JGDqlFPadFnLUndv8ngY/c=", "Is4KI4eiIyKKCoa5QvE1pZ1rvunxuW0/s6FRAjpn+3M=", "ClWedR3+FBXkDQIn17PdHxiNmdk1WW097CwDPeWiLS8=", "EyAjYPElyiLCgaGOIaesELGWFTI2+GxZaLMatQwoIFY=", "HoW6o3aYUBW6Y8OjjngXqwo5zSjiNyM/TBvjVjL8ctQ=", "JFCxmLBF5PDNVAsLdN5cpW2F2l/lmBavMIBt0uA2xcw=", "G/BHlaeXlTOIb3+0fVoLft0u3MEJElWqy5bvqsZxK24=", "DxJu2UkLaZNb6XEQxHYRjQDIsHxYa6BM+BrmmWB+Yu8=", "CH7UdSBGwiWZRzJRxT9puBewipD0MUF9m86Hzk/SvAo=", "ABUYUDDBLYzKQvIIct5pmYmQHiVWmGOktbP6JoLb+cw=", "G0JLlUbYfubKKPuBl6IYa24AFVawjhkAIpjgXxZk3IQ=", "IUuiOmeiIq6eM7RhWjHnsJ+pEeGIgLw3nf0g7RF36y4=", "GG4O3AlsYlOxeRAqfJ7hSW3bYGDJk/qeg2FqfapsIkM=", "FRvJU07F82y6zde99hdqYMm7e2z7JoWce8wNH3vE3Q8=", "KBkvYq2XMj5srfy7mpn1utpord26w6TdwY5puVI5sWY=", "CCWxIy5oMWePaR5+HrJ4iEOeEue6/4TbPRi3vUUXKxg=", "CZ6TUAtisQEnYJBx519MVMrXhzK0hZbRa0Tq5Fmln8c=", "DdXNOmRzH4A9p4cwV+sKSaKsFb1wV0hbQ9RzQKICq7o=", "HUzxYmUQZ/gvwhJPbWdNrvA63D2nWCK+0rDYtpC2o0o=", "I6hrRA1e+7CianapmTtuwBwztGkkw/YB7Xmof5xGQGg=", "LJgzAqxAomy7Mj7Kho6adX4qZgU7sIG8pV9VY1FoiE4=", "BumNO6+9tC29LqL8uWmCc5gL0cgI8ffeeZYyqQ/wmzY=", "Dy67kRkidsp1IQhM/3oCX+U+FOuISYk4HXnAb5+pCEo=", "C2eIWtnf2sX1Np9uMYG8x5CBmB62F32yfl1vbYUdUCE=", "HDLiEJW+t5HhvHhQQ7szzZR4S2Ix/4+Fqe3/kvkb5Lg=", "EhgY36dtmFicMnT+LXAtqDrYjO2d9EliZQa+Hu74MmQ=", "KDKsm7ILV+zJabpP9ccTxAYi+mtOvtBmxlW+IdoCQQo=", "CRcYD716GYFuj8OkX9Q7Q1usay3hn1FrN2QaaxxCNDQ=", "G9hfTEsRrnFfRaF7oh3b3H0cO6aA+5eKGyrDJb7UEac=", "DQ8qhvsNSN6ogEnSvLZnAwop1yHkwXdtQteDu8/SKvE=", "BGCviPbRGvtdGR5IhxL9ecuWEWhESRtCd6wLXvGbRDI=", "C8F4PDasyt1Puj1jTp9yxekCX3eEvT77jccgluLFYDI=", "Du+4ePbrFYnXpofpSBPZ2EI/pQ2zTejV66rBMC5vRdY=", "AaxAMZZQHwBU+o1LVmz/23+B9ClTjbm0CKPcILksEdU=", "HVvd59ZKY7rMJYW4oUCC2NNfO6jB6FffH3KcUuan5dw=", "B5nfr/Ln1jBBSn3bD97qED4bw86vPMzgd8hzOGnlK3U=", "D+D4Fu/XSn66XI3V56iUOImWJJLxQ1Phr8eO+sUO2W4=", "ByVhxnrS/AeTghtQUY1LXYrDOvJtptLOd86/gCkr0n4=", "KJE1KsYP+wnpyIZguESd75mG+UY/WoHGFafLn0vgcks=", "IG6e/MRsriz8foZsraCkxywp8jXwRNVsgkSpLogvRks=", "LnxEk+dwBfSUB/LVy0bN1tBPIqBhrI/K4E0tk9fI39I=", "C56UTVus2Im+71kJoTn157fyOhznoeVabEucOCpRFSQ=", "JjW4RxEmUjRI0LG85dj1T/W8mIoKb+U9ynITBPj2Iss=", "EN9zv92rmUzcB5IWy1heqFMME9pY1jga4MUX8t3IjgI=", "LaVPenv9ePQMmObsrbZl8mRLCpU5sndl3yProkH//Xo=", "Gc41xqEE7jl11KlJCPWx4ERNdwm9p8X8WaUnyywWZQk=", "GkfbveLVAEob4O18IfV6OIochvi0Zm1NEY7pmrwRWj0=", "LwN+c8eIjO+dcEbljZmIg3vo+so0xYvFDwIehzTFOZ8=", "J6tycZjZt6YuDZmy0REnEBAkZMP1+o3v8nYq+Khpnnw=", "MBF2NZvptmWryN2meD0713MMS0k2ob2DzFV0xpQIBmg=", "Aw6HIEzOQD7k6S4FB+jpnK4wlZnc4YkpqUMBAPxcCGk=", "IY6GU3YWlM9JofPideziiGam6ZY8PubupGwrGTaI07E=", "KyGWh6RUnrF+KdufzLV5ahHdtvsnG1pUeUbw3jJpijY=", "Ih54STnSnrVEL9FhKzCli55VWjmLrpbWotbZphbs4Ks=", "CA+9ubxLToqDsq2JODslUm4zBnjAV/fDSZPyfu0uFMQ=", "FgHmV6IriigNRFLVJ77M/bnYw+38t70DctDfQ+k+kSM=", "BlLR2Hja2df4VOSAZlMf/9R3PopcYTAfWBZRtQ41l1E=", "ENuIFojj21i7YI7Jk9NuyFMa06tYDmXVN/Tzfk2iYCc=", "HYoGtRkn8DeSUOc1n52rk6qcz692TdcKzM7HF3pMcDc=", "GcvC6lC3v78An3CdFZqp7yosD2ily60fXhyZ6iyiYj8=", "GlJ544iDtT8xP4aufrsH17sM1li+WQqjrDtBNBX+Po4=", "GvE21TzfZ2woQQBwXQSpdmRSNPQ5cUD9haLYikhOqws=", "Dbivdk7vULsd3M/gWD/3MAiPPpwsVVJ4o8mnN2qJMjI=", "FhPBS8hvleJeBfjscsj/aqIHvbqjP5EoCKxpPxN9XVE=", "D8R++S8Q950zZVCrPgp1RcdNLT4rn5e8xD5Hg9HZjPk=", "Dyy/QLNEcHzOEB53l9E3qeiwEXl8Zv5vsEdNK3ESQds=", "Lv1Xd/jKImeIOaxgwaMIcDCUqdK+RBPIF8dR3PVtjhw=", "KrTjQTeVrZppWwRpXbMbawrQvtkb/DNzkmW73CgFsYA=", "LjtthYTkJmaCnA4ZVXHFDX+nv6zsErrXr6JCdE4AwDk=", "GDPxUd5b2GymjSZNXeXTU7gSipbjgT7SzQDjItyRyNY=", "DqgsJS2NVUma1jxhxHQZyOjkIyV3Mvn2hvaxBtfa8Oo=", "CYV4dEImk3BafJgGNAxtoHd/RXHpIXTV+CwHuR8shb4=", "J3KseSivCnmTH4iofmNN1h+szPYQy5R3JOeiEQ1QFEk=", "LmIjm3kFMHVsoynGPm9DOOJjHvTizGfoBG/i6Ib2dpo=", "AmW+9rks2WIphiHiYJyQFi3Vh/iBObxg10vzY8ZxJig=", "JEhMDCkTeZF9L9i0hDn7PXCwWxVei88zCla1Anz9vDA=", "Ky1Emjq1Wrfud9N3WdtYrbyR0NUJNlOM+wFzNgor2M8=", "I2Y9GVb88acjCFglzGfKyC0+u/0BNPhhq1Up4qTH3lc=", "KPyuwPts9DpXMmHRDtMsHbtLmXVkP63gBTLBvR6g5BE=", "AUXG4kGBhanrxyzY3Q9T3FN4UetaQu3cBMqlLLOuir0=", "FnN2oEIJnvrhzYmI4Cxm6M/aN4+qZOhWJr/kY288WAo=", "DLc13g5hKmFXWVKOsnixs0EHxKjfWOpnTuf7cZ0Nq5k=", "LWe6xmFswEZNT+kH5faPDs7QcLiBG+cpBb93WPPr6IQ=", "ANvSovjX+/OsQDsRFVIxErfwEKCt9spYTXrgP5R9IWs=", "EamS1+ggV1euNrurtUToQ7AQ/dx71auqgt/dyrP4XHo=", "Iw00NBJG+3FbeEeX6d2LtzB6TEbi9EcNLDGTQP2+ACU=", "Cf7v/CGKr6YU6Pt9xOx4btJRUOwdNQezpxcLkmb/aUE=", "Egj/lPEiO9JJ2qTjoCZuB5cx98P5mLf6cH3Z/lODP4I=", "JgyjzIIPhzljzSbfG4/+xM80n6vhboHy+XNmNGaALak=", "EmVeLJitNexEShNOVc9o3N5o8Up7c0s4NHJTCGCbyFQ=", "KQCX8sBHo91mALcGN30OHEYUXzqengum18za97fgXvk=", "AsYuW9ZTgeCXJBTOAJCpbCKwVVv374sq6uG5hICNT4E=", "IzxkIwjb94NwFCB4ixkVPc8IimPo2nZcUYJklCSSb7s=", "K3Mo42jtS3pi/tucv1AQRVe2w9m+XQwnRbzHZHb4zlA=", "FzjqlM1DMce2CfQvJ8TdV9jbeLcKldoMI5TE7xiZKFU=", "LpAtGCof4fPUDaKMNYx+iQdtLdre+A4xuYle7QLKIbg=", "FoP/foSlpPHayyBvxE/JIXnmZkUMWmX1Q1S76GdvWF0=", "EylYRU4Bwf0rxD4CQk4SlrVLVdPdPtHhy884J5DWJU8=", "DetIt99zeSZrEj4LbYOh/gMYB/HuN/dnNzhDiupk6wA=", "LGg0ibMGXkrl1xBuGPRVN2LVjM3gBu6WvWkfFAsV84Y=", "HXwXtSHhWK1CDJ1pI39LpugVJUHYeOJIdkFVcnNMzzI=", "Bk3ufwTPVkMz+9xhCri/aBBjKe7qwbGllhRyZWHbW+8=", "IelOXZra2d/8wYbgMQrFT/OLCinThJ/jhHd9AEir1mA=", "Fu4KC0UXDYnF2RVX6tCyU8OahC24BBlr+gcESubitNw=", "CnAJ+CW2+hgEVf3oqQHUKiglDplIgH4kpigFOIzug2s=", "CNWjSFPd+wmfsP4d90YM5KjklSoUjaZB0OFfce/Sz2g=", "D7GYUxvK17yRSJq68TRaPrxfXe1bIcHRcjfMz5saSBI=", "CpH1DHKkIvPwwGz7FAHcrebLmcKFsHBVQv2q1A4LUSQ=", "LbM7NOXZqYivNVAa9OE3xHF0gbZzKSJG2Y53KKE7ySQ=", "G3Rf+cblPCddN48KadbA1V1ZhUnO+8dmm7Y6PUEA7U8=", "EUVU46/JbfO2Y8YiQwReJ/aiSlwmuHXnNEAUsqmFgyc=", "Gu+WjbR2W0UPCY1OGmIQtxZcU+8zaz2W9V+6xYpUK9w=", "JL317E67FttHg3GJFy6KVbNgOMUL8fOM95BVJ5IlvlI=", "KufEoWVZdaxwUtEB0TRu+hD8pbDxO6vd1i3++pgP948=", "FlzUKaOWbRvO2mFLBtRZ56Dgz75G1j8lUhya90AoqPA=", "G7PUsvZ0QKX75BB1aUW3vdyi/x3tP+IQjRJWeQl7B34=", "GGlfAYVECl81rXSlRR2mM37aBJ1QuaXXuyhNUvkDPSs=", "Ausb206qP92qYlNE6mUK/EYDBuDj1Lxhj4Hp7XO0Og0=", "Heh05xPlxo0vVtUY+OqidSKf2PyKfhEtfRok5gTT74M=", "Hlpv603O/CtopbLD0GZNqrsfBzX/Ki0raEMPTTmxCfg=", "J6QoTuDG9z3a0C+dSZvpD+3TLr16+G9ErFDjVPdDx4I=", "AJnY6VRv2JG7q1R6DsHcg4z2ISZ4jYWydZd02d5153c=", "MEOn6onR5P4U8fkbWE0Aw7p5gx7Y2GSbW6/PdaAM91k=", "DnquBNq/o0hZAk0HWjAU54yQljY2kPU+sOmbfWKIl+8=", "EP4KEcQDDe9yXOdoT9hyTgbWzw0pXbCbQZnrO2qfBrg=", "Fozfa69elw4ea9eAmTHUh2VLQuntXY2SpI8dro0rTCM=", "DSQdM8VSyFVW5ip6/knlpxKP6KohB3K7rllXy2CiOcU=", "HiXA4A23fGm4fVvLlcupNLd27CM5LYzOtsOSr+WWHz8=", "IrDlL3ZqcCr8OMLGAWHjUtiAP5IEMaz5QQ9/0R6dfTI=", "EuybkfOV8WZVZzGL0/ztenUsoB7goIgTjEBUmjEWT7Y=", "KZyP3KiRjCTa+HaBIlinVSfxtdF0Gr1xqC6sDh+/INA=", "D0KL+R1NMRhPNddwpUdd6/Q1POfcqbwidjtplDNE8jU=", "G+BUmlRwyUKfDhtvlILzxOdS6JwgPCW2JIF/Ujp56ek=", "D9zDzgKOlrIfkbyHrQUteORMpslheerWQ3jNNW3SrMY=", "E2pqmEP+EEg43AhZksDrjjCf09Fpr2ivgFjdi2BeqhM=", "BYREFYHOY6TtIXTbNTZbywG5Oy7AL+1bbO1zFKEn5ms=", "G/mrkLH1z2yp8Blb1DNuaBNaWuJrazURzJBhVrYhzBM=", "Kwv2s8yc8CO6E9xlAfAKdC1E0mtm6b173Zar+7M8x7g=", "GdGGGbtzVIWQwAx9AuyUtSu4u/GqXC7gbh+Oh1mROX8=", "FJCfjIkg951GhqFKGqbgOnG4TT2Raft2czF6prKEM/o=", "I5fzEfWY0knmzNua9q5b628Jf1o1CIbNrwaR0Kir2PY=", "CsL3o8Lkpv1Y+eUC+d/PyQRgh2PWm5TqUCiN17Y7OEI=", "Cr42pwSKNNkRCkY8/y+iO1qglmo8WNMIbsr6ES9QAdE=", "JFrkeQEHr8m5vR8Uwg8Q2KdF8HfrFalg5devN5oY29w=", "FK4RCygpEmJQ4daU8IQ27gxW0jC0idCNMrw1A+c79OA=", "IKBXbr3vCNviGRYP3Rp+ddg4dwx4CmKLHMcg8Cf2HGw=", "I6Bcpbch5I2lfTc983bFJS9m6fljxpfX2OTs21Xvgzo=", "KBPYmoqQYcMANIzvqUR/GpY0PzKfZcThZbWxOHxMZMc=", "K/fuVC4y4oCB+r7dkvSxgZG7rkikNic9wEkWrgmmRVM=", "JcFI+ybP5MPZd7F9oGj9Z+qJzFEHn7XQzTZUqRiLE4U=", "HT3SPmBIhm8IVXQZA3ZYQnVqYniXz0fZH58rHsirK70=", "CveZbPpLURY7Tqj/Se0uv4peVqRGh6jeNR78Fyyb31A=", "A3DfvZinPiSVLwII635b+oOsd2HYwLS1PsZpxpNphzA=", "E6rNv+BaBkf8FYoTBoA8vR6/jZldWye8XDqS0EOCQPg=", "BQ+0/yP1Z31/QrDIGEwiS7adTzBXmmuOnaXSKk97+yY=", "DLL1zuhcxuD5vss5G37dQsr/98NDgqqeGd5HOixn45M=", "ChRkMKmKhfkG0x6Mp7J1dXCZbbz0CnqotnUGZ7lqLvI=", "Ix77I93XzDSFuLyoEomK78gJUHjlRxUWYqu6DM4fYn0=", "LrzACO0OzVUYKWVsc7a6jYsO74ca77lKIaPrrINWE1A=", "HSkC6LYnwEQ76p+K6lYBsh3ApB3/2YoVFnYdQA97N54=", "J3NY2+CcO7lXCIkpP3lcQdnCyQQlvfGipWb55O5GgZo=", "H79pLofaIAvE/9SJiJPO+2WkP8pQT29nUZP41jxgObs=", "DzuIH7ZbMPsvhJYg50oNv1k68zu4ChXrf7iKCdl+D6o=", "ChFvoyyXYQhms6k745GQgCGb5gV6S3W8o6e9e++Iuuo=", "MDhKMbgMUy7MoS0sYc5OuYCYp1QHmmmw5E+qCjvv8j4=", "FAPnKYFK3bz4CeSaVGXta6bk8DVKmGzSfp0Dqmqf0YE=", "EXlGJ+YSWsRl/y7XHZWcMYYKotjqw/pBG2gVK8OBzSQ=", "BwNU43E4mbOK10p/XjFU7KqicxS0f4V3O24Gb9TmPbo=", "LR4B/ntJZg7O/Qk7WrJpriAw/Xgn1kMMK8xT0oAGMbA=", "EaAVM+NxPh84+Uw5BoQzI8DIi/q4A+E1BCuhuLzu2jw=", "BY5Ly090Y7xtAtbEDX6Fiw4KrPw6iNwyAYfYxaAV0Vk=", "GyrTh2LGkYIB4JPSvDk/n8UP1fRe2UOo8Rsml4MzXnQ=", "BaudOTpLt+7gByPo3maLJAShYqDhdXem5VuAJbGBSwo=", "BAWK3rWt6anJ49hp7bcDIieLCc4SGbpFaFv49tac7Xc=", "IaHHxiy47OjTvUNPh5NsOhhCQy8vGmxmEBsayNEcmhk=", "ICjvudROWvOMDB7TX5y4Q/OBhO4PufHEISEhBUKwAQA=", "JLB5LWnrMTZM3It0wQkiPBwtJEQExkpB1RYHarAkDKA=", "IXn/UuogMu/ZWsTno3qcDOUDTTytNmEFNB4W7HSD2hk=", "Kcuts393PG3FgMwMLr8pJtWYoZ+kH4geEs9KXt+voT0=", "K4kvCeqfYP1yBIUva7mV4gw1EGSL3EALl9+3zE1/vfI=", "E7rb0JU+CWFaThPUs0D04b8qA6LfXmuPr2nYaXmQyVs=", "K4/t+MNmKwoQV2ztvXIM7Wn4YhJP62LuyDxxUNmTZBE=", "ArPWLW7+oKIuLZaPkZqL6lZ5Gje58h0D+VGF2ZJscuA=", "BwN7rItmkHlN0JB/fjFbqlJe3HKYM8icZgQG3yG/tlI=", "LPnqR0k8t4Z7hpQuNTSHzU9Ms80z4xDp/UvDw+a1JC0=", "MD9aj6rypq6teA8qE5N9df20YF2PWmVSJCZEKQbtrCU=", "CRtii9/U1JMzwqnthKuj7C6rM2qNkaYFud7prwr0TyY=", "AfRo9u9cNdPJVZLiex3nohOHimU2hav7DSly+w9/njI=", "H1kjcl2ZGzbehVfSmc/ifYsHbGQMxM//zlfpx0d7iaA=", "DdXXsdDVImbDh8fhEfq46sRASyB7xeIWq2S34QQUpr0=", "Juo9xcvQG+HAbOwE7zKKfSZq/jP3a7sm2oRX6WY1FEQ=", "BnIxh1o9U2tFEdCgsht9JJWKS/HNHuxMWXwl46AKyzY=", "ByS9TVI6cAVMmVJBtn9K6k5mlFit2aZ3nYnPPTvdnag=", "HMnb+KrUXWcXjFuRoKpEcBYoskEgmQ/m4pAmoLIem6k=", "K1hBRTpmU/0wwF0lgdv7+sW6ib2niEIgjiSgPEb9MqE=", "JaG9ksnKECJrz3+9mx2OKyJ7wt1OPUbhM64mgVRnT4s=", "AcNS+9kickiXq3mmDkflu/PEtxSpB8Y/TvzFvVzG6Cc=", "BeRIMOwXCkpd/Z3oRufkIq6cuYxvSZu2doH89g9+grU=", "B3wnNqwtCgcKGhxuReqcxSYgHWaO5AQJa2nchQhuqcI=", "AwPzT2qiKaUij+yVlUT4Me5xoRN97bakt2RDAR7sMUk=", "JzARVZ0jkWDUY6K5iQCWukVY7/e2Y3KRCCxeqp/7FT4=", "DE3F7+AWSY6oI/rV4S0uAD8stOyqp/DgKRliblivp9Y=", "HLmQ2An86j2qjQOzvN8Uemkv96DY8MEU9qCA2qWjrBI=", "Ggo9OGwmw9Rn9QunM+bXkBpZt0U6SjQFbpLncbbdT2w=", "INgWGMDmrl7DA8/eVDRicQQWNMs88iIZ+ZmlS8UDO34=", "Cjm6j1fHk/5ltmkHzGVql/9SOBfPzsy8LC3lu7jewMs=", "DeBW+zGVJt/sFdUCFzSD6jXmBX5klJ+252kNPCWSP24=", "A/gqwS1b5jmXR5T7PCMiv25homLHtHCsXpfSCkpNiuw=", "CDWsYQAep5UNgOMvzCC8DHGX0Sq7C17Zk5IQE5DeKkY=", "Eg79nAZj4O87bFlkFPAYpzy1UyZvvLFWRFLfkBa7SXU=", "Ba/DYC4CORvU4sXr3aKACF7CwfNWo6XNL9I3K+bz8lk=", "D4hYKTWAJPwp0EHrKaQxMOxAOSLER5xVqzs0ZTasFZ8=", "CXUsIeKpx9bVuJY0KI4RmgxkBqvp53tK0bjzbJ7Mjxw=", "HWuzLUFLj5hYOElpSterV4XYjscL3kvNdQKHAWr87rE=", "B9RVzWmtAOk7CaxEkV9kp9XqPEwbPRdrtRhZY5+SS1Q=", "EYiGiQ99Pd6a8SBKlZDhB1DJpgNeZrmLutH7YlGBq6s=", "JF57NkOndmVmOV795uR2Aar+MHN4/QANoI+swz27BD0=", "LOthdgc6mKZhO0D3aGVNrY0RmuZO3WzITks0Nw+UCdo=", "G05NQQYTroN7f2p/UgagPp7KZpL6lwKHpTMXmQzoEUg=", "CABXuOZkrVgOpfOFEFdm/A46IiZSDPUjYElz2idNENg=", "ETHsONiWBWen+pvZbfp/1Qg+FPKEMBKrNulG1LkBsKs=", "HSeOYsWPPBfhR2n+Pb1sa5+v8R3vfQAwZtjmsP5/saQ=", "BxBDH6iOA28YDw5NRujteKfmNhojmr14e2zi9UYVzLE=", "MB6GsGk8B99g+KwVrGscqnbxPvUXVTXY+XYAuM/jteY=", "JYcDeMC3BoBBuSp/RLSFYFRIRYxNLnqHomzalMpAme0=", "EXYhjUjDnOe2z0bnYNNIhxJmAFywB0uYhussS+9b4Js=", "Hh78OwP++xyXKJFAlDLAL7D06bb24ys/wQlCOHqagSU=", "AZLOT7l+7HaGByEKKo+xyymCjUvYQCNvFDJ+GG05Rs4=", "CdlEkDRWzEOkPpgnNodVuTijHUKkfMbZEMoLBO4Q/Y8=", "GOQXk1dYjyMKuI5vphDYgkQqiVGcpxvxDYumT7KqvzQ=", "JdD3v/Iqnpl3XY84inTU/9cPnfcdl3oH2TQ3n+5ik3g=", "BWzg1HQY4sHtfqY9ewbct+cGir95R44rU/QC1YT4AUw=", "IN15STB7ws5TMjAi/LZ2U3nJU+hVH4eMS3EgU4ehe0E=", "BLl81aR4dJKOjjrW3mRCJkk8o6h6GbGC6uiYEts6oGA=", "CTdKEKpssLLK2qIenxBFn3k3b4rQ/QeDAEW28elFJgA=", "IRS18DjNQA0klZkW+D0MyCc/f3pRlVvbpZ3z7l6kyVs=", "J1HYEkBfE9IcTVk30gqYHbfNWTOCISQYlhVhH/S6LZE=", "DNkKiCJ26iuKcnPtoVWm/Z1j3QlLllAkQRKBriurv3c=", "AoO9rMFHV+KDmOZ9bnkhUplR7a8MmHIZRFYZXpeBWB4=", "FvF51NxPIQHOqNEnptwJ5PJez+T3n6PgKFH8BhCP1Jg=", "KG+R0bednmgdbFQL0Ur4MpnP5SVNmhs6pjTlRWr7cA0=", "FczfrTTSkiadZzTBc+JB35ji/XXobmHGE2nG9Zq0e/E=", "Csa5DGt6R6HtqdSm1Gayrf4HjcQcnG7dCjkDA6nfIQs=", "JUl8pRXa/DfBJe/c5+5mByyNTBUqKjD4Hhlf2+x2SYI=", "KAlIz+PsoZ4c0Pu6pf0jo45nKFR+ZI/oC6lHxHWCfis=", "DNsbZBK225fcWSvJZsbhpn/acCMurZoVfyf2AUiFRz0=", "DEONWr71BCoKY7pDGNeJEf7FNz+6cr7G/S9SvLOGaC0=", "IZ7Fgsknjnjkh5gCPFNA1SKg9+Y5hY3kygEZnERSBgs=", "A6CScwzDse6opadhJZ3SvqT1husJp77rF8KaYlu6gXM=", "EOu/w1Iz181jG2IEzcibpP2TKuBYGoVqOVqKUmYjOaM=", "Is4IkNnvTysO9OaYJ9+2jzpupsMKJKZ11RueGZttfDA=", "GJSPWANbsQlWvfbUZnwuFs4YRCoZuMKB1JsuJlNP2K4=", "JhnO7cuDS6QAiFOutqjWFE4oG3rjZ48dUtNS8EqfDfE=", "AkTHTXk/Ghbxl6L7ABvdMemG8JSoPgnVjyvFrtLIvrk=", "Fuvt1LI9RoufNsvbNeABh967FWaMGAyKsznuW1nIfL4=", "K8Qcnu2fY1IyRfS0EiFnFdKb7PUdZgyGva84gJZ3utA=", "AJ7b9TR0X4xzWsh6YC2Aa5ncaAEut9bCwdTDigZz6iM=", "GNrMjRMgK/IyYW86F1vAIRiaJaKW78mXeIB4KzFAeYk=", "CyYAoHJj6DrAdrscSwf0jywqPPa/e+SvdyYtORc1Tuk=", "J/bSD84OdHz+Q3dDMaGc/kwjTpnRgDMok/cFhKF/EWs=", "EFC6IMj015ehruyd5G/H95TLaRqbFoaKLe/+7Ruz9io=", "B93SEVoeNTEbBSSUucBe1H/4/i1BgXjsYASHrI5l2iA=", "FSpltUeOD5LsP8NgFD5qHLg9bplmgWj+vtNxYK3aiiw=", "Id5E6+SEUjwXqc4WL0L826px7UQ3+M3riF49SiBcNww=", "G+N2RKHTo5e2tUmBBWjsdjahvk16ZK4j983wfsk6ARE=", "GOexEmkyIyYKJd0Xxx5DG+XtSoq3N/N3XvYUiSmPh1k=", "ACP39xC8BXd0AqIb7ENy47ZIRz83R/HrKKeMfgOj29U=", "JHDeI2d6AWoABMbvKSBkzux5zRLLH6SZkqO5vNCiXeU=", "HR+/iy5BAAgD72pQvkCZh8b1LYtTthfEBVvSTn0nv+w=", "An9f4fS+2wZEc75Lbqwez9ZWrSCGq8MRtn86yLjJ82c=", "LVOvARnfp3wo3RArKCj+6Ar5rmUdsQFMPzn6W5uP+FI=", "EvGZR8JkX0SByJET9FFGQfSvt0qMQ+A2YDboBUmnH9g=", "LwBzZ0v0/XnSSWOOxkeGqURftZDxCI6+Sk8B/l9MJRM=", "KO1FtH4MRcKavwOyZdn7dQADepVlTu1LbPShhdHJrro=", "KSFC3HZwY5LzAGuPW0WkUfPDfsutn2mycRIRF4aDvls=", "F+qp7vPcmnBZv2zjpRzqSkX/A7fMYFy4sFw+3yudZ/0=", "GhZ9Ik9wO4PyCprh3JC+d1Fql35vLtB9qFsGkQplvlY=", "CE7r52axQdei7Pz/CHULBL1v6oBTWyoOMK6JM9mAJso=", "LsD0AsbLlwnm44F+KzZCheGMq+KQv4uDh+nR/o3tyi0=", "FlfibGGg62+LynTFu/NKlHdy/9bCwPm2KDah6P9vR4A=", "H4gnvrfayGlY7d3qOLKPmedxgPPDuVmXk3jEd3ZharU=", "IXoH1lkvwAAfwkC+RPccAX84cAYTG4PyN/pMlmjtT9M=", "BZbZ1shPdFRw/JmXxaHOnU45BOF/FvE54fxvC/J62ks=", "C9Lx5hp+1HcmSC3nauSw17QXOOsGyemP8Cd/6hbCsPs=", "FOTxSyp7v53Yw6G1Jgw4RFGcO9XRObc0Rnj3Sjb05Ko=", "CYCws9gHEKFn3xR/nUdaKNyvkYpqo8lnpbtV2XqPbaw=", "Jabe8fGnno1jVmcd8cozUN+FUGn6G15+hvJ7r97mCsE=", "LLJCopckdA5j2EiK19rWxdN+nl0JFVguenHFPlNrZOY=", "BrMtwECLF4LAUrulh8N5zrNS+ylXmyHGGAzT+zmrevo=", "CfIKE3X1bmvuUyasdWNwm/9ukBgqwJLxIUXKCI/fP0c=", "MEAoHEfTtu24MUGCpZWh8+Z2TmYswOyHi2OIJt09t/g=", "AHLtoWBoPDupyg3Lsn8AhQXoOoXrWsdTt6Z6I9JFUY0=", "HQxAa9QLuP6ADKc31QHhnxWPogXZ9jowtIfmFfRyFAA=", "LhtvcB3744RiBhqR1fZBq8x0BqX0Y4IrcX3nk0TIqds=", "KRjT/TMjcjoc513BsfgpSNKY2hRjZs8BZ60IL1r7Kqs=", "BKjt6C6gxWFEOFj+CNLJBdzURfUbEa/UH0Z2Zz10rwo=", "Ji929a+/3ITCQOaGNi8lzR80l9GVx5pAzJlyJaQ0koA=", "Dpg70gKkJPJKg/gXNzfavyxxHswFIE4dJrT3fx8QdSY=", "GoyKOxODekplfCbQ+ATKfvg6rH51FhhLTCLrev76UWk=", "BaFvJ/RgcZ+LdcScHNrzSHOataIWp4MDm8BV7G8K7xU=", "EJpOICpdbulDshONxePIaBiLArpXqxWKRuAzWQ3rHQI=", "EUvmNuEgYNMXp/CMRLhWFE6IPcigevH2LK8wDSNBLd4=", "H+zvroYHrrLxCSOeBh0YOd/KEmNKSwAb6h0RkOTsgCk=", "HPtQBrYoEUewXcuKCKpUp/z+mxIfEr026YnS9Hz4Cc0=", "LC4xyicZdZC7DUZoKsENIAnttX4KiLR5DXMcs06SbYI=", "GPKgsAtUSfS7gmXZvCsDoxoc5quuXq/Z7sLzdFvlYbo=", "BDG2xinOvc5ESwr3ffCAhQYQb3ZXIJqclsc/a0TaawI=", "DPM/wv3h4XG+FR7jRFlXBe7J0JMDQUia3GQz/bmUH5M=", "CgdDh3sooqZ1lm5q1uLK8y94++gwvLAYerpMIf59knU=", "GVudKFpY3q4wdYoXfiCkz2Y1DPS+zYEmu1uJ5nLTn8o=", "LD6sXVL69bRvylS158Fs2VA79i/x4/fK+VFJAhVER28=", "EACDlu1+Jgl9Y4Rxbd8pkxv6jPiNDxVAa30+MBRrzCw=", "CdYSDYzv2NuZopBiaPwRb10xM5wRkIJS7Aj9Oa7mbHs=", "KfYP374Nd8FkGCW0meJFL1/KPftCe+B6MiAbyzgBkYc=", "KnfZiEM9rd36MXzxqGwlA/4BlPwVlef4QnwLg/kLQYA=", "DJZQ8UnJlGcMu5ZvOQPlKmN+lWtXkvtpoNc3bnMugRM=", "DL+heyNH5oIfeI6aRCVcE/UDJZjR4hWoIuPn7Zt1fLo=", "FnxMmV9aIDV0lmePwawz4IQxEnrvkqmgBkTGHv+t0Hk=", "F7CTeNqa2Pp3tdENtsx7Ui35Vmb7IEr/I8C5qeujeVE=", "FURLNGou7kAiDVq72jAyT9QisSvQYlB4h6F0nJ2+q9E=", "A9CKJvhsl/McTNmgGn9o/sjCCNQuyqftLP9zt03BhlY=", "HFOckkF+DhGyY9maD62Pxh/RwGXnA5mv9RLYd3188bQ=", "GbkgnhBV9ARkfS8L1IF+eYlyln4fdoiHf06FdAD/hSY=", "AU5zJT47XSyQ8ZmVnr8HGxiTJvOdF3KYbeG6edty8KE=", "D3aqignNBCVZ4h7fZElVV+gGWSodct/oyj1YOgT+vQY=", "B+l+GXf4c6BYHtp1eVXJMnSodFSmXm3++UQLvhLwFIk=", "L9U0r53zEQnJSNWl2TNrjXvFGJXDS/zerEj4tW2ss2I=", "G3lxxkS3/VFwM7jfIyXfgvoio7eanuADMje7Q/34dyM=", "DIMJacqR74e+EJr0bQrWLJPoCxypMH1ycJUIyx/qZKI=", "H9uG80Euuxh1Sh+c9N8wlssRuonnmJYilcyiVMVl8ug=", "LJpcgkgcrc3qa/vaMDQ9mBUiHimuYXow+VDSmDStJlQ=", "I7GavB2+NKl5NTfx85o9gZRNG4z8TyawY5yk+uzZjSs=", "DNaSLzMEpNA4gzxpewd0FHlyUWvcj5ZWeymmR2lxVIM=", "GDIS8uQn/BCAwje/rkID7xJHKgbIJ/k9ul1a8k7DNqY=", "BEF6DdbT2M1tLvgcyDMzItcPJk9RAIdKTBYD0db4OdA=", "Huf9hq5r/pFvvYfPCnKkvkM9TT9bO5ZwftoMR6Qiw6I=", "Djht3dhw+AQd/mGdTdju+FGmORz0nu728fFEPuoXPRA=", "CzGknpV6w7x/8PZe5v27TPSxRd2KI08NfmwGOb6gB0c=", "F77fnxOrnOim4oGQR5k5zSeGO4kv/NrgVHighZx+7cE=", "HCj7M9md0bOuN/iE81UlRqT1r65WL0hi/h6S5wJAnhU=", "FcbQo5QWaWfLw5KAUF65UozasOpS8VlcXnhxgV/9Asw=", "I2MDFQ+edlA8zxvlyQw6SF+Q98H/rrscT8uqgqBRm80=", "H7vgdHvSu8PMu3Us7ZiXcxlC952adh06ukoWloHjD+A=", "FHFG+m9GT35YoTBEQdK39kMz4hd5zXH4gJYqUOpjhbo=", "IX4CySiUFRb1qaeOulFGjZO/snjRx5Bh5mbfSjIJLAM=", "JGATtCPMiToWtowiiwG5OAtHsK++Tb6xtDQPWAG6TBw=", "K1IlSWweb6zVt08ScFyg1Ke3fDDByDEcPIGDcWerRe8=", "CpUPVydJtvrW1sMk9AVo1yGedaiE+bv5QbIO6BtCwCI=", "GnGIjmZNK6m7paoi+8OA8pgQ0JJ9KGr1kRB2nwf5l24=", "FcXHIO9vpbApNjdsKYOUu+3OWYJNbKn8Jg9e3I6l+rw=", "HISYPKsy+5bM0CdtJfy1qXjt7mk1IMCxygl3ksvRdC8=", "EHWbenROgTIvg2j/+mhFEChn4hymiT2XtGMJTscqHiQ=", "GrQ/Gs8odjdn5YdUKj85nwmYtNIPUy0fWzk17yyj/Go=", "HTLy4MVkJ1gN6WLxR2M4ma5yN/TM/N1S4Nm3sDfOIM8=", "IUdQbgD74PZFgRUSbfnusa5MMxpKOBkVzBlb7JSIjWU=", "BOle2NilVGlfKoRBwXXyLGGrBBqk0n5IIQYrAveimrE=", "LMGB+U3lcZ/izvIiJ3fdmKranUy80Haizss+p4+L/q4=", "FhX21YJsqqZ4xOXAHO9JtEJEgVfSxlHjscmdMrLFHAs=", "BUsOJJHT69F/f+4LDc5nuCNG0iSqqkd9XZj94r9d9dM=", "IQUv4X8/gzkK2Kquzki3kk5UuAcLYwT0tOirn4lJNxM=", "Gx2NkFxxOVjdMVsMhKZdR59vuNhphjDn8JY0K+TxKb4=", "CHZd+SFBzHtRvQhz+1JZqKzVqbUIKImuVQvz/x6M/Dk=", "HdHiwGi2UyA1Qv6jdGMp7KlUueKP3L2JWHCzLzSBEFQ=", "BQWCr/38Tlw85z10ZoC4MKhDk5VhIWdn5O5jQlAuKhg=", "FRVyptH1feL6nkqqVF/7hCuxhK0+CwveKScbVXMuotM=", "GNCqOAw3mo5wAFMqZtVhQQ6NEY0ur7bA1tP68tyOhb4=", "JCSlhrtXwIg+5MpOxzGWnHQiUCyKIZy5XO06EgmwX90=", "AXTWZDzLYyoUsRFi/DVwBgTFk5nToAf1+JFQS899d80=", "GCEEyUFmBS/cdI1JeZAROHkVspngSoDjPmEnQHBuemo=", "C3DBGFIw4i3LlIQozt3p19ycln69Ra9NnNYtoHvVIvU=", "HbRLbgFCuuEHD3NFIrwdQLmc/FHmL/ba04n95dxo7KA=", "I3eVmBGfr5IzNqLp/hWnoy1GAKix97vHPN3xD8qBqrI=", "DTENCNSMBNx4vaaH1IoAWYu5Y/CbGN87i40xYpt7ioI=", "Kov04tUkduxIgpqZ+lO0fLEEW8P8zr6yUiGBhhYcezw=", "E8uw84Gm5mCcP+QHfc4NoyE4lm57ooEolgAYN1hbLqw=", "KuQSZS5EFycz4ZOf0y63gEZH0pdop0szUDayRVNXG0A=", "A/Qmpcdwen2hqDSPnmwObVstUHu+mKAG9xW/LyjBQzM=", "CS/R/T2cW/zL0VgbShbsCoCRXtL1aj1AmbI5qbREnNA=", "ALHoFt+4OaizHdzlGWPzUhExpayhz8s9IEkvn6T/K4o=", "DNqjpjeugexfxrT1krXgT3/Y8fZ7kV1/y5XJxb89fHM=", "Ef7Vuec2Vik4pXGq1sG/mHiVvSXVPvtek6iVidY40Ps=", "DQa5A49dBBqe3RFLPWNGrV4R2IF9+j50A0+4L8+8hjI=", "IvebPZ30JW/INfI9XhbI+WPrD4DXa5DEevRjt+5Jry8=", "K7Ls10vjyEfH3xShyDk3+LJKO6J0SVmi83M91Mt3fms=", "EL0dYRcH6+SoLSypYuAFS7K3Yx3oXjRo+vAFre3CuTE=", "L0A1/bFiLSPRucuC2mT59wcdCXMs8XpTzoQuqkLzZcQ=", "D6fYwX+nAYrRTwieuFZLyafBV3ALvQfDpkuiWLjnkg0=", "C4ypNoi/t8GuNlrrNEYwwZ0PHnS2Zt7CsAQ29Ja8xdY=", "ENaFYUqZpAVBPjVZ2CYXUgWgP//ZsDfO2QvvCvDbGnI=", "Bo4WLGoCyu4CHW9EYftOHKHWCSqF2QBEw+sU4HxOSoM=", "L21qDE7iEpZJb2mpZcuP4jm5HqgXZ8uCBkqKpeJ7zFY=", "DGpDmu2OyGtbpfKkoEX68v5Iu0Qtn3UhvvSY0FfCE3w=", "HmsNS4jjk6nZFcATtP2lp8O1iYcsBt/dogfh1mQari0=", "GyEW+KfeaYHplCVEbBtyDLRJVd1L1G/MbFIjYOHGvYs=", "BQE/AMhnc945wBujzO6lwM2w2ILxmVafqzfEQOJajlY=", "CD1DDEiexoTBZN/b/FoFVt2Qq7sRqLoQN7kufDzkLNM=", "Gw36XC8PpzmwOwv/QGFsm1qyRsKWlEc9biO6XF3ZgoY=", "BVP9zqFJjyipxKWG1HsCl7I35ZwsDnA0RZ95y6SykEU=", "FkwnLELh+Qe6n8evYuWp3INunnEk6sxtvFz+7jt05eE=", "Lu7pSTgrdCKaOl+GQgxZa4IkIg7pwdCTz5ZcIAPHc9s=", "Gqe4mdtCi2SfoeRnJYGQnxWgkcMBxSfsSlTDwJPtYAM=", "KERmcJJWUVfyqIoFWEUK3MOI5hSNJBfKw9/5Xr1wcwM=", "JHwNhljGpX7Egq3F6e5rtnlI2Wx4GtmDEeJ5uB9n7zU=", "IWIaOzxkiZkbAA0e/NxpsKVA0JaASX1h6WKE5mjJq60=", "La6qsSWf9lltCe5LVnzaZKsPuIoxeDJm5dFASBGOYvk=", "GQbK/n309Kg1mkgYpO1bZ2nK2gouBG4tYTi/j4RAn00=", "AMKttRYAu6kvxT3CFl+A9wU6E1C+UPYmjb4YsQ66KzE=", "JrKFFpIlZY+MzDBAzYXDzh9Efkfut76OO23zjfPUS8s=", "HCt+LbVk7vCQncd1NgSkzF1F1kM1XjxgMh0kqA7WzK0=", "Ldo+n8CdLC5tUqdr2oTfEG7SNv+VbxJ6gE/HAlv83fg=", "EZGbj0eX4O6J8F4EKPV4M9i150EEgUpqtmTeikWIfvY=", "EnuywehVKUBYID3npz8FXG9CYBokdbHXX5OVmTraex8=", "LFkxjPQyuOSZqZoIY8kU6MeDaiOzG8dYAoGC+DKD9hs=", "E7JGd+aK37hz7Q8jsAJbtXR6X8dENTAl0hKNRHAXrH4=", "Jij+JrTSvF+OkGefeYzZ3lpHvS8EhlFLbbTHDPPCR8M=", "I3zRYKHWrjDvIMk0dsnODWBmwOelq9Jh+qpLzM6v6rs=", "HhrVhKtnXVtaSu08pbgE1iwpczV0y5ya2iV32Ha5nCQ=", "D77XMaghdN576eBHmFZzWAq2zEGUiTiEyfUeoR/+j1g=", "C0QcjxQjoppxsdyxb9rQMW1TNKKY/USAEl5ghdz/EHg=", "IU5XOmxX/32jlsCqFe+qIfwJMMWZhM+cjHTa3jr5YfU=", "G25DZFduM6PPVL8hwQqRxI9+3b2RBrUFlkro4LSKXb4=", "LLYNwwqvw6mfH0Oes0w46KerJl3kb0UAPPJgDzpGGaU=", "CBwLXFZxHlQb3qwVCwZEp87iVRAqRiLdmQ80ENFoU8Y=", "GSD4R66Dlpr1vjlaRZg4mEoNt3MQssjFM+tgKQgyFEQ=", "G9FMtbCVDTtHg8U9LHM6KubpFOxgFVFwORKLFUdGrvc=", "LKFnAOZxNL4O7zKfVh+wV4Z6sMZqf6Ha1s1g6zwNMvo=", "I6S9a+9/TSHCYZJHVUckVmP73TolGvyidjbtHe3pU2U=", "AJAgTL5VCjbxHJ0SsqVqauc5nP/LwWgtdknN+hK1s6I=", "GumUVtDosjhRalIGdVnlmSB9ooXQN77Vx0jzmm+UoEs=", "LBizoPxL81vrmkAGSmnH2Xbv9FuuLBaRAFy4NawH9E8=", "LcqUS5EBHqnyJP5eBhLsICHi4xHfrY2NUjdrYN0pY68=", "LqkM5/NMhkWWYX/sVitM2foKy3EWFlWVetRhXr30ZFo=", "B9Khb615XzgmeZmnDr3ZsrJN6FqtEsq+EIVcK9cb2i8=", "I2RBX8hk30w0Go5CZ6Hz6DLqUUOk4mhuDYRAwET/hiw=", "L1yIuWrthUzABJqbpHamumF4nlaSzy19jZp8x7nQy7E=", "KZAqrr8+OPDvOcN9615PsPMvzyO3RRGmIUaz95wl9u8=", "DhkOBX688CzgNg92/Vsnmk/iuoBkbtacx9VoQR6By1E=", "Iwl7gsDHXlPLgISGnlFAC/+eHw11tSUumIq+NWJwL38=", "MBgOF1MLhgkBsf3K8jsu+8E+vUlXTmmqbfFZ1KnchVM=", "EbpgWVmvtd6S0KDPaJRbXmYKWebJ3S7kg4qeUt03oJ4=", "Gfi+6zYpyhdyDoMmnAECeCMaMwMZvqvnk+mvQVGKNMo=", "J485iXzINhAzDbJl9vlZ7Jg/oTg4uoj3aq0DTC+QFRs=", "I0nKvag64r9VhC5yuASzZDWkngsvhQHwCFZgXiTew4I=", "ByebdfenwSEAXDtit9GdrKtuFUPxK9NmXDGBjF8seqE=", "AGpJzsBQDAWb9hlw06A8TsoHnzvqdr22UsnBPrOlfyY=", "AId9wptQQBlkRIVXZnDzjKUxSWlbWqzFxNUBCOJoMQk=", "KUlKSZ/XzE40cwxIsipimyTXSnKDAGlvUjvvrYoyn3c=", "BiCGo6JPPdByGbOJdcRRtIQJ40M+yobAgyBwyC9tuqA=", "KwDTnu4rQQanDqYYTZXcGZkaD8IcRycXdAwydqmpBRw=", "JceI3t7jazgZJVA9wb/IHwmHY2S3ZJifhrmpZCyS7Os=", "CjOdfDOZ6wCQ+cqIcZb1Xlkn3ehoLDf8noUAXQyhTl0=", "AQ/d1NYo7sxrtV7E7VY8nJ+9du9FxZHCIeCLZvRMlXU=", "CMrX8J/NbQp2OxU6a6E9CeT7kQ6Yp0VwcJXEKsMvfNU=", "K6jPOgcTjAhkMmPi1O3PmkpHMov9oTft1BFboLMnTXg=", "KAxarbkvGGPAqyDKFLAbACAbId+3HB7TKVmyEt3o6K8=", "JDxDvmJYhb+6V1S+/9uMTicYvRrji6w5tmiDogMkVH0=", "H7in25bYgHW3qzbnFmlWixqIwLzFcqsceAMDxWnkEIo=", "D3rfaifrl50KFHtBclUFjj3TmfJU4dFXHlpgJdhdWT8=", "Kpwgv7AjTdIZrFkz52FgQP+Y1vCZtTzp27dreiHGVek=", "LbEaddhkmSpt9Wy7HrVp2jaSf0M2Lpg94St2YaqR9GU=", "Kc1j71f/iXrFt987qO1y1Dok/xigPKpNmfHlMZDNI5o=", "FNBSGTLoc7bbheajqrABRpoWjpeO60wak4YZDddO3nE=", "Amo+g0BUy0c2cj0dFaJBhp+PI0ddN35p5KNzFonN7RY=", "CL2Cd0WejgqDWe5TI1QbzBRlsnuWhfzw135Kpz9KXqI=", "GfahtagCK9Ek0mKndJliERTIexvcjorHFfDZBrX1cfA=", "H5lHfbUDGwunI7HAxtFW/ojq943gkkHx9Z4INPkcCBc=", "B6h+2tUGfzYd87dk7zf8MRdeAX2WNaZijO+RWPY9RLM=", "Jk/hYcmKLARRS5LyC3XCEiOywiZV6P4vduTOjSVjkQ0=", "Jby6g5FZVL/Go/5bzPbsVmiOwgnPH5dqSEVNxt7QeZw=", "J0KoLEGuL/aOUkgDpD44fkJelDooR/1ykifNAbcH3P8=", "CkvKIp65zqln21+GUPOpITp+q6BmRSnsSMtIFqMvPkA=", "Fi279y8x4q9ajGKXXWrdDddHqGgXvtCdaQ0glawfMCo=", "HZDTqXBcWpoeBsd3yRWNeGA61PmxDO9BqtK4AI2Gv8U=", "LpfaEI5BkgxxUH0//EGY9OQD/AgOMZO2NHHoFtOqZVw=", "K+p8/P9Gy3mCjRvVvE0Yo3V2W9aSeSi8/76iru5FRRk=", "Ll5U4PxkLYoKId9IMQ/onT7Lgb0tVksrEtN+pBzmY3Q=", "LfSkS+XvwMYcSWqMtyPp+v19yoXvnFulLHGnj/KlnZo=", "HdqcYIM7UmdsyUduy8s07n9bdZ/A+CKfHWReOAc/4FE=", "L5Hu4FT6UUMh3ArKIf8lr3OByj9O8JovonNVxPvYhss=", "CUMnp5ci7hFqr4GWxIRORC5/NkROqcgWlIQQ/xEeNQM=", "Dg3jKevAE2hGcapo8PXFamWjx+MbNK8o1C59tgay7Es=", "C/wb2uo5l+Y9tj6U1DB06jedXV+WFu3Z8ZwXh+SHWTc=", "LXQlbUcOj4k/WmoScjfCRQLJ4QVnuJL3cUmD0ULQB7Q=", "EIUjBipRqLQo7sKmYoS+vQfcHu6QT0NHCD/REgZJ1hY=", "DFqAXS7H5rMgHklUGE3dx6k9OfwiH9hnSzO2jWXKnkg=", "FyoGIVZz4MBDLJiszhxCbP7WQIUBl+cv6EizPvvIgIo=", "D2XQP8zHU36x9P1sXNBfsEtAOW6ZMoqenzRMXb0qLps=", "IMMK09a1cld6hzOZYJPVuTn7gPLnyqU/DMlnwzTc1vw=", "A3P+veECYP78bOlnCRSpzsXCBaddI972LiL78xph3qM=", "IzS6wpuS23acBjCLeHlDN1un5FYP23Qaplad6NFkF9s=", "Cj4gyKYci/rsvWXkOxOlk4KwITWM2/epmAXWWCL0N7o=", "AOp4umVSiscDXgb72b5jpQ4Mr40GKPM8eyKdCTGqbwU=", "DRaC+gqSS5s1ERiPvI8h38b5747qGJFgfyKx+RZyBNg=", "KESo77hTsttjSjzzbOfP3DMefzKwA11nBd7BVLgktM8=", "KipXRmH5OebGpJ+QEHorVKAAICL5Y8IMG/h1PIJrrb8=", "Ec9i7gbkq5JsSC81Ulpd0wCiWb6tTNj7lJbKBqrJBlo=", "KQRcf6nHP8Wx4TSZ0XGhbzdryLgS8mVJCLXs0rgmF2k=", "BX5EN3ZC1PPHwWJd7C8/TSLpFcfpBVKHmvAW96FmXyE=", "JYxGQKwdqZW9BSX6kWLXyzpdmyZ9BEqMPDxDEOaJcf0=", "CV7m/1Vo+lNQktdMFjEeR3t8Yrq1/VhbfU8b9lq0zGw=", "CAaVEIjW+DYxo3GUhib2ZiWADVth7upj0NU/HEauTiE=", "LoysX+L3CwJthPOfG8gPPr/yCTYlodRNjJSYoxcu4vw=", "ESquPYAyroDf4CenCWHATRfJlgmjjCpuamCevTEqEUo=", "B/G9KJqu4fTCgyvNiHRjQ9ISi5gm8Y/0egLGBOBLJW8=", "Ag+yUfKUrR/D1VPPncUyzyEF0otBnLM3m+VPaDhNNlY=", "CnYwnvTzWg2ULSrbQAQhAxF/ipL4+iJxPlyPRjCjOv8=", "AuM4puJ2OU5iCFUTfSPYbnO2qcRHE1Q+bvDKNzAytmI=", "ESd8Ah9LsFZhEqYtApifMGvj1qYaVdbCvzK5stbrSI4=", "DkFvWXeYwkKBPQfwL6P1r9PNI+7ovsBczzIoDS6vDoU=", "EkboCh6Q2vj1DI5woZcyKcHAR2omLfeRNgh7OyUjJac=", "Auf1asUwAq/t3S7PSSULUjTUDtJZJM4E2lL7E9gZfbQ=", "Czg/RgtxPRrywnIe+G3bnul7TVEoGZPtt3RyrO5VKCI=", "AUxGtKPyW4Wi0Qhc/agSyK5VhmALR2rPXmthRatEnFI=", "C6OpXTwos5LzlXVpF522NVk6n+XqqqZBAlnK56ZqtjU=", "ArvSrTELu10lRjKIcsVLZOJasF40d+BM4fAwIe8xuQs=", "HPBjf/Kr1ypMXYskr5mY/CnV8vpiq0eRTfFOiXRn0KM=", "JjrN9F0HnUOxQ2Yl2cMinljYLa86QL+J4mcv9nhbpYA=", "KBHrl6YA8TkSNI9OmvR9MNvggFDqCDcBDhdOw/Os24Q=", "FeaBlgg2hRsVyOmJbpHWX/sbwkd5TFkA5oroLxz3Mq0=", "Ghv117c9bLPdsPzRBlUGdM+LSSqGRA+QmUVDRx1VRAU=", "CRN+hzZJKvxtcU2FTsG9jA/mPUAproQObKBfs6izYkM=", "EAdaAjbjxpOOis81dZ+MGchjAmC9jlhxbt6pcOwCulg=", "EmNEtBy0z92dePkS4C7kcFnAkVn5fEKUPF0rc1tnac8=", "BHKprH9mAIgQiaF18yh//cAf7leAo44eCIsG8EcCTE8=", "DlKxqNxmAUoUr0gLgMiz/ZlZJjPu7Wz5UG5PbKm7uMY=", "GQ4wfmYmrHlu18lpMoANPxVcqJ2EwDkrtIpgsAmGdUA=", "GQF1KSE+HLMxodB2vjJUyO5dnqQAXpOVcG6g+RhJE4Q=", "GInez61WyxSm4pKAkVUKRQT7q81xqfTjiVNnrcz+x2c=", "FLN5i7J3E7P5L7CGSSNnM1QkxW4Oe9msObVYX7GNAGc=", "IX+qC3hmxmCnAP2vPvBDis9E/HPLfqvF/BkLZMqXBW0=", "K/Rly1Jx/lYxIbuQh3qCHVKfyBX87jckdOwCzzmPm7g=", "Bqg7bzNBWTTMR8lSt5EcV0DY1W3mo0g33PgpK6gjgR0=", "JrxLcVLslZZ94YFi2gQAorNpyRCIg1ZZ2pV9HOK0nno=", "DZvDY5qx6aUCNMENcEHqIiC758lBYxiPqx955lbROxg=", "ExUvBxTt6Xu67zop1E+0Qa7oGNrATxHk5cak3DHIyzw=", "GvwSmmdLpKx1Ut/q2a6NLVhNx+Si/yzOXTtvE1DgjSc=", "KEmLBF3RubVuVYBl4NcQBnX6FihKwM7RBI4HwoChdF0=", "E/i69u/JQpTIKCn1naKshhkbAxu+Ky/jMs0wLNXZRsU=", "KwMU7s/PYa19TG2Me5Xsf8mez4pkjCHiP8XxlGQy95A=", "K9AjKfVz0FvRTrWXH45t+UOOireLLTemjdsahF1M3a0=", "LxIe6kYuLb4lMYQDDEwaWf1Q+rGsXEnr9iHzI0fbwMo=", "CxHKFlc221P//XLg2Tmxb9W94HoDZ427b+EwLf86vi8=", "JE2dm5vb8KYiGT31tT5TOuFGrv+7lYFcFN1ENA4ZK5w=", "At/4NH5kwJZs0yfEMdQrv6jkPtZdWNRS0khvKv+0/Po=", "IjYpkbq+1Zxd6dn9lqM5rJiBgbJWvxrsUqPQy4lS9xc=", "C13coEz2YhpvIrlLkDlaWPqPHPKW/lvrQEnHVl9PKlA=", "A7PtxrN0TPBXiy7EDROpnevbbnGXPgpA0mW5mlTWMQ4=", "Ld/Zpd1tqpBRd5Egyxf/kEbt5dqiS1wzNo+4S1W+440=", "LpKPJYVk8RvXIVa2J/A3S/ilV8SfiFmKyUAifKL1mDM=", "D5cLTihOlal5CUWaNKA7kNyXA7JPnPBftSUMGiSGEHE=", "AnqALq8vna/khF+bMJB/2zn92cRMXRgWEPVYgrezgd0=", "BKx7wDGCvoApqEQO+HWiSKSAmF5pP9Tq65JjfHPonjE=", "B18xka+9IdUUl6JsUkZl3nQxVxIfCTwSDZPhgFgur4w=", "C9O+khMSH3ecKysKAkvoK1GOG7wTSmX0QMRHap6vWF0=", "DJvOlfLVln07WPk9fgPJMXCRfqU7X4sn3HCh+qtHTN0=", "HjsE3uauZjVyLjVGVfYDLRpcoubXr6DHewvhkvTwxvI=", "DB/DO5MZXyqsA/5u7z5BEHhMfEgyLjDuUcvXj2zp2Ts=", "KrYEJn2uEklFUOHvJzcI3RHBdmZ3D/DMfAd8k1vyr4o=", "HGmYX/eFWVGaAFLqBeYI41ys5i237Mu87FWvPbkVZGg=", "FjNPzUISVjmM3u4IqTRaUn3stxoB60NST4092w2yTUg=", "B++N12ZRUvhdAJOc+6vP434rHvineoRWiu/gHx6bXqk=", "DcxCbciL3sjChI8tiKIAVxuKASzQhw/G6guYFJT1gng="],
      M: [["DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Ky/18nUxtvPWqF114+CPOi8NrDaApsJtVey/gDyoBWk=", "C2WISc5iC77v8jO30SJYAV6p+HpTkPVhSYHrbky0pfo=", "EYEy+8HNg/lRZ8tEc9VMa9LEF+J4Ll7+oW5y1HtItw8=", "C1lEdo1hwbNWKldJ9PBsTdCFu1Yrg41+LvFKIf31JMA=", "KwTW/7r3FEAS2SxcYhKAPAtbzA17GVC4idH6bz5WRFo=", "Kb4qQoNK4y3jMg+w7ka0wQKj0a5ExdzhUv3qtUUMnEQ=", "GUb+neCpQ9WnFurAhWHNkfkDH+yC2pq3KIPHshixHrc=", "GvPKYkClWrpV345Jg1uS+hfjmtVwHvcPgUQQn4lL8dA=", "CB9YqRpODRAOA2n92BoZADU0L9BnfuG/UhXkf45YwsM=", "IqhSr5BoCoypaItx7SfBV9ArQGvWx/2BIdfHeTrSMF0=", "Cye6gqD/uYNomBc2rpJ6IngomFwAw+XfjBJ2sQAQiaE=", "BLRlJiB+3HCg0jyEOLxJo2VjVVLe4kBmGize75ZvIPY="], ["LYxwA1cxrZ77qSghqIEZ9rgYOjYr5kFympPWoyfAOAk=", "Ce80kq0Z3R0L++sZEzCogO55M8nTs2u1+gIoO65dYF4=", "FFjeUWpTQZDFVQxqG+069TXDiyQuuSkTcwluxg45wfE=", "E27yUVlV/2YZSY+sWUJIFhifiWrA7Wm1mFTRBd9HxLQ=", "GMv94M0hwYN5ei8IlZSoHNgo87B0I3HtAuuD+wBk3UM=", "InV9qegiNFKXvQYKP3G7HnDOl3BJw5MjUDVnfoQ1cxQ=", "FiKAUSXd80TBjjUdEegikWGLl1girQyQPvvq2lpR1E8=", "KXZdjPd2GaWAZY0Sf7b6pE1scKD01l26qWB1S0GV2f4=", "K7C2sI/BvREHDtxC8j6Ae4LouI73A1Xfx04Jan/zgcs=", "BJUedHt65rmdklAQjF0rcBgak/8dS/cjeB4bk4Apgnw=", "F3gLlGnoHKcMfLtDR+f7QMY+9o893lHQTLR7O4P8KZ4=", "GRPVHZxx0EK/v2Sdnm5upf3YK0/TFz/y/gK4VYJSiRI=", "Kp40KlbItkZtP+UzuJ8atEG2Lf8xU9OuZQDCw75jZeg="], ["B7YgyKeOCeSc5UeqeDqnjz5FlMSas91vYCvGwDUdgj8=", "J9a9GHA9fKkqokB20xh7bAAo0LYhPZ5dLGYRUjehkFE=", "KWnrUBbySzGszxc8ogRmjcIimEW/ZEbOoAfBEzSb1Nc=", "KcZ7zgS/0CD0/36sq2y94DSyL7hjNGdaNh8FnlA5UxE=", "EkR0sIgp2bcXxQiEvIlc0/gdUZhZ0hI116dEUNCpQns=", "LH4o9Z/oqKO7L6KyseEUzig/4iqXij359ioXHLHWXk4=", "FlwLl4tLtkap/yJaxJAFISkr5UyHmILT8R6qMQM0FIc=", "AgZhNLspnZ41nLgqg4D+tjtg5LmFnZuYcu2vkVL5LU8=", "CTcu0Yuhp3Tq/hv/be7EvAgUsImcYZb6Faes0V7MXKI=", "HjoTDoyv+bXlY+iq+EsvxzZo41HP0oz2b1AS3mE0W1g=", "JVVDoxSvxaKZFBMijHXq45i5BXayO2zYYShmXMO9lHg=", "B2VHRJ+gOEXxheYVeKWo8mg6GXM/wExzrGoLib67hFM=", "L5i/CB4Ot4+AJcA+6cGZ8ug4xR5aCu/TM+n3z7OPU0s="], ["IxmWtZJShXVWfTnQBkWoOxOSkJO7+gDWpmHkppA1HQ8=", "GT8yo/g592BJycvyQUWQaYohGOg2WDJ8QziqNkjY99c=", "Cl2mWbb8saQnPht+O1RNLL02LKxJev0AS46pIP2wS/8=", "Aqgyzu04N+dCGW4JSR/iPj9uURJuq5rOyW5xlTEC7yQ=", "CYuyxMYzTf6kdNBMsul2GGH2sYqAWKUrYZ1iJ6JiKKg=", "EBdJ+d0mBRkcGWPyVpSuJn9rRL/i0a80/vy2XpWHhLA=", "DHteCTQ9tcY8EQ0xddAbtJgpDZcbHm3A6aDp5xWDVrE=", "EWoxPQDPmdwY4h+TpbsZgBi76kt83O0+TSEJcd0KaBs=", "BATA+hvR9+BZBUy7h/a1xp0RRX5Z+QQZzkvRC7ioA98=", "DBwhavMwVMSX7wQ4H1hYIpi1QzX2Mr1irdKeCAZ6Wdk=", "EcsgVE9DQ3poin3LVzp9pPjHtENzSe7fP85DKm88FlM=", "GG8WCuhm4QxL4Op9IEzWTlczfGDECzTDo3HXU/L/ABo=", "Hh1ZIO3P6day0N2y9vdBr7BlkDQPwHsYLqfD672TOTE="], ["BOR6cuSbnFqj9p9q8i+gq2QMk/xSTdPFCEhtZvB5hSo=", "I10OcaNQ8fI9m7UYKsROyeRhXneAHlqtyrgzaq2xcSw=", "Ehl0DEJHQ9u/iWmW8O56QHa6lgpX6Ndnm4KEeSGFcNE=", "K1AfEAPieqgJ3J5c2El2o7jBacHpxjl314I/gNP4I74=", "DzTbk+qNKtfR7/httYIMx62ke9zYyC0Bgh9cIaPqIyU=", "BNAqsFgm+lC8xfmvnjlkd+aFQtB2toPuYbhYadRTWJM=", "K8yC51ORvk6pzQ+KUF+eT2hHePx6mxvOt4aLspnNIHI=", "D+KbW+rVTFu/QmuxKESikgiErER5BhAc6piImGoDCxE=", "G7IJGHCk+sA2gv5bHi61axStbkj0Z2/kFFS/7rD/1Nk=", "D1TJxSKlx04NTgxjYRp1AmV1dbepY8DnhtKnYcToRbs=", "Fg9awLJIH4AZ6V4LJkRbpk3AOkvooVRhSWJH5qwpACo=", "Lz1rjiNhFmCJUBuRR+hKtrCXkqwXpfCA11s+Mgr/yGw=", "G1m7YOmGGUmH/OoHBJi8x8k91WHOivX63nVM6sB7FwU="], ["Coy0sr8/DF2mceSPg+XBswGPDTEgCm8Z/VGV2yLu9/Q=", "HfXJ72lK/mG8JTrpCKj2rwoIzbnnip8yLCI4gyLxbCo=", "E0QxEo5f/Aq2ATbF2FGhHc3WPNzxetZP13UXcB3mdfg=", "A+pOK//gLaWXfO0fGm6FLpIavi4BXzWzbOS9AkbCzYk=", "BuA8oRRnBVIrtencc1YO7ua5tL9R1I+VP70fAG11inU=", "AUxJnuUZJbIx2hfue1WnX5b0YuQxZ17jbHvk6bBp4mA=", "BhHs0fN5oAYrBcSu2xALwBUkTGqI8WMaRWzCrMqJMMw=", "Iq83wOSojerp9/rYOBmRBzXLS0kxHgquEct1NNC87m4=", "KZ75Wu2MdUlNuC6GefvG1aPS4prs3PaXmpsnKmB91d8=", "EDzIOEvhvhCHubtHwOtgSfheBBP3tAjx3C+h5vxK+Rs=", "IGz0KQrJhENPp3S7D4kBojOQVjK3k8gLHVmWbpanODI=", "Ddhdzwj9ONIvMW2R2BLLKohDCHda+p9mfGyoCVQ5fIY=", "JM4Ky1ItpSfT6rcoZc8HPZVLq77TzRcGqmnXZ+mv580="], ["GLuwArRvLl/sKxIPr4eCLKjnes6U4DqrXBbEuTFzncg=", "HbICHso6NiSn1FuxbPSkTir0+uDcKAAw5+vlU5T2nYw=", "CXxhM66o/kjzpfxBa99eRtBd4HI7xJ5Tufteg9NQwpU=", "FQ756TKnS43r9nAIBkEzmxJoT/WjA7L7fB2NVvVqth8=", "Ejf0TwNrLaAGepSUczTjr6KsTPEAmJZ2b1sZHN4oSXI=", "LZ6pnS0jcygmbVndfgGLvWvMeUHZ/18HoXuvAJn2FNI=", "BHf5UeGfUxuENK11W2eD1htnnvu4f9lW45TbnENOI1I=", "HYuLp3LEzacujvmxnEJNVdVyUbJHxjK+olUnGvz8cLY=", "IGqi824ysrBta+SK1JPTVMp0aHU/Um5r2CVJ/DbNQQk=", "KNqTCazKED7PGd9ypyITTVMLrmxmDbPDZNDrsgDCrqo=", "AblDWFXWzEM5JA6fo4GcL/QgmA1s8Ucht15Msf5X4Rg=", "I4gy5kMVjpZom1gDsLd2AbWb37SSYROjRV8f9N9uK0Y=", "C0O4+sxDz8BntVE6vM6EZQS5OVzcFN+WhhpSilKuLsU="], ["Ar+uGwVO8ukk11qKASg9opEDxXutEp7IOWzidLpFJN8=", "GkaiZpGEHCYQmjKuB+tYSmuK9lcnPNxNihEt6gvMhc8=", "EH2geE37MU2ChZvkTTe00rY0XBdLkWUcZcmESWgqUgQ=", "K0WzviZ0/YIFFqzWzGGDxPrg9+36mvzQLf7szQK/7UY=", "IILpEDzEUkWSQokRFScxKGD25+6UV48BGPSpIND41SU=", "MDqeIoVdldB+gXLzoFNtS5UUL5YrAGqKsJ57tjNehIc=", "KWNRQxPwRvhE+VD/6oD15bQktwfxZZlmLlouNmjL5fs=", "BLf40dXsi/aJrfEtZWuU4VsLIpwWOMnEdX+vDRj6ZDM=", "JZVHFotksqIolBpULzlKJpnAgcFJRj3Cw9If2LLk8xw=", "J5Gd0vnT3J/L2hojuVzyPjYw5v1SEPrKas9GKbiOX/E=", "K5I35ZQeFlfvpQe4ksO43Vf8jVKHbstZndXhBStrHy8=", "IC445mmINhnsvGpqRTaLm5o+mrZ+/vUPiW3+SLeNPaw=", "JidY+z4HaTaZX/MUDvfRsKHg/kJApQdH4sPBINl386w="], ["BtEBsZR30WJ7lUJYG/DN+rOLBc3v3LgZZcW+ANeA8ZI=", "DK6AzAWu22bW5kmwV9vFrpdZ2l17Q9XiWkAOH5Lp0ao=", "EiVrO5nTHYo3KYb5XWbME53SPpNUh9oms+JJ6ny/ka4=", "I4ll1liWevorzlD/GMu+U1MnxlsLduUNowc53tJetJI=", "I6bhQyhOjyOMS2Mq14rOWw3NlKiXywXR4pe0iA50M7I=", "JOE6OPBNXg/Atrbg94KmpSOos7ASciS44jdRucufiWA=", "CQENc2d2IKrhsPqAI/8cgSMTrpw79DBm6mC8GrR3p/g=", "CkHlpEId79Xtes/UhAE5WkCaZ8Pt9MFozjNo7ZRCEtc=", "L8fRfzqa/B3iia0PlBJq7sg0SYEgYpzIfEWGxid4AHU=", "H4bj6dFH7WBMceH7bvhFnPxAABu0/FzMJmFmmxVavro=", "GC2Pke4qmiYhWzXzwO7PjsXMNgEkz2uQPnDKgxJpddw=", "Bn0rYS119Pl0MS0Erg/vQ6NbYO8FTA9HUwLFX8EL2rA=", "Dqs/JkF+a1PFMgct6S1Kp4zN8dqRZgpGGrsPn9e9zX8="], ["GK9h9hhP+F8QTCvvF5s+xaXSQt++vo4nopGPYg6KW+g=", "GVBXrxMZ4k3xuQXG4uspVwA8/DSwAcDlS53PLqXfa+k=", "HZUuv/y+3SYDbFSh6KKCj+MgrfB6KG5/LCEbR/bD7oY=", "A3C3V6xs3UZhDuwMItQ6VD1eBIJXe73BTnEJAwe19po=", "IuB2o6puv+mWugaL9b/7F/pyQzjNZ/Z+olMwGVxigXI=", "EmhR8+rcAYMoinUBU5EKQeB0s1RPBhClEnOtNpi+DLk=", "A2H0CCt1puvSP5pucwnYxOdSAVnaI0Qe3WMaasFMIM0=", "Gr6LrbLRI1O5u5gVIIapQht87hd2FzDiWsKE1rHtezc=", "FafmSlpG9Zc+ToKiY++QXtZPGCsgQbqgChNZ5+nF7ac=", "DhVOvVDbPChk2+HtcrCBYhCFG4bDU2ktF0TLM3K/py0=", "JVKNXTHb13z6bnsYR/joTIHB7VuuKlHJ5APMdUxUu1U=", "IfDGuJb7FCINgRRBYpx4+Ojid0YCYiDjMczriaDuiaM=", "IK3esq/SDnUqOdLyHr3cJ3J3OwYpItyN07oGiDbbpGQ="], ["EeOnwtX3Q3G+sYjG49ehSzMSivjuModUbRLXd3zvcMs=", "LU01rNnyij5r/WAUcpSCk8Hk8ITHFN2xoHXy6unOIbM=", "JjCbUstV9upakDCwE3j2XS5repYZkm2bGx4hy6Afp+E=", "KqhMHvnoSKZPdIuA4nndz/hx6cTD4vr6r3kVmwtOQBg=", "L+MbDfBPJ2pSW2GazEpbo+tY2MMhxiOQ/rqwXs28eY0=", "J8G0Br0Z7RPVM1ULi2IRhrH9R/Zx5mBGgDF+ZjiwkeE=", "DOvPMJdbNyZ67fUh7ivHU8NCTcS27fOYT7Aq4erUTa8=", "KRwNpzHAFsDWxMdThwMKliv3ous14VqsAvrfUwJ4o9E=", "EhbwVgfgMuSQOKwUWBAOiayFGaWjzuRUWwiFDYvxYOA=", "Ga5llFodvtOWXy3jo5/y1Uqx3uDzM7iPtJ7bP8mseJk=", "L5lq5iDQCj1OVe96bOC2gTiPG3/zh1tyWupuuQOdiyU=", "LIJe5WHEq2oiMxF3mZyJgG+8NFGDh+gHwgw1lzm6nrY=", "B1SUdDbDze0ppgyeiYI3whg6Sdt+cOfrc677S1xpMkY="], ["LeXWp6JzQ90EIqxxuNQJtDzLC2cul4+P39IU9NeGZAQ=", "Al6y7YTFIKuhZOM/A1O1ExiGwPvRjlVpVUFRLexWOgw=", "ChJSXweBMiNx/XCwkozObi6qpnuJcNzfMZ3yXoAZpt4=", "G79D3bWgsNKEWSOxzhKCkjWcuzE8WHb7tS9eax/LcDE=", "I+jDYGrugY0q+oxEZdXsucRb3njdgZwPNaYgWTwfQuY=", "FYiA9a25bdE5gSi5/zOfPYJ9pkY4kcyhKcASwGsWsyE=", "I6GsBzUZRql0yIQekgkqT/xq78f6mI48H358h+FRKpA=", "A0xGD/8ohi73pQmhdQom7R5ZYPy1jE9Ix9Jnx35Y3WY=", "Ij2xjzHIXpjh3XtyRd3doP+OMZvX0aZ/28fu9W1meBg=", "AJm5fIeM41yVfQG0PasH+AA+LDebQcphpuVqkgT7Frw=", "LCsefHD+wvWMoBvvWsN8u5RxrnkUvwjffkfdjjvDzpM=", "BGJfIljt8CYroGR8rkJqSG/IAdwLWdIOwPTQr4y9I84=", "I5ymGm735QGBCqiatJltvqj71H/S96LJaoGOk6PDjIk="], ["Iny0O5gYkk8qJYiWSgrX3fo99iKEtLOxAZmlAe2XBiI=", "FsfFxhYe2jLGW7NHZVrKqAvMmL/AI/SrEvWyqJnzfj0=", "J+N8aKAVMPCSzTfEom3s4nN4aNwsNRlDXh8suI8Htiw=", "Gd0cbUUpgkitSZUx8zzgAlBUWNdheOyiYpjjmmL7lQE=", "IV9VY0ZOLfao2qjDRHakZeTun6CtAfxDmbZJsuB9Fnk=", "APNtFm6ZE5ub/BrDJwo9mMSvqBv5dDYHb1c4PaUENqU=", "Ht18ferySeD9P1doqpLp2tZBGLSRvM4SNAxG8hCwfO0=", "COF0Gpf2NI7W1o9Le8bsiy2/A/QmdpzHec7uS6G+sD8=", "L0qoZB6kE1Ax9Nl6ei9nmoy8pWK6aqVOrn0y/30E29I=", "IaCkPIjOJu/7+LmtZoBWtbA2LlAJ89gAM9tHMij7f8g=", "Axs2nQEfIZ5Kj7Id+TUoeNk/+ANbzag0w9zEHDwt+F0=", "AgpyCDV5BZy2WZUtPyoB7ZDSEAInW16hHyCcdjuqhFc=", "GfEXcQSbW+gbQ8qB42EfQQikudwwzRIkQfdDGcOtzek="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon12.js
var require_poseidon12 = __commonJS({
  "../node_modules/poseidon-lite/poseidon12.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon12 = poseidon122;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__12());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon122(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/13.js
var require__13 = __commonJS({
  "../node_modules/poseidon-lite/constants/13.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["MEwprrbxhzhHh5V20w8fboo85BCCwVx2Mt+SDW21Fk0=", "K3OA2LJbymSbP4u9CoauQXEJBpvicGb0b90cfIfUxAw=", "BMdyAOVJSxy4o9M09prluvp+h3W6GSTlY+/lke/zAvc=", "BsC4lm35MIDDrBV2SG5hqw0CdjeqxBuzXkgr+hDjT8U=", "JMc/QlkDkE9A2/9ZAiXyUc4ZgKWlzi0HrkNuHQkHeNc=", "I99vb0RIJzx0XOU9XXq7XSbEZySljWiETTw+5F6bkks=", "HcGxrDiSgBiOk3VmBxuEv4GJuVXQV5tt5eqKUTa8Luk=", "J/ccXKd0ziACi4FA8URHIEORfNSRnP9k2EinRb1WkYA=", "IrLuU7MCui6Da5h4PhXrbenRWnLMfKo3TmG1HdDS4sc=", "JU2FBl+HJx6G17QR1qzCgPntJXwJjJ/bBKLKTffH12Y=", "KGIHk/N4v+iB4Ji9LsYr60aJnzelSr0FPPsLO7jV51Q=", "LBnybQg2Y1sE84+jDuXGSPoOobIC6whGghrNPGmc8GE=", "D57Yfpobp+58KL/XrDj/O6EISfsE0zIomLqf4BBPtEU=", "DR3v9CJjt8rooSOhZBtyWAFUdhYauIHh3CDhZbPwRXk=", "BbJ14HqeI/R3qfDiKUInKGUo3dptx0SE125qqnFNtaQ=", "G8JVBSrtnc43dlvFqV3neSc6lvS/QBNUJYiwl4Pqf6A=", "DsIobLqZmE04w9+4DMCK6/eaSvjsuY/8U+xKvveepug=", "GwW+9x/DlvG+l8gsCC0vek2LMuzzDBmHVAkFDjrTWIY=", "Fuk8fu0NwABpWNGCTQ3HQLXPuMmG//zxth0QDynraag=", "GsSevADjdPxkfGWYHdk624mY1hKLkXpiNapWI+pGEoI=", "Bye+u4RfbUdE093xLCqvbywqWOBFcf8Xrf2QXNV8YPM=", "HVZZvk+p5xPT5CjCnTT5/6muDyrKNHRUOiDWJUsvAZk=", "ExbkcLVPDc1TEbapMDR7/9uDOQHgJEipQZ8Sf4ZC/Xc=", "H3GCkG4YS9iFlMolif+EnrLaowyvjL9SE+0/pHR+RYE=", "ExlxTs3H5rqyt89X2LCICUoAPy1PiO2w0L2EQbTO8xg=", "CIwQb9rrMjp2+UoJEq3RtmviFghKQuFL7FlySOAX2I4=", "D7irW9xhaNGth2kiVkHQtetP+PtcYJxmHajug+oqBIg=", "Ld7d5ASFjE8JfGyN22agA4FjXE8VUBTTASrR2veQNF4=", "EtkrfHqIyYafefxh5OocHIgbsTIMC3eHxkN+IwtY7aY=", "IcrVIcGr7EZL6Zp38MD3kqWq76EEu3wDa2yKQFBQqk0=", "EQR/un3ipVPD7FUlF2gxRABwjmF8m9/zOklmPKLesxk=", "KQRSn0/AKRRJw68Y/J9UcirSx1FiDY9uDh8qE4LKxac=", "Eh/mLFP2hHWqLMvijViqdKKr67JlhCLNbxRcJmLMlqA=", "DdseTqem82cFbu2s95O5Sl0336Ag5lXpBxEwbccULRk=", "JotEh18Z/1ihXdhPS7ZOqLrMffwE0a2GGRD7mUKjce0=", "CcF4KEJd5ek8nuuC0yX3cJNd6MJFhFkbdEgIMWWQMZs=", "IwFE0pRfFHU3a95+u0N81zWNUBuclU9n4GwKbpCrPEQ=", "BYUaiEfN+8gCiJreNESldyY9k3GLIDigWwW76JCpiJE=", "KbWtLGKClUzjVqp8MQheuRtsxJ7GvxOUIsOfpU7/ALQ=", "Jl+hg4ri9tWRuPM963jT18nKFAFBcP9lBhi2AUQ76RY=", "HofLhliMab9Pnt7TPwPUl8FdYbDkjdBFlN8zbYeTojs=", "JFlPEVBj+aBjzLGlgOjp8EJSbIzPbkvypqJzr+oWfwY=", "HQUrDdVxXIiRlP4X6Ddjym97x5ogTExABzvIpRb5NMg=", "Hnu2keZ0EKJFB92aXMMjwPhvl7hCvBPs512IyADnYEk=", "K3VY0Iq4cNMLGGY++ccQ+XzkxJRU00xL9xS+iGW4DHY=", "FP6iP9f63VPJ+vQ+HjDB5CZmjQCA5wY4n11E+NDNtEg=", "DY+F/2t5fpoo9KumAZM3QS16d4w7fX/+BtTiCGRJGt0=", "FdcssSqObTycgA+W/a1RzyRSd2jJ0TNMYICE1aByjMQ=", "JfdeNhwmSVvZ5RRorqFo+fCXh05WLXJ/AwqM9djFhVo=", "KGI6aIaGchzPztpsnXhoMuAmVIWbgVDiHPA2/MFUGSw=", "ADHnB2ZKQyvmOZNMKy2qV1dQzEH4QEWdhabW19iru+0=", "D9VV1VE7jGlF+Xu286XTsf8qwtgadhLxLu3v0iK+4aY=", "Kh/hF1O3qNCXcDi+EnajVYV6sgy+RISwixUKRsjjktU=", "IueXDaEAjbV3K8+6Geq0U4VTjiVF/CDZUKYPhA2XAqU=", "FUH+yFCQsH2IVkAuoiThuy2Kip0RkrmhPeyBuPaWgrI=", "F8N750YixgjnAwEJLtxp69GdF76aDUS8eJRKMJ8iHNU=", "JgMsl7u7XJIOEghZKk9SRrEdTXjWOqGVzjhihb0NtNw=", "LmLXPMis5bwS9eWqI2zLcwgw/aYtbdk1xqPEIP2cQOs=", "LwJqgrFYcjhZeLSca2tIdlnk9cw5Tebm7kq6JqEE4ik=", "JdKXYcweSbZhSsQpRE4ZwHC2okupDnrHJmcsfPw2MnA=", "G6l7SGBeF1Tn4X0a9+5JbndQ++YWXKuhUpyJzGfyeRE=", "J15a7SVGQgLxtxOFK0cwJ1sc6SFT0CUGPgoV+gd7UcA=", "KzY+Rdo/83EyQwQJyACOxoWyLr/oQ4320+1KeHp2LmU=", "EK2j2SL5lNiK/MQM2d35la4hGZYd9rHa6622ImL0Pyo=", "CjntFkKG45sBKC1lGc0CIRHb0P+D7xVWJppjoBAIM0E=", "HDfWCFeTowxH2SyvZ3wM4MrM0pgrz/GAeKRrEUjPYxA=", "JVLK7oBGmdTWynW+9KWPdAj5fqMHtEilxA0xEphWImM=", "ByUpkD9aVWyMUeFDyXhTVAqVa9O5UCsaQ/39u8ZqWyw=", "GpYR3msYiUrZZ6RPEp9Ir4Lv8r0P5AsLvuY64HvIq3Y=", "CgFMvt+TviqSS5qjJT6PgyhFqFYtRZrJMryDHgQlJM4=", "CGQtkUclVyu/5+t/e0XZF7LR3r08RNNjbL1mF8Epsk0=", "CfgTjPA/3WvREBScaNzk3tjUUgboAW/H085uK2b3Q6w=", "GvquJgnOfRXHrkdQl2doeljdwhFTZxUdbzjS7jNzAW8=", "Hic5KcJ8o/b+BPu0iPu8HZRUMfppIHEA28zb4mEPyYQ=", "A0X+C4/RMLjjo7I3mss073P+7RQbgGwHRiGk4FHBSak=", "F6OpintwpEWjrvMBY16OXosnfuoXcwYeucU2Tx92dzs=", "CxJMmrTe9xnklhmuptN0uyvdhC1bi4TrVWZTNMFDkXA=", "IKy3ppz87NYHM0Jq5adHLbm4huLxE2mqnw+ScEQMwc4=", "E3rGiniJOqRXzjr3n4SlLtMd90B8X+tatLTZqrPUecg=", "KCLl6CQ8IO3uOMsUK+Pn1+AF0nT8NGUi9THBzgsFYOQ=", "GcU75rcMtceePkIJaLRUiz7lXc3g7SgHWUWyro8jMe4=", "JwqRySXt5FwAi9vLFi2dUycXV3oB7pSOCpkT7NLvnSs=", "Kco+aBHYA3owkpaj+tzXNx6Hq+IerLN8j0rHyY8dSKY=", "L76DKHTmoESk5e4bY/19okkQ7WheHdEkRLgMlflZuRs=", "KxC5Q7xCsTBq48DJYvrBR/FY2eKt/tB59Ki3y4NumY0=", "BpJzU86X8aLHW1eqQtdCl0pg3LsTWG+ZmeUtQre8pDM=", "CIGf7gHJt/jx2Yf8PyzHDeeFSs5t4HKLp6DnpdchkX8=", "BVBKFngunJXRhwFm1uyFPc0oWdDUyvptMgcJBp4iE0A=", "CmycPGnlWECJMSQIheTt+R5USCMKoCCllyHpTuGcSxA=", "FjiiRbY1Rukx7nltOtf4/bH3NzFpgzqm3dTKDTSZaT0=", "ErWrPUUHHYRTm+dyyfRoyM1u/vFRo/WytSuGxHyUgNo=", "L50Ex6r4VBgLfJlDqGq3ZvHGH4Jlv/uEdyY7WZmaTuQ=", "EXCaJCZX4Xcn8kKcZzbtG/bHVtu6iZqk6uXstshFVi0=", "ApZo9fXEoyRrw6hvIhMvwM/GJWZvmeZA3qDh2nqbVnA=", "K2E9SAT+q95H2nHybhPWFCjyeBuc4f3giJAt7PUV8yI=", "JfOJLrV4YvAIdVfqDpOGfSvMAiD32ivAc8onbXUK2Do=", "IQP3pSFPQOL/ZEdFg8zgkU0umk78Ai8Hzly9eR9UMnE=", "FKhxEHKorrTjxyv3aFEg8jJbZPkG4sHuMfavrWyBUTg=", "LYIAEQx0DdUb0i9CZ8q5eTTlrbhtrxwvBAXCeBvafr8=", "BbKZ5AUTG7VjEHI5bFtXy4f1DQcPGWUzvD8FBsj/IYs=", "JZXk4iP4Q90BtVDFUyz9xRkx/cNAoRytEBn94IQ87Ic=", "G6krx48m3zFI2pIMe0CE8BXuFkZipauzyUrPNveKlX4=", "CSyu/e1fgEkkzPHmNUPWHf1XAAehBSq7dkmDIzzGPks=", "HA363j7D1FEZI4x1xwC4JqQi7gL0VDHsEQRJ8fdWdbc=", "HaBerEZ06ZuVRodkYTaayiDiieZ9BSzOEPv0GLCgRCs=", "BQhpKMvQ1JQDv0rW9MYmy9SMHZx6IpVzBvC93OnakZs=", "HTL3Hk3Zk4WikpoCuSkSCFFztIJUjhvAbvs62W+jEXA=", "GP6JRcCB8amTfiA1lXjL2xk0OtCsUENfJtyBk83q2/Y=", "DCehRp18G7YMaSNYeoG/oFF1h6Ow0zVoJqRcOsiv1NQ=", "GgvNsnS61U4cPsoeThTq7Tva+whGtP20HAy8bvpJAMc=", "GMFaO/6A5Ig2AWZCiN9iFxr+rX3K7sD72Vmz58ao92g=", "I68q3fzs2M9AO+6MTcqB+3yXj68UfJkPJg8RWy07yPU=", "GG77NaayPUBu/GI34XXa4C3pxE5dwol9VjPP/1cck5s=", "CrFx6VxgXG1TYf/THnb/jk64L/LaVtZZxmkC6dOSh50=", "EiYibVVB5ghvt3WEN4fKU326WpaEuofsDeWSz9IOiLA=", "JGx35tKFijSjyinTWXYRrfMopKIhH3TV/QTc7KmDDI4=", "DXSVzfgHrD1hhMGN2ehYslD7s3wRop5ikcElQNXivaY=", "IwhT7EftctH//4Or7wO1/3Z48uEEuSltjSlDAUDolwI=", "FB2GCIxjFs4Nw6VglhpQ8Hact94hZokHfPZcYkXudqk=", "H9T9pXHqXbUL+aN1t+g+4Y2+3DeRSwZkYBSlAJKoHiY=", "BZfMFDKpc9g4lvq+mR58KlNwRfmorGEqx2aje8r5ydo=", "FtyTI5t06riYI6r9kTl96npcL+oH4S5WKv4qlOfzPLo=", "Fdc+7ubUgQKggYz+cKsPKt2S67fI2EeSKq7wIFQoBBQ=", "InyDMOLXp96Qfuvp6C9yZMFt6X+yP0vA1WOnh0vL9Xg=", "G5Uvp7DZ3I6fPFKpV0aPSSoqrUXLLUpQN6R0prMjGv4=", "Lf4ZK73l2nXBdawyZYV7zpBap+zFha0g9Jl/Z6UELkQ=", "GM4bWL0/K8VUt0bpDxiKZwX4Qr4p+FtqZyMJkJ/sIVY=", "FG1fODsu+5li53OvpLCGwWSwqlMG5Td0XxVoCoX2obQ=", "BRMAgq6ncgOrHigZ1HBPDp1yPQbEV5sbz/e55wzxyyY=", "ASLSwcSFUK3myI00mNe6g5XUR3YxnxJkjBTKy62mzDA=", "Ar4N/CqewoRKWFY/jwEVlE6aOaj7zPw9eYMPSklKQpw=", "AjYrg+zVrIapCFM6h2yhc4yERCWCL9D14GRsll6UzZk=", "JzQ6DKg7fL9M14/sfCv71kUoWfsPe1wU9iORqPu4E/c=", "JfZuTDGq09Po+JQDAqdx3ncMhVy3/OP7FwFiRJlQBZw=", "FygTWGEmHj8ZlbB4rwoPEjbrRX/GIBxazrjJP4che2M=", "FTtNdWVMX+YE+i/Ja7tqDvEkDIKB+MC2QyvxpSn1Dro=", "HvKU/nl1aPVSU8L5PEoyq2k3oTMrscQSuMwV50s7jvg=", "Kl8wLEmoyP1uTc4eJlvG7A7vNMxGE2+cymZCc6w9jqo=", "IyFaFBNjNgaoyPIrpkK8qo+1WffNMiywiq55ZzW9UnA=", "Eynw1vqdgOU27RIIWNrm5RN2Ykx9quO6eXlaVSWmxIQ=", "JmTpqY+vdOFBaqZFtkWJ3eyzvCyF+aiWiK99tw7GAoU=", "MF2UD92lJfSeI1rm0l+dRHHjlue8OhM67s4eVu6qc4I=", "EnGvb9AEuGdITeod1Dy7XVjXMdrG3o2/uzAmwXMx6po=", "Ix/Z4RqmiOMxJzGmoCfswTMVFtANfjB4jGNSGqkyYlE=", "Dhn8uGOCi6udFS4FBM4J+mH6o+CiPAJIDvb4ZmVdV14=", "EwMGVBdrBq/LYRIDojaaRC6GOzwNHIi4nNTH/fT57wY=", "H81guaUix0BXY7zJVGLXfAo2tOlSxGG7Luvx6EKFRVk=", "G8HMTxIuyhe5UUUcdzRy8KP2pXwYUxnOHS3g0Zuh8ho=", "AsAxhWPb+ZrmNrwBK/MQF1yrt2Y/Kmdkz8PWfRhqIfc=", "HLsaKkkLYRdvkEW0sLYOwD8SsVswVVo5Mqo8H/6ms7c=", "AGeW8Q6bpmnf+Ujob9Ri3FzZW6gHmwLCsrStHmL6N94=", "B+ao/kpDl7pwkhXFqycvPFQUZcvY5DZT3OL1nN743uU=", "KE4JPJhWV76+lr1nESDJKZW9vSyZHN1JCTCcw3IrXtM=", "DSBx2t/Sac6odAzAKZMjy24aZL8SPf4a+YoXh6bKPAQ=", "GUW29bnPlLldk0H7tri0t7RhuWOGwenPPHxOOy8INVA=", "FXammEClDkflq08hqznVMZADhZTsWZcAQV4SxGkrRng=", "HZ90hBlOkEOVjW7nyKVSwNJflYfmbNiZ0s8CkXlkFnU=", "FQYAPzm75BLhoKTypX2ynimvKrYQBjgvah1Ou4w5Q3s=", "IkX3ft+es+ItZHhTaYvoong/rPkrFLg5LnNopFnaYtU=", "GJfnTG8b8xOQYOuASblTKP/06duSYOraHlU0bbvezjs=", "IJ/4YIUnPmgM7ZV9Dk4WXHi9lnCiSWnoOuiw2xJjjDo=", "BiLunSOwxhsFhFsjhT5A2I1zWTq4Uei+OzOMp86M9a8=", "KuBlnp50mkfj4NJEhizPX9b9bhrwsoiUtOxylAd0vZs=", "AsMXFOLGfARUVGU/G9+kfbA5KEOdROMhIyAj/00voPo=", "HEqCeHS7SkVdeQzXqGZyY0A4uvsS07iVTPOj+qh/+uE=", "E02n4ZJD7rCOD35o6rp2QemOw1+Kt38TTdEKityEma8=", "FfZTaeURVe1CoNUMNHnXuIDP+H6BdlqXzorSi53mcl8=", "EIHcrhD9f+wSozKKYGeMLXYBM4YM8w9eRaD/9bqV+xQ=", "KCBrXNRM23vxd6Lj1grjheOrLHyO+dqps9rjX7uZJng=", "Bdk1Uwar6noUlLSHXwb6n4H0+wuFUkqmGwOqBTuvQ6o=", "CGmuhoModCM4OiMXzlj8+IQzu1RmddaXHKKSoPAKrzM=", "CwfYVmrGHfnC+r6NQGLY/ka93RXQhzSk7t65HcmHOJE=", "Al3VepvuWjDvEpHwrKddVfINEfjg8uaXBAE4MPJsIrU=", "HJ4u7n15t54ZoB9hfzfrj9++BCDzxf7FhJH/E2tFny0=", "GgU3Mc3fvy1Y1yO6XVD4dBJXVciywjaxGi+uPrFdFU0=", "EJ3WfwbEkJQDlt9kEGNvZTXqfyuOubr447464doSs3Q=", "G46Tmjz7dgVqR5PoWxtC/TgFmFbBpDSufskL4EB/gP8=", "G7RUmHMZFwH8dDl0ZaxImsWt+ZBxD5rln8doXEifLjE=", "DZcaMHZRU0F8tkgpjjkvT2He/KBqBbTkI7l+RcjOFek=", "LFj3IxZC6G24LcNKEazg6Hwk+aG7jpzZJuBz90qWo+U=", "F5fTfX7jXlDaxiq0NDTTwQPHRCsAiR3T+L8NrX1/RKQ=", "FHsc8LRO+wjwO8SSSHe/Ue9fekzxXhrcVyU6M/AGxgc=", "CXZnoDXjswRwKZWo5RohKBORP7lMjbiGxsT63VJht0Q=", "AdZTrpbcV8G/7HzEJbMo5PSn4BdiG29SgYjS+8WshGA=", "GznNnxEziDZMd/dVvx+kK3BocNYdvcQWg48mRZ9KJjA=", "Jcve/YJknOUZaItOT4UzQcEeFOyoO3DGvSfv2oY1KTE=", "BCKJ9RnFx+InKLdMqSr6jOiQztwHpwVH/bj7fkZ8hGY=", "HPlm6U8dfGlhP+GHHycE0jnhgEF53H7RMB2tsOEO5yg=", "KATSVbVxuas/VAEbaf78B3Lbd/Upzv4n6wrPHkNzURw=", "KydLI7ZtnVYdBXvbetOKljQblTlDpLs2GsV/gWtEq5g=", "FjcFe6fF37p43Y44ouOopBQd3C37QVmJI/ZrXviGy3E=", "HlXN5YZL6l1g18HtNOYDbAB9dtkdCSnoHhkp9jBTIrY=", "FpDplKoUiZ2T/yGrmP/K6Wktfj8AyiWGhCaMBrfIBjI=", "J99DD4VAkv6pGgjrfkBXA4JWOxbHjBK46Dnn5+PXI/M=", "Jiwnhlxsyykg16jX7xgRNs1fd4jK56ub4jx0mNI9ng8=", "FNjU7GVQBCjrrESyZ7Mi5B1cvcq8J37Nw87ng4sId6E=", "HSdmVYGVo64wMbv9MCQ5sIzIXWCLvjbm2Mmu6i6gtm0=", "EcK+ivMTFpUV9KhV0NcegOthZ7uI01M7cPgY6wyUXMg=", "IMlpL0o/rf0K49L3p46jAKRBdpbjIVA7C2rq665+RUk=", "KM1OLnwfPsM0PkT2yxeGwl3/I97LeFMCgg0Nvu0zArw=", "EfNN2XM709CCLHY13JdrLML2cH6vQXhWHdxdT1Y6J+Q=", "AtbHkJZVgqBfjjq/0eBp5BSh312GpS2w+1fekgHZuWQ=", "MFAl4cA6qhqbQxI/ufNTmcbtzzDf9zmDIKeL2pILG6k=", "H5qRaRpKOqdlxzA/S3q4zKzU2DT1yOaAaHBT6se4YyM=", "A/E04Bja2LgMy43XgMgI0/ux6yIiw2SgoxKQSCWdKdw=", "LZzcOzyiRnwjfe5mbze34txY28WeC+R3JIlh79Z4KyA=", "D0N9jzzE3Eh+iXGwOKETJLephMhcv2mNKCOyw7cfSFs=", "EkE6pj3gOMwEJ7GsvSTuLObNGbNxScbKdhUE/B45kE8=", "HkLMCytL9YAXPfrGO6YhDRleB4iARnza2HdJgKGGdW8=", "CNYrTs41SZtg0b7KTyOpw9Ob1nmN2YGPlanwLnB1esU=", "KSSYhCKzzxPumMUT9P4knDw/uUSAUoi1CGTCbC45iHU=", "Cnl+kBb49SeGBX8bKjz1D+IPH82YNGqVjkvBxQ7otoU=", "Bj2CIrryVNrRZn9r2yTIYOoXozEhdjkI6KsenD6kj6g=", "GBXY6c3LnDt9GXWciYsHijPfo6OPPCLx/0VQNjYDy7Y=", "EAVB4+qL9ZIetmlRlDtftEUwB2Mw0ZxszEnV/t74FYk=", "E+1KD31aJsBSZlNfjuseymPjRv1+8g24jt0dGwWsH+w=", "IX+0mmAdB6bnchIgdPe64Rb+IGExWWbuOeezy09R4ts=", "HrkIDg97tvAbOwX5xgxi4L+naCdunlnurrY7vwb14Sc=", "AhHQLp1FPehCxuJ0TVzmVXo/qmRny5I3VdVDq/0wIJQ=", "DL1ffLYJx+Wtzbsl9vDLdNpiakJUr6QJudLBlhtN1LU=", "E+xtBVAlj6kQV7DcBtjwCkfUDAWqEk3NESTFn04iY1o=", "EljKHnfPnWeougLR9mW7QFs4hVOlzZ1sQwN9CCSsS9I=", "KMWngkORtSnprbBi05g4Ju4ee7vc8gUKokBFstWs+O8=", "Gc9zpUqx8uRCHPiKy6RHdt4XQaCzF8teHiAS31coe64=", "MBFFXRHEoUM+ap9uqaxVlSfXoXoBkWhpcbeDajFwcxo=", "F7c3OsXD8+INcbNJr/RJxz1B808dAIFA7VgpyyZVSOc=", "IEqWNTU4/gjagHKz/ZfWSyReBk2byQHwwKGO+6rgmVw=", "KFpymH0PDyKMxpTRDe+F0iujWOdEglUiGC2q+xT0wlg=", "JHS7n5H29UAfq7zg8QL5dM3QYaXlengtWyOc9/iSWpY=", "G0WEHqtSpRBaqkLPf22KzsXAbqiosO4T7WkUdwVM9aQ=", "CjpLi8d9RYyOsmNS6StoXgBgKmjdSp8TysEOiM6XLOk=", "LKtMNZ2JCh3sGIHSTf2/+XghgANzWhA5LL9gSdXNOCs=", "DQ/QaU2md/magJ94XuHvBndRMiwoYTkpqPtySdPmeH0=", "KeTgnZdbUCAcQKi7l1DTHzDKNgHhENF7shxf+GByelA=", "EV7+ePiypy6KITwksfXG7+gPY0cEOeZ4r3IaDwQiE3A=", "KbPM3xUEKFg/6qKEYc8f8aTkmqkvkMb3IO4vqJtYkDE=", "LrdUmQ9ol1hn416ViUNkFLiKJUQL3AiGYj8aVo9RYHc=", "CYkzW8/UECDKhWzPYa9QMh6x0hzgTRWB2wxiBD+iCbY=", "IIqYV7hZw/YgFpBXUZBQcZBDstQsZp/9S2gaHlIVkVA=", "Dn+EaRhPQanuxpkEWSIbERsBxdwPrQmpheMVduAABBA=", "Jdr6e8a+Ch+f0hy9caZOVr+kb8fyeyp7E1kEoPdnLmw=", "A9otwgSdB8TRhaFqKYAPeFvPYijMiR8c4wFW+zF1yho=", "BHtf8ZqXNAL0Yh5R/zFGUTUFaH9yDi7AgLbkTEaIHTo=", "KZwB1glaHWYNTgAaaCH4AOUO+hNmwlZW0UTOw7ApTGU=", "FmLX+gB+ox6J5pLr9SJ5Ti0QbNhE+PDdXQtfWXWeRNY=", "AP5M0GUJDf70DQdAOb0GIoySXHe87UslxuspheptpeY=", "KC5J4xTDG20zf0F+naVKx7aG+mz8H66LWCczU75lhng=", "DmzXUlN6kYC4b8u1uoVxgUx3gLLkhml7GKjcOhWdn78=", "DMcM8oZvEjos3yy56KI4gTsBEt42T94FUtOAYjIL2l4=", "GspRuUx0eYUNP2fQenEPVe14TUy7728EVCK4C0OOXQc=", "JnChzAkL+x2xbFKMGtUUeLWNtmrbHru8v+afWuR8qEQ=", "FEtWbTZn+vDq4+qcjA5L5VOnkXu2+MRZOANmETJ1WbI=", "J7AmT/WU/s4izSbmCSVC7SiFGnXR8VMQpAkb2/7Tb80=", "H2CKiOjS3Fu2zJG+L0dOrEw6ZZ4L3Tc/nG395Nagrdc=", "Ei0FCdJQjGDooqaoP3cPJ9JKpSikBCfbBpCT/o54oGQ=", "AV6jd39h3S+NSGCyAtP07drQ9qWsUIlwW+DtYBNf2Yg=", "Dw8caeUrHkENSaRpOe7b1IEpgIkj758F3gJfmTdBpLU=", "FtvZY/oZj8mjwjDKq0WAs00lxiI9YRNRyWV3AuUWhUU=", "AdhWU76sYWCfCNSpiLhcWBpbV0wmmCHmaygVsxUhKFw=", "Cf8J8MyaU8h4AoZSmVILhjn1m2pcrwbLgMyA/pYJUPM=", "BlCuiHVLTtSNNSCqd3H0/57kAoC4XZ52fT5TztNq4NM=", "CRdBsqQl1aVrL5FLz8p2meOFxzS7pgbTlCYbY2exAmM=", "LvSBCLvEx7Z/HQDgReswkG7eADKpg45oBnWA8iwVo4Y=", "Eb2oRqXlhov/9l6TMeC+x2SnLbpVSaxmF5pFJPvW46s=", "K2s7yULaaEpYEkeNzuXyvAE4OVy70KBaxrBLbp3wgm4=", "DhF/xYl6ptfOICWldMjk8WUf2V/x5jwy3x+tQfKDBHM=", "DShcZFZbxQKs2up0eVoKZKRqFIuQTvmGp66zqebcVtI=", "CYFBpXyca3LqoLzcmPIDNZE3+6G94nr6lBgddVgjxyM=", "HRE8//LN8Sz4NTcBUh/5IOjRBIn0d9V1NrWcYAgSoCM=", "E7+YOHlErtPiaNCtFbKBqCsoD9kkuNTrQ6BbI+Dzbr0=", "HIQkmozs0TYaS2a20ZEWNa3mQPSYGs4s3Eu4WucZkXM=", "GIj4aa3fKpEjC+oDk+yAt8+0pMvnoqBJ90QB50ef5Ko=", "JXNB2GMiVddvKc17M9iQsMVLDpe4zWiXiGtuOJqNIwU=", "Hfm7+0msyZxDIDQDyZkjpv2ci/f5qmy7kb0akapNfpI=", "KiiM5Lj+0blMvTetyLb4FKMlT+sNC8aHITwQd2SIGdQ=", "I9unyZbeazwifCOnB4UHn9QjKhfxnQMR1WE5XZk6S64=", "GZIx7fIoeL+IDfMFQS/9ijzmpVWx5+gcfDxyqgKzWMw=", "LMPZ0RB+el+mqpSXmUMWKUx9MYmNgOzDt4JXPYGTKHM=", "GEfo5o1MGD8wlIiN6hUAemvGs12ved7Mnwzoi4jcPGU=", "HqeR29mqo9KtVuWQqnNEUU5FaE6jIB3Ju6IAoEbDuJY=", "Cjjp5HEt4xelM+PJKdbOdJMH6ISRN+Pr+ipNC/bAgM8=", "At5CZHwCMveHDEEllrrOvaCL8n/hJOFvFYXPqdH2G9s=", "IIx6f029TALRG7aECj/ZareP+WI80KOePfOszAP7Xcs=", "Dd0i0seiJ5hwcYdhWpH5Ewpm0sDX16AV/cNaaN6444g=", "KpCy1YamwEE2LPJmfRMf58QmB1ATwzkjsMYuP/pzYMs=", "KYqy41Pfa6YoQhlIoClSsq/aaMRjv6NgUKfBQYoCZkM=", "CNptLKYZgpZygJgTphzFMV8CRg2LF1fcAU+Ue3KeWAM=", "Blycdhn3GM3tGnhPA3P//qEUFwMQsxBeJiju1iGiVhw=", "Jc64v9oBEyNk8HBEwzr8TRR1Xt0b1lAlKMNnSXwuHbM=", "AvrMeRc6oHBZNXnWSw81hB9lzaO0fErk5nUROp6rojE=", "CS8VetEj5l2ZFASicEqRsjvOv94UKh4g2I4T6P3Fmd8=", "Lkfqjhu3cpLAbsCQKcHRJFlJ/jneh/QQEzhBfdP3K/M=", "Hjk2lBk5O4/6OJo0OSRJ2VOpktevsLo0r48hWfE5ZTY=", "Cs5GrQ38wxYhGlB75OhxJ7IYChayRE+okXRZlhwDBZA=", "LiX+fBnYSKx4CvkSqkKZzVmlXPZ5Yl//6cFNT7mU7t8=", "AdjTHZf7Xr6Qwlqz+0M/ioK6n7tEQ6+Dx1SdK3aIwX4=", "ApVhyAyVJ65IpfYF22HmmwiS5DdB8n44cV6+FFVHdsI=", "GRBMyOOadxVqVa6suQBYpCsAHnQpjegfLRjMYXdg2wg=", "HLLhOIYFvdZYOqE6bq6y/J7N4TN63g5W8+Lj4/geJfg=", "Fkt8Doez43zQJ2UuL+84sIl2da00uqx6d3p4pZKGYPo=", "A6LFxS80udYDrdtjI4NHwgTpux5l/tKy2M0JQozLBgE=", "FDEHvvpIA7GgQmnQMCM/aNknZ2gyARx1Erv+KyLDV4U=", "BgbOJqGjt9i8+t8A8w1P8N/L/rFDfqD7NfkYUQscN8g=", "JM8TN7Q8gn6pdjPjh8eUjfkKPEKo9/J6HvpeB5A2+YI=", "HCYCiz/3q3PdLMmd8Kw8quSp+BvkCRrH+uV2fkQ22oc=", "Hg5NJD3ZgsYRY31RD0P/ModOpmgMiCRqBTEh+g4wKo8=", "AEBPORgWVzBuHq6KzVECEjiXE2mGBrPIxlaybNTyu3M=", "ETiqJOQryIOZPUxfbreFqMWct7sSABhrUZOvvhwq5Hg=", "I7Em/N5QLfVpoDb51l5lGAXKBAsOAXNVxqqZDh9I6KY=", "AudhI5o4mlMUk/ppncyz2GElUzpGCGiK0vFZJ43KyQg=", "GOCHBZ3g6q2148XEuSec123D9tig0GBVixnDz97WptI=", "JzZPJ3cPWLbbo9PxZm5QSqRehnswruWRRKU8soFSiWU=", "D+AM4WeeOqX01re4Do4gIrwvgEXrQ6T4/p8EzU6u6U4=", "Gv7elIn1q5RnHSDRq0mlrgrupPop047iEuCpyvr13gU=", "L9sNfnVzHtqT/JMejY9Zdi4MvhW89uCj7h2g6JlUalA=", "C3R5KtTlYk+Uza9SKNj3t2QedZol704w6ALjB2rQkAc=", "BAeVCyRTyXRYC5ujFK69SdiQUqHY6ypgb620BS8tnd0=", "KbjR7IiPJ921L442bLB6OCmoIb/VcpbfZntJaZ4klZM=", "JdDCCpAGu6vU9RYPqeq8ZIx+QVUqB2K101DMFR1sQCA=", "LzVAreLlfybONqzbu0GYzwoX/PBMbJJrwyg6EaZh31E=", "FGlf+NogkE4H/vVFqxBP3w3Lr1tpo7g0hQSKAFflgxI=", "FsfyhTGn3GdOjyQONddbCMZnOZWka6dGvHGPQpEv9po=", "LiwmFva8AgG+kIlByDw43Xz3nEeAX/k71kDrxVLEygo=", "BjvKLYkQChECG+w58RWQ7AhIggbgFiVwYcz7xhM1cGA=", "D4xQq6OZMQ8wwgHXvmmQp7UGHVLh3sXftZ9p7JPXr58=", "ELZDVCGi7bRNgEWlEzKwUPE34ms31CmNzDMhMiW/FFI=", "DaIaCOX3OiMblOINxRPyaBuxWtEvM7rj1fcaTA7Ml/w=", "I4+tH2lg1hmUfVCdl+/ds+LvPjDxiiZkLigoZKfdtCY=", "DrjBfu0uMwMpQBtbpZZrus4RXMyJNCOybyJPuirxF58=", "GX8SAKKef881N7GHVU3Ont0iXLvYAxEgxX/amiotbNc=", "AH5Z75onMiD7ZwnsjRuDEGmzIWnKqY5/Mq/6cytVuCc=", "CHmPQSzirsqlenN4KVVuXAW+qCLOgfhW+cwJXGumV0c=", "LEP4rcwrOeJiwlLDMJ5f+9btc2vA7R5FlzqvUvfgBj8=", "CMHQF7zx7dU+Td3AEPm5l596DQ3D/tNNu9iw78SdGWw=", "Ie0vF5e1GDonGSV/8+sdO/qJbmEZkp396A+jQZdiciI=", "KGiGtgZ9YnlHiR5ls2+NS3yBxccWrZX/ROkRsDQesMQ=", "HArjiliwzT5d+WyOX65fmxm3rF3Lg57cQhOl+pbJX2A=", "BUPyhrglTtw/UyO/bKRwq1Dq/0anXgluqaIVUIqk98w=", "Jbza+01bbddz17PPy6QPjMjbdnW8VB0YfCFTf8LAo0A=", "KKgQcYJutPFmFZZDBqp7Gt3QM25hWLMN7Cdz3E/npmI=", "CyrpLZbRk35dG0LIMDiCVN0n5g1RL+jEF7hfyoybA6Y=", "Ea6zQP/okIi5ik/ucgRYXX24Qj/dsbQQZLeFqtCih4o=", "FBV+LasEII7uFtqmfzVb2wT3AUA208dYbL3MbBQwuC0=", "FUA1eZJS9dM16xWva++eEtbzfjO0PUwJnonlGKQYfEI=", "FF7kiFKBMwslUGh1ZpD4rzxS/+OgPG9TwQGoQafsr4M=", "CMYLBAAG6sjwGTB6/esAqpMUu4MGuPpg+MFDTADSyos=", "Hgqr4APoNJAJWKE7R5FKxM+PiVCcABx/j/76SZ8xgA8=", "EqDRMvYVt4sHd6qRNuZ5uN0zQTcCf/5euygSFOu+SoM=", "A6d0jFkat6kdjyWFngbnfGbMAIjyurBOkZUIkz6E2Ys=", "KBWn1Cjxq/ot3XtnwukW48yLLWlQc59RRoToEV8O8Pw=", "Kk5p1nORBS+OLZ8Jzwmw8lJhv8CwqiCLFTLi6yVzJTs=", "KPQrtegGl1TXK5fywIuorOou8cIbOq1kLFywTctM7m0=", "IPtywDLyzbPKrn/4SjiSCXBTrYwu4Jf85rJHRQ7MOYc=", "E2nJWvOOxRTdpn7Z6m6w4Y4OETf3DoaVKON77Rh2hZ0=", "HAIfJEnyXccYZz6pPmUgErFJWP2bAmjDD+95NCm3Pio=", "CuOBXqJq9DwzVn5B+D4wXQF5oFn4miKOgk2xaExUlk4=", "Bb0r4xVlhlAzR1sOVTvi9HwPexIW9zk2VGkXT2f4+YI=", "I2jaKGal3RfRh1ZPvCpP/oaCr+cUCp2VcEbCvaGg9mk=", "ITeEv/bvHUTQjLfDNgJmakACrq5JHdWBlrC8nXMeO/o=", "HcgkvjNioYTujtl0iTM60sXsisgPwpyxo/6Tck61mF0=", "JVsqHCAqKFElCrnR9BQn6AMbY3ruKf9qQdLxbiNeXS0=", "DHr2YT4ewuAGeA/vdLN6EDnf4px29jdMgRypI5YvHeI=", "AVU2hh2HR0KQTLw1ambzAzpDMG5nwzebPDl7jXOXlxM=", "JUnHv61FyxkxCCjMvTtbgDJYk/P1N79pALN9lswQJis=", "F4U+aivpK3UhSWBek4xZ7VuYpRteKY2/Cj9C54XsYRw=", "IvuRh+gm+8NAVhVbZCQdGVoCHBmbzpYUDEWgZrdV7QQ=", "DgHbsC0E3tmSFRHuC0HUIqR98az6hczoQ0GzoaQVFz4=", "E+5674c/iistdhLNLOuIaU2dra03kX6NMjy/f/hdvxM=", "BnKEBaHZbn6RIQR8bp5PqRllzVabilXJisqox5kFhuA=", "G41MHZDxORmd+NoE9tCYs46PCP8IFcfFDscPDyIda4Y=", "G/UPl6KQ9T3Zk4e8nD/9/i+Hi7D/ex5HMdw4+IBtRps=", "BwhWTMbDmd4OO5bcwG74d/g5Ipqq6hUmUnuKu36KHHI=", "Bhz0wiYK/iRyCT4rGNW3pj4COg3SMy/BHLnHeSU2nhQ=", "DBAS3S9BaKTubI21x7UcjziTTp7INdD9ErrBr9I7/6k=", "AQ0seycvax0CFgvXip+/VW/KbNIce8huI6vXSXeGrSA=", "GafexoFEDalbGGZ2C7ikihe0kfcaYb1Iy37NnwzyosM=", "L+o32vfHiFWHgqLUY2vIsSoCHWgGVeFtRBlOiKKEbh0=", "CTGBMCtE37wGT+t+9HnReIxbnG528AJHvMH08o2HNk4=", "DVYvfcyLGle0fnMWwoMkcER9RrGgXRX7h9NVDVLjELQ=", "Ax12gCW2UTnepXyCNCWfqv4ooaSt1fTeCf71sMU6gAo=", "DIwlLsEEbyiOxjuiPcrGi5FHlSge4t/OXDEor8Z5k5E=", "JJkjrj2tJkcPBxxW2T6opMRdnsvDNcGDVeDIlhqPN7U=", "GP7dr8mWEezgA64G1+08p9aafM1a3ON3ue3a5d8gpno=", "AdZK/f3pm+hNN/rrN0CrSETV2xeYNG4+Ig6FQk5OAxg=", "D7jebKQz5YbHteHLCjgHaea87PeK5NnhwJh5/Z4oJHs=", "DVsXyURwUsiYovS7Ie2CfrnTbqw05Ju74YML2pNfA4s=", "Dyt9Uex+pld7LnM/A1Je8ej+xr1PJcH1eff2VbqTJ9M=", "KyPVvjkZmXZJPGRzKrZVWJ4FUyp5pRl9JOBGwoHA3R4=", "GR62oz8+gPvSJ/vcQ2+4seOqN7A2F6fIdYeiywaPsqI=", "C9GbhHkcdG/VuBD2jxDOH1FOzgCg53SVN8EIRP/KEeo=", "JakaJxSnkGD3eyUD8NMHD7270YfTTWCXrig7y/TWXAs=", "LlB6/58Agg4hdS51aQxhm4oDseJpnse8C9VQ+sn2MTs=", "CwsFHPlSbEAZYS3Q/Sr+d0qLHoKNsuQvra7W0m1R6hc=", "FWtMwEZrlT+fOJ7/mhx+Jh6QKsA0vZ0oVVnpxY61Ep8=", "AviIfcfBbBEUdRMcQJ8izasUQO6mhPt2FI+sfzOupOk=", "Hzp8Lka9T8F4bdlJ3tLi0z7l+9UxMPhyNSMCCYGDRrM=", "EQJUbxxl+zhDEVIXRhNgjf0XVkrq4XZPFXD3K79HmVA=", "AMsrZ8H0ruv1TpJ++QP8aqDmrPDUsUJwQOmBoQLRX4Q=", "FveSTCmmHReQ0j2lT6TcqvHiZORtaILIXU+9hvK5fC8=", "Gol35/n4gzIBBLzKuntpINT7Kz4V1RNBhMjAb/qcu1w=", "ADjd6TZmoG/231GFekAhi2w082jnvMUtRQS4Wp7qmZQ=", "Ca+LfsdPlnQPjtqfaepywI9eIxHnjAYzv/eIdmRtbsE=", "DwbnZD+m/QsBaQS7EjSFXa4GBEcqofnnsSsO9ZR4D1o=", "EP+w8NZZsXyrWLLnSRISpzTUW0Hdq4ib62VRjMKyo6M=", "CDk+BYG++dsnK1US09asFiiabVGn6P7o8MqFS355aMk=", "DNkZ8R45QK/Q/jt9aH7XEXtAEA+Jpguh/Hz3Q5Ys+X0=", "F2zS1d1QOa/k+cmvhPGSDefIPx1mOj3M76rDwKzvpG0=", "HM8gt53ceNxjLkHBHlN+WZtBjUy5q4inQQGiemaM1Go=", "H4y2HtOAYUEcdQrLTDE9L9Fn+63FiKFP5qMNrGcZoSo=", "LeN0TvLXEU/Wu1j7A9CWm76S+/TbSbY2oqSHZBg7Z5s=", "FS+MR+hjQ9l4AyTDewhEaBsabFt23HqjpX6VftwKr94=", "CZ5jOl9V/LgONJTCDmxgf/Ec35L0Ws1hNAEe+W4j1OA=", "GPiMfdXcUH9jJkYQ1mi42jsccENYM2cYvGjqItX3McM=", "KeObQsMsZC7zYQBFEhjaezPXy+e8WIJWGjpMLzC5DC8=", "DavmeBJR3wIwpwDvv98lsHdrW1XigWvpthTDQz6ibFs=", "CaH7SMdXXLIV6YGvr2+k4PBZSfr69+w/Hrwaay4NYf0=", "CVStDQtrnGY7GTa0MBGUqcvmd/mjjtC1RBIjNLxQnxI=", "INNAvaJxvuKfCT8qXi8ldYD313Ov4/1gBvtdnJRh0zc=", "BOF1qaVoyaNHMib79n88jb33GJGDP+tRbtjx3JUtFD0=", "Fu/FPqDJYOa7tnpJMLdxSlBNus6nhQMD1mKlYYlojJw=", "FjZCs235ybmdalNQIiE5QG/1WMSGRFpXqMIABlo/hfM=", "FohfLWfdLqprbm5KHLd4/ls40knR1mgVbAM+NvjzW84=", "IVTW8krNDNoRMm4nnun56E3bTKS8Ee/XE2rF1UVzqTM=", "Fiz5jAggX7X0oOnLdsZURbMAgAAh2x7zsteRn5wgL6A=", "Cm+2fCwPMyDiK0EktP63bOEzD4XauJxEd6zXghT0crQ=", "JgIc90oCsZLwxO53k45PRSmF8CHEabboT33z29hlNdQ=", "LIuXBMa0F2nJBZI49R+zgnqfsUa6Qk4xirNZNYuuDXc=", "KPtshDt+iSWcE+UViYBMpAoQ9bl/xBhUSbGmGmMhUY0=", "HiNMF0BYdhVOGvccLOQDMHgJlwXPy3GIZrNH2A3tCYs=", "IoNuNxYu/Ih4mtSlYV+OMuFqBfsneABkkKL6+zdDp7U=", "KKcNKv9nnfckbbpfxdjkAccmESnooZZcXF7Vfy7lp6Q=", "IKWkFsQQH7HMrLTxAeyTwIuK2fS8wM00xRjWvBNtTWI=", "CEBXo6OdyS2h89oaG+4pZ580MJYofRBE3uL+KcyIsGg=", "Dt9E2inuQYbD663RFI4QEbUIqpSlRJFfl0b3XFffd34=", "H3XzyzJaU3sRwWACySf/XYx1GJxjK/5meTJS0kIiDUs=", "AgrLaPAVvWiXed5qbHAYnkD5KaxIQ9HfHXjmzyX2dT8=", "FWwGjzLg18qqMOhuqXP37MS8LVMEmXDJVrCu2jr4iNc=", "DrXGbIYwocOxtnoofcMuuHTXuJRPfi5LbV+BupqGNR4=", "CGQyymwQPL52RJ/yes3Axy71U1s99etyjh1Mqs04Z7M=", "JZGhKhuy6FUm8rARCw/alwM3v/PEKw0OCSH88S4T6R4=", "BN3I4VIULFfHZrUMTIuu6raBNGfBy9Q65XyVsPS3TLI=", "Fr7zANh8ZYKVTwsuX7dLsEt4UrLQmvU327h/TAN9EU8=", "IrtArJUSftBdounDfxTtqSWGtQSF77YbtX57BYpcxd0=", "IVKiXjKGFuzGP59iW+StTuN6KW5aWEkm8cHmqZ0zX6c=", "G8XUG60XtE/FqmlQqmQ+3gHTc7Cu3HA8JqJ9+mM30Ew=", "GZk+I1L+kH7O+L0z5kLVSfl4RUXortUSr37qClcD6k8=", "Co4Amrgp+tNOy5hmC6BV7UbZ4ZpUV/rQ5XE0bYMgcnY=", "Dlq6o7IOvt3b3hYwJ1FK0i6otkUtHg/f5dbJLKGLzeA=", "Lew8FzEnRpiPeDsU+S/ZAPs76hN7naJB4taFjce2keQ=", "GgW3gYDzv0WZT3hEu7WfAlON06BqH0YrOoWG1FJz/84=", "FtIrh5M0RIeFQFtudOgj/SPOguaNsrOSv748p0DBQbU=", "CJB3Gs7TmYRezFuc7GSm/JJfKOOeSOoMtHPyrTi2cPA=", "JTD0AOc07YsWW1kNsWWAYMtFF4/Eo7apa99iQ3xCFaE=", "FeApDX7MVbJ19iOmNSHTl5d3RCoU8YkU0fqDYbuuxmo=", "IEf7eNSGZblsSIXlVh/YnGykQhj0qtSt8gLzKj40Nf4=", "FQUHpILJsC6ciISzOxVPTYViKGVee2TQRw7rkvBwUXs=", "JgmNuFK/2wczwHcn7pRZi1t1+WFw8s6kG1EIjU/OuLs=", "GWk5T7SmV4TDyksf2dJBZI5qpYv0Xa21hIubVa60ndE=", "LM1boETgmQLlQLxYr5mIYRlbjRuWvelvBZziFYuPTSc=", "DiQaHojBZ2ss0rSP9UpHPTtejJXaOcJOhDdedPdkDrk=", "DWT1W4SgpSSddFLLvNJle8LO3omTgBae82rPc8b7Qqo=", "J2z5gbPISFp/boqFoMN7/pSF6v/UZ5aCnNFw3x0l9d4=", "Elq3BaDzWmyecON8+Cy/0bdKR85N2MY2Ug71J8/UmW0=", "Lt8ryxgrbBZdd5RqIZpUKvyTg+mXYnGxnlhc26O0wDQ=", "AwRFk+URXIv0tCvMc3TtofM2sdAM8w0Mbg2LigLnCxc=", "LJKI0HuGR0y/JNsnt0Qh3UE7kIcM/AE/AOzA2p2IAIY=", "CAlt232sXKvdAnlOBlPe94e9y76nNmGRWyCyM7E7STg=", "LKDGXt3qZDxs3Sthd1L3HFs2MUr7VuLXczxU7X392MY=", "AHIO8Rt4aN5hclQZZVYJUeMPnqyvldoYPnk6xEBceu4=", "FXdRaCEa4slQXN085hiHgtAxZIz4EtnrorJM7KNid8A=", "Db1zWFBUeeyj/nzns8dWFQGJltAJks1DvSc2vY7g+ms=", "FRphQ6C9l2MpKmrq98CZKrZd2rXTXy5xMof71nK59uk=", "EZgwp/HhblOf2XYC3cln5BGdmkjW6EKBrQ5yE5wKVOU=", "Fm1JVfbHQi9T51AIRGK7gs5WUWHHinH2jAar/IDF9Xg=", "K/f3eRrYSObIgEETy3igptxfGpRzQQBt2/6E2/luy8M=", "CbJVDalVwnRus6ABTBFuZ7BhQCByrPLN3chK922iHMU=", "A64k5Y+Co+l/rIs5DGRDRyIyWzOMbeFqsH6oPacRW4k=", "IuqY2ydQLkFCgkozPZTil+ATR1fzFtutI3HMLwrRjSE=", "LUICC48CYX2a/QaT3YzQkADAKpSqoUs12OzYCO38FZY=", "DZSMAyjWrens/xORzJJtpzEbtLMRzYk6n+kXZAsm58E=", "HqHCyMKCSAm95j3MYvawahSf0rm9raY1pMNe3iannoI=", "LpCIcnem5ujZY3mXmMmZO0Hh1lhFwXhAvBZpw0MsZLA=", "DIUKhml9mmCdJvAqmeEWwWTz2DldO9aZ+DIfdigHcWU=", "FtiQmducMtkOZ6dDCLhciGfRzfC6PJfHo8BQMi+RIyk=", "EiuLt0obiyKcSRrTFjLajguQxm9Svhz/uh9QvXQBSK8=", "LLuy2mKpUlKD/aX8V4Lk4RwPTvVZxxV7g8WZ+lHBG9Y=", "FkTC0K85DHg1v5of7AGuCHvd8aIaPZiKdcnF2mAGrNg=", "FHzSuuLptxeWPKYjzy8rf8uVZy0FbB1z0q83LY3NbPM=", "C6pNDOYzHZK5i+ucKPavr6C5wsosGUufcKbTtijj6iU=", "BG+aSq+2VPSmuRA9IIFOSFsKAIGfIA+LL8SETu65uHE=", "Lm5IKBNJS3ei0VP4zprIT2FIceLW1kEKfp6aeGIQ6dw=", "IZrv4FML8IMziGXVnkJldZbKaM4SBn+8hFxLkGrm2PA=", "K5PutfXe+qLNzxZckdxLLGefCoJ14STZpF5O9JunhBk=", "L1JwrHWB8hhv87zFjG/L5Tw6iRKl4rUdBzsOPipeBIk=", "EM2/X5az/3GW+KbKoOh0VJMnf6ZZvMRI795ytx6DI8M=", "L9OJC4JWywYAntwcphTluJiWQUGQxKyRLd0vsKVFR+0=", "DgFYp3a65s/sWGVEJqjgh00qC1FYAIhoJijYW49ijtk=", "EdA551cwlG4bQ/9rGjbKCMxo78FjpEr7u9GBrqHj92A=", "Bx5MSPxGJXXGdGO+TeTGfBeOaQ99o6AlVfEk9yLyjAk=", "Ih0RqY7rvyruU26jLQKsGNU5rVTukXLkaiMqAQAXsqI=", "ALpOT2nDSWNoonfKNvay2OdAKVhDIZ6Qz3y6JRhzV/E=", "MAxMZITeA8s1/4WLsZn3qEpBTw9yjehHQqiHc2QtCqU=", "HFCNMUzOeMJdN8KZ7bqzDtdSThkCszW7TJOG9ZbvP3I=", "I4PqpdtPetdBijhFlSOyt5Wk8VFQW9eWkWxeBcC3tyE=", "CVAHybrOlDmU/Qqfnyvwn45XaJMlauqGlp0b0hDyJJo=", "Lr6kyUcMWXllXDEXJN9qDkUc24TLLvsFgwN0tP7pmnE=", "JLfnP2L5fBPuNwVS8Pvm7wtabmR/QtlfPGbjHgsOAiY=", "CANZn4A16miQYzdsGrms/2IgP14MG6Fey478MPwcvbo=", "KrTAqekRXMEwNTBzO+qDZU+z2KitStu8obN60h+NmzU=", "EPELDVt6IZGPhCY81krcEOVPh2etoKf7WdcZHDHWj0w=", "I47jLlym8pEQR+B5f0/SVx3NzXdagb+UV4ff+Dwfy2o=", "HO1q1bpGbz793rdJx9CT1aWiQ0jJvttRPeYEdifKLSk=", "KEKVVeNOe505sPm41osJyJy8C9Yd0wGqlR2kK3ercvI=", "GzpOPbTdZ6XfgwNbpuVa/3H1F9fmaSI4CR/9HaiaFlU=", "E8wggrxgRVHvT9AagaUiYfeXnb6g64Qpby9kFtV9Rg0=", "JjuePNjcWkQTzo6MVzqBFt5K+WQr2qo1rDQqyHBc5f4=", "GrOVIay9yIqrrVgvoiLWrfVjPLFvqFPm9O4EFN2BQ84=", "D8EzAQJwICtVCgMi5WmpZToh8DSoswWmGBnCapy1OLk=", "KRh10Ae1zdQVrLx2xpthIshqvlHBjuowE2v2ZXFYghY=", "Li+TKTRtkgqYOG8sCjZ3QOAyRoaW/NWsbizGYi7YHWs=", "Dwk7QoxiRFeM0HDKFuabNrC44qWF2r5K+Jnvp8X3qzQ=", "CFvBO2mCOTELBVAc1Zp46dHzqtFhVBvUMIDZ/IZ9gcY=", "E2IiqR8clIfz/zILnjuqUu8jJ4lfQUxNSyuMy/74LQ4=", "LpNB5arE2jmzNj3uk68EgiRLR2ed5O7LWlRlXhGEEwU=", "KJiLuYo01RlThERdds++mnzal5aT0lyvaBlzmIjP2ns=", "E7TgMX4/nMLz9J99wUyXE3JRjysFPeNXYiJe0mXNWzY=", "Ges1xwIeFOlGIl+seq4JSBVI0Oq/iTBKP2LOkVdop+k=", "HTfR4ewNfxGb0zpRFuGbB8y0Kmv3sSm/KqHcrwaQlP4=", "FlKhEks6b8ICnkPcJN4KLjBpaLEgknh+PVeO0dhR2xc=", "LYLj1iJY2xoDXmCuz5DPw1wqaKvM7oRtbzDce+ExNsc=", "Fxe/isYUarFO0y3Ho0D4vAFlve7lUiLU/A0bm46HMT8=", "L+qMonUbFlAF/FeZy5ySjT9XGf03esPVq5iM/n/NC5Y=", "ExIgICYWOFM84dsYGOru7To+VGGSXfr00a0lPQDA7ZY=", "COY7lpFvyIqrMxQPbtR3QkyvG3kqzX6kPDKEgIizW2E=", "H6rQM294pRjiIJ1+hYI75T6tUG37DrSRBmQSH02219c=", "CeY/LH+hj9tvocJjrV9ssMOedXQalL+fMsWYQ0c2kXI=", "DVgSvNOxMFHypYEWCMswlo3k+cNt18T204/Kqa694fs=", "HO9IsdYSJriYgUgVnoJvlC6TlyzjYFH1XQ3AGfnr0QY=", "IT0/SoAXhNQ5CbVHnNFZy9Youviwdc2yy+9VbcEgYeE=", "E3eISlFUTaeKILyifAM9ZmwFF59vDDtXoUSk18FU/oo=", "LCAoIGxqWOprP7i9cyk10hBDn2z+toO3+gtfLZBB+Gw=", "KRwpyCZRTSgH/mVrwurbCl8mRBGxOBsNhe4hXkgGpP0=", "LH8mfTkGnkkCWXyeM0i4SpUPkdx+7pGoBheF3gwjFyM=", "G9//9HWXM4frjNvcua3HuhyfYwAKMz1rWnfFudDvzm0=", "EIUE3mwyPXvWxqVLPHssvmfi+GOkg6/PjOxNZoSeKCI=", "FDgwdYcC2ih5GRB7eW8+LEIIU3cEs1XvbX1K87FlGcY=", "IMug9ETFS31EbpVGA0dgu8sh6U9k1rTJqrQTVto5/jQ=", "DQXxEB2omMqANCNMV8G42QqEBoz0JC06TcPsanG1apE=", "DVjJnnOW82eRuSHva2Wwb4fDkbZud0v0DaQq95No544=", "Lw01uRj7rlIhJnTSwIasNf/vKJ07/Xg+dhg48RmGYhQ=", "LPSGgnC6PCiPTeKemF0BF++PIDIjW1A5y/rPr5W59u8=", "AUze1VZJJZuSrBKL1uGxvbcRUmRMTYGMHZo6DjpG6yo=", "Dxb0lmMzQdFwnhRN4phG9/saQOQbs5CfQeeRt0l5XUk=", "AgdmCCcYBBN+DJ9owbCutXHk002jlU4H5gZw4xz01pE=", "IUFf1HJ4noDLwV+8Sl4/yWVn1VJFMEnzuooKQVjYspM=", "KNgMnWl5VkVouHdFQJ/Qwz447+BWUQh0cnys9l5/QGg=", "B/wyiCp0hMA83ToOJKv+dYfvAsHMUrEcVa47Ym+LBwE=", "LY3S76mGi6Va3nlyJvp0q4jc0M1r2UrmhfANQjg+X40=", "GphtwKnBJQN/o7MLoLtJlZ0hzrIKxdM2sJWXxCJTeuA=", "IfOSGD7tNuARuFExGvwsqsb+dszh62ykK5gTcCvwFcM=", "FNVvHOSnczPmHhDUSWRHS+x0NJ0iwgm9TB48Cj31Aio=", "IybtZTAe8cJP606WA4YMqs2cb4BoMwPK6wrX8myrCXA=", "Kj2fyrTFCLByXp+4Ug7Qa20ptSLl6K9ORia6KB7oVxg=", "Kc3P3kD2/UuEuONni1HtVGvoo6DQAlv4kjV6miN1vP4=", "Hvgr2tCbn8T32EsdNV8JMbCWyj0Nt87I4z2v8rQJOoY=", "C8/iiutzWmZKNgEgsJF2hjN0w4fWwP/+pYcLwOqHfNI=", "B/Pj67DX+2C9V2rZ58skGqMQzKDV1FAUlkGX91lL/yo=", "KsVsI607hmf7BUaTFwIwNcuHumSsBm+gNcc4N6yN8e8=", "Hi6ffjcC+oL+3bFgNrlEQu8WEcoaLxyi9HM28W24D58=", "JF1V6u2DHL6v5FrYzrT8vb/J0O+O5v8D4xBo0IMjmN4=", "HqKV3s/anApADfFEg6s9rlv0OYftkmoC3y587yu2TqQ=", "Bbv1aCSfPMrkyY4lSdveY5iCkns55PObt9BfN/avDQ4=", "HBKRqrmJPkbSdivuuxv7l0ZdAPMNps8z6GB4WHTK19k=", "F2NNHM1R+UMxUmNMNZdz/Pyfk/gPvmW6pZY3cDZG9+o=", "FPyPcjT2kSxA+Cob286T+hr40k/Per6wwtT1qY7XHCQ=", "J+/f9a1meNX8W9HacUOwdlmLkNt3dyqOnPXFKV4K97I=", "BGZExOcCJYDoPu4zDHIoRpt+yK/RVKR1ZPDMq5uomHI=", "LADUV/cuNFLIbBrjZF5kXQ/uLTT11QKtGzq00O471DE=", "A9JNfV9mjgx2MwswCz63d2etmCqHj2Q8qTWgB0KiGuU=", "A96UHfgH+xy94PiLnsibZMESUu3dzlEj0kQ/2r3+xTQ=", "E5aO51pmbvvt4tzcHN2aXhVUPL/dPQRUhuyrrTYt+C4=", "KknxHzYDDrKNuxwSPAC8EkkaRhEm7fI3HUeH2/q2kNk=", "D6aAwIZhzgZxhH61grXrswXGm2FmotPTLa3TW3PIf/8=", "BtWguk9jhAt9vu4XB3LbwGDE59p4WA9/At/428q+Kt8=", "H2JIE/9OTqVRsYp1T7CoUr5q3pGAfobKbe8jjMDyPyA=", "EEmI69ZXeDmisHoDerTSDisA2utkUeIephAosrasspY=", "BOcdy3r6LoMkh6x/E7ee7ETXeBiX6QdbkZjdqYTX9+s=", "I29rAR17lklvp7qrTF2+dDJ2vJdMDS0XqB/weaSD/yA=", "FYdmPitddA6u9Z42KS2FaGtYVAgs+QPk3kvrU0DgFdU=", "EdRYlbYjm6C/fWjtd5BQKq2OE8i0XTE+Mj4nQy4svPw=", "JTx5Np+yuxY62Ix1HoHQ7ZA+D+bxXhLA/PqaBu7BJHY=", "GJE0WLWdN9rNDcFoEaNPhEtyU+i/TX2+zr+XsFScKwE=", "CNW8oZaozrHdsWWSev/ODj5X5CsioTA5K8UiFHSSl9c=", "DfHrAitE88jzWKdCQCFAIDPrVtQ5uvygkgGkY3Eva7M=", "HsmaSj26tYFI+cwwJNoof0CD1wqRlmpcdrRrCie9ZRw=", "HO88YZxscAvSlZNwYzlVAc9OIIGCIJ9nGNV9ozoj5ms=", "KABkeKIRfdNQBxHPhD7he5cCaIRoGlvtBiHBV/eKE7I=", "H42xcYTpqjnlrAMG5HFAioMVQ0Csb5xYXtkQ0NiXrWE=", "C03XJ94GoKWUaWG29fwLzvAmP34uWCndtuSQCMvBsWs=", "IXIJ+omW2GDaofnCEOyiWA6z8c7Fqru1a9kBs9n8hxs=", "D2i1O7uLtHmNGRYI+VQoScGGl910AtsLXzAxfSF4vv4=", "Du82tqIF+76L5oFaGYPmzRRuQileykbbsxb5dr8FluY=", "DqifVJ6Jd7LKmb5S6f71cTpz5aBmY5GMg9IrzbAX8Vo=", "K7Xxgn4USF2iGDwsANYk3bwB3v+8MjWHjwegSke+0b0=", "L2MHEahLmkcDVrPPwuoLngm+Ft/Jp1CGtLWXi2no3k4=", "LRpk4EEdZmwO+fBrPrHwxEKRPKYhpUMHlhiW9h/nRkY=", "FeuF3DgKDLgfFRHcz6/4pQee0xAJB3cu8Hb2S7T7H4w=", "KTXetEEoc5kbYiCu3D6SPAXrh9j92v3L4dpq5HYHWu0=", "ISpYpfKsVTCiUVQ0Q3U4iFIYUirEEkls5fhan++i0HQ=", "DcuHP+K/j/1k+nYAECNXKZe94JN5k7yYIpKEduc1Vh4=", "DjkwjBKBiZ1xUAktHxFuQbmBIyydCWER2CdZLjLF6lw=", "ClZ50JQYRmpzAOigqWT007uSKViIUUe13ssUOLEBz4Q=", "A4qPMmzIpR3UEJL0DqOqxK1yKodEEB9AaBOcXZEV6+I=", "HcD7ORwZyXkzfxmDsH2QrSJRedHGv0/YVgH87xwYVK4=", "H/6w/e65xyDnvlhCoBlSdomzuPXj1jo94lBalkIjopI=", "LNZRG759ydKozAUCJbc9affCB1piP9b/S9Akwqaa0mg=", "IdRwZZCxhU2WK+xM+laVGuhEHL6x5BdfXTthuNt59oo=", "EtpZUoq5KunwJo6xvaR1lJIOT1pFJieEeN2aAQe9/68=", "B67Z4W7dQarOk8IHi6EzNFdnZpfOuNd7WDMSGupj8Go=", "E+nFJ2HQ/TVnePLJypT2rBxxQyRDXgEF1BnhEtP0LH4=", "KIyzwuRdNTIz0mgDZtSRPBJefyzGu/1lBpU42J9NxHc=", "AWr3EgdERcivdXjNaObjLg+IzZ6Zs/RsY7hMg5JGju0=", "HB2bEFhKRGRjuQXXGUx4Bma5qgCngezxADpqDIFoX30=", "CnyHb4OrTv0NBCSTaB6ZOmZCDyOw3GM3/Y4f8L7e730=", "G7hDXNLm/Jx2hEaxOlP97O4Fb3ntjQ0dNuOnhM288lU=", "LZC+GuGCw/RAuF/W2mniHenrKSnlS3USIW3c4Ipwlb4=", "DJ3joNvS0UJw+KFsSGSVrlrS1EwDIvDZkKxKTgJL9XU=", "Hjl8GCEW1OAKU1gaoQjlv4gPj+BzbpgSSsqShzhAOZ4=", "IKYR1Ps5LJTYVoRZDqCqo45IANAnZQ+CO92g6Ag7ogI=", "HqG4gql9cymRgFrkaTUjPutCT5Nj+eX+hk0wI3SE6/Q=", "E/Z+5uj/xv8mZIvG4xBrg0ozVO2YnTUfTwjyeWkQ0bk=", "A11uEf1xRYyqHAp/doKOM2CtKvLoinqo5eX7KmEQpW0=", "ElS+tHOKXo5Q9F/HrXPFEhZeDCDAx2SxdH3STaS1GG8=", "HgsjH1lZWJd911ceDmmI3azBSsH76YrHhPhoShAfQX0=", "HXh74Y2T7uvKz065jyImZFzBqkNU5q9M6+rOa0QAGWM=", "G2Kc4bUjSKmGWr4Y5sU3+IskVeDw3jOM9R3/FOCZk7s=", "ECsLgq/OytULbNl2vTrKv9NO9PV8ePX+e1cSfRZlBLs=", "LE9OFDbYXpFBYr1Ru50Tv8r5+dMO9TvXXY9lmCASTrA=", "Dl1ijnW5zcOpiYxHIgI7zSbCMH3Ny3TQl/T+ALrQIdU=", "GJjv27u2JZgtsN1RLoVA/5hpJbt46pcMtdBExT3t1LM=", "Klhq4Bk9wFDGimNA1jh7WUTSHLeVZmEMoVzAr7vr1hk=", "LI3zqDn/Ky4Qcf+XOWPhY8veWZTaNwDSTAlCofuPPoE=", "LEDnP0H3ranORv7XVLmH13x7nJvhyGbPDlBJF4X5qoY=", "EKREGaJxBDvknM9Q0YcwLzAAJzY/IBh5JduL3QqpzF0=", "KCUM3GHu7YuY/PD5qDmwyymfSoD4hTQphmCQKTKx6Mc=", "GwG21DgiI3+ohruG+l0K2uzeO4NDJOk6AlcSAtOcFsE=", "K3gDhvnz2psj+I3H+iYV40KSiNnF3kgD1Czmns+2RmE=", "JJhKx7DTpANQDwqIpz7Qgvh2LBaG83nVJBtkxtHKJsg=", "KVSCnnKmk0f0oFteS7Oj5uW63G97lj/t+VxS7V7MSI0=", "CDYH+eBTpcd6uVNDwaRiA1cmKJHSghlbzE3tPdeIzss=", "J83I8GGN03inymuJ/Mhs7ucKfMc9KTZ9PUU5KRtzd14=", "HEUqdCazHvnBhpBrJSjeK2+LJkxwg9Bxlf7jJA8M8II=", "KnC496T5jJTf5Hg5bCTAxzRFFTympj9BNaYaenFJIJw=", "HdrywpBgOEpk8UKWT2jDjqmy3fFMmu+StwGgD014yWc=", "GNdj9ZVWacdWhdeLvP2ZI7Hiim/iLRnlMYK64uOHpLE=", "FUh7KLPwaHRIxz9DLPyg21VlAamYXbl4KtHxYBGqVYQ=", "HNFX9gI81yAYDlnbnc3R1tas7/m22xrHIoTApUFXu7g=", "AvI2j40EaxiTTdJ/Kbv/KckJu0gO4P3LdwUnN2ahib8=", "CdE6Au5Hk3hZM87Sq3C7AzTnpv5lPo1O2Xg/2/ml8b4=", "DWbGH4tQWo79BqhlnR+DkQp4EYKkODucc09RIA3E1io=", "LTKupMwyb4Iga5HJhhgfGO08MXGlMXckPy38dHGXa3I=", "Cv3l+FoELr4yiJxqPgD7QMQNmhMl8vQYkWsaRuPkQR4=", "KaPD0Mqr3MtsfTWFk7z/jcLgUYqeQf+tJRtQ2bOXzuI=", "AyLDOGv8vqiPTDIu2waqbVkkEi2FjfNO/mNzxEt8vWE=", "FDjFhxrdesDTpJrNgooAUiLOjI30MFntz+OZ2Q4oE2M=", "Fov6e/QA9bwMwUOI3ReAVQmA5BNHAaLyH+Ds7rpZxxI=", "HcBzoXKqlyjFI1RSRfkWDO8aduTPdLbqx9ET/fkRljw=", "JsgPgeLxKjAuYw6eTT/EqhSn70FQjks1oLWPOmOAkpA=", "Lb9K+vTF3fsEyzrnqqprxiRMV3kKaTnsD+viwXvOUys=", "AJBbv71hrEIibz2aH7/S6Q6wTcZl4CPqI5Xisc951DY=", "HB2qA+K1vONgf/FeN77R3LteGJsHO2wgwnuhbuKrqBQ=", "Gi+OjVUzliPBE0CuGxNUVGNcccvY0gtqU2o5/3NqUkM=", "GFNcWS5iWBF2o0ZHg88Jn2uQ5cvG2A8SOYcI15Qe9FM=", "ACn2vEncWZHIyJySNuBTX/1uwT4jBCvSeEOlH5/Ss2k=", "D5m9qJArwmMKQYhKXEd/6M52l/6GooEZ1aF77bmthao=", "KTb0GhmBbavEEyddlD7wnz+WG0nhXvnWcdEZqjnitNs=", "Kz5cH6G8os/kP+//rvre5di86X9SSErOWbEGVJCaPCs=", "LPVNooZMKNxoFwAKqBX01YWCF4C7J/1nYqxvjCzlA5g=", "AxjUq97RH/RC4ylerl9iuatTx4OwUJZDhDEjuALSVJ0=", "CtXtrhickJiuU3NFodMUW0Qqd3Y3Dsb9tswzzqZ4nGw=", "DALsZOkSpS+YvJZ/Z9dOpTN0oZXmuN8tocCr+V/tHJY=", "ELNU+wXge3LX1lVETMlkEw4+57Y3RJgePFplJ5roBfY=", "GBNaNUdEOt24CeVtKZ1qtxYAympn1z+5A8RuofiKeKA=", "FpstHJUz/eKPW2FyXrHbLfUjyKfzJoFqSKBrSS99CXE=", "BwbMaEaZG/pQqlJ0fGOrG7NXx86qSzigtr39xIzHRdI=", "DyOi3weaOn85Cf/onyouXUjgjIH1arqGm4oHOxNMJ2Y=", "G7LtTNaBBHp9RJpDWxQSoaVFdtGimdgwfJMl0NlXZlg=", "KNQaKsezxxl07gWMciOgp84LtaHkhdvSaGvBMAtH4h4=", "JatQ8g3TkbO62D//DulpIlhTbaIoGQtyMHPVUxDEvR8=", "J7JLNG3hb08oagVqJCOYla3eERh+1cfRHnxTW6XKYwA=", "D/Fq/dnaAoFbmPuSxXY7SbDr+xa87WKbj/LWNxCQxJU=", "CKEyn+tU8ICS0Y2yKR6RxOF8fAmRP+1MATD8jn91ybQ=", "DNa9cyMH7FMUoUJZ01S/fSd/BbrbHNByU4ZkctfpB2k=", "EBvaHygxHCl3zTtFLfaqQpQkuHz0fJI2bNRdmSagq8g=", "AsOTGURZmfgOe4C1o4Y5oM681bB2b2QjAif2gJKA724=", "I+ev/9DG/i7JWjlK8stySusIglAhTAmTQyib30ZdRvI=", "IXbnpUWiRM5LwafCvcqVMS2mL73Su/ja40fGEWcOp9o=", "HGBncxx30B0/qGfo3+wriKy8F+fOrdcGxYquOCVOouI=", "FYiyWCEx0F7iC+yhzkBclJ/BYpIhlEfStzxij6wAzFg=", "Iy9lg4R24BvhKHty+Il5OPB4PtqSufTB6+ggLrKdyIk=", "AitvLGJLY36EPnSnbDJbBf/CrkYUOE4POgzBhWViRnY=", "EgLiwKc7iitDRpSV3ZUx3MgHLRbmOtwCkjxQsUGhhO4=", "AU4gPKZNwFc1szB4rYO5aUIblqqeg0fOLlIus4iG2yQ=", "BAkjISsbfjfJN3k67MIz8gLWt1ePxvUndLFl7WeE5HE=", "D7/EW+fF85Aave+FPS5iFrcYNcNl8Pl98vNB8PBJ6So=", "JzEBVRkrFyZ1DFv/cRfE6+wgmcmLDejFU/WN78MLoxg=", "GcJZQyjcqVlZwq+Av7F50lre9Z6qSnTxXtPxk0CgjMI=", "EEeWvnQ2M8zFP3KBRLrL6/Wgm1vAcXujP6ad7z8xzXI=", "HJf5HfHXmg5beAOypZ8VqxdqIH0c4/aG8uMiMUuvz+c=", "CiSq+RbODSL+Aa/cX5bLHEC0nEjJlmk1T+LCgKM/jLQ=", "F9x6UwPqeXGE+2UCc/qsRHKEvrI+KTOdPsnZHT+MdrI=", "Lhs4fvlZ+CoVD4B9/lo0gPrvbn950V7GX5JNCu0oClY=", "EVPEzhCItRNZ1xclgj0WPOaVQTF2EOBJvroBXyVsH7o=", "DYuJJMukTVce9TkSRVInpb/6RgVwGPtoMU3O7r0IhRU=", "FR6Gj14Z6W9tI2cijTiK/YwIB5TQ1cd8djvuzKyfwLM=", "L6PrEqdw54N6jmkLcV9agR9BAvPxS9MKMIoTmGqS19I=", "KDGOU6mUlkF2Hqh69sgVmg+5SRUIPRoTCL6LsF3t44k=", "K8OBkFOtmmZWAG/eqH76lOT6o3nonEwdOKoS0KFB6bc=", "HBJHdtK7c1KD1KrRStgr+o6CHsVCqvcGW0dld1esMdU=", "KgAHEuSpv1s5Xt2jCS2wBA1EoDRheKoBKJl0WYdMS8U=", "HggAtB7Jw5LC774l9d587trc79EtQ32HTcRq+ZeuAIc=", "KrO1Ch4XaVfcHwjdRxhfDtDZqt3sRcXKt5bdLZkenhg=", "IZCgxVdiZxVuyQgZYTOKRxoEItVgNbi/Oor+eHCjGWw=", "A8t7t9Ojin/xq/jJKCKYpVUcVdKOG9tsTnN3yqA0lh4=", "E0MtGApLgV/4w/OvtCUMmeiclRhBfOXhR0QN+A2T5zA=", "FZb01+WpufW39eGkttBotqrJCSh3uCDr6VoVxZgw+pw=", "K3VwMkmQFvyF35QNfqeKa2yKG+8EF8l2VUZAuRTcm3U=", "KxUov4eonFQneeHWZxomkzGiuaZLVlAaZSvvDcW9UJk=", "L9FDGURBOCtNr0htFZ3vWPHJhpqgo/0Dq9XZySPbxgE=", "CE5b2E6fWj+KwaC+QmnhyrO+p1plHrR2sjrwqUNunhA=", "Jsc3dQIXpOOU4GOBUnXz6Zv4emM55DdlXOkfmaP4lOc=", "ABHUShSiF0VLfLmwE6ftnueNOAhGkD2rkwqfOcBypU4=", "LP8C9GsOyAbEe3yDTgwzeBcsoPdxm2LeF/WY748EdzE=", "GNIVnjoEDYrzmQOJS8nsUdSaqm1Xdtsx8c1N+mFiaNg=", "GPARCuHQZ+703QV3Iulr5mFrbF7a8QHbUpsEmk5hJuc=", "KHDnyiY1tcP4mGVrzY3YU5kXBOB60wFhL017sXS+0vA=", "JnT1ntH95bswPNAQqsipFFi+plop25oWO6OrMTy9bHY=", "A+NLLzOxdrN9jojdNQF3Kolh8Cpb2ymBRYikSYgVfak=", "F5RMDH2RRlGBV/kgAJK8gr8sVnLchYSCNlmwegzvN+8=", "Emeqp3zXGZwQ98K8VYGkLzx7CDceOqpgu0I60uJymDA=", "DvrDzA2qI/HjeNHcvbLt1qXYSVTdAFU/rJZBYlkSODE=", "KHLvRvxXAEYfmvApw2EUAKCoBJe1hSCvtDeU2nEyapc=", "Gr8/tmuTP+XENrLpDcHbxqwv+nTPYLvRXRgxNPBptC4=", "CT2okKakFjoJT7DDFAaDupho/M+OQr7wpR571Xe9oPc=", "JSDKjeNEKJCD9dASZP92pa53bmnWXWcUQvUqaAJCpE4=", "CPN5EXXrRUlCul4/1/AEY+uIkA7pwFPRBfnIONKbEDU=", "BDibn8+bJqDVKnqGsR9Q5M1JzHWP+cHJNSSBwrfPVbU=", "CL+sZ11NFiP1SGZiuOmnL9tJcwZNXMZXKjb4aRV0z6k=", "Ko5TEIpeb6Kwv9LgGoWTI0ka7lzKRZgdcWjxrR3UKl0=", "Hql+SW+mGcUsGdWzMHbOhNUe2UeXBkOwpt8wEQIlKps=", "KSEJewYzZZQsDWpTTiqSqkCJCLaJeUXueHvOZ+RXTO0=", "IRP4cbcTx6se169jmCz0YJWCHiqu9hNo7uEzrqYkXyc=", "BCHJ+x6n0FjAHCU34i0ccX5AwDlsZDvj58ApwFVhY3Q=", "GBxX2QE1VO69Wz6anEqJp/1V53LrL9Sy9H5fAVtSt9U=", "IQ+8f65JqHEbcnRKJYeNHs86iEAdvch+diDvCA6bG1U=", "ADinMDfQSxnDzb90wyzb/xdZ2rV/3UKVSjr9mAdTfIw=", "HE+upSeloUYXDMOoUolHn7IuW7WtLBkAmZ+qkIC7vuk=", "ILx0RX97NpVvJ1mtahiwDsYCoDnADKeSkwSv4aoAZ4s=", "GNvtix69FPzyhY/ywTnSb+kBzk6LUPKMFrpqVsvWw98=", "KQ5fkYzlGCeT/uBi4KyCWZpgOc7bAyfGnMNcSEpgtS8=", "EnDxxJvwW1cRKZg4rLLXfk1SCdZQ3lQNAA/gtjaVclA=", "JEvwBxhEkQWmEv2Z+B+Ck739Q3WKg3WqxkR9Z6+gfUs=", "JTwSZ+Fpd2ncW5FKNBsC6tNYJhBH/adJ7dzD5klqti4=", "H2IFkj8V1mdPj6P13L+bauMAVHGvvNhXGgsCU1JG/3Q=", "GX19hCZUyOlYKQC1tyqbvVtDFVwDkUBkawj+0DKvx7s=", "DcUWKBQzjfvcN05tsvS1QcWY3jpoMjYfRAA6ioixP0Y=", "EYwDhx51P3UossCDQSPKj0PKerN+sf2lNLuzNOlMUr8=", "ISqMKWd6kZz6wrnarakjRq5Yi+4UJlT6g2NHI50jFE4=", "Erv0DSRk+snmTdBNZTmfpu90+FKM9qOuwjVVqCryOFY=", "Hh3rtPdvPXrBVjPja/8J2hjfH56og687y1q02EtKeY0=", "AM6Y2x2lQxuNzYre5wSWP46Jo1s/Ag5pbXkGiuPPsC0=", "IZRGJ+YMqHp3Dq3dVIbBXKXkh/TdGubsIQTeg8MhboY=", "Ijykg3dKfF1PHOOIMg4dX1P/ldxc5TRCru2UvCYl05I=", "JQG1DH5/cpx/TYllAeKU3JHCZr0qbewMuwmvihP8N6g=", "LkOMbvB/m8ywIYZJqR2pNzhwpFrEUkxsvwczGaIZT/8=", "IOsXtT5oDCtg2fPVW53Mi121ngS2Kvy5aM9hR+Nakcc=", "JWEYJTmE63HybXgVBLhNgog5gpPMQZrvWehhPJ+vzUI=", "ILwXBufeJ7l5FmxQ87S3E6oHpbho9fzJ2k+vegZv60Q=", "KLo4pIJ6qN35NJ3EZA+oAXsMrNtFapAQZaps02F+F/w=", "BWH41pl7g2Ui1PGGA3mc3GA4H19l/Pp7znYguP6MdGI=", "CRSHFGWy8PPIPEFlNaUlCC+OZVi1TeMB5fTt9Su2qo4=", "Fg4LSda7IDaLKkiiDFXaDSZZqUq1nxdN5d1ME1BbBNM=", "CXGsL+HzhIPScTf3kva8DvURCNKoeHftsBIFojoYRj0=", "DbNulZsgibN5CIky+lJR5l1O4fQVrUl/VnfmnWIMPz4=", "Jg5rrqBqU+eUfhY/D+gz5RKAL3hi6HCPV1+2uqftbMw=", "AQPnyYSarhLDZCunOHIUHAv7Zb6Jamzg9FrJrI10b/Y=", "GYU6DvDEk4EcMWjikoVfaQEAtzBpu1DdMt3gbJaku7M=", "DigjhJ7AB3wujLJQRvajh4DpQ8o6/9lzyIOAniJ/zZ8=", "FWaeEPN6PSUrKPjAX2ZCCkvG6br3pt1wMoOJcr982eg=", "HaO0Z8EzkSxU/STgDykWqR1TPuRuaP/wdNGhRnF5u58=", "KMiqqAaxP44kDpR9SL6JxgnsJLQu+bGyWRZmnrYT9xU=", "EocwkSbc8gNMszqg0Bt+XhsCCooIrOG64zUw1duM8Vw=", "Jz1z1W/EmNG+QUQohwqS8AgmWNOBAT3nbME8gKLNjeI=", "D3PikUnQ+l4n/6U+SFEYemU/LFsxDt5rlZjky701pag=", "EVCPqi/0+GpOzf7HdOnT+QTgTQ+5yiW5m+MQwj3HS/M=", "CK2jYWXDp4z5POTenH4TvZ/t8isCIuXnCQfBdliOSWY=", "GmSfKnYSGwCh/X1JReOR/Nrzv2lEO4YfzxXZI6RWWPE=", "DH+43MKl2pQJlod7Z5CEl/4HSpiqjWAIBBvbH03G1v4=", "CmolSiV0uGhnv6nlBV7GGCY2jAKOUmkyQvY6gxU6vTw=", "AChoduLz6Vknp9zXbzfkyTe0xeJ0vxI4AfBWm/pv40s=", "IJXC0qnyM5XXfxqGF5xRLcEwHVSZlqMlAID1K5cEyNI=", "KskK/1K5VngsqFmMuysioyhVlrWJGh9g4UEBK/KBLvU=", "EU6RL94h+8EjSL6R4FmLBXQwva+wtOuc+T5n9yNXSaY=", "MB/fDB/1vpgHtRqRYUVBvAaWzsf7FqUDApz7RwTZaW4=", "CaV5w2+LuP4SwN5lwk71h8pAeWyFAFPAIvsBX8a7Bys=", "HG+T1VP55PlqV1MlrtloKlPcphuIUHcjttKt8s1oM4g=", "AA7UGXKPoxxVxZRttEa3+ng/ivWUFY7GCtjB9miTwX8=", "GUEZlsuDvdleYa/y5tSle+mRIHg+Qf3ElfNYyYImiQo=", "Kh7qUyH/xgT4fQVbZQ7mNQNYRJWSOkUbMvwkGsEU8uM=", "IdX+h+OQW2wZw4TUkCv/Tlc+0d+WAQD+L2MPWsckljY=", "Ii2iH0t8gH6+j5O2e/UH33FfU8OyundUYEv5Ou0jp84=", "EbyzMpTl+Ogr+rWBUuqiuR72NSqdC6VbrAA9xzUXJik=", "FfYrjlrBd+fFL6ypHb8k5qkO29pT6gxU1q58OCR7JLA=", "HjKerrQC7PJiWaElf6hc3xB429hYOUwG29Hke5iM8lc=", "H8qUMoEDXtcdiY0WHrwkb5zwQTXDJVy4fK/G4R4OcVw=", "IRJ9Vvbf69QPAm11iku4WR0+HUjBLih1PMcUMaHbHs0=", "Bqad/euegHlqY7SmmCZgk+G6dTTrt+Kw86tYdR0Mv2A=", "LApXpctJZFnlR9Q2bjSp+JrauCH0GLmmxwqhxhUSzmY=", "JhhY9zf80IIBUZZoY6EQNDtgZZJrEzhwkSxZXQ+oA+g=", "B0li1U8moCkJ+ZvDfJPvcAQ+fMUedzpehz04YMV/6eI=", "KX6yC//7s8Pc3PtW8LDiIe8o/PT68FKlKEwEv3dqCHM=", "G4xxGwphCan7quA0wN9lDDLdgM/FmBgW26Wi07qIQkY=", "GHLAz6zyv25C0R1S0owwb8zVPCV1qaJTS4PdJxhiE6Y=", "CegCBjq4wLABJlzPnlvNmoPeD1b969OFzL9cu12oVms=", "LQF32el64W6pI7wpw7NPQ7l0O7BOCvOF/kAQ65Kz+u8=", "IPZO+fO5FDpNynfNssEacvjjvvjK03puB9FW2YLTatk=", "FAheMV/RG9QxFhO1Y2WOGUqN5dzoKNC0AZdNpiqPWVM=", "Hq45B3cijAPr1WP8TMEe4N7XGNCtqO0yfUzAmjMH7ek=", "BkctOprdrbfKVa2NKG1+8GMM6E+mMYMgCfLc2twxXaY=", "APzf2zU9Opm/LCE9mmh9AyGETiNxpcpIvUH3sl6Wtqc=", "IkxFH3Z0V5vgRWiVfa74auv6uHRrjY1oy7XU4sUwGeU=", "DjePILcczf+wsgFJ30HigyxXu/OF6VPyyPVf1UEpGhs=", "AF7etqTKemy/9cXZJpS7RmmNLUduzBeHkEhj9JkU5J8=", "EVvda1yThZVaiiDSRMQGKwjut462kurXiTSCsAvv/ug=", "D2panDnnYjxFg9m3IV3U48yX5ajiQKzg6MX6g0MGDvU=", "KuvnN3Qa2g3PmYDoTwIVBtX1L3pAgvDpfTeUASOtC/g=", "GxzpI/7GH/jaKsSsXTwnksmhrfkDldjHYaqWc1o4omY=", "HCIWccp48A9Y1dVDnA0Rv/O590ti5Adwp5ja6XCl2yQ=", "FXcKkwFuh2FYm21uW8V9yoTLkRViImOROazG8lZozrE=", "DFMNn7DYSisE1P1dI0XFxYfoYDYfgI5dXmDX9hdbMbA=", "Ccko3dMQ8BOgF24xTS126Uh8VjEILcTIMrGDsUNjB4I=", "B1kZp3QmXvYki66AcEkpRWMUsqJ0pE2L4iwaF0fs6Ec=", "HMAls6WfvZkzGNvWXyK0QY+vill/vp2cRiYvW5n+EEw=", "ECRPDpW/k+gy/lLknhwFgw8Q+6kTYie8e+6coQq3Jmc=", "J/xIxf2P7OSFHrX6sojU/UGz6wzOVoJ9rMejUJ5PpMc=", "IZQEz4x/7vdR255dLE2x7JbuZnAeeEIvV7c2+vJZM5g=", "AsFjbWEu4Eji3x843GeSCr0AZ2qXevh1rmbqXVJ3oTQ=", "Ex5AhYehs3Lct5yE1Kkyfk0ak+Il5oL1qMHmrQ95sMg=", "FkBksFJJtsyH0e2vshyOK/F3+XnUa2iyv8bS+bxjajk=", "GjLThhFM+OqdxyBxffhVr0EGUzq35CfaPW+AkeppWQU=", "JhOXaNO+0d/NV1y9XGH8V90s1FuPclwl29h4GRKfI60=", "HSTpdNPBTZo39lo2zioqWT8yHN7IGkCljWXxLaICw9Y=", "JWmv+I5NPyCQYcsCPvqTwmpifa7mbRtnuZdAaCoFf9c=", "ELYh0gxh5wsykghZNxILmyjEiIdezvS7VuyxNOQn1ao=", "K0QZrwNTvlB/PTEhJ1+c6aGjyEAD9HNDlyJItcDS8cI=", "GHNpeFZw+6Rz2nLqxqa4Jf1FgbW9UseEIMskaGWEW/U=", "IQOjKPSiZzoMMpsTb7fwCNGh8AXtXkyibbdNTX9J+8s=", "B5nHvzAHV1i0AONBCFVxQ8TXExlOLfxtilAImxy0Ytg=", "IK7FbA5biUyq9OU31wjKf4+h6KHeYAmnov6kOnBRkjQ=", "K4OeTL/Dv5WU6JPgQZiUOYYwJwVtuRiHwtwJNz+AzBw=", "CVwcBqU5OlmVhw3aLmW5CiBDPc2XiCWHqsAs+P0EQsE=", "CPLPeIb/p4EeFM+LT17oyigZa4NHje03GcLOyaK03n4=", "HqJ2PZepGbxEw/uS5hQ3/kCTJTxHu/sqnlWyUs9/nyc=", "DI6fkWascu3W18uA6AInzMrh0tIFbWqFapBFX1b9cGc=", "BXuzRq8ov9S8I0HWTmWxpXNANK2z4Qmc+fzKec2pyAM=", "Bw9jCvJe+o5NjF41hhNEiJvrx923kAFBE8HCoiHhYf8=", "EdNbtyq9kABHTUSP4iQWyOv6FSwI5qD/z6Ihf7hunBQ=", "LkhhAChJMMLpHB0ArdnGyYwxFHObE/Oz+BFxc3LCWiY=", "CMOf9uYI3Os1Ej8tZNaLI8SoFoHlt9C4uEB+mqHFCtY=", "JwqqtYUtoC58HmyBZ3ObHXGfLaOAYRj+ZrCLUQqh654=", "CLB+2URfPU+dUgVTDXtkkEQGUwcMb0w+OJaOgrk7pYQ=", "Bma0gEcq2zF/WxOKkqTSlRJ778+4O3ZgaB1BuWxAjdw=", "LgaYUFivnhE+siN5zFW2ehXhk2EzhbvEd1poxsUmttk=", "BSMZyRnBlUxNOKfHd0GUmoObPxiGGfdAk+MYDRRMcls=", "L4yAqMMh3XTYXy2rLLFyoIJLmQymN2XW4XtINzTEpMs=", "IpsX/v63FwOnq+gElf9922FAFT9351H/8pAK++GRFL8=", "D5mFrsJjw76GZ+TJPcDYgS+HTO9twyGCfWb9kmga6c4=", "CvFcVmtoLBDMg8O7quPOYh0bw+C0UQgSbMDfmcYiXHg=", "Axd3VME3JqVAUCeH8D3qkXycCWD7IFR4cUyVFdahDoc=", "IshIhdpoWsa3TjkUv+Jmj6CCYu8k8a20xV3doM21gMg=", "ETu4eWG0Scz1WVz2gynLGTCejQZdAT/bAJqw6QZFGG0=", "Kr8ZJHr9f89o/jCYmpo3C5mh8S35svrjC2zTOD+NaRQ=", "L9T+z05G0v5yZHvXCPS9SAn/lh2J3P0q6R+BLgo7n6g=", "F6F++7w1jFP7QZMAAnaN6eE5jznfMqiwbiMDMRTH+a0=", "AiiOKrK4ehLVWjGbNR2YdMMu1EzBbZOmpj4IUvD2Rpc=", "A6w5+GcAtmEfEZImPZRC6QDREA8mAxvLio5iVe0an00=", "ANUyKjTbMAl4U2bABgxH0pphj+CyyulF3vmjXz3a0fU=", "CdmnbjduGU0FNVSiZzRrfgNKbRNEeDTbaNHBAjZ7ks0=", "Kh4L/H84d4e5PLObvVHNnwI64Oc4q8Q96By78SLBPl4=", "LJuhJlq+intX9p+LNjK7E653K6HMmMoDPVNpZkxA9aE=", "DoK3hN9Uc5NlFWht5c+OoahkVaaLO1Wr2lhXvVUn4+4=", "A+x36WS03BE6+/od0u6tu2dvc+J4mfAzxvrKIjgCSFs=", "Cm+e3Mp2x3pdaZohfde2LQ1wRIUjbtkSzmuN4ik8HiM=", "G2KAhND7j+dtY1O/lIK1mvl790im6ARujuypqKn7DKI=", "JID7sEuvCTvMHJFi94IUv+FMNklQDXmOh0d/9x6pkVk=", "LJLBgekWJLyyb6J7bABGBU6ArrzzQt6CLfd1Mz4rGzM=", "Is+8+ErIM5Ijl2Lc2wPoR3smG+Ge9X4jIsBDwIk10nE=", "CaoND9ACfVisrK8g5VHnZDS9ghbrHqazF9Gm0jpTseA=", "FE2OVUCMiYZG8uDdtuwZK15BabsxJZHSx1i5cgdAmsE=", "Dxo53ceFywiBQg9C605rXswQyB9JC+F/gV+dfzTl5Uw=", "Hoc68YpVZjoEyERwSYskW0bva9eB+7Lkv9QzO6FDq0Y=", "JKR3mIahyhqlcgTh+1DgM+Mcf5m4CE0oWwuakzyws8c=", "DnOu3JpFeCVfHQ+FJ3CPnTETEgXh1hQO+XV+jgfVk7g=", "EG8n6CRXuR6fozNY7ZWh+6+GquXU75lUoE3UY13cT84=", "GpUpR/y3fAqwfs8y6/QNltQOx/6Hsk65K0yesW8vz30=", "GXue0ajKhIe3LR6MzlAtqdK6eMPyLPfAXYMUci//cuE=", "FghVS7MJdyy8mgqrkUxOLEANcvny5drUZt+h374F1cg=", "CEgoO9ggGDeXbUM0HUNXj5siYJrC5FfgJmTTSDBnHjY=", "FL63fP4oVAGeBRYLkh+WEZ6U1hbpOgYHk2tFCj4DO2Q=", "A0oUlJFOdpgYXViGRYK/6C/At95q1j+TFxir+CONKAU=", "HDGd87JoC9jHFmlrXSz1A+DupbEdXd6OlSF/SqtqvQ8=", "EsKclf3r8BRjEhog6zOgZCXpFKqexhv2ZbwByiJY4cc=", "G83/tBCwCe/aZ/QF+jP9Eo+nz/NzCzhg3ymyvVYeGsA=", "LoqbgMzStDh/DsJMqg3a+3sP7hys40LOsY6RIj7qduA=", "IxSetlW4ZAt/52scDTtIbCdJ5keo0g8ptfkrL8ZNeqU=", "KmUGleN7/qisyZiRQzX/N23NKXWDJiOE4n+4BaIiP4U=", "KQouZPTh8XvznV1FGaFSgB/8LSA11Iu6DrGo+COOhpo=", "F5eGAZ02kX6Lr6aClHHFgdUyvxC+faHokXpfcKdyThM=", "IrxowIVe7frvVRRI2jtjknEAjQYzqp54P65SQE593LQ=", "E0DVts4GAHVFmoT/f0eSDNUxj50Sf55STdH3rB0IK4w=", "CULJrX3lVd2XYniuu/HSLxvq6g5cortbDm5nnyx7ayI=", "DmW7y16/I6QNbiVwOuApoxcitkoNIQSW3BfJAU+d9FE=", "ARKpGb0M64RVd17kniFltSkbnk5ACnXpd8plZuagvWk=", "G5HE2KVENpsNrureJ6DClmt0Gi1GEx0xBXQfMd8g6hE=", "At2FeX4WjSH6fluWYidm7AwCJGv57jKKkV/y4sjZdCo=", "FiJHJDFBR9R5rgy9JqOB1FhKis/TGF1EObUnYZ065MQ=", "L+hOWXG/06kZ+tBCFKy8UNB/MBXZfChAXd6SgnwCU/M=", "LLZzThmz4CxGqAPVYWcwrWND09kj/pq5hJKSHb4Uw8g=", "GoV+F/LsG0whCt+2q3DHs90M5v9gO3dB3Sp+7UdEU9I=", "FM5jo1DSnl3HD56i4d0JEvjXNNMoM3I6r+2r9BvrW5I=", "ATHS4VLH/D5lqJ9KIuc3M17U9oyCxdzrQ4tRnDUhMrs=", "HkEK8uDE8tITyzRkFNkWnL9IHpuk1EMeI1kRnXlnEPY=", "LJPBRU0MyG60HfEiTZhpcA7eeDZHVhHrHwagNgcC0eQ=", "C9WDWBOt391/5S9MijsQsVfKYwc+4ngvdPQ1BqtY/FI=", "IJRN4b/Be6keek5X6syxKoZPDwP0l5u0oxqEQlzEwOY=", "IXh7VM5UPppx0RvgPh7jrJzN1iIfQ64NJhYkrcK9mC4=", "Il50oLwCPIC7Ja3xEdUquDPqTkaWcoEGQGHt4PPXDjo=", "GfYYlHMAtWHcPUajzWKp0l9+mzPzATh9gasSCf6wpUE=", "IzpGKH1RmsVorfmbuGlHB3dbmZptCjq8qNbKZOAYSEE=", "GNDbqqmNtnO0csitEbSQ+sdvYgieEN7B4lOG49BNz/M=", "F3qmvoZFSttORfZJZyQjGJ6u3zRDkzyl2M8tpLwIb+U=", "AaAoEKxqdnnkAmbyupeMYnhftGe4T7FdprA8Qo6hmE0=", "GubHCl6/JR9ffkoSQglqMm7x1VFMOEM/ASj9xmg1dQU=", "AiFO8XrLoopxWHR2zndfbuDTvT+l7a3piVu16OXQNVg=", "F2lIaYBIuJ7d6MQaAtQZj/Rj12iBo3ibSw2+iDe91hI=", "L6jqeyuxNBXkF1jwS3hJc/8I9Ivj1dz/kGn0id7YQo8=", "AUTMfGrSj6LkfrAnWhpL7/6pc4z6j45zzIkWNJ0eIsY=", "FPmqtcFvsCyayMFDpB1+wfSWj0jujfeP/k+Ht5ofPF0=", "Ief+Dzj8rTdPUlp+WuwFtHoz7umXCX17Z0yvxKBs3cg=", "KLCpHkSKvgkFh298S3z34NWCw5AWENcvov00RTOfibs=", "GhaHTcZ3VUr0NoP/Cvga6nw30Min1IAmaYZA9pRH9Ew=", "JCKJHUOrcfhzDxwURzIOUPk1IT9QNtodLKMIuEpZTuc=", "HaZlJRN86PcrrJ2jauT2ZsPLejsp26nYL3soa0TDL84=", "AMRzGCU1erFfSb6L6Pthukqkm7xmueqInedDPojG1Uk=", "MAACjEAR2uvk5vZO2x/TMzY4r2nUDw6V9IQWWGjJu7c=", "Kb7ck6uztiVp2vyLiYfyld4lJwBvp9HtD9LxSB/WaHo=", "DL50OAUJyKx2aIlYmfwvtrf791KqSD4dnczCUGC5YP8=", "IraUvGjfK8RomkgAUxuxydilNih88emRoDwCZNAJ/CU=", "KtjijC5L9zyHPuhGPqsvO6re2TKlQ9ULuRgvJG85Td4=", "C70EtDSlXUxc2raE+iuEhPihuDpXCZhWaOLU4Mc5yAI=", "K9FUpgdKFbZRth3BWpNkCoh72eEXBCY0ZOy5/sPwQ54=", "LVrxerJYV73XYEQgvQDx+XIy25N3iWctLKknoIIEa5I=", "AvjnlOGy6WHTssx3zraEykUzi+Zd2Y9MzRLnfTRwjqI=", "JOpPvn+bnmbEHMDLG7XizjN2EeNgkl3TzJSVNDKiM84=", "CjfdW8yYvf5PxtD9DsRSDG9EmvWou+T4E7XtXdVEFo8=", "CGpZI1/iDbvhDMYD9pp4t5ZkfLCvNbxyBsVBpIh2cho=", "K9dNbD3Jd9wjCaCnsMfNrQnVS7Rmsr8MrxmCGN/OrwA=", "H69EvQS6v1qy5xUo/bzNX9kdssIAHaP152FiMTYI7Kw=", "Jup//4b+VrdxK1nnDlAquc4JvYvqmAIjY4Frcm83QUU=", "HbI3C18UvkhIXhv/kDOFPJnYBzyxi8nsCweMLNkFKP8=", "JPW/dX0afCj9U958jKvsXLYuRMNzoqMvN42lqqB9Ges=", "C8us7Z754LA9O4frCcQFAQUsS81fwy5LK/e3XiEUit4=", "GrdtrrvtxfHbRAeIYWGHyf7UOxyyZo5T3lFRdhs5J3s=", "JJ3NW6bX0jRzwqFpx261gRhTmfkhaqyt3SRj4FGf5tY=", "DF2hcgC5CgsSWwOe2SK2lU00uXk1RCN0PmAWtbxdgCM=", "LfkIh4yUAv3QowFDUbCSjxxVl5Cg1BatJaJhbBoHPNA=", "Ic4uMwiZUbAa9F3zgWyA4gSGhvHoAUwlfJXi7z4nU/E=", "G77LYHlQxU90pic2mp+UVIhnd4YE3Y3kBkg+IfYe4aU=", "I8F1R5lls7SpcZz+a+amEMDHdnDlhsKrDPCDUB5p8QE=", "LzcNFY0VtzZWLW0EV8RHBuZxvpqqUkvGs7/DQoCZYQA=", "DvEcv/UN8eHTa+DI81WIu75Aa76jGju25pt/fE9Ooac=", "Hy/xF2ddl1NcJNGaWLqvqwOQ89QRSpZcQzUMF84JWu8=", "FHEtAciXWQ0u6qtumOGOWsGVhpKgTBtRJO4GroYoz6I=", "Jo42F1LHKkrZSbKtHvnm8ugGN1lGuLnmM2A41PhJws0=", "Ed4ft8Betjikq9tLQ4JhhSm5mXisxz9OhWPCgxzeErk=", "DSpyNDqQ27UykCOVgbL/MSBqArnNmLrGZn/SR62QlUQ=", "D8aT+fj1y2obi+ZonbwD9QMfXfSjB4LYCR9zjcfh6d8=", "DkHiqZf6TQ+LdS7MDcY7OhIb6B6g4kIVTf5n7ASfVwQ=", "CHssqNeJMfb94IN85PpYlEWW88nPKtq46uMLRJROF4g=", "El2TrM92nU01FLIdTGY7FTniJ+nLxFlkQgNh2NIgIV0=", "H5GscYZIzR/a8r9vEa7v972CBs7ldp2IF7uXAznojrk=", "KZFKts7EZf2S+PLIaeHOnU27P4g7KWhQY/M5WIESZZw=", "AtpKEEhu9tDv/rJvhpvvmfbVDY/qoeoci96VmJQp5dU=", "CCVX0/UPpRfeJxDgSYpoOTDbW5+yaeirakJ3HVrn3DM=", "HSCDLpYPVQ1wYYcvbNlnlvnPYfr0+AffDDc0peg5Iyw=", "G1eoItNOStBs7E4Z3/Mka/hGvDQIA22rArwrEso44EQ=", "C8eYyNz3nKmnx2yw6Lt8I2Zxn+dAkuYeb0DoxAh/wLU=", "GpdbF5ZJsRTjxFWaGxQSXjXjYwvx+Dg/r5rygsk2cAw=", "DKrp9LZrReRzLpeFGROllFQHMPJlKYAVOcTUSJYHX9Q=", "COPagSTGIeBw6KQfD/Hxz3XiIRCHlVOS2FoXI70txB8=", "Jg4xVRSPiSt/lrLXTmx5ueLBo82c0HhK5QeHXkomeIE=", "Lj7Y0n7nG7QeW8mPtGbdT/nQ+KZohht3Ovgl0mCuOUM=", "IdD7fONk4Kx4Gx4R2Jq/6gBjksq9IPB0DRVr4eRefuw=", "AwGhqsxPhmhOPteg6wI7ksx1r2+CFJEPhAxifD2jzXE=", "Ee5TvrHo7k7BBon0/kDr2TzRyf4G2BLpalgzaENewrY=", "AdQtLdnSNyUwww9NYSJzLRzvjeqeLr+zsmeenw3NBMk=", "CGHkSLkv/nOOGK5noUOHbVWljBYvdNjlVnFNH35ih5I=", "GTeTv+XHuQxtYUdeic8NQURxKPKA2MbF3Uvh/JBy7ys=", "ASawXuEkyFqiscEnPCHDzv597TmzBcXgOaNfkCTMElY=", "BWncwibC4hWuaXuMYAEBHLrnzlNfRagD3GD96dpQyDo=", "D+YXLdWv6P8OfjP2SZkW/Uxf8vq5aWN64y2OTP0/79Q=", "B0/yxfAIBg6J0wllWRJgZ5zT8PWu0zFirJrJnaELq1M=", "CG5lRE1TZtghM9jK0KYcIAZrib4chw3Kv+RTZI0rawY=", "C5vL1St7iZplGgLDJuBkrGqXvnRXu86JbkZdc+k6+5o=", "AmngNcQpxL2u3Dk9KoeXihwvjKCyWwhepEzlh47FBrs=", "CeG3ckWDsOFqebp2cGNvh+oTShniDcPscMAce5RmTa0=", "JkylZRrnuE9D2IQc+ylry18Z+loGosTSGEtUw9Y3CTY=", "JOStjC84//37UDpN1QV1xaEkJqU0Y1njpWVK8BiPCqI=", "Ct/KzvarJi+PydL2FMD+SjJzyCqeczXl4OCADYHoeHU=", "GHrduXxKZDcUWGbPJw30pXunBZcP4eBhmg8BaTMGXSw=", "BxBwLfhB1O9eDK2rcZep7xnXUkgIu6Vt+EWi6PFBvKo=", "LgZkqrx0tcVNnQR79UcORevHhAJhWSc/HS9eR1nABlE=", "Jxy3qukUKtcYQqdwzGXfGdfRAtkjVFTXxgCnNaH6Tac=", "L/R1+dUiQcImG59SDSMi9SJo0omgKOl0dC1An9i7OwY=", "LTuyz4Uw5pi3ce3mZXigFJ5WGzZtUCpuecI7M8UAwqQ=", "BcgLWha2pZ4eNjA6Wbp4LNcUB/gyc/N8GepUqWHgytk=", "Fwd8ymnu0o8h7q8PAEhpLNMQ5rqHtlt1lN5ZAqgp168=", "Ltvk2ChpYtkc8akxdfklsXTPU9hVko8vEM9G57rx+ZQ=", "L5V1emLRpSicagh+XIKeVNW8LgMIKthiFkHYL1dYJZo=", "DCyhpPFoLaP1ZJDR8VQZTr5Aq0QZlRy81QjIYAXMz6w=", "FRtVl3Ptv9SkmkU8FzIhKVXcnV/2FOgOdaxj0GXdDMw=", "MEOuCGnrjRO4EBeLlus3yqJ6hHB3e92rhQAjhLbhqhE=", "AahD3/liFIfTU7cM4E2d7UOPdsUBP0eAeYBjpN9tt7E=", "Du+CQVJ3hMv/M/VR9uLlPRa3RFifUFCM2qCELgXsoB0=", "GuhbRScBfUXYBaJbE54/Qk03RYQc7K2kZY2Xs4zvxMM=", "DtQ38PEZMr8WsM139Jg68VEeVweEJ/7tMoeAgouNhCw=", "F96aEXFhuuf4JDFN23pJ1Z4kQ81iDg568ILnJGpyXpw=", "EoWM6lHu7C5PulByqQSTGN5A6ppBefp0x7/B4VcGgB8=", "CM9AQJH07l/cBo/1Gifnmhj4rpOt2iO0Et437tFk+9U=", "B2OPdVg0sF5tuvG5kqur4bV1iX53bq00caT+aNnnD3o=", "JGEFVY9FR56M1Ul9kkCm3ZjZboER7U5v6K5IHMIhOUs=", "KZTk3iP0c3HGjNH2AucSlaNqNluXBwTHCyL4qBaFC18=", "IsjTv73zY3qWMenRsIUG1g/uaUWwA466jy2oXxD+8Mc=", "KBwvryosRJu0CkvEc46mTv7BGNNL37OGUvyG5VKXoz4=", "GMBFzdqrQziTRLTv6VJU3OfSX305KwUlbCuUnkfKo/0=", "APiafxrJ+zeydTx1itAmXJTv/n54OMXwNpb74eoZzWI=", "F6qqa8cbLRqg2ISwCTTxKDxZkBHpbv1G1NYC2V2Gn4o=", "KRNFcXUkElXZTwAuxQpRg4YW8nWNaXI6kb8K3Eb60Os=", "EuujTFLJN2Ui+ACKZmCKtPCEAaq4XRY2R5H9+RumYfw=", "E16TeWk/Ttvp/IaESTilJRjonbn+E+RXWRMoco8V3Ag=", "L2u06RggseE2f4MTTtYygwMHBlrfda7uFmbTpZvqp2o=", "E1Q6mOWLG235gkf0UuAA/gcas/zbCz5rGpGa41I1KBg=", "L9gffYRLmaxh6PCT3GX+DPRdwqXN6+lvALD0O9C32c4=", "LVVSIiztTiDMgDcaAhBBHpUYDMSzEOtmIJwqRmgafwc=", "I8FTOIvhIZa8HJfYjZoY3trgmbyw8f+ldphTeQIqGyE=", "B/DSaes03Wmt3V3vWQK5p6ltzRc7/kYIKO05jvs6Ovo=", "DVEWkbbvezLWtku3DiGYJtEFwOPfuQWouIFkuOM/Ldw=", "KH3DYJd0CW0rnZjG8lMJRpANnc0F8APeHS+LPLjn0a4=", "EVMbFN20mwZvESmAjwQ+PJ0/MgieOuvP4pzknZPQ11k=", "JwwH+4WHHzAXxGiz9HAcQsViu3miy3Shtj+FcJCTMYE=", "CRz9eQ1JBJci1IISkhHwrsOhCvPRy6/xrMZ09ZjPvSo=", "Lh+bVGXqXoTIyyWbpc72PH94sER3vq87YSd0rdYyXLo=", "Bk1a5w1LhXT/MHfoNf7kiAF8wxfKivJiFj/PnxNIaNg=", "GN2UVqdnRJxlfD1WY+6nHlTl61s4HU4BWMccoOOo+yk=", "AVD4tY4GNbyo5URS8+Mf9ZecISLi7WMVx14uHvv02VM=", "GcH4IhNfu1kyuuuGImHTf1hhPBrG7MbRqYWlRqUuYUI=", "LOsqsldrK2beZMmoxWSGn3kQCng9SupB509DZUfP1jA=", "KJ7zBKEAI+Ty1OR8ryV2YHkQPltwWfrcxBpHWTfqR7c=", "EGRVrBf/WxYlE1Zj8oYn2RnrrpEMaXyUDpZ+kXtm46k=", "J+GUFhodDeRUyfR6R9hiiaEyTzBp40agoUopHtH1D3g=", "A+o6zhMaWAxzfq13J1qqsfu/NflXul/6QOMZARf/vxk=", "EI4Tb2wKcBaqPJEUAXhmj4vpKuqL8ipYpgQBvwN/OKY=", "E4S1b2nK6TkwCVgoXOrVz+sZcfQrtzWFLSHz8/8ua9Y=", "F6/FvMOuFPDdqqCtfwaHhcKohnKuJmnKaNVT9LVhHac=", "KvK01uSFkMtqs3JgzQYowwXpVxoQSq/FowCG7Tbrc54=", "BJZfyLuXB9qu0geZTIjSNqM8wJmcfhFlEvw2w/PEhRY=", "GqJ0+TmuklvayAkXnmBUe6kXbQzE07Zuxh6lkUYnhwQ=", "AsvP9dC1J2nuD+z870zdmV5mQXCU6EyUeYVngPsdlA4=", "JRPyrVm5kbkBW4dIkBo3Am0uUR7K8SpxZkOBAye8I0k=", "I/4xLnu2ow/tbNAPoNmKIV6QO0VgPuwU/5ITUtaUTaY=", "DONSwVu4Gzn+DnJjhGucC60PmtspNcESpMpPWMELRgY=", "F4So4WG+jMhSV0pAxkhirfWtZARo9FG6Ed4/2sNeyt0=", "FIr2a406BtTaS/0JEhyrIEXPoaluie4eI9xhRFNm8cw=", "DSgpWxd1MCQ5XFD4C+xmiQr7xFiGaFhHT1dlz751r1Q=", "CbxWiq3yXJqIQE2ifHNzKBe2qmyb+9TOhR6Jrv0Umd4=", "Cw/1uWlN7pzsZphi1JgluJNPc96uQEyeWmAWUq+P1PQ=", "Dn/O5bxSmVb7TTHpjaE3YnbK55UDkG3Vs/mHv0I+wNY=", "BXkDlpkAEXwoeynKxLMVKX0TeynvKIPjnxftwxhSmko=", "Hc11Y1yDHPPPW+rt1UUO1j/7F9w120Tr+gIHj8VcNt8=", "DyNef8NHgOgAXCQsyEKHZL5uSIyOuGBL271+BkQ2FwE=", "AdhP/sRlTd4E3psKCThdUJzCsgIWJKWdJ0/Q4GOziZ0=", "CALPNoTsJkbFNcAYMFvBN3tDdZCq1lSVFRnFOcMNVN4="],
      M: [["DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EhhrsiAArYS2vykXmt4tTn6U/wflFifglYBXEGH6jOg=", "I5n6pkiu35Akxqw86v6iSCFuJKnlbK9azSnOJUap9rI=", "A63Sn+OY7S1E8jMSXs0VCePO3nfmvgi5SvT+yH6z5I4=", "Ehr2H03FuySJCr65JR5c6pR3CrBi3Awou4mV3Y8YNjU=", "LKj/7i1Y8pRSl7AM0LUR2hZwgNU5SbPx/OrKlha2FD0=", "LJnvXgZBR9qXgrkUopS2wU0h6n7sH3LodhZxBp2CoTQ=", "DX0HzTeY9E2DKmVxwhcGdYaT5ek2hM4tGl6KU+DMZwk=", "KRlRFxBmI///sK9SXIOGhtDZcln8c6UZRgmse3sXExM=", "AbYtSxfeZzdbWPJIqI2/cHzJ0UkbzgCVZEygIZoB5Ao=", "LhaBvHwi0kxDP4HdOjJv0CQr/H4r3rYwfk0qyjKt2h0=", "AGWFDRHQ7Kh8Npe29eV/eMqGlSutHJBH29Lra+np2zA=", "Glmza5T51yNXflBNYAxJPygQ8OZxEmcsdDq7sTq/Q7g=", "GksYa3fNU/lhyMy3gV2Xgc73pSr2TQv3RstSJRLT0K8="], ["EoJuW5vhybhffJiqypziiocGh9NijWDe8KswcrV7Cbg=", "I345mA+QB7v4aZ2+zgVP6h8ZdmvmEBiF1CH6PqRrU0g=", "BUD1SSSXWV4TCA8C9rHmU+LlGJUWD/1coU0mrtk7hnI=", "Erv7sRDsKXEAfdrF+ONvZVRl0F8kYplrIRTvrKxwr7U=", "Ly7FHEj4tzxRsmSnDSugtGvbQ/kz3g+uqKfaKpfLQfM=", "JuNlRNC1lS3eQAfRGBhGW96RxNzmWrwBXnVWuli5X/o=", "Imv5S4axd8/n8DED1Z4/nOI5OCGVRwjnxyP4EEpoxmQ=", "JeMRs3zuaTVF4sLvwgQ7wHNVIRWzoGXO8T02VHtrncU=", "DyM24O7kaFdByiOCjDTCTwc0kfDnLBOWEFJKVvcapAU=", "DZu32rShiaO2mQpVJsgrCuULp91Vj5Ubuf00PLtLDhk=", "KkpsyITP0Ir0sNvom22ODlgRMget7Yy6stB1BT7+mYw=", "Hrl4GbNTHrtkDta0ITQzVBkQHR22DdGpJO+WZfepGvU=", "ImuR41LGXeT87hEkRb/yDkpnrw4RCVcxmyhg1Qh0Brs=", "CsW4YSjuR5RMEq9THPFFgELDWt/NnltqdTGXNxRVnec="], ["Iv6hKXpKXwiQTVVcLhXQFhAqTtKcMrS7EICe8Ur0LHc=", "GAjL593yo2hNihZP4tFQ32Igb2vjPVd9xXmPGTru16E=", "HBzLRP+KttqFTpJx9L7ybSrCbNdEHxtp0W7uDXp7SBs=", "G40gnWayway6ukNeMEriBmLTNtEDML6zNVz4AfGUcz8=", "EXOM7TkzxLJ94TkR23HM1Yt7MTRO2RU9vd3bkfvbzqs=", "HpfOATr6punJk+nP3JquyRsGeHgZgwmFpy6ffG5Rarc=", "Bmq4vq2ue+vSajOtvWuzktaCXaN6Z56K+a6LxIE8MWg=", "IbN75SGDXDK2c6Mdca7RvH8+qW/h1MI/FGI6CoUaPNg=", "HobsCGgFvHcSt1EN72USSbodSRB2JB2Z0AxpKIDzmnU=", "B10aps0rjRgcng9CJ1yYhK5voJGG/iJ+XEZz5W46zSg=", "FCqDIGdHIA/bAnc+dm9QTGWvgrIAwOf9lC+SviPVhr4=", "DuRoPI2lNra1B3Okabu94uQXoc+b4iFSCvHnVZaNf/Y=", "Fo53Hp+PhgxJNn75GaANTxKLqwHBPX3XLOjTa8bR2DU=", "DCpDkGcSFEnB7z26a+H/hParf6xLvVStdTnmGCbKGXE="], ["JMxnUYlAh7gxWYtbx/nbPLtIzilNkgjhqkNstfougOE=", "AzzM7wWwvPe3eqVWCg+UnJC+XMLFcSL5iF0koRfGP5g=", "Do78hc/r3ilc5YneYK7A20PIH0vn2kTrJvpLcffLfuk=", "Cp1+5+6RZ3r/08pPxnRiW+iX33n4LsQ46A8eAAyLH3A=", "CRdbH6+s3A5itflebKZ8P/yWom43z8c0eVuS8eRhJNQ=", "MBawdMgUIl4tXBCRqDA+7kvkdrFFitVMFrThaR9rRyQ=", "DAmYYVReATpofN1Jo6KWqNLC6ZaRwlNdpxLTUdXmPBA=", "C3Gga7dbChC/0oo3iL9UqKFEsyh9+cWRomQ8QQD+OI8=", "FJN4ecTHEnZEx2W2Ni+LmM/TL4Vy16rZzDKb7VtQemk=", "KPngBY688VkbwAfLAqw6zeCFFCfbIMc1jb75+pxXwro=", "DfZTUk//kt3o7ByaUcG+wwvzak8B6bO2LrE/j/33uL8=", "At/PsoCj03LbwVY56s5FwLrFYsROKS8UKbyRZXj7C/0=", "CzRYkLM8I9FnOWxYPRLk89nvyQTyYSAlEjUBkKsZYcU=", "BPfx+v7hIbuBE0T3P1T0o1gwdnOd2d/EYrOuY0PJPLA="], ["LMPQUDoOHalSsIG6XcWxF+ZGvtVypkUmbG7DzgoUdLk=", "KFTIK0tfXfbdOHLj83E3LeDRLhbpEIdmkgtUWBBedr0=", "Cx2BD8xyFVHipZbpAJNn/GqSSFerKbcDIHsIyV7NAB0=", "C26yJU7frh11A8NRjmTPGfNEPWzQO3HPvxvlk22k4EY=", "IQpKgObqp5n3zgV1K72k1P8FIHQslD4e/usSqRIppa8=", "HBss8R8NOjoSG+fQ3fsk3HH1S5vvlDruMpY5ZpIqg5k=", "FXTJ5cqqimp/tIlNLEXRkB0cQrMhT+mnL9PMZo45n3Y=", "Ju1f/wbvnhlCvT0NO6aEjkfsBFzSb5MEnYDL+mvMc7A=", "BZ3oc8WYBvVRFLw/gwn5tkz8unQ0quIgRH6g6cSmbaI=", "AX45zLo0MqE1wAddcgxklWLuTTG22i6ckL1yoDl2XnM=", "KufxQU8UQ3NTGBY+G/seG89cJx839qvxqoZ2ay5Z4Ek=", "EuqSGs9bitxqTja+hXE1dtZYCZIwsLF2bGZvEtkqsUI=", "GBXUwuahj08/pTigBBRtf1QPvoCkYFhXcU+6J5VhXfk=", "GPbEDjzPiFgEs3RDOvCpYrKWP7mqAei66MyDSz4Xox0="], ["Ee7b5aWWnzNEZQNJS0aaK4P4jTqkd+XW15Y6gzOmExU=", "AJtjx138q1ctKAsFf7w2QNNd1fFiRIY6uKMeCVbaiAI=", "Cfysw5mAZRJN4Bv3wMi6JqxCQfH33soe7+XvPVAV460=", "AamrP8IFmwz/fjzEMffbRfWdj39yTNEKA/MaNmOPi1I=", "Gbr9DXlCuDnzatPXDZyHtVZ0ub3uAqfcMOT5nrzB2U8=", "AMR0gkr9KogMaoWnt6WkNKxCLHpjqvjdx8TZMl7e9A4=", "A6ZakdNbbod5CNXEGeeFD2RfYrHJE3ZaIUuw96KRW0k=", "E3kIuqwuNeE/hoNKv+mNG1S3wl1shfxsBex83tkXVRc=", "FmLybPBPW5ac3WuT6JDvK1sRJPUYIoiNwhZ7vs98Mec=", "DNCkwn3hGutkYOMvoryyicuDMhcjFVMEkp6wyk7qA8k=", "IDC3vCpwkF0DFnTvtCAzb6uwdprAElw13+L/NywapOs=", "C1NCUDr0Ru+CTfTfagiBlftnJ2ZX1CDm8xKyYo6SKYY=", "KCpVX5rU+1dpj6ofwyebuMKMH43IxpMiW9hSDbQxNIk=", "F0waEJXpXU8JjI1ggmd2wvc2kds37DuTeDW2WwG6E9Y="], ["GJrp6bFiqxoZ1ZnO3O9Ci9EyXHh0CqrWcVtxC/rEweY=", "KP028cdh6nvOKebwAGf6QLMuazGPUGtslLuEe/crW1I=", "BdLwo8IjEirAEhQlAyC1L/Wj0kIRjhl3iyyM0al2xhE=", "Aj+6I6tLwk1IgLpab/1utQUN+40PVkdtOjApDto3KsQ=", "JrjqsN0NlbeoQ54P99NDinOie1mT2B/OznKagko1IbE=", "GXdex4H9QImFn2t/EnyR64Put+yereFGd7CmsQuebiQ=", "DAc+rdtdP3nlv4O6wA83cAvWRQLYv31aCZ+z7/fTsD8=", "FDmR6DhtYjNMoNh4MqCEW0hBbvUVjBjnuduM1q7iI6o=", "BfuJfXHt2NjrHztcgjpYgqBtlkBWr9Uy5siIk6JfJhU=", "J0WgWdCWLxvw3eHhuX4Lv0xBQ9EP0/3rjSspXuTXqd0=", "EqcQ3m0X+Rr4kBAiJoU7tkIJ8bQTMaHRcwW/W3tSFy0=", "CSZfsxSmdraz+CfwcoOh7U8wDo2Q+WeyD/YfRV0qsv4=", "FIqxWXKmkltxRgJxD+nmTAoBUFOsuDjQ6HakbLVlP1k=", "H3+XBMqxz+orJHHVee+Z0ZOyNK+Q5iygm1pnHCQopRU="], ["Gq0RRJ1uLG4a3PnokRTDNsAUVSjzVqwEn1L9jLCENwo=", "K1bC5E9wOjsUPaA8JXSTZ/dSsWgXJX5tEjsQvIVUNDI=", "DHUT92K2QCKhUdYjAgmd/9UXkdmv09z5bL/PYDWiwnw=", "CyZwD9TpUMJa14/ttj/LDZunPsq4WMBxZkhmqQlvFNU=", "FzmF/hfzsPuF3mEEwCtGw9ee7p3Ci1Z/AqsaHA3exXY=", "IKmmKEz8Q4F5XjsGg36VloFf1bbxYr3gL5fbaHyEef0=", "IXqkALK2Jbw2QypUXlMxJPmcHLmOuF33RzGehdUwRwo=", "FI3JM19iH/+cjS+nKpz1tv66vh9c53aJwaKeOTGF+6M=", "Ds+sqtDBR+Czx+BJdx5tQHKwLuTRccDlMiQhTRet41E=", "E2WpBMf2chAC284XB3qJqSu4A4vSevUzM/RHxM8DWoA=", "H7pxO5h0IxHfs/o1b/g+7yNM6L8rDUpS3nr00lGfLxI=", "CrkT9l4c6znti4O9XX/ZAOeFEe2rz+YjFN0Q1WeFjY4=", "COE8LmHERrUwJNIRarF2yENgDQDmdkAsRkF0UVjCQ/g=", "AfoCYWAkzZvt9kPqNtJi0bJPOKVXp3qCxoZhjDwz7fk="], ["DX4eriz+xAZALTTCWeWWb24usmHU8I4pCIMlprtmmmM=", "GE5YJGieT4FDhWffQ1854dNagZBB1+rzr5CEKb6yvC8=", "GP3mRRBiAW7eqjLkCo/DB1HhfpusGS+MqJHBHznr/4E=", "BKVyuGEF26UlPX7R5201oSbmcYVRuXayCPWT8IFY3qk=", "HZSOh3SxgPpeGjkyQ53+jF8ypDdlfSEnfkJhS0yaPcM=", "IEQapfTVY45k162ZgrG/z94Vj2o81q9ilB4FzI5TMVE=", "F4pY/xItFozU/xGkcoCkuOXNsxNBG29umpR8f7V3pR8=", "JW4UU3jSYE24xQndpFUkUrbEqJH6xdoZnHVgdo2UiDY=", "JfZNQqdQlxr8uAIwcPbsl7sjYrGWparir2pw8uezV68=", "AvgSEh4urMx9Ub8mY5jVuo9gGiqm0zXrafeGRkIXdmc=", "AMj4ciiSovBsWrRU5Ae9VX6cLqd++AfuDj2JxnhbDTM=", "BAfVhaan77VhN35fOXIxmj5yheFGxUme9shQSj0LYuM=", "EcuD4B/1gDsEmitZrpkVs+AEXh22lKbfnenE5xUtGR0=", "LhwpLga3+KbkNE8QVAZ1pjyknkUvaVZfz7zUO6wPOvQ="], ["B5aiOtbtKsmVEEoNPmx16XfOKauh0l5iqaiiA2TqG+A=", "EATF7Lq2t9Eva7TK6rM91Wwfgp7ij0fCn7+7FH6IRlQ=", "B3VZRzc3VJ37IBbfpyVYuywcgW1zGHY6Xk/VFrBJFOg=", "G8vmftX7dSKt6v0dmhUPjVetohjbNGkVyG5sAMAOOLg=", "G2GgPiGDYiBP0gtnU25ebKe5bbtT1T7RYCMCmIYUh28=", "LT0mnuMk58Q8EaqEzRW61lRE74Np3xV0moprLIEh4rk=", "DqRdIkee9Xc+WLD+dAho/B6LUL/3YEnVtu1ecjcRhns=", "IoAlDiEr4qSNKTeWqIrGKwVBEBL0amb4egIgo9/z950=", "IL5wP4bXwLna2Y/4u5/JL+isCoTGiXp12FEUb3SEC3E=", "IfjYVAkd22AdqxsB+zDD1Pd8wxZ/ozMsOzI3egfmqsg=", "Db0JPcFuc4Mr3mLQXLsG+CcfpHIpRwRi2MGM+KEk+es=", "L/W7vAItG3T+GEwGTljZZ/Gq0fCSbJBqXjVs/DuBrSQ=", "EZgWhiyCJunl36vzFns7K/f7PRkGOYmyShbZfJS9U9c=", "BvvO1SV2qRPmzcXFyW/cj59Okx+pC+60bZs8LXdeHjY="], ["KZuOhiHX2MjT1ihssSazTuU7LcmjaXuDgMbkf1cRNFw=", "Cpc6ZlaT7QlDTtsssKlxrSd6grM4V4hVI0muCei9DIU=", "LenuZSnlq8eu6Tt5TE7v3VF8T+EvpWvOBqNwjYYza74=", "Lqa3pyZcUD/LKEwrsZUS2uce81cSXDrHVca8bMN722Y=", "E4C+rHsGLGuJkUqXao0LnTJ2oTyCwj+iH0+kQD4yZ80=", "GlcY9Kkt2NF5uTKwgg9lx7uT6rzjmPmXMk+YrHYyO5I=", "HHy/JEjecRTu1wGwQYCQNOB7lGoDQLd3JoUp1YLCJao=", "CcieBsrVQwFT3VLMZq5PUhv0FF3wSGgb6y4Go4UFARc=", "KW86nBBCImkqRK0k8Pb9gZACfgdVVn6acAnsce9EDqA=", "AYOTUF6mIwZpqAMPbnYTChTBBwqQG6W2QLiK6A19MLU=", "HcowYKa7xMMk9++6IidP2NHyVgpO66jIsNOJl+DZxGs=", "BtptiMIz4xgsX6XM2hOSwPiffGvsTmDajfgFSAfrCSI=", "DGHsebEG6dxklKY1nxdf9jeDnKU6yOehNHHFZkYYA5A=", "LOxn5iMgvGoMoyUY7IHHQ2OkttJZvSdaY0JdbO3kaNg="], ["IPEe6B0qyantHKxh2c/fEL8bSc37ttIyhyod8UJ8GDk=", "ElR4yJc7w5W2SMgiCR+N9GlQSnHKT98dq1mnCND+Rxk=", "ErWRt681/9mXs6YTaH5EkiViXdXRAc7y1vKvAtnb1tc=", "MFRO2pwyLGyHJnHWZ/xfzwnPuNNOjlgStuc456tA2O8=", "IRDBBe+0gbZ5zrLxEtbqcERCdjrirGXt+PFc/RacVg0=", "CP1Dl6qLOoTdG6Ti0Ot8bRxe2h92SBS1/+IEyOxzVgY=", "JIffnV4Ga3b/yy8MoZCr9fweWHLEtqNqRocOkVkgEBA=", "Cq1owg+t4ePiv3D870tVC6ANY5niDYNAL+CbUt3N9Sc=", "BjAWebbNsXqmwhLONC7PaBq3zZa/C/uTNQNoAE2Xw1M=", "HhUf7f6hFlnBiaMbon8sz2lWCEGI6yxMmbgn9kXx22E=", "KRvZQB3iCRa5ACoAZhFLO/rk08gwirpK/czfCuwS1mo=", "AKqyfmJ5lSxykfA2kY8LJ507HZ+OTorDgNp37C/CTqA=", "Ho7mQTCLpv5WALLfSSzy8U+YkroQJYJsU8d663vNsEs=", "J24mI4KJSeai/ckX4u1F3ODuUDza/8mt2BX20dPE+dU="], ["CkA+l5lDuNL5R/btptQRcIgTQbteT7uztP4919zN13c=", "KwaW1FmAAgoqQhBzRA46T9Oe3FKI5pAKWVjgzYHg7uY=", "L5+I/pvjZFfopUZFWqAKD1EAp/MlgLePJqd70LdhIYE=", "IGcz4yemS3jTxItvdYDQiHwXeDQ7Z3aIWeJTLX0cRqc=", "AMJy0Qry73ipjf90hsSddQXt2IySLlZyo6uxXMSfQTQ=", "GjJ/8sRvWWn8rLRjUG4QLWglAjgfw/mZuf+9RSC6RpU=", "LAy75GQikXFSyhkGRivLWhPvU2MiqHFSN9oJuMWUysU=", "JfQQNSHjbVXkGBYu+Ov+xtRWlVIO9HuFSLo4tSon+/U=", "AHlA6wS2HsU0HBcC8DmT+u0Wfbb6LOqSKQzYIbFf5MI=", "KuHsnglXfILJe0sJFCrOUaqtHffcNSzU5YE9jO6cmNs=", "HJf8d1+WL+Bae2Y0a5PDJgyPapCn9cYyI6M4bhmFLq0=", "J3N/zXbdKWwogXZG0wsRaMTQDh92TEVlyqMnbe/RXH4=", "FrYbJC1B4ZdYQzCaAaNqFDl9fI5760r72SM7RTqszbo=", "DHW6YPjg9q+hJudXA7g9mQgRYUe4sttF7yTzFWuPGFU="], ["BGRiUzgPS/ZClyroGXd3lFSqCDP9o2sYIsucCXGePdE=", "AmRiXHTyo7u9wZSBt4ZnV+Y5wSS061YNpTH875l3OQM=", "CXFOcX2qPOs+l5TSSrzRcoMcuhgGbEwEiwmV6ebfHew=", "FNrJBZyeeNlsfvgHujQrlGhwZ5eCIx0q8Pbkq3bL0QE=", "Ep3Wd8H4qi020qfVNAZF36w0pkrkVvkbl96fjpExNhU=", "EIec6rw60EXXb2zVsmtW3Ee1EtZQlFj5/96Np55mSc0=", "D3w/PMls7aA55DyGwbaAx31vSfUOlN4j5NtC+OnK99M=", "EL14JPwbiDs9oActLGGUxKHllXFWWU6Qitv25rGRK5s=", "CQ2hLhWVVR0lAPkDELdwHfl2dkBBE8M+R1sud0mtthM=", "JM6wdm3iX8IniShqCSh750AxDEF0cyC98utclW4EA1Y=", "HH3OzqWeb3vrbXAuL+dFiEFdMOXcCZcLstVqzI4IMo8=", "EQpehN4JIJ6TY8A8IrU3rGp6q6L2qdGh9r+rcalgpYM=", "E4ItzD9icbcVScLNkXuFnNrDavaEiATRWjVNTeD2fvk=", "CF44CQXrLLfnU9CrD/SRiyMsc0QYtr/hMx3kkvx2shw="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon13.js
var require_poseidon13 = __commonJS({
  "../node_modules/poseidon-lite/poseidon13.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon13 = poseidon132;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__13());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon132(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/14.js
var require__14 = __commonJS({
  "../node_modules/poseidon-lite/constants/14.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FI2eRUIGaxJdptaf8/tnbr0n5qOKH/QoG9Y5yXr2/9U=", "C2CiiAUyQpX8r1G7iNlpI3LL9O7xy6i4XLwFk0ZpGog=", "LTj4Eq0desecMv3VelbtuGGIXyD6S8bQ2ULC9B6OSn0=", "JXOKzRFjWAAzNn/Y8e4ZnX6zw3iR4GvCDmtHagNXWIs=", "JH9pZ/ykJomujiC1p6GY1jCGVJt4wWIKUfXTaCTM9D0=", "LiKBMHemaLK3Ukm41RWj3Nk1AgBmlCRbsIf/BzJwi5M=", "FSPqib5hvkfhw2sOAkBowoxI2nS/cGmrLXc4nIPUdPQ=", "FGaVzhOCMOCHtT7xv4FgHyWR3TRKfLUJ8TiTk2ng0cM=", "EtBdlXH6S0FxiG2cLNRMfX/FpBJRlefSjDxHy1y1t8U=", "JCchFHCE1GE1Q3iJdxEfP95siTJqVW41vM0qLnPKxos=", "D9khuoOVpd3oM+bbpBczhQB7ONGvXjhBo0XJpIDJ0pI=", "Dwu9x6OeUUaSny4cqftKY1UM6o8SEJwdguYBl11YH10=", "AA1lAIWIsu4aTe4DE7bUOWlS2QE4Xy4a/moKDe92XcI=", "CupWe+MeHELOM/WJ2QM2OkgvIcHD2P5Q+m3wGKLcfCU=", "AvozR1ewPexr4d91jr4DUzF7NTFuz8cpNNBp8YI0a70=", "ABcyJ4Kzcz43nIkJrn2pRlXEbdK2sGG5JT14eh6qm48=", "FWgW9I4++Yj/4EzHesTImvj++EgmBOf5O3XB+xFk1g4=", "LI/5d6JzUrXX2ewQP8jwxye4SnePQa33d8OOAYAK/aw=", "LMIly17kuitwU/mK97O0iFaQFuz29JQ9ZLqEMJLFkik=", "DTTXqLj0mr+kjHOxDyk6yhngl0OoNF6eGvny1j/q2Wk=", "KgNVqwS+3qYf6uCDVhBn7fFHayByXPXgMtuAbTPtwgQ=", "LcrrRlOgzK0cCHL3axA79Po49tYxGeFDfHmCA9KXaMU=", "ItLmOQf8C2VkhQEiyOkkqXLegn10kekt2EOXsuvKd3A=", "FZOltQPfSDBf/DYMT0nOsCU2xz12tPL3dPnaPVuNzgM=", "ItRfEgPMEeUrkVV0mnwKCoIdpLBjzdyCBYAoDiECbr4=", "KPAaCttfj4UjbhoSn/r7LN+GrrQFbrX/WgaVHWTD1LI=", "G6YCrp08TL+t0K4sz4/M51n4PP8pvxK1PWBQp1heaqo=", "J7ygYdgVd47YcZxfT1QGMhPFAFpG7XrtDJedKtFVfDM=", "JVk75Fi3WlNppL1qhrcK55h26Vq5NwXSRBAdXfPkVwA=", "FWCAMOi7KozsX25pSJBkzSH5s2FwNMl1HFMFbMETwEs=", "FKtlfvUncyabQAK3osxtAepm7I61Gpfgvejvn1k+qsE=", "GvGFia6QBY0NsVafTU7PdBVDhsu2/pBWQxG0NAsaEdo=", "H2AQb4j6202Pl86ezCTQkQpFdcWnEAAlBLSPqij7kcw=", "AGYCezZdUSVfmcqrgtUAmuBm22W6EDli98ZfLy2upWI=", "GBMB+jh+Uh6JUaO/d8WULFu8So/MbDlcNLT0kakGirM=", "LcBMs6gKUjmhMpnupwugJlk/QMz0nLjr1z2imnZBPjs=", "K6VeHVzAkEMCdZfk/FRqGJIrr4XWqw7G7/HPE5IrVZI=", "LVsPAWOuR2k85zFWjNZ8VLgvJJ8qQp5YX2VADwx63eQ=", "A3SsR2n6b9C4Fm/WKhEjV5AjCKEnZFRT1y9SScpck2g=", "DnZ9YX275BCWhwj1hdugTplag0fvI+oQH+oIhQhAOqw=", "H7OO885Q8VhFHje/VIC6cKkfj87pMnSrAh3+1w8uKCI=", "FOI5qnO5Q+Ocm0irsgXMqk/1nWj50yW3F3kWZhd9tls=", "JxLZQBlUD18NYcEcLBbT36sCVzhYlr5Zwx/5ejfGVVs=", "Dm9SQ5JFLrrUCXOpgOCPaaveshTl63gw9yhMHRPjYDY=", "KUcLaSq0pVBSO0SGhOGX5r6byIW50xEMKBV1wbvGfKI=", "I5EIJ9DUpB7osTpxGuGbWsYEQBoiFBcXLDAYpJ3pWfs=", "C/WGL4mp02h/L7JGmAVw2W7SWOhBSsp+DJ33zugz3YU=", "ACcNSGP9AfJ7BVhGi8qVZIvI2zylWqpf6yfChq6tsns=", "Lfq+x2ceHpMrB/Fkq0nmnmPxc1E/LUoBXOjePhaMG8g=", "C6smrLxI+GSNc2Nmraop/eSSSAAC9QIMYiD7GH2uiJE=", "K83wgEMVRKTtJcnbhog3otF4dv17MAG/zCK8toZIO7E=", "IGSn67fmrenLzFliAO7JfKXi+b6yomrMZzuTohjxasc=", "BFHlhhfsiCeZsrM6rTS8qraocVOMIHggCbXaKjd7kao=", "JYL5V2tWsikHxLv6fkFVtOKK4Dh2lkzUCtsOJVtsGhQ=", "Gvc1FbZhvQORW1w7XYzsBgtJDXQsT0jUPtkHrGXqbIk=", "DuthmwFkXLMfH1FF0tGsoEXmn5qJdCz4X6plqPMHgcQ=", "G07muagfvwwgHQiYppSKCZXrzQgODOqDraPY7WGCqxc=", "BavgU5koivhO/rhI7GHVPdDwdDmYLgTjpaMEFmrBcw0=", "LMAsnM1j8j3OnsKzWHMi2kpM6/nMkkbHANtmEqp2lnQ=", "DaZPk1W8w8z4epaWs0TlaDytP4dqW55fcVoNcKlzAB8=", "LQs/OpAfiK2IwgEsKzL0658Cu9rt9M0eN7hPQBb+q3s=", "HVZlI+1n5xtf8Mxc0XoyXTCSvWalJ3OlN4luPG34bHY=", "A301RG4Z7tZiorYoEmsoUPfaoIeXTiH609M51+Lcwz4=", "IrWVR8M8N+bDAKNVb4fbumZ72oThuO+HQwpSKldt6fA=", "GW+Nb4UfW7zqahYUZWs4ow5by/8mHO8Z9uNAZqy9t0s=", "BXbW1txpLZ7XIyAF5j+VTS2hHHfm6RmyudzrrtoRtQc=", "Cdz9X/8L4t9aUmWFbCKsIxzt2BoTEjBPWJbwkJzD5qU=", "JveSKGzd6IjkVMHd8DWS1tYvS+SEOCNSZQmCn8tJYWM=", "KZkh27apIB+Kyn5p2BkCONXkqC3adDrthcojXKuAwWM=", "KGOiI4Vr3ULjUGnSBqUIjSF7X/um+6CTnKIoWM13Deo=", "D/pWCdG5qoSHIdLh4q1toF1DokHo4Kf1lQj/qbHt5DI=", "EdklJ02Prn1Rjf7OpYqaV9iGQgYpaeZ+RX6WLj7UoUQ=", "IcIZIEImvEPw2yRINJITqeVj6U0//yiy5pJojQ9bKxI=", "LASunyULoBlL9Z7KlATjr23NZN0443CgOPP9Hjl/UQQ=", "IjzKgx3HYNt7lU1BgQYUum4sYr4x6UiE1Mfl/6Z9pcY=", "JEs4lBBOUaFRpnHKEfyzQtGsIl9Dq+6DlGl0NFcTPYE=", "JPcdWgrASjh7dYxpeCRJ33ucztthY6fu2yHvQBRS9FA=", "Lvs2DZyg4V9SqkAz9MQj4PpcF1zdBeSuvMJ4p7gpa5c=", "Kf/X7z0BjJXoA5wumQ5M/mb/CTgQrUUIww4o6LuXBiA=", "Jn/3WlMhI4PszKxOijvy/J6YK6837ERHhgHPqm9BcjM=", "L7/Ess5sKwjLs+N0n7Iv89aNO7fTNc4OQuxtwnCQw4U=", "Ji+T3iAAXE3i9KXY0FXI1fVomRsKhiBH5a2UyIaLo8o=", "DwgL4np5H80XVXVPkx2bh/WtjBljoCqnyv3R6NMblOM=", "Iac1ITqMeEl25lyjvsSsxCJFJ0k80WJtI0YTOriHX/A=", "FgqS+2pgfV7nlJ/NVTfIQxxEnXmqUbuVWEXSy+aEu/w=", "AHkVn2NkVD62Q/BCRGHwATVzmBOECsdN6B33yeEMj3I=", "IoYkfFjqpFCbqvhblH5plQHTtfkBrMhHWn2deUFgbNU=", "ERBCUZi6BsQu+9tulYQNAcALXQiFDwzUZDXNuhvczqY=", "DsWhVXGVDOw8MZOsoBV5FgS32uGF17nYmS4CAYX/2Qk=", "Ig+YM1WXSTwuf0/jvcDNIp0MgbLQtvnlZcz2Xrood+M=", "HC+i0Xb01wcP5Fz+ao1LvQzmhaoZbkuiNypRleerZEo=", "KYwf4/Y1MaqYtqrQLkOKjyeLytTtl/PIKgkfrqkQ5Qs=", "LoFLLwiNkAEr7nTO7xDHATAzrxKDVt2kiOP+qzvyUlM=", "ISYJlE7AR5JfMcE9fKn9Q6TlSjP7CabslGPLY9JXDmk=", "FXu7nQVG+G5Ki15FADarCoTWEJ1VBshfI5Jn9LpYS1Y=", "E4782zRLW0D6qcCkFWZL/9dyQLWpy6VrSZ2i486ms9w=", "DKUOCNJ76lCPICcwIfboOc8SSlQ2He88mypkWV5Y/k8=", "DTTS1ZdaLanw3XLoRteXqzEgIjmeH+cJgPmD8Vh+98Q=", "AN0b5PP7A01GaagZIvoBTDwcXFdfOb2AmHfbK5//l0Q=", "JVQPzBYjB+OQarrnuiWOT6hP9N1P8ZdCoJadCAGLIb8=", "JPV5Npea4qO5dS03wBdXRJNSSiVKW7wQITt/prFa01s=", "Atm9YmR6RTNNtzYx2p2Xon6MYn6RG4Pxli3DQX3Gzik=", "FJnCmUrYOHcO46mvZDYqEN5sTF8y1atbuuVcoLKfv7o=", "FaZFmgju02vT4jFX3VlRK7yEhH436KTj99f9vHviCXA=", "FI1lpqdfvvszllvi3wmJ/gMfR0eJItJUbx7hJt5/Nfw=", "FtL0hlx204N5+1rS77Ied34BdEtOIJwJXTMuQe20V0g=", "DIbGnpSgA8xFTimQp62BZ8O71HMuZG+fkelhEUvGXDc=", "ALEiJ6MQ+GIsms/iuzIoqgXO5hBcQmjCZt1Bds5/jiE=", "La+R0iX5FYhObP2rQqy2LSdjQZh7w6JUGBnsd3TZDo0=", "C8To1VVhS6wbjMmbrn8AjLfIK1zRo8SBpVPK+Kw3P24=", "I3XzfQAwuJShqCmN0t1Z4rfnNmfzGxVuhtmzhhdQD60=", "Ho48K9DUhS4mGjwPqT2D+5wh1EtJV4Mw3LlxjL1UsoU=", "HoDsyimzRe2Ivo5TygQtbGKv0qRiTLrLO9B8hYOTMrQ=", "Lh9e5wM4xQxFb0MHchYSX+8xTGZTybpyx12ltTz+2pk=", "DpujGuE2+wGZ+dng2FgPVWBEnyqLap0PIj7FLEEgQx4=", "JN5S8VayII2BvxCceQ9Am6qUGreXivhvvA+JGl6QT3U=", "Bb3HIFomvxJwBlZCXrrEjRFQ4C/ptKywekFgnXFo8E0=", "An+BBlQtmaH5A1gq11cHbhivzlYzZ7Y9XQlz2AmTo9g=", "B8ryvDeF23rWgbtsBd3yRSXBnRUZqYG0QEWl94y6UrY=", "AjC4RGYQZsI0SDx/32MkSZIkU/+47zeXV1Ca3dgc13M=", "HFE6f/i9+UDvDQHnb9TsGQhhcOiMZClPc37yC2YZgqw=", "Dg6Xl5roZLVfJzcebG5hmre4h849hh/t2ErhEb6kDgw=", "Bi1GrcWRNHhM2vDE37bJ1zWPMV8JSHZcj8vJfsPzjrI=", "JkLO4jQIESeyi07bA4SXp5oqMTobdJ/S62fjd5QoNkU=", "JACzmCyS9/whgYiacIfA3JRtsrLo2G00ULwlT2UY2zc=", "JNqItPLC3HBV9KVfeDIjktgIwHby3my2oDiB8jVOkQY=", "GjlRzWklMWSBSErDmzG4NielSEwlnIGO4jonAMbOrJ8=", "LOyif7mWzbptbuHhBfpd+LprZ7hlkxwBdRX7QpCN4BA=", "FggdBL1lvBnkGt72/Y2ngU0rsM/fsuzOXfgqi+qHnm4=", "BO7UuJwO3hvViFGpMeTeeR5Mac8rERb4o2srxVkADkY=", "HWACG0E3sgd7MRc3hwBCAfILBwFBHEirnhRBj+Ju9Ls=", "FjbCnYVof+w6pBJbtm5dXxVWVXpIYMHfhRJ3kPCaYaE=", "JccW5epc4saitnGoY9Wss7LdSWOHn0wWPaagb7JlzEI=", "HezgAoS8aY6ir5fePUJs+QEQu0m+caOTwc5w6pcdtGA=", "KSoYVprtPChoUAHUDLQt2BU/qZABy9UnKcpvjixGbu4=", "Ju2qCrf37qyHdr/xILRIPOmmvOhdCZkx7JMiuh+/OIE=", "BdI/0HQ+DjcIlYg5LG3wsE1a7y5SaKsZwunps6OvSSE=", "MAu+wwLJuLfkuqBpkFcf712tJq9hjQd5tpl3okTFifU=", "Jp8tnOCY7uieaU1T07LZhhSQzxhOoJuvZA8Ao5rHKj0=", "ESKjf6DDeGNDEYK7gne9DoSbIXioFtMcdgT8UhnRqmI=", "FOLbvrMKOld6CyKZzprwU50I6uB0inIYgKrKr+GGRTg=", "L5JsZ3OoxBG4fcUZjDCZA9n0kq9vCkOlryAo5Un2yAE=", "EWnxEM/0lwC7X+6eUkpJ41iJxGieOEuSeYTplXxYf+M=", "AD/shj9AMnsGbmgFTIfSDO+h6xMUBSDUOmebnkoUemE=", "LodkDOtAEqmtoxSCx5oI9kurLiwBDLA2u6weSofIAb0=", "A+B6jo6GqGOxRxlHvS6WKRSbVVAqas2r9gntr6C8nZg=", "Izl9og/h3QX/Ico9IT/AznzkbEaVN8GiqvUilNL9ba4=", "F5czp1zhGv6KSEL4UJ5JMB90KNY8qDlzuNgVb9gqtpo=", "EMHooO6BEya4g8qOEPOtsSRCj/zFx9x56Dx5B7Kh6uk=", "JN+TaBtDh5pLthtcYoD01eE2AoeUW5eOWbGD8CMzh6s=", "IhQPNC/s744n40WEQ7qn38unrDXL1KGgmth8f2PXu1w=", "CLr4WJSQDsCDIiWdUXWzcP1K0z1fWZ1gnJXi0Vwm+94=", "JN6UiAgbhJFO/759VgBFmGdTY+NLQf4Om3gQeTAxLhc=", "HyUpEJOFb2SicdvYYUkxuXwx+OyNpxIbC7gsqnH0U8c=", "Eeq+TH7+OuxZKlzsaz9t0QlfnThOoM4EAmLqwPBTyRk=", "C3fbBCDsHjK5ug6ZBKKJIfI23tSPP0mqLXYaYxwlA4s=", "FonjWg/eex06bm0Uk4D/xrfZdygHpVOrfFBz6y4+3ho=", "FiI2s0PCwvf0izbz56fsl8B8zPIuMlTczEs6MPM8abM=", "JIyVHJUF0s8hNvayTCt0nHdRoBqxzYOTS+Evy7jQXIY=", "CUhwQvAUlMKvBGuUEFtwsbjl7RrF8VhAgwmmanemq6s=", "CpqXB2xdU0EcPo//a7U3ApCAtnEySBn7ivM9ltQyrOc=", "DEPV/AAgKS/S7NBoQs+oNz65vvip2YQ0i0P6lhSzLiM=", "FG0QrlOqr1lcuOjrKa3j5WyS2ptVo7wkvs8qL1+rA5M=", "G6y6QtgMZrOwYstd2mpiMEkthoWGJEfGOMybTsN0M3w=", "FuwWjbA3KpFE9RHF6GCwcROmcbMjlSqG6P1Acix/yHk=", "ARPlRXqt3+Gjk9diWtBb7EDp1Ep+GF6jrytYrmlat3s=", "GLqBSip/3RIG22ow97mPPEXKtZM2K+/csNKolqx4p/c=", "EGhDu8NuQGSFbrZojY86kKQ/+n9zv+Ywchab9SAkgyg=", "AM55D1SsLTSibKF83WQqMbHUAFwJdSxrxbQzBkzuYyI=", "K05Hym+JfjN9bVLB/zOlJIfGibq1/TViDYPFZ7V6YAo=", "JyGbg60kWbLfn3PfXNHS+L5mUS2VxPPYG6h2dAUZ2y0=", "IswJaAZhJVPlBH624OyNAXWbnfI8lvU7b7yqijYWuo8=", "Jz4KKlbkJD8hM72Q5UaSZHGEqIBf3SzrVBoiAlOniy8=", "DUSa60HozJsvMoVvidvxQJ1WBfxVfEPHz1c1cdWu6hQ=", "GwfPxg5hwWLcnxLeJTt/lSqSRr0sfERco1uFcuXXGaI=", "Dk7rUSw8rIR1NYl67U+57TS//YfAEqEX8qPaqBDfseY=", "JwIecg2gKGthwjt0jMfDWPtogtgQB4f7zmhfBuEQRsw=", "LqwfotEhJiS8XgCQ4lrA4BYPLXOQx5Ci3ndAd1gw5UI=", "DMBkWHaBf4FSzNkBCm8mKlFq8MookzCjQNtkdK5m0mE=", "LM+S0jpqvu5ueSS/DUqecEC3FeZiF5oYL9Ebsm//WMQ=", "G3ad3DERqdON8x9ICfMU10m4vp+mQtKqo2lh3N4L4jw=", "LcCaVji2GUxtbLecVu8gWwvh58g/yu+Ysc0TZSlcfS0=", "B+/KmtYmh1SgPvtnblk6jHWjq4StkEaFBlSlSIMS/U4=", "G7c7TjRbB0FUjaKqaYeDqMh+kjqxsQCOctc3++f22fI=", "BjUXO3VR/U/oMGq9dkoWm8zm83Gd1gbNC8HysRf8Nv4=", "GJ3Tsg0/j1Pw9aKtl/MA+Z67hAkKQ493OPKhJuqKRQo=", "Jl6N0fphlGGVLM0dOpbyqpSQbZ3wc2XCjdPpOiRPbuo=", "FDoFj+OYeq8cob8sN2tJeTEO9Uwpo+ZowSTlr0N5AsI=", "GG7I8cO6cK2DTBHOp5YnUNdse+hpHmeb0ZWmXf5pjsA=", "KBjrAxmYxVTJVwhCGARY0UkxbxTin+FiYAUHseUJUq8=", "CM+bF90sq8It5oBysPO73kvqxctYtXUhnHD5P+HsXeU=", "CimKnwRKFZC/tKaDUCfJSBpAbHZe1chBh4pcFLHE9O0=", "L0BQ5LOxUBfGwZ1Bd5DiL6bSkmnTO1TYAcSvmM9mLOk=", "Hx5QNfcsujoCJqBEf80oxrshHaX96SKUWMj305dKBqk=", "JXY/vJQhNdqF+vNU9Hs66fwnYGrXAb/n3j7nBNgWD50=", "DrYUK9oqXya0n23tq9y3qX8gkx/BQlaqheajsFmcg4M=", "H449ibXJcyWnBjxwMBQUSvGV7DfLiwnVRHhutnIejvQ=", "GgJ1g+Laet/7NTQJVwDcb31v8qehmwbX1p1+tj2kFYw=", "KCPTgiGQFx9ZJLT/5TgwUMswH7rNdFwuB0+JFSpTRww=", "F/znogX0LxfIChRqo1KOdKPPxEShKJz1NUB/72z6Ho0=", "IRt6EfHTbJwQqbPnjuUymuh+fv+8zlloJgtkyk3NBu0=", "GGE2i7mOoyKQdfSsjOrFERIOw/zoTq5jKwMTikS0vV8=", "ERtN+arYG0La1QTPB80pVsxISOft6M4QB1U494y391g=", "Et9uCEfbjQGziWOWA8h42RoZ9EYRf5pK78qQOMydFH0=", "LV5HQRTHxgIL16224VM3xOcvbvFTJBBudYXKP4wRbE8=", "Im5lWAikBi+LtHwTHOElus/mjnhA9LpkdoQQQcKAiYE=", "HwGp2YqtPZplpTc+1tK2cgMNwcqbRhSbv58ISn0k9OQ=", "LzV4y6g6rIqD80qvXGUbBXEZnjpN457AV55e4zmT/gM=", "GDkdQjxFQBlALPDsezbMEzJH65i5u0OcnBib6uv91aw=", "Jvz2yoEe3yZ72ADgsA9rSeYOWhPKlEgQo2YyWV14gYE=", "FA+bWFmE2TH+hWvfRRgF/KZK3+NNVbpPQUBIC9epes8=", "Eeh44X8fhnrek+kU5YAkRkOFq/ZAP9SmIuQfsdwi49w=", "H5l8beZk6c6wQsVb0iySMrhY5A/07+tAgsdvvWLd2OI=", "J3MoS26xxH8U3nHyMpicqb1qcKrhhn7glSmfZBnO5So=", "EGa4cwCvQ5yrg2YFIe6dA7BqF8mgC1t6jVa/xAH6W90=", "LxMJZEZ5MH6Y1iB2aihhzuWJ5tVd2XDIxD3nrYTX0RA=", "LxBDt/nktuw5qgdkAH5QMgYX2XqHvp37jwC0zCfFuus=", "GzrFUL/cb89O+YObZrMiO6257Mdq45/pXJpHwqEQLKs=", "BwvjDkN4Tc99meQzQQKmnEDHmB7u02DVuZaOfPGc/rE=", "DlUpxf1k45IPYRUH+umfjId+klf8Nnv1TdBz8JGjxlE=", "EdiPe1ZJpLDh94jInvGQ7ZF9vjnKZMxYzehjOqR5uV4=", "L2y/8YqG2LQPiXOxzjC92s0vJIofR/H2bTIB/UbZPRc=", "F2gjlieIy3SOEu1ZQmutjuiBOBAkmT1XA8LBB5wLeFY=", "B3w6wRUM2kOUquTjlR+NCuvbb+noszbYme12N0WHWtc=", "I1XHIltgJRaARasfnPfWdU6DNlVj5FohGqmX0bhejzM=", "GG8La21gQKfhQL9yt0pxsjxt3B6EluL3M3V64ADpACc=", "FHQIQFFrgNI092oC3DEn+aX/qxs/I0aqnJuRAFhDXtI=", "IgNDO+BmgL8u8FCE9FyvttjpQVjGWYqxY087pm3Rbko=", "IX0+mENVqh9t9lLxAbvcKBxpt8dRZKE/0pd2uAsqkxQ=", "F3fwa6PrxH76Q5WfoIm76LrOZPmkQGk3YAwnPb4h5NE=", "H9ilTfTm7UarXSmXufqwQOi0hw9XVDZIUMUIqeVz52c=", "EdVLjJSe/LmYFjKNt67uCkEsfQdKmGoGA+qvWs/jKh0=", "LMQeUtj5hu53xZsd4mkK5OR47/JdTxA7FcwFynq3RG0=", "BHxf6/d0xiIVqn5sw0OYmPV2BB8ZqzyFALB9XBmnb6I=", "Lphw7VjfpX0QCBkRY2i7+6gcaaSQOoUXnPekwqjzFEU=", "H63TvTpcYVik/z8K6jdPljX1IRcwx5s50Dn5zhesiUU=", "KlyBDWxDqy0p/xxapG5NmCwbZSe2oug+xVzQzE1F0cg=", "Efr+mDQwE8L9O0Nk4eWSLbW+XA96/de4ZF0HtMkdQQ0=", "HRqCqLJdUD60rmXWv1ETBJNCwMEOLzy42pU2yVsSEcs=", "Ev8YruK6N/RI6J3LUHE1VjfV0VVFz5z45guq8suDJ5M=", "EXN+ZUwzdK5fTrXHTyA9HaKqgSu2CwxcrLXwHAsPY+U=", "GvP6+LLalEAQxeOzU1WrWT1Z+q5AQWWgfOku4RNW0rE=", "BcoXmtDaNZ2SJS/zMk6ISvJbDt+b0XAOAS9FtoO8LfA=", "HWpZiFGx7LudOsRw2V7L1YijsyMDpM2KdoDvXfK5X10=", "AWFyDc6hSq1+BxCmcVGSG7nVxAusE2Z0+GLBxDiZ2VQ=", "Izhc1J21dfc1UHWfZ530jL0e0daZMnABed9v1hhw5Jc=", "EzkhcUnadNULJaQ8yAJ0IOJy/BNnJXAvgdqINdC59BA=", "JlFlmtabN6R67Am+cUgbzjyrI9wEwxYRjUBwBVAbDAo=", "Aoc3VeXXmWmFTMyqNs2EZqqi4FlOO6N7j1G7Omybh9A=", "C/huykwEjVn/P/1hDIGn+Zh1zg/x4ZNBX7wrzENVQY4=", "EnI3qgkKQU8mdrxbJndqQg19pu+RSonfsupDS220LFQ=", "Cq8BJZP8AUyriHm+i2PiTqgpt4D+nNkbaIknBRAtrgk=", "I0lRG88+FLWsvJc+QAY9IMGkL76eXe6Zlk39UIadAoY=", "ChOHfoL9VL95RX5wOjxXgOqxlwqbN032mIEpwy4u+4E=", "LxNETAJGYT5KjwbFS3c6VTtu+Ur2XTQ3wE4/aFbubn4=", "FJ+fha+hIKql2zjhOU9TbMFTD/tjnikq+zE2+wURceQ=", "Ca8ex41OqlUvFPpuftQYQqQRyL0rSclyHc1t6A4WSbk=", "FZgwbGa2miI6FpJZOGIXucVDu2OyJsKDfINQcPpu5yQ=", "BS0ArGA64m7f19iUWv7iAhp/jNNxmYL0Y752XSa+l8o=", "LQtb/N2+mutChqyp0Q+aeDF2v4ud3lUAjiMrno9FtUE=", "IudtYXvGknjDl2FF++yKEd7XDmu5sUc51Z13RfvoATM=", "EOByXmLmYNxaZ14tpgyPHOdWwWKhC1PNoJi7FH2vwTg=", "FS5YedtzLvAm0nSNaxfCEAWiMSXswBrOSyrUZ0S2kY8=", "LAVkzSBDpQeQG1BU2y5u2ijJRTYBPOZupXZ65FPAnVE=", "CmH9uHSCRfu/Am/jzWpCuHOBnIOQXEKl16AbPOMKYjM=", "DYazieZj2v68XutyAU7k/9IFhB+75D3LVaBwG0LCHnA=", "Kw6gbqKbXr9ZRv8F36VtodufkRh65niaUSgyhrckK1s=", "LJ09ZVkantB2GN308QdwWWo/zyXd9HISbIyws/iXVnU=", "BerqlmPNMZ17Y5D9N6W5FtCty96g72DeW+o9tj6XM3Q=", "HOsIjcjkdu7iIg316JyZQ9KPmvNq2y260XQfGdBkEJw=", "H4jHE/p/nq4rqA8qy+5WqsgaJFSt1msecL7h5TO96V8=", "BfwQybOrpCN4YhChiajL8GOUSNI5CIkmq5Y0bMVD910=", "CX+ZJ3o9j9LZVN5sLVjjP2UgilO8NtE4PC0XeXtJtSA=", "KVUIoGlmGngiJ7oqdMIS1HKPuOhpXxtIJvh0CKxNCHo=", "B2C9XTCCcB/Z59F9UwpFfUGnvlXOa2CK4jY8PEXbRXY=", "D2xBP1EGf7Mk2gSyE/qJD7lTMy6GPfOwb7/j1d5zJnM=", "GwqEKyP18AWaAvJledlSYJMbZDhb5CVVNwJwy0YutV4=", "CJjl9NYrtZE/5f0uO3VECIfRFW9BWu4YzWf8nXKBNOI=", "EPiFJlYFX2NSJ2QkpU7ImfxubYekKZ7QzLkAEcrLEZg=", "FbEurbEAOuY4Kz0ziFSlACwVwD2bsChC4D+7ddp2nME=", "AFjX8czd8m/fpu4K/TQJ7BA7kfSZJRgwCsKnu/glg/o=", "JKz0MeZ6nX8b7UQXVrA6d3qZ+nKAsR3vEGHN6yh4u4s=", "Go5y47dkaMQ0u6TxkekBcKZCzn670okIfRh8MF8TpM8=", "FVqYHxYcjDx1b+IE/yolzg9TRpV9afrcaFXGEH4CqNQ=", "HHR7lNuljDlwQUhRMYpv30yGpfZeTZHo1HcvVntJqIM=", "JZ+RGfr8/zwKmNgo2qXRrCEojG68jhb06Khd/P9EL5U=", "HFzRs0BADjejfeCbsgdT1JeTIuI/2snHr/n4IJ7qE10=", "KJcuyBmsA+ZbCwDFLr6sA7XveCgf5UO7P052LnkExvY=", "J34t2ikwFMXHZmKCbdPXbMfGYtKLKQW7se86P1CB3Ko=", "B24Frun4x0nRqYs0AvSiyHvihAZZpRguFcqH8xgJyE4=", "JrIpHDHc3MLrVfAEweq0lkkNAl8SJlvoNfeDqWE63xQ=", "HsrFOu634spDaiANqvHpdb6KxoeoECviOn8pHZJEhB8=", "EXZgA73/Xs81IBRQF3bQou7h96iJhAmyGr81pwkvRhA=", "C+ytYOjqsQeTP5JJXsblBwsmFJ6ua7EAUZdVYiUjn5Q=", "CM+8Xh9e//j7Fza/EYz98PvYHL6H6mGTHc8MxwscSIo=", "FfYwdrIKGfVF6n+dOGxj765hne/ZDP2DR+Pn7tprLWo=", "CpichsqX+UZyQNkjmlGuuox3cqS2izf5f0+6JpWLvho=", "C2ZnAnxBUwz8HPfGtgv3T9FaEYb/wLd/CXbV4dRQGpU=", "CofdIFgwvu3T+L+SI1zieOLIUp658aRFMM4bJibEnAE=", "JKgz2PXbfPSeiJ/iPFGFEKiVgB9/KHU4U4ujsIKPgQE=", "KgEWKV4gdMI+G9gXhCWG0RXPpxA92YJF5tNkyp1WQsU=", "GCckAkvRtIenqIZgTkMS8l3xG7KWPqFSZJzttv/PQ9g=", "LsT9Fx4JJ9yTMVQOH2Y54VQetODLdMZs3tlboF5xi4w=", "K+wp914TrnACITu9gbqYSFAdYTiUWW6fo11zT/6a1Q0=", "DKj+hj+yNsEK507AlKif+XS12cxJhUb3bAvxpRCo+YQ=", "FX5q3DnphP9g6QT/2F1LBsD3yV2LIk6rsOEJDAgKMgQ=", "EzfmuVABiulvRiFEJSEJB+dXiuqg9i/jr7mHfuMQF4I=", "Jn8KwyWTBGHe9q/E9UttCeFj6EwApBQHk40tJj/WSbs=", "HASQATZqNSHb/fzpLDJK0CHQNXZ5EVdPvUtOkACumk4=", "Fn2ybR+T2RFBxIsafs94qz9xRIFZTz6x2rSkt4MpcG8=", "FZ+iPiqoG3h9cPrPQWB5to3muNfA4jRCH8RQwvGRclY=", "Ka2vIM9ZwIICCadJxho2uE6xaCh/esZAo330pWnD3vo=", "A8OQaUunq0gAuTEhu1OjbWVNzqj/m9pkyVdw+lRdrVk=", "CR+UKS9rUlJXK7QZ7EVdVDXqsUc+69ctiyCuP94BRsI=", "KdZNA1a2zQfKvBjrXeKHKMJGZjxgEz3Zieia+X9dwhI=", "MEiXqlA2s6gHdOQJmU9dHnGng29XeDnTuS2ThZCIhpc=", "El4N2PJJSG8TO4vLkXnFUlkpysOrCbuu/ZenUby4foM=", "L+9py54hqletwHSdMjEOu8OSHXX4tceZeKXoPWaIjm4=", "Hjr0CL6M/ku+A4SacR/K2FtPJ5d3M1JPK9NbcWZDhoc=", "BOZV32EUZIIg86KgVoBaY2MHuAl3npOXlT2/2LlHe1Q=", "KkMinmZgk75hhOKStKh9YFzThgA3+irvB0htT4Vtyow=", "FW+a7HNZ5UJ9X5ehZcq0R9JwidzknxQB6Ww34VlJDNE=", "ISRYJB4pqD0NEcZP2w0sXnA29EHlOUpiX1LBEA+NrqU=", "HdkJ9aMqZXqJ6vlIoR+O6odO7M9JYysxAxTXftcsYlc=", "GdioH0hnxAzSkjRN+NLdZLB/6tQFQQdBSkW7UEu+YOA=", "HyhaQ4/HymLtvb+l+a5if9Gmto1Lu9erhnw023PGKNI=", "Bu3SyXy47123ETYHQ0WN3m1F3g+0HGRqcq/g4CAzqd0=", "Lzdx+YTTNMcpiXPpss+qGtWYnPN5vEH3i5ZAc5Vbl48=", "KrvEO5IkGISVzZ7IR58512O41WDfTp3qHNexYY/Oyb4=", "JRePCDiRU6ojbh2jw7ul5AjVK6kTw3GBKKWW/EB1WlQ=", "GygEXTbOlMpyrVU5xU1qmocuZv5iBqJRph31r9UOPpM=", "EcFmRjPxL9k6NdhVP7jh6/Prq3NhRkLaSPdCSDwNgUg=", "GTB8aYDGrbf+HUU5wQ1hVzEK9FzqpGGMDUpn9xpKjDE=", "FPrkbQBzPl9+jr+zYIUzEfAh4qJScFRTysI9/Ncrcu8=", "Dj0UVeR507mbyx+LZipDyIWpkRsjjgj8T6a9EJA2lJI=", "Dz4oXoVd4HnC88VitQdNCVtXJosKsaoHxPdlAlQIfX8=", "JK1YULT5I6vWh9vEr+dbomA599SzPMQ7tV9gC+X9Lr0=", "CiIUPrGCF+GUVeAjvVcdHnV8zImFBQT1gOQzy0Cv3ac=", "C5aMCyePMunuG0rf83q6PRXVlDp3rHeDNTOXtyxw1TM=", "J2mQ5dwNsDC42IpYKKSzQxd9zVVPzoo2aS90/zj2TGg=", "HxgKzqp2byS5JVIkJEigEyZYCpwtvirj/7tTDyO6Fxc=", "Ld30oUdXso3gPP4hC+M4z+O2P4oC1/sBVaycbj4ra9A=", "FIGEEQjoCZaweePpd1eEQ84OqImdVY3ZLFzyAnl5Xdw=", "KjpqFzQByoPTOwmX6qKAW/eGnMfeukBPOV7hTgbao+I=", "Edc3LbW3ljYylsa5kEDYg61m9UhitJZfXaDuAie7xFY=", "Az51fpnj8cqCbJpkinPeN0oRwoOAJM9zbdMcW198CCU=", "DhuuXnRt7VEOqhFFV0qEaMOn4mkaezJKm577NqnN1K0=", "IYGLH7qwy6HvICRe2ZRRyh3MqJkiLBR7QxVTAWoJ3EE=", "GiYExlees7HoA0JySezxdCqb1ypq2aw4RRkfjFNvfZE=", "L0G11dNJ6VXhX1C6DMPT6FTpBl+NYkYTMszXRry1eGU=", "A5T/8sAlAnY1z0p8t1iKbvWH7ZlDFOn4E7ermfjUwyo=", "Cp0OvdjNw5K6RG1tzVyTgN/yl18nXjD2NtyWQbKiNio=", "JVSYy+fJ6JWAVI8NkiVf6aF3VWnDgKvRjSIASAe2iHQ=", "Kd+xo1/lx/JUkLbi4wPXEYhwUcCSqOZCwH3BMK05AbI=", "JaWZWpjvD1QCslsgMWmER/+JqbYwCU1xqu34tfxMzf0=", "A4/2Bf7t96dA6JCGL9WT+3EqoZtHIdDZewqF6nfytiE=", "GqINcw9TsDWBPxUEqFPsh/ibtWsF+3s08h3rGq1MGME=", "ESTysz4FxBWn2YgdlIueFfWJHIFqBJXo5i6JCJopZz8=", "BR067yRO068YgNaGWLT6RSqj+Kt5600d4qG4J/teo1k=", "GMORHT4l29kBpzdzJ8ViJSKin1b8stOVxMmsHgVAnTo=", "CeCkdz7Vq/JuR0yAUOlXjFOYq/xC0q5mpyw5V2It4Vc=", "LeQ2yKIX8yvl0UUb+/9+P2s61GotpY+EOZCNKFya/lU=", "JprSjLH6wiOGHaZkrN8zDBcy51zp0agAcdj2I+ZodY8=", "GNXJ8KjDwcYqMaEtlFrFYufyjpURRdcAdRtZ9cTgRt0=", "HuwWnqeaFJtqTFs6zolPQhd53J6bs2bo7N7y6zxT/Tk=", "CYLOUY09LjdJ2r5rV3WP7562Y6mW272RrsDthOqnXt4=", "JyAH7p1+x++2yA8lohEPlNIKxDb3xQweK39r3MdpCfM=", "EHLT1UDRsA38kj3K4QLyts42PlBUs9/ivs5Pls0V1kc=", "KLuNcZTUEjdnc41rTXOgWpTI6Tx+CPgIw6S99WRCASA=", "BLqhjbPbUB055CxJ8czjDdVhnh69FCZoV+OKdTxj3eY=", "Ewx3Y3vfGjNtm0yDEE7R57gYCBQqC/GydxtTDu2Z8D8=", "AsDOVtoSz/Ke/7w9ybBb0H161Cdk/yg1DHxIzkitSvk=", "I+rHaV/qI6ovLsnh6ntiyvXnHtYQZgCb+Tpu8/dAVqQ=", "HHm+QDgh9oD6+CiYByRKazwE0HFhNNCJrdRNu5facXI=", "BaSKvCgfdx7DbcpiaPWR67reBbI/uB55YcjN/11cglU=", "Airvwemk0GzHZOlJhjS9qXvxHu3VhQEAptvIWGGdJrw=", "EA+0AOKq7KaMy91MsFKN07jaggfWvOLUG0rswfByBYE=", "BPCx1fv3yUZ+gmw4VCS5H6/35fa1njdlHcS8pQAyfMU=", "BuM6ELm6+gTyDz5ZbAwdmGg2t8FqVspIZp1aBRQnAWA=", "CBvwVjNbHETEYcTW/B+eAyoYudL38kAHJNsGOFvfB3Q=", "BsoDqXpWGKxnHU0sGFAeXoWIvXk7LDtU3BVNH0C/YnE=", "EUvb2IeY2tWNy9uaH73BI+0bVkkKAVt8KUPrWq2e0d0=", "Ib0o/UnLEVG+GvrBy+0LcFt2BYeEq5L8s6IlgpF4BIk=", "JVFuNYBFKQ17zOG0Y2yjMJUULUsB8i732U4oz4Hp4p0=", "Id7mArJeWmeInvJDrJyJG3PrxxfH2BYZlddL9OW+wH0=", "IFmSEB73xcNJOuv1+463rNATGVJN21b7ddwVmgE+nIg=", "BmfPabRtz65y9/5rXYHm0Rke8CkoCAPuwDL1/66xIBk=", "K3qQJ/oFJD/7qkhtqsrvhQxNAzuEs2QduY/eATFeW+Y=", "LHrtE6qQZOBsTdkplHn9L79W9z7f3koRfLjbVNx24TQ=", "GfdtDB9bHvxhxkUYDFRBtWmpCtcRD1EnEEbGQveO5KY=", "BHSdLMPTxWEtdYbvEhTeOPhI2LPZr6Jm4VPto5IOcsI=", "KFjgQtvVEtnsFH/NXMD/IVcLtejaOyD39prL0oeFYQ0=", "F6XPJQj3htc0l/uwHxoC3Yvt7Ymio8IXC6HzsusxyWQ=", "CMezJjz9q+p4TSGi2Ii3sQ1slaKCoQFpyF8ioiu3jmY=", "FgT4SQviTmrbw3210j+CvXBlRtTnjAjjnBWAt8BNRv4=", "BNLk2xOtrUm7+TCtJDFnx3KXq+G9c7XRSFKe/XXr7gA=", "JJNhiIvexY2sU/nAF1LF9u172X/Cez/UHgy5C5spN8Y=", "AB/yV/i5D8PMP0g7liPKJlGeTgSubdOO8kJ1JYp/FJQ=", "J+nJHjC2tePDCX6hn+U0FyeivY3Lr/ONBXMTFp4/vsE=", "AiFUAV3/nfqU96gzn0/xGKj4F236ssiEaLLKx+ORTP0=", "A6CEcpRKTITuf+dqxhuhKtG17Op9FNTe3IsveoeOKvo=", "InBmuJNQqLE55b+LFGYMq6NpsIKLTKulhgD4DKzoSrc=", "GIVB+hLad+IdBBA1GQ4K8ycoGTGI93Ip15oIzeNeEfo=", "Jd1cHv0WI1LyWrd2mFsP/8Bd63CUu20oedkly6Moz78=", "Ep8pLpz8fNsbKuLHwww7tJE0nO9PfWWBLWYJWunqKqY=", "IGqAntp9OW0DTomBNxmljKrjgOufIh9EW2fNWnUU3UQ=", "Ln9WahjFxCi1W0t9S9rsY/chtZxKMHp6dARY3NnQXZo=", "HA3wsQDk5yip56o09rDbDaa4/JnD03fxVgqhVrfyYmo=", "C4daNmcQwGkYcrJtmpikmOkprMLmd4aMTM/2Yzlc+3I=", "IUFo6R07apTUhHaxtCTxYkC/yP/2dCSUzIlxA7p9JFk=", "Abq0it5Ga/Y2gTY0Yk2vc7bF1mFDQFQolXlcSXFjUek=", "DIQl4bJHDKQkOXz6ZmZfuGGjr07WbbkEX7tqf3YUedY=", "CHDhOZT+MflLgstJI+ggoTw31xHVbcxxj0sVoD1ifXI=", "FOu8/Ke+F6Xvw1aQSjGfSWm01BNvECb1dADNfbQk13g=", "It1epppQNv0NT2MVOvOG/rI7y9AhEtC3V0pjFbTdX9E=", "HnKgmeies3RD5C3h/33vFUlICFJgDPRVL7F0ZqvYnsU=", "AY/mX/D4kBYDzq6kp0YvvOuA32JgKpwTImTFqkneDPs=", "G2Sf5goXeSJSp37DZe+DL9NyJQXuQLCJmcco1cbbKmI=", "GKQvJ2Mgcbh1Jtldy33iY2KqKKvqQmxzz2eUULypWeo=", "Iqt+pwDbKyh7MB0BASTB0q9Y92Q0uLxHxZqohiCt2EA=", "Jtrak13u+FUam91HSYVZLipunqNSLAevxL85V3IRAR4=", "DG9Bf4il/giDny6LkAfiNg4dYY4bRqSXnLpZ0ptxlkQ=", "JHiP87CMTQ+wtRubQ1j8DL0xyjG6BVFYVaM6KC4t4eA=", "HbP8riSrWXIe/5rKXV1B7p14MaeaRa0+04WxMip7J4U=", "H0X9V+gR1OV0UWV12GUBzmvpJG9Ykd3vYrfM+DW/3KE=", "EazsCxPQWNxscjnrqQNKozcC2hfeddYwbygqGyvRaJI=", "IazbBdVa4fSq2HPsWttrYHgXAGOnDNLmMZ6gzvgzzyk=", "EQ2blNSXmbZZ4UJpnnZ9lWTORRebUiZI+oqDtF+NdtM=", "GNsrWLQHQfLgB/cBGOOhobwhUOBPo05CHbUGjeGePyQ=", "AUdoxpNBJtDr+97zQbV+0ikHbXA0juza2GR7HQ33GR4=", "FwTS0uGHagdbFnpl9swm2IN/fi0/diiqJtP3aWliwjc=", "LLgUdnD3Pi/3mtGRLINdPT8rI4H2DrN0RKbAwXO1N+c=", "CQi54iCIW0F7WNsdoMqXTC1le1CuHDxeEUESqSWnFZ0=", "Dw2FtFhhYet+E1P763qz4xtbYucgN57+P2VJB5rD5g4=", "IQP69mPDVJyb0HPeIUWFwa7b1QI+SlrmGZb14isKSmU=", "Enygxk02EGOmx9o3xsPCCAGBtt6l+2NGkVby+khuf/o=", "DD6d0Jn5ymAO3gOa2nifKHle9/xlDoRUAvwV+Z1IwAs=", "DqBbXU2IubX+NUBvF8obtKhV4KbufWCzHjaioh9BH84=", "CWPEvgccMv0GpSEkwNh67+WVwdsrLmwsnO9TRWu6MLQ=", "Cv+JwegUEEaPpR53dvI6B38nRGvZjMchifZBtkVuzOo=", "FedTAn1jM3ozDCYAAAguoHVIpyTcr6JV5nt3RVdGJKI=", "H3rLf/RqfGIzgRVcaCk3S7d1h6vR+fprh53zJAlUrXU=", "DGKj3gu2gRB8TcbZ5iPQViy2eE8kA2k/3WRiIgOxaGQ=", "Fs5YIBbPLhg425fcvs6HP0n4xgci11bFUa8607GpM7w=", "Kc1eL9K2hOR8B4/Vb4UrHduwfrz5lb6ZHpwiWVOfoDI=", "Euj/k81cPX4EVdnrDn6f+UBXXEHDXR5eRB5TDqiIqQg=", "DzxACGchnUDmq/LvIqkJAYEeyVxhkGxzDL53d2HOEvg=", "KmH5a8U8IyjdyF5FCWyVMsAS9HE7i4yLH+Eif4/XYMA=", "HKlKtwblaaT8G9Nsm2NFfV1yNbNWvla9+u8k+ZN4tGc=", "K9SiOH5uwSQVXeRwCXieG5Ra2jraxeNRBzmL1WlSQJA=", "AEVBULo0VIqFGxkfsanzWHRk3hes/bDd63FaLmQ3MXQ=", "HyKzm+3RFalQ99eExwMcoOw9GmpnN117bt5IDFyhRf8=", "B5pmFWz7mcwXxtOfycIhm7iSR7bK+TZY1Zxv0KHRuwY=", "F+5t8IIjcYNMIi+VTwOwFrjVrU2xvmbz+UbV0CjmUXY=", "JM3hQWm0p1jDoSarP48YB3+9/uDwP6e8z5mZGd1BeAQ=", "IK0I01WMnv4DyIla1NyIv4q17Uhn4azeZTPqL4bZ+n4=", "HQ6H5gTQEJGJjW6F0qua+brgOrURo0zZpiDwiP348eA=", "AxCjGZUvP24lAVq8zkn6gRC6ODwEhBPImaxNICw2uAQ=", "FXCxHmRhT9SQRyecRUB46qnPuIOpQ0oGT3Y0IbJrJwk=", "B6aFCrmXukWDekIsHARm5s2vdvrCGZ8T9jmGsqGc8tc=", "AsJTRAQ2QsY0pMAR2YGqp+Xxec6epOkh6NUtDlcWnOI=", "CfdOioXCk+6KLnH20jSVvNneVsLgA0FpA07uhVlvWno=", "B5M2NjIgx1NZCrIeFkq6UYlmp0gMSyiQ9FJyNoqyqXw=", "H/BGr6zRT7o0bOcu3yPlQNEIQq1+48czRnd5UYqacNk=", "EdZMwXwJXknEXrHKK61IKoIDJgA9ScjPnpwC7LestLc=", "LtIMC44z9X3tVYHPk3pAVfaAt9ctZcVUwBRWgIfVdy0=", "JZy9JE6oyYQL7Nct8p6W/Ym2w5x75ysWvp8OQ7c+724=", "Hn0vIZFylfw3WFQiXmOtUD4n6NbJIl2zXCujdc9Pj8Y=", "JX4xp7at2Qxhe5MyW603En8HMt+sTQrZMzH6eZkhKlo=", "Ha1U+tQnPpOXHe/33D/nSr7xz2wwKmRAP8doOWaXUBk=", "KWoClnpVE+GCfinHcoW+ZGgqsULRPG0rfrWMCSDf0Ng=", "MBL/YfYwoDUrdB5j1ijdvtR0rmmTrNwPnjFOjspZD50=", "D8uPohZ+u2tPQiExqO2EEwazoIQPJY1o7bR36OHr+io=", "ATV2fl0xEuB3dgfBxbkbEUi6ZB3OoH4cI1XCYChbocw=", "CRlDCY/QyUqv6r9NvElLY4XjmWnAbApoVN4MfmiMTXc=", "EwEGB9JOeheMQ9m9aCEhV3djIdlUONVyo7bvdxQeEbg=", "FnmdaSMbmAJ4mt+dIkaEQnZ0YbSdWU6alQ3Y1cpJ59M=", "HrB7cEAf6TuB35eh9FmZR6aoEuNEmL8qu+sdJWoo7cc=", "AFzdmnl7zx3vI+jKEguQCnYms1fvhpZE8or+DAU/Pu8=", "JLINiFzZpjGCaarql7JGnCtg9+o3HGqcIj7u2uy6SeQ=", "KYawujo+IyEp48RE6UglhP2D1tan2b9DEgpMVu5dsDs=", "GhiFN7eM6fZj1ktXVdpTz4jsruhSRCdn/BYCX/emZ4A=", "CGGRNHSYQZFb9fkswgRev7EkUGubJSVb6BSjso++EY0=", "ATXPbDzQxpRYH8Lkd9ZTinsjP4nSJjc2IngbApNA8MY=", "BPmlJU3/dlygQD76oqzZCWt/WfvCADkThmC4ksgIBoo=", "KbzdbGcvChhwcI036FEwIlxfyCbp5iFGMT++HuLHTR8=", "DB13f47tkR1MwOUMP0MM6aHV1xdoAL7cNvkrfkpoX+A=", "H/6Kn/vHbUbC6iq8Dh+zgx8YyBFEvOYCgR3jliPUpJM=", "IWzT5m7oKx2mWFSfTfE+w/OM6TQWc8SYWf8Ogxgnp+E=", "BrgGiDv2k4ixSK/XO0iA/2O8V+CJ7yVuSla+/nir27M=", "GGj2UhTOhZlGoqhusJJaZQzE1HqVuYijvZilQG+q7Is=", "IBsss/sAAlhL7/afqoooloznMgf3MTNqPVaGC8jTPT0=", "DxyZj/1lfVr189FQD5ghRTdD+s4Dri/9BVvt9iS3Zpk=", "HY1YT9OT0qjF+p+yhAASpOXP0fypf4O/bMpGiLOTH08=", "HUxex5LQ+eEhwX/1dU7/mAokd/FC+7gVkBtsWX9fUQE=", "BYKD2agsv9jwFnU3OqY9knnpu0Y8IlrniVqMUaeUvxU=", "J5e+SMmcGaFB5XzuMreEX1U5I7CEdHlsvg6555sF+OE=", "K1SJYRbMRd+qRyBNUVYHXR3smM/KdEevTpNFfsHZ7G8=", "Gy+tLte67j+z0hl9ap7cow7OQpJfE0geD3gBchGfsT0=", "BrVOP914XgmfeRyU+r/GLDz3WWPCGnWmDmXaiW6jfcg=", "LzyJYzZaQFiovnqR5uRR3LHXkzqoSEpapzWWg8z6h+g=", "L9mSnciVkw6wmGYe0NFS8oaL/qE+iZLQimklO56a/H0=", "JdHr6OnsD8bRgrkG10dJjLn6VaKY+Pn2ybTMLrMmrck=", "C25lNrowILviWfRascOLL102hluErIJBcg0ozfvDQSI=", "I7i02yLo/5k+Etm4F1fR5+3Gw53U3kfvbKyhR+n61xM=", "HCMr9hy3096Ldh/akwTCRCCwWf0B1Cx0aTGSrXdjTWk=", "BtAYSiH0WT2vho2VYORke1KDiSUm9qf5xe4mY8Zm1Wc=", "HZbsrcNPDvn1qcEGUdb/4/r6bWxxB9ipLt5AbCKd75M=", "JdaVT2uOWExl1woNn8W1dbX+NOfKZtgnOSjtS4/RkwM=", "ARVg0FgXtxFq68Cw482mUOaMD1KPYlk68TWH1oO/Pjc=", "Cke8VWob32Oa7g6v5s9+e5AWebGxSkfb/6Gxmv34d6w=", "KHr0k9L5Hv2eEvO8fHxODgTf6J+p5oJC/EGNrucze+o=", "EUmAMk7vhfkMOHeug6SABau6sMPA999GsyRNhAGbpas=", "Ly8HTJvCdtn6FyqB6VS2Fsr6yhEJDaTDMPN1nGjqwqU=", "E9GaWXKK/dpFg6nhgMy5sJX1tXKehmhRmCcRkDrc/hM=", "Jg8Dilv5R5CyLyeW531l1LUxQKsYxhevfaWbseutj0Y=", "AnCUSFS3cRFb6drjuuYAeDjoExH/d+M0dVw3wvirzLE=", "KfupCA4iAaTQnxeZGdj44psit6/xGjw6G6i/02iAcy4=", "BzXVUZ5/nPr6npQ/9U+QS63TwHgSpxFVV502GAOw0wA=", "Ej2IunjV1jOtT0547CgG1kKtjSSqm6jW6kOT04xaeU4=", "Lyw2iabOfRw2qkKQbdi2lL51Kk1WQ8yGNVAamH5jjao=", "Cp83yQFFayow6NVtZa+vfL6Qs6abRxEvapCe4ciWwLw=", "BpbRpSzZZcYbgzPP758UfafL2u1xvl/MCk7tOs/70D0=", "LfZCBtnLfnY9lMcuhdom5hR8oCI29nCju5fQcFzb8f8=", "D5JO7sCQsSOuZ4pHqj1Muy+8M9LqEK/8y9Vb1YAhzHA=", "E3aOnWuoVMVXEk5+zy57mmo7weJXUcXbULaBuD9eTms=", "BSV/EhNTjRGK6EuJ4q3efkAD4EKDb9oyplqmPJanAqc=", "Lt24VMTeBYFIJxV+nXYA4FPGhjRlN3dlkskanFHvrv0=", "DFsobkanD4EmGheZwDbP86E43TGvhH7qN5v9zoz/3cw=", "KM6xMRrj8hEsWe/y8d428Cf+dI45jmHi37X0FgUZW3Y=", "ArqjxCjU854d1RFyhAzsr8k4aaXU0sRR7yYbkdgz6xg=", "Ev3fy6TtxI/6Cvkn5dKdZ4ytQ7HliJ5JZRJCPFHHUZQ=", "H/5KQldlrLtN2PZx8Rw6vtHkPMhynI1yWKeHNm5pNb0=", "BRjhFnY513Jt6BTlc/jW5kTeJAGQ6yLaB6wqbdGkn8U=", "EIgIjKOy7F7zQG2LGUmECSU0I6DLqlebeM/iK40v/dg=", "AUETLmOb45D1T7RtrxvDOmmNoxtuISQawlupG0p6I0Q=", "LTDkB1eWBQwPQARABZs7CBQaPAlpVcAHIPN+M0mxADc=", "BsD40gUEENeXl046IrSNe0qg9MEtt8caMZrexDYZQbM=", "AncUBZs8olMeOmXgJNO9RoaehUtoiEprFoaRCallMzo=", "EUPpYAM7KDfjWRGyJZZvs1Wfhphop1h2hM1yEOys6dA=", "JFYQIrM1I0Evt4US45YXIm7IdAIZOdPQ6bekAXlGMrU=", "Ilo6I5BU7wYeZktW1l79Yt2+XP759VvUAqMni5TJvB8=", "BL4WWlM9GbSaAVHnGDhopRIKLmQitQBEEFC0HEhjBbI=", "FyWFcaqHxj1HfRDmTQaf3yMabkfUox3dpNbl8ZM/k98=", "KppriTQ/xBbil9u6b2vD0oTbGAzd5mzpSwuupf9xa54=", "FOBZWI+PivIil913u7ARL1flbDt9PqR0cTNNNOIYG2w=", "CMCc9nv00P0MIRKY/kftIz5qtS68uhtST2ba0BNm70M=", "GRbtS4pfl5FUqRmVZqizYcwQB1Ua2dtFUV+KbA4bJwU=", "Eax6hg15P5eHDpUrMkZMtfUB4hXmaRql1LecHEz8zzM=", "J3DFpbg+9AfLefyeVWoxC9aqPwgea0XZinaD9gwyJ7Y=", "HUEtFc3990jzqX2tgph2YN05pOqTL8vFGggiM8FW1ps=", "MD3vLq8Wd7XHuc+2eYKYBNZzTavNetOndLv7moM3vEU=", "JB1tUL5J+3lvzNNiqvRbNQvP10Vz0UTHPnq0LjBHAR4=", "EUcnqBzZEHM1L3+APPYhgg3nec18bCuauHy1s4JzfUQ=", "DYGE7u6v87L8oaTNqznklR46VzJ93uUWN9xtJEZIQvk=", "KWmY8WJwCazHkTrwVrw0KANF7GqcJ8c4BO4UL+CyuZ0=", "FFsnPBHFdsdXiksCKB2bFRU3dYhLtueIQFxIecDtwtI=", "CXPm9Rqc9Pvsp0FlVi16ZW249kLEEFooQbG5NImx5zo=", "EugbAB4ekF+dzqUStR/2PVVIjVfNJf863UAlzzqfZ/k=", "Jy54gKF59XcdvnCufX1RyiiRQSDqHcOrhClWXNany8w=", "FVtNOnix1wX2zmJL9GXYIyX+9wFnzXeEr4cocrNIoCU=", "CSA+YMMdr2AHqe8gyy407KnRydk+mQIeCjg1mL/nc5I=", "Ea1ID6cts7wWlcm9Zy0uCaVOcqyejKn0X/ihxz8PdfI=", "Bf5O4wDEiwzv0DuHBxVCZM1RPAyIO0Y5RN/tMEDFXc0=", "GCoinRBCnbn/ClJYcp5wb+koLGt8pgRz6iNMoToxv+Y=", "HvTStmih4c5ETSE/GtTSPebMu/bPWpPTFoflPpZ/ndQ=", "HPLTvyQOAWkcxvu/I79I0h65uInGKUzBjR+3nJuaU+k=", "AMEQFxqPBkKsDtsH+Drix52ZGjQ4Nm+YwywtEvL5Skk=", "DYKmiwVwrIy0tw+/KmC/F5Yv8ohihO3+WquP/YQxS/w=", "CjHFhZOWaeVpfGsWZ2ftrHTmNZ02ThJjE0kQknZIrTg=", "E3xbBluNOnFhxju6zWDeyesuF8Y9xpal0Ve2SFVLHFg=", "CQZYmRzOCa+b93vx/AUGNG5aA+MJaSHo1DZGn9dbtvo=", "CbMJ9jiKf2U5O75Q69YRCFSpHGdOoFGJRRz2r9SP26M=", "DNIX8w7uJZjKpzidLvoYKkdW+t7PZ7g5Fa6ksMNs67U=", "K5pQ0pc/Tsz+JmFu7qj38qn8Hwno0oU4aRlEAhebqnw=", "HURO+iceEFqDsxBdRpyh6u5qJ1NLmmLMIQsZlG8I4a4=", "FuIeCBUl09vA80V3/RQ2g3yRLTkk7XVVdxiZLRTfz0w=", "FXt8/XVWCgvq1neEPFJZHRdVTY74oBW+I+NK3DkEUdg=", "G8RmasP0zR9d1yvP0dzP2MYP43IqNfZWggkVht0oUoQ=", "IrEPXCGU2QVCIewqnMahv8H0RBhxgx1fJNPaaG1NXp4=", "BR5UhGnRkpCiP62E2u3StUlVkfIsPca/Rn8erxKgn1A=", "Fm5k+n0JOckSeqWLeq8r6mHfuzE4vN892cyYbpyk8MM=", "Ln+NRxB8DzEDHeFfhA/8e0O49kgV3XwQNX6FKWPxTIQ=", "FVmKayx6uRwbp2hYXxHWTUyaP2CazpA533U7TPkBaTE=", "CDAIB51ZAM9zrJ8FAc6yfD6SJQ7MuI0Q0OAcWTIC6Mc=", "Ao4wCWZU2hb9kK0sIAgPrbC7rRCaPtGJ1COOr9Lfw8Q=", "FOuZNWWJTQVWGJrcUJtZRfEnX3B4vslpl8NjC3Q+k9w=", "IDARww2yGF4/71M2BY/22aXQXFV8PeG2J7tKrWUdubs=", "BjeQGsZHW4JvBz4ThkmJee+6mNS12vktKpq7Y7WuqnQ=", "IDyz/fPMI0py7UyGmTJ6tsrA6LdHmyhMCMcJfRYp7Ac=", "GhpAj4mchBRbE1ygp6Q/Nes8t3zVEkMMMlzkShHd7do=", "CQDCbahVfgdguXHjWvWGbHzElKwvvyDYYhMESexB+bo=", "MDpFUIl+23lcamO2DqM8xe74L9BEm2ohGat01V5JwkE=", "FyLlqENIK1mwea7LmVxD1rgnXhQT7AilXyGLgA+zB1s=", "IKiqGgwvtM0QqC1wLCwwEE8A3lrZkQOnJN61Lp2AHWE=", "L5gNft2rAsBrb7IDmOenrPYTKvGmBdDK4BgilJUvUjY=", "GBSJhwZJSR+EkSx13/3VXNDcALCHJOof5DFH4Zltj7I=", "HdC5VK0uZazFykZhU5GueLbdJTlXap3kQXVVNW+XlL0=", "GU95zqYk8rylHTaHBlIaYtxHOUcgmqXFAIODfBbuxqU=", "KunCROSwvOQrG1UFOk/Jbuev/aIyZ5IKiOh/FiKf0TI=", "GuamqMm+9HfRWiEXautCK+JOXQ8MvYycs39LkURRDjg=", "JODmoAsXXiJAfeZoFb3dCWtC3XP7VR64EPhOAb4wTAo=", "LxarVnEIn33gu9HhR45FufpihP9ERM78i0NGkYe4Pl4=", "Gdysnc8Hi2poUj07zDQSmA5VGc5tuNErbas5B7vX4Ow=", "ILC7HykBNq6IvbwVs8hkYksH7T3/V5BVwWgLChhfawY=", "COiT2K+Xig+6KkL2v/fy/jp003Zerf9JqCBW0BTb40Y=", "DqyZ16903hrR/6qbX0Pso11gg0lVNsCsvpjLry177Co=", "Genm1WkjczkjoVzX+KQ1A1LqMI1hYEc9WTfpxLULfP4=", "GOQXZNu10g+FgxqJ/cFAlO0DQyFvYCZh+lpU2+vAScc=", "Jm38bp0xBAz90QiIQPwLZRcpdvWOBkDqb16tso6ryqs=", "CfGsH12A0UPZzQhyc6lX8Tye4m9bds8w0/tzw5L5HPk=", "FJU4TFk+xNokiheqRXvb6M+VAgFZ/0brlzprVYptRt0=", "ChGmPlGR66FvbMtOkr1jickprRU8U6EwyTOkH0a2tMg=", "IxoiouD2qyBGZEUSnZakD+7BsplQmUlYjA9Yp2bZs/Y=", "ADo+sRENdblmjQ2KSNoHbn3NLtD83rnMNTjBF3MEe6U=", "KLUr9t2NDFQTrnvaXx5rXT5FSKRQXQjjb3e3JinZd5A=", "G6GIMUM8sVQF7nJLtCgbulQSmc+t1IXGsX90/OQ2z1c=", "HSlZZwhChKISuEHqLr9/8p3c+ujb7r2d9Ytfhi5/2Ag=", "DoY1Z9eI2sHdXzJEVkrtkox5I7q4liRSvHiFckqTRy4=", "DCFKUFPqYJ5WCOmm1UNDoyzQLTJPYFPjOLNNwHAatcg=", "Fv+w2bXz+9a98dUDg3I83XLzUw0+fe0piDuQAIPGCP4=", "IOBYNVUOajYmBvUCUdisBwbi++V+RrSXflLhrfNIni4=", "GJGo0bB4ZQUhsIxBYhbKoIbg6YNlqh1bpB1K4HaAet4=", "Ab0TGeqBqPieLaP0b8dHnF7+oeQje9V1T1b3GbI8EH8=", "HE78OywPJmnLpUlgCsAj94FaldJPlHZYn3NK17lPqO0=", "JDjjv0/HJ6dD9MRAlUgkDm6FKTnwPoXjUsMco4bEMvw=", "KKjSUKCiqirPSNeeBD4lLu4V8dHmqE1YvsPfrzfwuFU=", "Kinn04HY2AgwQ5cO+4qlYYaDk4UKDzSgp+vNPX42vcw=", "D55XntBN+F6oArSIWIdpw8DlN2xCqWjovQsC3CNHJJM=", "AqgdwD9JrLpJcJ6eeAxWqqnd6yRf5gJteExHzdiaFb4=", "IHEWruHntwIqkKyCFDXp9+y5T5+5Qve2/3xjQqAkF7w=", "EbQx8yEIGGWMusgY9jZV3Gwx8AZAxIcDGnpmmbVKckI=", "GXpQr53sIBRRiz4vwmATpE9wZGbUWW8GJD8lW6OBgyU=", "Cm/QK82/ywIA3Yn5uGZpv+hifOZ0VLJATUlm8XJvR60=", "BfrFz9Xi9WkHBPM7RA5vc5+0/0RFxb06aXidtlL65Fk=", "J4Qs+KTr1wCc4tfsNI/3g4MKzIdHmtTkAe/V5zOdJfY=", "InhoOu9mKgfUJ9Cjbua1LOlijpkUzFO8pbpKwkk2Y6s=", "KUz+5mx7jeUF4MduIiVhkGbqXr45r5Lbp6t0uHgIU6U=", "AMa2Co4robd09SwfWY0Uz82a69yNctTIfbnG6u7E3zc=", "L1YR/ZuKnLBS07bvKy7DLUghiGLapOVNYyGfzLngrE4=", "Jhu2asmIyjp+Lf8CeUT4/LPey52YWwW7yw/GBiCAyso=", "C142vbV0LtoDodHjBERlp1H6Kb4oBO5ps4wvKUOGJNc=", "FAh2DGUE412wLXbQtqF1VxnHV0GaSUuqWW5a4KSzEhk=", "L4mOWUfxSwZV8EvONd/osIqkEwP2AnR3SDU5Wbldfbs=", "LV+tKcv0xCDmGS/36v+Xhi3lUjrNaoGuYRl+heDyILs=", "JCA3ZDZPHrzI9S2vZIr2sC3p5GKT7y9SuJViafWjBFg=", "GoYnp/pVLBzQc6pT/XzDT7cSBRPip1b/czW2qyPUfjI=", "Ge3P1r77P7Xf7HaLXErtKyfdkxHEvUntroSYOG3ls+Y=", "Hszs43M8KoGgBpdbnkM+aTHacMZJ/vZH82imdoLhpag=", "E6cosL+ysyLIr2ZahHiRPy8Wk7OQd+6onrgd5BJa4eY=", "F3O1sJZV6b3ay1CvTzP151x+qo9L+kaAxL4RxxzCq64=", "HZEQfs3V3jcgW/6CfngAyEZvZXK/YRp31NUCJCr1sjA=", "EJ5YkisC0XLINj+IxbkiXMASL7mA4NIQuE10pauwGl8=", "AKDRstFNhh+wTAfoX0Csikr0gcpgK9IkustEIpD/dLI=", "A62UpeOPv7W77dLTYX5vvP9PWwv4kyngHoy5U4+Rwmo=", "I1JpoIdScSRx4tiyBM7L9jP4obCHuNUNQ4a/3uR/0Mc=", "Bj0ixG9hJaIIIG9pkaflU+zd60M093D2lxW5wx3v7kc=", "JEhSvQ+IOCWUj7pYx5U4n4Kgxsq9kF9vZZbWC4py59c=", "IMnD+tCKMNZNrKJNd8yT4H+pUxqUWLZOfDbiuNXeelU=", "KPAsS1PF+7m4T5vn8tEVGj/qQIKVlhUux6lZHXt39Ts=", "BjKC5FybL6XGrF/Mtk86lBIE2KfQ2/tuLyBjunnbyT8=", "EyKVeAPoFP9lYoGolqG0VPg+51kdBK5FxViU79oNRnk=", "JvkcYybF26LiMy5l4lrc+oDsRN7dsc6/YvXDuQ/OB+0=", "GwBqiigvX6j6gmgXQFj8RXuz4icNv6vxp3qxD/GT4dc=", "BEtHAaiX9oT5c+81+RPIcUsjoLxokjmNKZnVuJfdzzM=", "KQ+m3A4J7E2ceFlIkTdIB/Qumu3ccQ2uY8npqCTxzzI=", "KBtkYxRwuYVypndjflOBZu3s9qSEbsS2aFeqjOqdYS0=", "G85HrdWH5gftaIaHwBedoXxUynP5tPYJH4Fu6hcnU28=", "Fcju01RpSjASuCJiC8kfHWjHusDmaF8KFcSO9YlBoZY=", "GG6oLwmB+Mo0fwqe7AVtq6F2pERly9hee463vQWA/4U=", "MBR3fftjoRo9m3NOekek07asT+QG4ZXzujKgFYF/6Kw=", "ILokNW7/euC5zv8VYqSkFYWqnKDUWRUgTkM/ByixWZc=", "LmFhZDsbMdw4KUSGIt+mrHzXkyHuQyOZh33E7bJe2zI=", "AktRLGMgcL/OPvqL0vNLwQDw3mR9D1UQJp/ywBx/Kbo=", "Cpruwi79AXVxr/poQnciof3qaSiAhvnGk60qQudztZ0=", "FckI42Srk8FhE2GthPBvoRxTwjEf/R9GlNY7K5gsV3I=", "JWK1c5FwxfoeHP3ofXpWwnlaHfnA1uUA+ms3WeyoSYY=", "BBNZZeb9AniNAPmuIYPxngk2KIgH9I30WtP/GnD2nj8=", "H7Tu4zKLqdPHnxr3GjiVLEBfPecUWM9IhW2oPgapb4w=", "GKXjU4TU5HlFmtQFwFUyVTwk/tkLg5PzowuMOLsqs8o=", "D/9/c+QqUuu/MLbnP9TUXCETPkziKPU0/240ELWznxc=", "FZo9qmZsMyoSxsVue1bmJtjuqfKjbqaqzpWDTObMUxQ=", "FCSHUiH2jL1PDeRHK6dr3l5MeQp6/3grTrEhQZ1h9Wc=", "GLMgkgLGdXVJKWsBCVxcw5DXrie1Ix3YQU5pmrsYYT8=", "DrrsnKuSsYL2WraM+rTPfhqAo2cUvK4weY9hGHpqkwA=", "EVVS/v8XW24yiVFsdcch4Vkizu6DQlk4eDQ00S368Uc=", "ItAEh1mF7rM0F7T/vMxolYiwD1+5nHbPYFoKJCioIYU=", "DzlqZZM8Za2bVArOFBa8R4eqS2yj9/I2ak7Nle8Szjs=", "AO3X0o42Fz8MOyggfdwLVfoS5PVNol52GYccqNhDnUI=", "DX2QCcPWeXCQ5uEFmTPiE2LSzwN+JR+/wrbhhhGHW6o=", "LjaMFT+jWj2cpowhp8pYqQuiirJSoY785aLVmVHX5IA=", "DNZ3SucuBxoL7tvq56RJ7FI2L3blsOCkQZ7tGHoxv+o=", "E8JYU9loDS6NyMaE70iyAueiJ1kvdgEKINWT7WcgKe4=", "F6cX0eP1hU+1m38J5vjVE+Mt24lGRn9wgL64yhD7oHY=", "CGkRF+v05nGAAh+9bfYjykjAZ+nokOFzmpZyouuknsE=", "GcrRLERTQTTD/roggqKdr+tVCSDxPzdsz7ZZ6DXOirE=", "C3x10BD/mOx7WtHjoXoeCSw1PFRPjn9wf16BZRn9b8s=", "IFUVYUXEQR21R775Lvv9S4obtf4uExk+DZwH855Ydcc=", "Fkr660Fmcmlk/loHmhszJReYDEejOgTOIvVsM9A0Efg=", "KTbFCYL72w9WzObU9XWjFmX6gT1yJSRkwndqcOy8LG4=", "BN6fS51EJM3oYK1VNNqoOXsbg4Ndg/ADcvrE43bm6Qc=", "DGVTAHVGgW6Gx9kFUqbsIW+aNJh75iK+F65O70VNWl4=", "GnBB0FX5jb4thzM96KPQtPY0j06ylorsnLx9wzQlh+k=", "FGfO8XbLcX7q2iuEIwM2pw6kXg9K9cVaRK6uI8pWOkg=", "JQqtw66Ynz6C9Ksa8E6lrT2SqYFR0GBGtjVPmLBGEQ0=", "BVOXKu5ZPr+qRckyvLFT5i+mOBZ7RlVfmop0o2H3iv0=", "BOVlayZ/jOCxoxX5SThz7qNcEZPy/r2/7N3klLaUWDg=", "GUAekArOIllB9sWBgk4zj/mNM/LwtD87dN+8CVHsqGs=", "CHJTshFuj8tF+Oyhs879khEF6c77M+PMC/faAGODuAs=", "E1vYBoL3cVcr9XTz9xTzQQWvsh6H1yxAovRuzYUYync=", "EcI0l3IA22xoj8JUBTrTAWOQoCXQygl10TN7wHfbOM8=", "FqW3W5cOSKXsPu3S37CNK2yVtzLa3/HhyB6Bo9ybJLg=", "An7davs2Kp2i9gM1IH1yltA1nTOdQYYCqMJwadFn0jw=", "DHpxjmPB+vhyr3YYfFw/j/yFXUCV9cVduqAFM1FbI4w=", "GE13w9bXI22zLZo+SMlf1EiloMH9PlrRX6/4uvEDkBk=", "IDGFnb4qNompl1tBGW/fLv8aWHqSRzYeeLewKXY9Y+Q=", "MFaQwZ1226Xf+uzs4oIYCWoymAzeep9CBbGYn+qA3G0=", "LeL7SUGX2cHxRRZB78JHO4UwDQXA0n5+0YFt4UyUqbo=", "JX5+yziQPkTxpVi0n9ACLDvdkyWYRyyKEmAregIOTDU=", "AyUHF2+qBJwNzHSo/8ezJ6wpdDZ58h/1UxcK/dLwS/w=", "JnIClrSDcFklega9w7CdJpKBAs3lfiPpHRVAz+/E/pw=", "GveOXpGJYwUKQV2ySrRc39gVOcr3T770uABHOmI1oOs=", "L8e3Fk/0CWWT9FzGdHZdtV1TbNToZxEIX8BbsqfP/g0=", "Gkqw9FFbSb06pK2wP/+0UU2a7CJPZ2gxW7sjZf6Z3M0=", "HeIW4vraTCTX/Hj1h0lsJKjut6qD/LnMc3kZ2es9he0=", "GqMw3E4lqNDJEL/IenrQUeSMguYlhhebGMLOlWyLM1o=", "A9X7HKrZ+1BJGnOXTI3LKC6GimBUlN16H/my3xawzW8=", "BF4TBCTY4NlDwRiPlSGm95kzT1fb5iywXuRpQ441tLo=", "H6+24l9+kaTyADnCnpR/hjwJD6KdxWZNn4ppJhMn5LU=", "KHpWAYzQj11ik+FlLbjL9AJJzcdZqE3Xys9Jec9N9Vk=", "I7NQjDPpzTc4dNqC1sFcJQqsmdM95RbwNR18QhVFBXo=", "GzdFsE7A+EO5/Yctbe6XyMz+lSo2F3FiMRmNi9g39E4=", "LdOJ8Itv460Hm8nR2u17FpgBHXSpE1Arx8en4dc5/e4=", "Cozdub4AxuF48+yDFIK419vX6Rtcjx2ifxOGBo5Y+xQ=", "LompDMSt4+IVDK2GK2y8StQLj+Z3mo5h78SCf15DqlU=", "JwOBUhfVf7YmM9pk5HdyKbu2Y/zKdijqNRAaWm75kck=", "LR1XC+CCDo2Q9u7Iu6doIekO8gnXBWBNbkODLch2ApU=", "AtkFO4hjumzUas/6CJHAcgvZt4+hZivA+EKh4F3mJAA=", "F/Syb/MRsbTVTnT/pFrSg1ZbZ370Di5OGaY11jjY00Q=", "LmgCDKgpYwha782SUHOmQnBQ4EkG55MMEz8YidEjAm4=", "JXTDDaEMJ05ljeqC89WvtY2hqDTNJbf/pcWWZTALHrk=", "FcNholWFImqGZVEB4PDzE2x7d3UhrCQJ5W5mbKRJdj0=", "C1ThyL/ilKCDKDldxs06NTEIIhFhzXD73xGMOVTKuck=", "GAURXx1bYBkexahzPMxbG1tKMtgccPI5gt8qJZlSiRY=", "KTTXPb/aRmazMaDMLzj36D7YCTzynREe90p6jXByxeg=", "AEiOw6ZWNTZpYTTYoKUahyz8Su3EWMROtqcjWvkmPJU=", "ExnZtPs70BQm/8sm8la0+GNODxj5WX2sN6D1+aAMu0c=", "CrXoLjReMEsaig9lf98/4D77AGsuU/yOd2UGeWwzWBw=", "A/1o/3RyKwnKxNWLN34IGGcdn/UqIR5EmrFiw9DPh1s=", "HnxVLlqPNgVgnDZnvB+BUwmfRuyO3/eL3c/35CNy0Ak=", "BplS6csm2N3Y74RIT0//hJVgFInd+c+8hnMcoVvCtCs=", "Bp3kMi85D7SzxBFllvmo9RsA8uzJ7VO4zocDel2Ms2w=", "Ei5TU1HQN5C5oUEevNWViha69hsBwQb18VhGHbpCclg=", "Iv8i8BH4wibs55fR42sSAUSTOPvVI/xGulL6SLMie2Q=", "EWHTBJDxpQffGnW+hqXflNRIoiQRHzwxOsP9JzFlOIw=", "KuL6L8OWLyL/a71DdrZHeyrOP6ljWGY31wCuk22Svgk=", "Kp3Am78sQ/Lcdatvm/7TZXA6Q7nDWBAffrzKIIJlOyA=", "L0AuYK7Zxf6FufrOEsKncEg6zoETL83J+7x+/0h0wws=", "FPNS6dykbWXv6L7De4mlc/ZfCqjgx1O80Q0k/QRf0PU=", "E8cMO/Qs40w2iTOQUAuC+xSGow05IbTssfpHwIXyD9k=", "EYYZuxSlOiGh7O+RE7EOfGt6NtOzj35s5auql/6Wv1I=", "I2pFsnIyDOpqdCgPKpVOOxVxdLiS1fOyrEtuXE2684w=", "IP14qfZi074HwHuZ5NTLgEl0s/rhreY42IAOg0kLMaE=", "BJkq+LkDA0+sykACWGRmE2pnUiIJOsNIp3hMi/vN2aA=", "I1Sy7Ix+jm0ak/cwc0LHtm3WzJMT5ds9BsOA/rJJGTw=", "GsjJVYiF36fX30kOEbEChU3z3lsUxfv/8veqPzH9Lig=", "BjZ1l6t6LlM9maREdyY4jDWYG5l2MuVVr9tJF0bYPSs=", "FDY2PIbOShdqiCuybEt19a2NpGmTWn+zvoGCfQte1JQ=", "JR5h0Aq07yMsM9VacziO7d1l4xM7xPs+3HCXl+lSmxg=", "JzZWhwx7i4nTimOpSFZjrf88Rqx9Q+YWBuJvUZHM4Lk=", "LsK1TJqkQOD6AXvCkTXrEkrqCXCGS48deU37Fvi4yxY=", "E0xlT1o47MsQcKWniDG8AFumrH16O3blVVgOsSM/lJ0=", "KbyONLGhD5eZdQJECXmxGMXPKvKr2XJB20BpR1BQgPI=", "DPMRKDLEXEjB3LXthmpRNltbt5ScDP2arfZ9El1POrI=", "B43OUh07uqrlx5x2j/3M2LBOER2LRsHy/6bS5gLvMf4=", "FiQY66Kxkwoamluf4K3mY0SBiOJbKKyBQQ/wjCLHD1c=", "C9O0mIytKQEsnf3cnS11gSY07goHRWQ18aD3PALqCMw=", "EeM7WYjWsuVnLVjFkh97HNcpBjVnW50+DNB+gayy9Ys=", "Byv4GhMIz1F1nychfJaHRrMjJLydQpJwwQ4Wcabzp1k=", "BVhToz0RUODhBhYP4df8ZboY+uXL5Z6PtryMx71mMhY=", "IIP8GtNQ2C8dQ93Vx/pHUmjCkn4PAua+ceUJD4ITcWk=", "Jsp5qFWVjkXhqJu0VG+Di2fZjcTIySvsJqDv1nTKYhE=", "CcZpqg6DFXK+WlQuhJgJDvaTkAu015pYiq3VzcvmJpY=", "AmHLkKt5amI1qS2preu8OdyrzQGHSvXWPZDWYDe6O1c=", "B8FNKIzvyGI5mhFW5/py3vz7wEZuB2irzh41NmRQQEo=", "LdzW2s3Lv67zfLLUxQYPDvNvERCAf9gcQwic1Fom2h0=", "Fi08P86PMCBMUieCwMrmb5EeQyyLRHYWazW19TDT6Mg=", "CQ+6/h+GX0P+OiFgm32EWf40jWCkxHHcYqCvxVXMJkg=", "Hb6OUMKThGMFxRuqNHPinazlfm4a9I+7I9gVVuq1czs=", "Gf/vm9WMpUesAvS5U8uUHe82/YNMH17FpZQYstIt+RE=", "DimwR5UbaAXBm3ohrH0kEpyo+OKzhXMbIZTBkF8h5AE=", "GY07qso3nbYQVnUFKlWjHB/USodzqdfHibzgbgdxnTI=", "Dujeryh3ika/gYEEJ2u92btIkmzmmb0YXGSai0p+wWw=", "AwPZgxjBhshXnRgDmE/eMoR0SrFh8UvEV7oEXzwTKa8=", "Jl1/qIwK88Ld+sDbPUZMMd8JXNqW3DkUc/gzrPT2SAc=", "DtrI2Bg/sOoxrzs4Pvn5IaPCk+i9v5VZj5UKICpnfLk=", "KfqJ0WGQ0WNHBMwJbwMNyMx8XJ+G0T2Vl2tvF4/9IVQ=", "I0w+MfQS/B+3yaW3Dr4x8ztZh8c1VfwOTufnUoDYQmQ=", "LgU9wYZ4bkRx0KxvXhmzP2ONyPZDkHfizzaNFNT7rmE=", "HWFqxQWH/wxzCxoJmo2qbgXDLbtdw2ZJ2ewMH+7ytTM=", "A3dx6s3IUxJcsLyRdhDAw9OwZVYGALSu+IO9FzrcR6A=", "AxxGIWYWrjJBhR6C3s0EX0ColgfFeMYkgJizDFRuHnY=", "AEgtHSmH17/G0lavMHK0FpYDilV8mGeorSZwJ+w6W+4=", "IRXXzRz5qE9D+2QmrruJdleP8+Vkb4nyQKSKzRbw/hs=", "JtqEdPW/25yI4NcvMiJ68sX0tjQMj/yWsEI7EXLH950=", "BjbbWv3TNeMZWKcOaU4XJF33/I0UjRy+Gf+IDn3Ar28=", "BwlrOVcB+ss0kqwkVkxGgCblh96rSe9jxSj0GPfkcfw=", "FIvG3582S5KNaBgKpqJmeimt/5Zs7z40DDaAgDMzvDE=", "JNz+y+IDq8ZzE8gyTGM5oiqaH3L+lEWRyP4AP/KhliA=", "INuTuQJGCrYRJW8o3+0+cAOz0/ujbXvvmT84Hz8iMNg=", "BE45IBqpkMTjLJRAnBsUEPz+UR8vWryUIWsNnuqkeh0=", "Kq+QwwzmDhkIWlQVP0Z1khuOZecSu0sKBA1MEepmU70=", "I/oJCNfYnzZz6hQO1mT30e7Kdl+yNsqKeO8rrTBKnPY=", "HxnBQQib5/1z/QvLw+Zy+STp2X/i7aQp/iX18fjB1Hc=", "L6W4hKqXRrB+hyCdECNYJHhgOplPH/7DwdZi/gljLf4=", "JyvUNX1E4uLBUvaU77vCOBJfD1NPx6jOeAOn53pDtv8=", "EnD6WAjAyhQzQjuQBgw0reAfOpyBt21NKzz3FYM4Y50=", "G0f50/LrD81weh0px/D8QEgftr0uGSVxNYrQbkKZUhg=", "FmG8PtQERcm49aa3TKUsgeMHIRemud3q5WL29Rv5uLY=", "ADjI9bunPffZqtTwZ3WmVqjreAwLh4P8pEBjHYfUhuA=", "A3l8lFVMcUIb4OohCL1dwtYXL5wLUegYzfDJmOdli18=", "JvgBy+rSwmvC7mbJxWHWZI+dz7oC1XMxaZgHDUNJIKE=", "G9nrB4Gu25bJeZ9wmgyrqA2wz8FVxDfSfe2GQd4Y5ho=", "FIXIP3SBhsG44jfq7ubyPgk8JQmDhDbAhMbvC4gwP+s=", "GV7WTdCoE0aUhY+W+hSvtAIY2sQKMwR2IyW47+A6lIU=", "LuMQYcpxYM/P9BSvZ9q8WtFWqd4mMla3kScKas+fCWk=", "FdDw+4JIYL2uXwGJuwnOSzvAAqf4bpO/hWeNXJvVF7I=", "C/sv3BnbLZ1+r48lSaya646dzYPJHmegR9D6f9NvOFw=", "F5zWJItcCvJ3s5LGI7dE+GWosf6FHfJ8X8Kkegqh+g8=", "GfFGn5yBcHZm9tuQDo2QEjtxXnSsAiStw1fM3qhzf6I=", "ITOaIgOvzF8ssf1W0u6ReWN85Fq9Lf3Jp8VhzX+vtos=", "DmVybaa+iNX5FhVNICrT2+P/9dZevcKcfJfqgtmYfkc=", "AlZOiw+/ZfFDap5xal7H4Hnu0tbbcbfZSi8kNOAGhoI=", "KiNmR9zk5FxggJz20WA7qkNilT74Urj3he5elZAR6kk=", "AXSszp5zqa1eyq7f3Od21NHGt3YfsVmcz5cDKlnF8/E=", "EM8qgIA7aALPKmOjfhJ7VWtw1lu7YWV/aCHKRaBvJA8=", "FhZ/nRs6sJT2fQy79AoxX+ObReRUB2jz+jXdbVW69/w=", "E3sbB8tg/weyGqFRck+bxqUOShemjyrqUS/B6TloyJc=", "ANWQ63qvjjDc7RjKMX/70EipsPyA03xUqL23ck2N1kU=", "LQpjaQI3rTRpq9Ry5FDBH+Ue4UQNO7MJsilcuVTv09w=", "ItVeBLoNhV9CA50YodwU3RYwWuUWxonVFBqc5XILj34=", "AcxxFp8yK5WViXuGRDggi2anGQK3P5UYgmFY1xRd2lg=", "IflJoWrLNRlNnlP9/FrAHzSRd1FwJUwstLkXcvRmNts=", "FM9TUcFMCHpZz1+lMDxXUsM9RGtc/zF+RXDffWhaqvI=", "EPE78XJ61+kGn9ZwFQb5WP31n9LQiw/FBIyUhrQ+tkw=", "BjIIXncfdN+Pz169B/lTc/gyy0HsmAiX2oqGDAXpsMQ=", "Fv1nOqS0mYI/sXPZ7+zm5rYErgO9WoxnfXrr+9c79ZI=", "EQ2pFaypyHosRhSx721vA9gifWw+LWO9oCjeGlgKQ4o=", "Hm8SXz+BpFRZNeUg9eva9vmaDAO0hfWC/iOlOsZsG40=", "EsBpqDtVtmWqkJUvv6g0fsFXwRU59JZA1L0jWNpYmzc=", "K3hOL1LDuVIt1IuvbD/iguJoLsxQ+xZ1X/iiZe9riC4=", "FJSGG66tAFiAHUfvVoQnI8a5bQTTguR8RUc+7eur5IQ=", "CdxxdR2qWhRQG7LDy4silT86PDyIy7d7GTEYF0HccJU=", "IdPhLF3mUl1dq1oVAAiI6M429AvjtJ8Dskz/pwxzkxE=", "Gw5wkp9XcvcurlbIonLTGVaJ7EaI2WVwtG4Z+7Zocsg=", "FA/ko5Rr3q/1LAzT7/Yo3EDjCvj6hTTGem0HyVjzPfE=", "DHNJ3W15HUhxQztQH8PFkzUv1plduk+mh/UB7ImG8N0=", "BLCjXPYmxA+CofB7kWB2wNNZi0QU9zyfbJdEICREGj4=", "HbAraJZO6c1SopNsx4PMEviNmLYOhYyzY2ZRn6ASs4g=", "EOLpVpk+I/k8Bzx8pNsL/Hro5Vj2dribHuZghiA8BZY=", "H0XeNl8dk8+EAoCJDjae9uTFqYuaf4M57P32BNXm+C4=", "HLuFvaiV3BciMvfVmEXG/BcQFrgskdkfQzJh/tTqnH8=", "A9Pzu4bvFhKV+RNL/lhEHdcrZGG1++LVeHkC4+WrHec=", "D/8CgU1Hs0UW3YTtF6IAxErXL0CA+AV9p3Bg0RRx6e4=", "LpQW0xYeT3sCO6Ycj2Y1YXhV4wjWIztOhelB96Xmyfg=", "BccO4+64DbhFAcFUTCQWH/1VE7ylzytcdAAR43k9jOc=", "BmbXM9JJ295P7RBbLqLW1LmRmD4rT1itVJEJI9CWXcM=", "J/lFuyLcGAqZpZZEnoOzLb0Q54v0NnUx7BHk2pNvOfY=", "EuJ68Ut+zpuLz3vBySQdDYX5+kfIMVODbhmeuolhVE8=", "Co1sn9gMeZvuB2F3ofnXvrpEarE7fHmVbwfZlGd5Rvw=", "CKDTZGxHYmkHcGLcPER1U9YaRkjzBtIOVvrjLRCYhvA=", "Bz+q1XVEmsNc38UUcXJRvxaOzs8DKXUtt0A8VGPs2E8=", "Iu4i9DYHjeBI1ZP0r7q/VvSj/U4H6KZkX8aFQfDl/fA=", "AbUCNa07Gm9qx13jqfdfTzmGbmASQ5ycAXmrAyxCZqU=", "Ls9PPIT3XqexDsEaayWWFmzptaKKUm+AzQLWZSJqP+s=", "J+x/PsViTNMxmrhfffE4AoOlmzbr8YrDi+11GrGgS8c=", "DldiUOFWDHfKtnKvFOv4VkAkaNLpsKwD888pcJ4T2TE=", "IlHydv3nfJmNQrXa0FqiX+mKkIIAtEC8t7q+y7d+f/E=", "Ao3M93xGfHgYGS1Hh+OEi7BXxJvgmfYCkaLx5I3hg0w=", "Gy2+kjb1on7VyeO3DgmUMtMk84DzkVjhGQaflZIRM70=", "CGmSC49QJsxDz/GL45D3TDVYbNK2lDsp73sXvu0neDI=", "FvT8sYM2Gb7mZyBqLJHL2RBVsQeDBZsL5S4bZW1nYAw=", "KlDNbmlC/KdKzRNARcKIOIOHI/32UdoCvzs9d0E5CCQ=", "La5M6CmnAYLb3EGo7aiWURELLJnGBWWuM23yvSr7220=", "Lb/ZRH1CFPmqy59dKSTVRdBzECMMFGmvoDsoO4x+2To=", "EOe62VLIpjKt4dB3SQv4CxJcGgWuTveRLmnxUtZAbeI=", "KNSrMJf+jQN39KJngmEWa1uyTFHwTXaAguzus8ax+0M=", "B3KxwUy5WqazneHUwk7LfwjSY0OxSthYIbopv1mDsmM=", "GFb6NW/pSEf1dgL1/UHanUykBPhY4p5yN1aKjx9SygU=", "JFe4Ip29tJwgfloSCLECsPhsnyp2tKSiPA1CMwS/6dQ=", "BF+/5rLIdZqCNOFvD0w39TMSWW+pCyt70n8LVdxa73c=", "F/Til1gjlZbnBHiqqLY/8SanQFWsW4DHdcD5JNgPLGM=", "FGzal9Qf6ji8Y8lVFEplIj1PVlLFG+4WDa27xoElJxc=", "FczLKR47dWc7qo0sSEbuVtoz3bSXZhdgxL8Z1SUD7C4=", "DbVgxek+zRMbeyakt3fCgjTJ0VWIzF5fIASID17XbZg=", "J3CR9NaMTbwbi5NXDMJJlz6JL0jbPDVqllgWojsoaEE=", "IwwIeLjmcGcvI1mLdxfO8bcipEjZ0U4EuB73IucrtQU=", "HXquPNjdP5HifKtvFbopdP2/cngoJfmUBaUME6AERGo=", "LIfkuBFzzo/ZnJvfLwxL054yRdhMvYnXnY6fp96WNYk=", "KzE3s6dk1fNgQjLMF90uirltRqffnmhBm058GOv9Wo4=", "HZLRAvT0MNDhiUi5cBtUTlQT0LW7HgVu4mchZb9SRZ0=", "C/90ygTmVouP62oDSUMRM510kKddBzNoJCeE6nHwUg8=", "EE+zqn/ID3zTVqlkAbQVqrkcQHdCb7CI8qqXKCL5eG8=", "IdXFMn+cCsZut9qHunpjok5H2OA+tJgXq58QcNhk9gM=", "Lym+soEg2b3E4UeUbPfMJgu7vl6mQh19O62Zr587FuQ=", "FmHZ06uY5yBLI1XgV2jWz0Nn8w8URtjLV1dscdj4PLM=", "K0BvK58TWF4OXkTbUhCt1pfL0/C1IySaIe1jSUCXvPM=", "CdUHtQByZQsP/Fw2pjo1loBjdHvXCmVcnw4HtYrkqIE=", "F+ONt2fP99+vyBPptnc+ddnxJX6L/sHqnoMp6AqHp9E=", "IbXBEpK6wmYnmOYJjQrQ8p+ObYJq317hM8IVBM4Kssg=", "A15HOGEgr2ZsMtfE/IcFKzDvGM/CsGGTfpNbCQMTT9w=", "BPmB06mEyi2F+VgdenT4WbYcPgE21sRQ0XdoyhmHypY=", "DCojRX9ZCxJq9qTFTRragQEh9MtJddiVbYRM/+Clulw=", "G1yhTNl229EOdrEre/vCilSsiv22aWOd1MX2n5HoqdM=", "GD9o0andcGEJqJNvqtgTqJzz2Ec8zcd7POKTM7eqeqk=", "BqX5XZi1Vz31KnzyCw4zNmgNtet4MxlOgqkuvMarA+g=", "IUA7JV0SVsDHNs7sUvIkxrdj+LbXIwspW0oU6Qge9rg=", "Lw1uWZKwIebEgG4HhJTZhTNaRL0EPCfsj7liEMczpsI=", "J2YTf+3WAT2G2ck9PY4F+fdDSqLbgNRENx/+yo1UYbE=", "BykqHcivyUhS3eS7UT6pOAlu/hzMC2D1O68DHmTOeus=", "D2T0oCjjQZ5FE4DE/b3OWwP/QDWSB/W7EZwpU0M9UtM=", "HCs8YHLzRMeuy9s4jaoYRj6rXLWUPSxXr++rUYJLN+o=", "Es3KV7lMiqbCFHA9XEVt/IgVlAHn9m0UgbAPNt2Dhto=", "I/UFzpM/oKdIZmT7AOXKVLaFII37SZndNG5PJqaXuAc=", "GoS7gt7WJVxu3jdYXk4o/nh9IIRN8wlP0DyCxvLMC5c=", "EKZlW++sVESM0uDn5SpWwXjT/mcLEcWLFhCft1n079I=", "GiZVbVFRlawo+IN2jz6meQTsI/dCzlRPui+FQxO74U8=", "I6ju8IeRbx7T3wf3pg2c4sKhltTpxCMdDpvBbNDjiF8=", "EJ5Zy7pwDiLuL6C4UQXlKDPHxwvG0ekYgTqiQhoYjj8=", "FjlSjasd0fDplFtjt5JG0+hywLG/Y3o7aA2YaJ2Zd1k=", "IxPo0zHPLjQuEy0qdezg5xKvrYsLsyGF2RsCSTyHZ5Y=", "A+lqA3Yq2Cc/sFgYqyjPrWJqssOwFGX4yXO0J18lhfY=", "DjGGN7fxU2bERSbTrjwNM72hLClKSHaYjCjQmn92CLc=", "EqHx3DV96i2kzWpjJc0lQiiXNhF9lHs78C0yBFCFNU8=", "EXN0tYb0aSsWgvjQJunsczKkP3sJKbvVFUPiGzMD3mg=", "K6/Xv8IE2eVbilO1ZB5HbuX8URPWMXNre/qjSeYY3CQ=", "CNB1yEukjPNZeboBLDeavViCfxu1YhVbGbyloJ7QviQ=", "KweFRDotXe7mbu6is/irMX3TeiNY0YXb663VozZnYkM=", "CvIoZQqljikbGbURIlwfDcEcXJgtm5rlej4OrVJmes8=", "C05+NFTyuSF2mGMv0x2VpQEmOURTyJtpRSUPjTbs4KM=", "Dl8nbBQ/7pEBOOFxFb7PRYdYzpu4EtmGx6ibKXWBrHk=", "JBNB+EqOMWKVkuPCpaM/Wo+FP2EN84hCuAln9U6z0wo=", "IGBjANiwZD9sDLS0r9ttNQPv7bI9aTscNwXL5Gwn/GI=", "C6yZ21YxDn3ylnYIZlAr72/s1MkMF+5dwTpwTRcVliI=", "IXGzw0ii3xU/JnaOIGEUsMSWjDyZ6PuefV0GlgY5j4M=", "Bf6ZRc6nHrgCIm/myjg1frc+hqdvqy9m2Il2yCJBn8A=", "BDq8LzWXFqQdbFZhlQ+jGtEc7Q7/Gt4C1DryPd6QO+0=", "Kh1Nm9Fk1LPbzMd1kbaQ/H+nsH4J+lsnCYhwYuRKk8M=", "LxS0qe/0GSlqZFcWtAIstvw6jzyXzwd/pgFAzcQ71KU=", "CGUWgkjHsYqps4x2d00YCUna6i1kf84Pg53110nYVIs=", "JhI6DqOTRQ9v6mf3wRrNY4SO/QLQc4DjZMzK6aZUjU4=", "IsY3/ykHq6Fcz9P3e+Eu1o/DL4vpZpjtdnPogbcS1Do=", "EX/e8HxZ75yadwdWAnEEcw7p5rQ5h0U5OAShdiaLiiI=", "BwFTyWsUjMQA+VU5ZTZvYyrJI/ot3fadO2u+UDzpYpY=", "HoTHmB7nqP0/fyBQw2TpIfsxCgdaOugXwAp3+HO8kBE=", "BmH/DN5uWBZg9fw6GBsANTvQusqAFtb3X8omlQirjUE=", "Fb7aXR65S+5pbvhtAoPd/mk4f78MDtdfhR61XJyXICo=", "FEIHh4PEJhb1TZMn9dQ9ZZcT4sOWDtpFLcuJ7D5QM1k=", "AmBnBTbOfmTNMcl7I9W5bElPk/s7HAqdGrfeTd2uh5Y=", "IDiQI18gn9TItm4wiocC6WTFLC8CGOur4dsRTmpxCBc=", "AN5FfT/JphiNXpNmedqGBqEUzlRRP9Ed6oSX1V3QhE0=", "CCXyxC3yymkn72eVNr3Q2BOvMHClkWslnqzn8hQ47kw=", "L9Wxb4nf6+swhBYyuYkPalaByqZiLVzE/p0+yMelQwY=", "EC/cQWe/tKKuTtc4hk5bXB87+7RvXAypJqeRv76ZHJM=", "D9uu4KmqSWSb6YdJXPc5L0hXoEqtKf8lZJ4BI6UTzYw=", "CVn4RwmqCzhbfYklktG24Xe9ioOY/8a/B6ObfAxIowo=", "KYZoIGRG6S5H1BFE4vTF0A7vwD2iCgoqMD5XUMzG77k=", "GnmAgdiKueC9rAMnArRIYIc4PV/3XA1o0fi5uY6UUvQ=", "I+lHEVlOfkxnHfkPJg7PY3cKdjUs319HHdwx6OAGSiQ=", "Le3mmkQGSf4XMiuLzPTBzoS34FG7gumbgUB+vtuscCg=", "A0ditE5Hu6/Vrj1/gXPSqgwdoXKRNwvC+EZZtMgPSDs=", "HqRCsFRbpiQ9kuqXWaI9cyhd2Zhz6MNlfmoAajznzCU=", "L1MDhDLuFMdSIoE/M4DwLqSW13y5vc2tPTyF7PnpOn8=", "Gdff8piCWTf7fEwX0j1TEZrpbtPjl7HfcYD9MERhtQs=", "HnH/5uUWtXtIIvU38DZCsjIB5C5bDMIjlzMGetiQI8I=", "HcRtQ8KnFdVl356UhfPf6Si9U/h5XIsDoYYnc6fPZ88=", "L1Rp25XLjNdSpoPk0ocICcGr6y+EFg/yFkgVH3s/AYg=", "JzncwuSPttsAKi8Nck9SzRcAN0gW5ZIQRXXtQi+ixsg=", "L8VlWtrPv4ED/FjIy14Q3TDpM+z7oiY7CHph84aKSk8=", "EP+ERJb9WpKWVjD1pdUfZ+W242pksrUcKL9MfKtAOr0=", "CbMq2MHhDDHpJk7s7v1hnoEp2cMFMD6O1NwM21IqbvM=", "KdsVDTZ6UyPDUkdLtV8jVyCUPf1s+WjDS3P6yfvXeCI=", "IF5EtUC9NXqoMR82x5Lp3VAKOkneTjZ+uIW79ohitWs=", "HWtn23+LcgCoL/uyvSaxjb2WpTvYPFtCZO25BdhD/u0=", "JTZ3VBOJNwvUIz+AZ6eKadbp5Zb1nigml4N8wUFdmJ8=", "GQhCkj64DysiDPFeP4JF5KN4bvJYT+YLw+Rco06kOAI=", "DyXe1jHwFvkUSP56otDRPdQPmXIsUICF4xSHdIkedWM=", "EWNzgJixx4e27NoGkvJ3202veHLv/oqexSMNjZiLe7Q=", "EWAPDtPrcR3G09mg2W9Lo8ojmb+SSXhu9zkAybNOEbQ=", "HI2/VUfVUeMad6UCseBYk0Gi+5Xa7YHFAo/vTozBas8=", "LkpcGlV4e9wEa+5w9Jifj5Nd5Y76SJDYE4VWMdq8lIQ=", "HWA1wBC7rDvMRUk6zvfN9Abi6HbusyqIUfYgnDhaeMI=", "HWtvucLxh7Hsg3OhjQd9NWPcHkgpxz28ZWNArgxhsso=", "KEgMpiXuAkdUF/v0/GUTWbA031W1bcYuzrmnm9vO25Y=", "DABO2cUJ/Xfw+YQfOfT+Ea0Zknfa8MQ1nwArx42XTxQ=", "IZuVeY2bLtLSMHMsuvTKV7fQQHQxnXGnOfyptMCDvd4=", "FE8UcsPHpjndrmEbLrW+Iu5t8lqFmgUpLKgwf4YYw/M=", "KmiBd+llRcuR+c+7RKehSyQ3Z4EJfpVhMUzO7BbHi3s=", "JMiY4DLzPX4HSKVEFgIGJYyXhlvlSJiWyXkKzOklHhk=", "EKvh4N8Kq5bV1zcEBouSHswdz/eNYFoTcnzp3YsOrug=", "LoCuOeyhdw3KNad6SKmRtt7b9UkkYYdW3wZNSzPytlg=", "FeOej4pMf4kNDMcH4oppatad9bSPo3t0BJtQeRoiwnI=", "LV56Nv5osYRVK7xFK+tHapbHqF/SGWqpVyIIosAqVjI=", "FDnwQLTJB8UILTMKtDneR7S5nxF5ukasIBElBqgrwUo=", "LsmWskegqMFoLR0JAPBJ1w7QsB4WnnXsJ9dpoWDgbEM=", "ASQXEJb8taql0eeTxThnE0/xpJxqkPJSFgHE4HvDSVw=", "JT6iaeRJm8sKFAuQz3HN+SSEPTXrKG3AMFlkf3YRofU=", "CDxPqzwgV3Ij+sbzX47Vm/42pHAtpRSRSCm8Gtl5IXs=", "IoT1Rgd/MVQvcWVqRU0IvYXggNtOzMREkPiN2J0ZHEE=", "LP5R5BTV2Uw+KkY1jGsfterXesFM96b1O0YKcFioOTw=", "GoX+zjsnq1JB4qcgMu1ucSJBS77pD7QHIQEa6zDpRPc=", "EIKaqFtkB4qE1LiyFz4MrMPPH147jx4UiMG0FrvcuOY=", "BHXefYjd6UQhiS2MSGg0AkMcysQS781W/tAbzdo5xdQ=", "AugmRHj6YSlBGTNn2gGFf3kbN34gg7NhOlskPPOOZfk=", "E0lqQ90c+XSWUXCi2Bu0gNcWHVi1Fw9fE06+chAp7ws=", "JZqB6STtRsVEHtxaWnXmwgf3PDQ+aFDXrvmDm/mGmDI=", "AtLe0+WOuEPrOaM0SCkUP1Btz550reO5fy8Nxdl3kU4=", "Bl/no879fcd1vZbTHnWGGd3Dcd82I3DqyYWZdkvMvHE=", "Cc6Va1hMrqUcW1ejPRN3O3H/A8MfrpvBSal+KBVUz4E=", "HBNbgFXydza0yJygnMtyo3KU4GGUusxU3q6pRJrBfFg="],
      M: [["BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Gakqxgh6uJmC/lZQ5eeZ+RAD/YtFQAdI0sJeQPBMV40=", "MCYI11DxZJHfWihfX39qXOa1VPXazwtp1FCyS7tJZ9c=", "Gjx9qmtK9WYtDYQHsodnTYPq5bdWNAX0je9JmByYxCQ=", "LbHJhVrCmsxnk2fb9w8I2YiUB33yQR+R72jdkBd8Hps=", "DwbuR1WPGC2BC7yyFKJdp/cKVnoEZLNI4bMOyn3pnSc=", "IWbXjZSNr6ljOBzxVg0AvzoKHCiKdDNEyGQ6WNr4y7M=", "KSm+m/4/k800/OrmZdlrHeGvsmvK7qL07cRUxQy8RAE=", "EHbUOcZ5l8N8bB/amjfcL3Yt1XeUbzb8/czXiY7GfNQ=", "GFya0NqHz4JGJNAr7DukZlgioPazsl3v86/MaHzhMh0=", "JwKxvjnpEET7c5JsEQRxn0wDeqQVGCPOqyTwzsSfRkg=", "CvcaUc1GO5+u2pOAPNwDGGx3gYRSUv304BVXCdk903U=", "KGZ/nHMyBz4pPIC5jt/64Br09ntMUqtF5J24sw8YLSg=", "J2PDP1ste8OiMECvvNr5mLsTJUwnKl+GNaEmBqWcLlw=", "D4Go2OCHWOijKqgpJmbEy2uj9fBsTc9PxQL/l/A6haY="], ["ETrYtGw+7CDJlltaey6KUVKYcdBAG03m9j3p5SEWI+I=", "B5MM1SVvird6uSsIu7WxlaRKI4LGbidRRhnvuU5kkRA=", "KPgUS9rhuQTq1ws7cseUMDfea0hJDv0xd3g1lO3Si58=", "JHT1Q9Hy8zte8/uxkGURNaWTkMijZh+uLfHT8UQytgg=", "IXFahHQsAtBXrEH3Q7Fm2gIyKEJWgZUO36/4WBIBoJc=", "HvDgwfC19nZExIb+zwIjjLf0+mOggqPAMNrdzmWkuCo=", "J46NrIxWsooj26TZD7qR65R/UJLUp6nseAL2F3hIjoc=", "D68zhD5nM0N+mJleb3v6b+76c9dBDYWFkYw0fzz+kqU=", "K6Q31q5sWIxrcVBsi1CDR+Y0tlzuMXrx+7nMKpl/wAY=", "JKbBkZ+Uq6nbmKWvOP6qU5HNp5+d6/rxGGcNeSfkHbA=", "BNgOfvfieisTl2eKxCq8xuJmLIgFA+RkP9+6zmcnO5I=", "F/ajrtsABamwoljjG45uKkjz+VUc72gSpJB1rruHhfU=", "HmICkSlJLIvfhRSUWVBoE2FZGp9e7cJEnl8inIW7l9s=", "FrrndIZ2VuZPyV88JJ+AHxUP1+4o0ZW62erkN0OHUng=", "EPAXJ5m+I6j8PxVq37bFErpBXjUWe1Y797GG/RKkHlc="], ["H8UKFtvfocO5kDj0f4GhxdHvbnsiHUzMpughIgEw4AA=", "LY09kk8olxmeOOr7x+EB0X1+VjSIqfMZgGB5auhMGwg=", "Kqmq5izbhSSQxlD/nifJsz1M1AIMpm9eGms3TmYpNbw=", "GEimDvyJllBzuVdz9GdmZofjjVm+II6Dd9MZA5IQV+Q=", "DIk4CBA1SdIDDL/gAE6mZV4k7nGh+MHwctXPbheuJJk=", "CtgHGMbp0cZ7Sje54QPbMvIl/kKpumVf8GVhi4e4Kuo=", "Ag2HR28SQ/SQJG+Ic27l/W0zGR8FYScUh+lpP8/Xpkk=", "E0uGZC/yAjiPT+NzVspPDsOAVWa31NQS2JN6NZ75tAE=", "LASHi0y4FW6Zg9EVdO2Z3HVi0/uxh4JXq7xohS/dJoA=", "F4OkUhWAWt6dNZIyEgsYPbVLQ/mn6PuNzZW6m7q7ulk=", "D8ljAuhmLeI8xcjCKKyKwtzb/EiKWfTdQePycJX34ZU=", "JLIuXOZxznnf+N4W180r1jddfsqgFuz1nP6yRtrIByA=", "BSwz/OCNSjn9gFFWyK/7hDSUKLpJIM/S55At3PmwVX8=", "APDUdSJcmXAruk/QEnYQK1yr/3vU0UfA483uTAesMbE=", "EYPpG3q3Ny8VfUxHdpHur/yeiGP7LYBlcMZ/SxhY/FQ="], ["EhSp1tcoj+hWUajLgwSMdmnIO17YLKJkL/8B6FKkS0o=", "HA3iv+r84WTJg4BnqN9jQPnZft8BIjMxWbcU9Fw/E7E=", "HjlNgAZ/DhC6qV3g2ZtOOSBKGHJ9FAG0duyXa18XOoI=", "LKLYsKeT2Q7TGM219pcZMTcVW8+5Qtgr71WL5fqzWb0=", "KEJ6sAemjHqxI3HxO9fboKz36X6m5krlLVIZIQ/oorA=", "LP/DeNLOx2unCAs3/GcaljKLzfxGMPzC8hM9zynHDdE=", "AM/KodfTguH+H8uVDhTfICoIeT1xhSVbAl1WLrjZdUQ=", "HYckxeZB2W9uNydxsKd2u3Qv08COGuJQQyJGzTvQG94=", "D+6PlzE5eXQQCDRknuh6J6ySvno4EDA0YBQar7VCpCk=", "EW8jmr6CBze14egrKs46Rc76xImmv/CE4yMDb1QncQg=", "KjHK25GNeLltzVSLOUQlpC4qp6KKa2PlCSYb+ub6JbM=", "JAyvbXqy97arPRXvzzB09bIUKh6ATyUBLZiEVICeCWw=", "IiTIXwwLQJMBTbHoF9H/FpGPFeDNIxuEikjPgzJMQUQ=", "ADmiiJUaA4HjqvWY7xMoU7XWlHFsINuHkj8LzxTJFKg=", "F2INQ4SZ9sCma7V3rdTK3WatOeM3fTAr+D07uhJrKso="], ["DUIafCWvVTh4j0lHWDZxKvXaFW+IxYZ1aM2VjjBQJsw=", "IOSigwPdVeXO4zLzDuuvvXky57NTHZQkVMNEuLjBfN4=", "IL0CjJWNV7eeNSGP405Gnr2qjo5xTpGNWBkfZQRrlyo=", "Bu2YoYW7I1jzNOsleuXjGDWZwFTBtOICJWm4No2hq8g=", "BR3rSyNIkOMfWsjmmh5TJFN3Suk6npNg/gCe03eunDY=", "IfH2pjBHHjKouaxLftSwTFa5anHuIKZqVFjGuNXG00Y=", "DDnb325tJKkaCkX5IsiUviUrqhJ9msdpCfhtwLzGimY=", "MFYUqs39QWfNG/3Y/N7OaJLYTUpl6G5vfGNJ+3Xki5Y=", "DvmuZeuSJgXUJgqyAh37tHdM1f+u3Bt53GgSCL5vhcU=", "GtzLiY5f4YtcKaRwjEsRK1bQ+l0pm17cB9b1vABCi4s=", "GKJmHAOrmw2PfQEJHH5WPvwDMZZ0fjQTnT9cx6wAHpo=", "D4rux0FE0Ao8o4v/ELsPOo2/9K9hl4R9uHl0WutXteo=", "H1NRSpfotXIE5XvWsbHZVV87UDaBVBVOZ8ITT9MVFZE=", "J7zWOcR0gtLci20T2hn7jWPz1sh19v6khtpv8u4R4Qc=", "Dp6DcxFK0lr5fSjicvxC2EkDc8q1ghk7h0oQQo7mzSE="], ["Lei6g9K2q2pxH7kjCt7hy6Rt6MkwyG0masuMHLloTiQ=", "G7Fe5NSSqOLPGxDbG3OMZ4AGbqg0er5TY1enI/bPV74=", "J/ohIEMTecvYYgX/EU803S284T4cKgqORqHcJ+e2hv0=", "GrUnYUo3wv+wDA+tNgq6pEesEGP7n8ZW0BSM3OLXw3I=", "FwzuKYP6PT7O8vgG9A7tjY4TXO/wdvxTC7/uh2yefx4=", "KIhRdw8aE4IiUdqRyE4SNZP64cnLzmxP8jF+cLtlggk=", "F5U4TpG6+lVN7fUVbNeZ4RIQ/9Kv6Be1xjrVuF5/3QY=", "LNomRzz9zRhbooz9qhXn3iNZZGoCh+votg1wLfAJAQw=", "J6tLQJAUZe9ZAHEU7PH7+rYVfCT0AiRrhqYDlyZzCPM=", "JxIngd97sF9q6eFOjpnaXCPcd8wGEIwOuwYeXRvpNiY=", "JoEqzQPbNBLK1Luhrvcb1EsAlNMYrOA2bHnnKf8OsuY=", "IT0p1OG2wB/A0QnqYWlJAHbRMdjgNLMED3vZw8Nz6hc=", "ITL3GsiYksmEoKc2U/LUUiKto0GBqebbzqDWOWH5NPM=", "EhOVAjkx9rs+8otgY+t6LteDngg/25LB5Vk8g+3/X1M=", "H2Zboz2kq52YBsr/d87TnJviVPzExdqPVwCWER+xCbU="], ["Dqe+gvHLSTsbvYOrfKKFvwoVWeoFw/WYJ7OwE9CpH7I=", "LM8xpXJBK7fZz6Y3cHhTIX59tVULHMMKiUzfSDo7Y+M=", "BWRlG8EXkXDjyXr7xPSTYXAXtDshPu7Ya5sb/+Uh/oY=", "C8dpzXs0/NG0VKv/DAC4m1QKYZuHyVREZ5w6xr6E1FA=", "JEtrY/gEGll19GQLGMfQZ+SgYn8YdR3JBgFriJPDUSM=", "L/TuEQ7hvmLicV3NEZyVuVQTN26I7D3cPwb8nbjCepQ=", "JmbsGmfap76wV6oObooQOWYBohiENyNpwBK0mq+EkEk=", "KwZmlx/ZEVKecO+RjQGfRLXJ13RCttGGb252gy1HiEc=", "K7W/A875M+Tuh/UR3jmFz/AyOre3GNTLyj9Cmt2/MFI=", "LjenRA51tkmgeZz/63+drjj638fKtsVYXkqE9DdynQI=", "AANx8NSTRt8tiLnxraismd2BJc+mww83OPuZMqhTJo4=", "DQMntZMELeBPWOD/kzhtFgjTOoaHLB0+fgiRIKrHpP8=", "BNvEyN5wjlmqSyEW5TlEvsl+1CMJtKGEVh2PMtKR+cE=", "KQ7ZrnR5+b4TrxP5i/iFB+b98BhxDkhZ/S5IzGb/myQ=", "E1qjgzm9kn3VBk5NVy31WBGyJrq1SwrK7lEdYK7bAvo="], ["Hjrn5XddNSZR1xPr386/nKjpBc+3kr94dCOUUPkUyMU=", "AdSSw0skW8EpQbsWPFEYv8+FvE80QEKyAx7YZiofb/o=", "BzM8vQ/xPIreH+vnKJLZrUNce0UapyqMBacII5WIKGU=", "Ka1SNv+7WYovjSOHA2CNt6SXp0U++dV5+/Bb44+PdvE=", "LnKxsRTf7n6NfwFhJVxolfp4YHDOYtgGxFoi19mKCjA=", "KtNpqEtX90VboxBkABynd50rS5awtKkfFWq+w2aqt4Y=", "FXk/McrqOd4xXcW/WjZirV2OGhL6GnKA8u+q2vqXrfQ=", "BWxV31Q6jUBDoS9AnNLEvPQ6dw8+OMP8ea0hS0Lag0w=", "HuEOKMYS2dbucvEnSFDD6Cm+XAb1uykygBUqVhDrAeM=", "KfNW3Ow7eVI8BYmnBG7wdYSGgoshIUbD9c6YevP9cZ4=", "J86pxD/gvxzp5TwMAm6DnYCn2GkTZgMQLN32PN8ouXU=", "C9wHix7dnLH9LCoBqXvffUWGSEOfrB8oUJtBotyed0A=", "JWWhemvFboewtjZkMZuKR79mLB9J4uySUb5P3zPZD08=", "FbCFtetnj4zt8hv7MOLWSuHL3XRyRJ7STmA0EBxliGg=", "IryWy+f4y8qBspun34SN1lmQNf9RW21IVVCELho1ocI="], ["BZQ+NhijLPBQAYpOI3X00Ce4wUrIKg3lfLuQxRIqZLQ=", "HJtcLAf8z9ncazq/4FZ1/Jl+t7jL2Ni0y35nFhWw7M4=", "KQp65zL0dU4MuRkjySSJcZMmB74ugpFj8RYS/4qVWxA=", "FDTs4gnUkSgMWuBdfibPktmbtyiaXBysCaOM5TtuA98=", "Io5zmbDgWAKFK91dXgmWbwPEw6/1PGg+svaeD8whwLs=", "JPD6FU/MbWRZ1sVvcR8l441X6QvnuARsngAYFe20FAQ=", "GIAL2heomDL+pU8mdB2Gxrb7nhWwLnvQZVM8tWYdKpU=", "FrEfJFAqpMw7DCVioYokq4+YZDGyRANNP8KVVUArX0o=", "AgqdV1/qiRMCsQZDmrA6ipUdiy7ytWKZGUbrJUHx+60=", "D5wF9gmtFN6+r/EHuVrM1g5iZiJZkFEFq/r6no4I6uo=", "CV8dtDyCfm8LnNT+kp57jHjJP9AuyeDxCZL+t1O0ygc=", "JrwA2c0lEkRCgy2Xq9kIZtP6ekAb84vZX6etUmVI/qI=", "Fz6AWWdWzZruBL1t2dwV5Ljrv+/jdx2YGb1NREcm950=", "EqZD9KMnrNJFRRTdRpVR42qw4/JOzDsop23B84IU/jg=", "EeGwr39fyfBJh3FUrhc6GnLHvDuhkuQ4qdD6gf36SQA="], ["BgN1UYD2bpghXWHlNGsRbMAM/QWCdNfZabOvleeLszU=", "AkOTC6Ad/TlF8qoC1YiSK0fBvvL/gCOoSbTKZqG/6Ys=", "HrUg/qxi5FRfT+fNtnXjZHS4sf0Z4V18c6Kx37sj/tc=", "JV373zBVNBOh+PURPWDphYODjRPhHB7gKyWjh+oAzM8=", "GEURMlgbmt+ZbGyuFbktLkwJ/cfWwntEJvMrXmagtyM=", "ByIcrTnZtfjbcFqHIwOLkra6+HKEExc16vvs1TPdptE=", "FW9qCeaoHY7s9NvyFka7loskBnhs0d7dTMcyt1Mvf+A=", "GOoO3pAQx78PrDYbW45/l8de2ToTp61KAX2SDAPJhoY=", "C3MRnJjSXrbeFCRrFAG+9IXJ3GrM7cI0lLlSajnVMiE=", "HGaChVLKwUQzNO1wt/1/tSX5B6tkR50ReGTJLpEZhsY=", "EKZiaN2aLzaOlVB+/CCF7u7ozpd8oe/1suPZS8NC/1g=", "HxSqtaWa1FLPaSsSPGWHPdgP/BiHmKRXDsp5Kz8vJX4=", "AdNGVbV3biRwFiGstBMkystQFl4Bm/8eZfmDBPfYIqY=", "FqHu276nnFQRpjnjvw6Q9uP3QPFBWZr45qQ6IGlXL5U=", "FN5Ei+y6bKCtshsHRV0sKGTHuFOCJnAm4o8JeIItZaw="], ["GYF9tm/bghXs9wR2xARMP0HXisWlScaE41hFlH3KCxE=", "CPMo5eZsC4ebNsIz9Zi9hXjRji2p8BnwQRcxUk9C2Qs=", "JZoqHwRoRHJM+ZKu3CY19mgPVeig/axpXs0F+8LLvRk=", "Bn2SlLQHKxLDaMKBalO7Frfn4qeZeaQW8tAq+GKr7fs=", "Dh1+wqVLEbNuZddVHpqHWojMx6bARw58JuGZZwoIWbI=", "Fzs7NJ7oiNk0runBToic19eF0ePk8etypcLlbEj9VMk=", "KXdlihDebnkhq540vPB7vKYaclSa5X0MFWkb0UPU0t4=", "A5YJdzPeWh+kpUh0m3P/fEJvmNnlrRaSBhTTN4l/ax8=", "Kmbe/PSJwj7sUHmg7OHFNBAnpZ58WS52AYS4JtcNupw=", "EPQzaMBWf0Bapqr882fj5ovv+VfEsMuhfDDGKz+VSQw=", "JaKkPuYSZj29YYFPLesG7QBadBT5mCX4vmb1Qvlaey8=", "GC8ck8brKYZ7FVnFggemrq9Atm6q9XnKa9fKQKrrer0=", "BC7qYW2QUCUUekgutDajt1U1yYabdtbNrOEY4VyR+3c=", "Bc5/WS3KIUjhmFVP1k24xHnynSPx8W2vPLiTDZRW5MU=", "GESoHU+rV67btMRiji5H/LKSKIPqsLLh3hbySN5LuQI="], ["Bzll96m6jLM6lV1C2lX9fDej8CJrAp023LP76pXWQvM=", "KEovCD7jKmZjCByABxPg8jleNI3OzIn8gap1pdsroSs=", "CPeObcWc1GlMQau8oIZWmpCDyozIAL2RNOTUjtnYncM=", "KTyooGxfF52TgGXqR/gPZf8hlpqUKeQAqhd+z2tq6FM=", "Apto5lLerIGIJNoMKhG0CNeoOaLoV2xVv6XxM1/8W5M=", "Cbw+QL/l9hb71SDziUoP3Tf+spQp/TpQFZUxcd46cPk=", "KEGBCT5DQZeJJjc25USBcRH9y1WaQ3c/BRhmCKzFQuQ=", "C51aOpV+7yUa6cJuU0I/m+by78JLsYdWiTqdgOVqCCU=", "BKqOkdww+coxj+JHGP5ZWHH3iX6S1X8th9SxvPmmNeE=", "JToRxmRjptyv2Dmfyli6J/67wwfYgzxmbg2N8HLF9p8=", "Dk/UmHeMLHagLQ2R2PiYJYVucG9Zgzff6788ozOXlo8=", "Em7IwgAmLEXREzv52l8eX9YrzqHkk6CArxvSg6uG8SI=", "DPAwsQobQpHlduurs5xYP+oPpt7PqYz/epbcBst32lE=", "EQKY/n8rz9rAvNw6/+60Ntezo3dFOud4+r03qayymac=", "Du8E8kriEO4KlLxWIVdHg+SdTZM2Wis90Gn6/UMFVFI="], ["CaVQQxQwhGtmlBJbVkKwBgfzahopSFNho89Cfad+zNA=", "GXcug4FvwsSblkJ8atBXM0f6SaXfaRJSWSrrw5AFWjU=", "LY7Gra06ZGhDyIzaAShfjzLSnGsQJctUIUIr+L26f84=", "JVuWJY3I4WRPG8rs7nc2MvJabqgDzTKh4B+CVzd19vw=", "GG4TYAQRk+EvOAmbDjXnZ6/8NBD2qN/Om8dVZ+ObxAI=", "Kcsx4a/vTyUleKq9dvI6EyCqyQ1KCmbCIl49lMxI0i8=", "IA+iDtG4cTE5AMAfi2l3YNAw2MwBUP3FjgSg2KKzRLE=", "GmOlidFxCqcFE2y1IMLxxE13jkkMIS1LcunxU45VVc8=", "EzNps7zHPueT6Gk2DNUNjfYP45jtnZwNDQPmafeW6H8=", "HplRbCQNQryqrZxz8hpGGT24QzNJIDA17qMDmPnfeJM=", "E9hMp/NYqv+x7o666Bwy4BrcAekNCclFGvNuMa+CFw4=", "BaeEZKS2u8pultg5gnv926qdkkhArvZVXeZD3xZ9TKo=", "Jg7xOsfoD9LbPenrlC7e7z9eJS1MBFCLHhsTAZGtDfY=", "FIKfCdS+675vwwVFBHJD+z2rmcYqq3Nkp6W0J0V6AsA=", "EyhGfIe6cwKJIaiTM7q5f4sk/Kpy9Dg3y8/l37epRf4="], ["Bo606dbgpYi2GmrVAfOA2g8AkGdmbAhT0VbjPVnENRU=", "LcWQADnUyFI6w3mUXLm1ilTgHbrNZ/DEuu6F01PT/pc=", "G3KsQ3TpW3t9KM0pCVB/MAboNS1K8Z5HsLkJaCoDIA4=", "HyqNyv55/Q6iK7FWPDsosjxcTXWR1F4GdEs7N51CZhg=", "GSlN0i2mc0cDd9Zx+r30LOzTfsvAGDhqQ4cG1hBrBKg=", "GTK8a7SItzbg1L8wbUHmIuZsHWhapFmBUwVLQPdcCwA=", "CNHWi4Q3vJgKp8Wdgzk7FioIJ950Bw0tNLTq7cF+fmA=", "HANDgWuM7LpIUZtZsPttSputMJ7jgxHcPoz+i611378=", "BwnquWzGJV8q6ReRTyUIUCVJDEIyhJFuI7YIY4zM4pw=", "DGegazPPc4grHHFS1FhbeCI9hcd83cLH01lIJMUBZWU=", "B0DB6bjtFun64gQ2nFVM+3IAfcz9JTDy401UQAOuWZQ=", "AqhMQk61j5w4tDgK844EWEaJgJiPqh8NTG5yOEVnhSM=", "C8Nn/ZPOrLWZxhSqKAaHg6XSfuwfyPoXZQFbdt2C9c8=", "Ani1hQPguQFBBPjERr7Uxt5XXHLU3Z2z0YZoRpeaq5s=", "B5HYMul2tmvar/RQcx/zXZmFlauXSPaVu0XSwP7waTA="], ["Il4AoNpaf3SWtw0JI6fPf/Myv/BpWMwPP61DmHT2Ak0=", "DMN4tE5Y9mi0WDL9q0pJNycx7yQVw39Atd7VWUrvPMo=", "DX2Cc94je6LU1egFHFvV4xLSmLZyb/vTr35zKvkd/yc=", "IuvgoxXge+SwkoiF9SRJsBGzln5RnkOMQkzAQow1cm8=", "Au088CFPRE1DZlXgOviu4rTZaWHuoG6BM71ujT44I08=", "DLb6Cl4RuRkqUZBJOdRaBa+AVb3qPzefqsKdEwmDDoU=", "A5WYoUQ8AJZ4YCuN00dPJ22l1iQlCD7GKKFzfozKPnw=", "GvVuZXUSP5nF16t7g3cPD9YPufQDjClCZEBp48JDeT0=", "Do2cBwfcW/gKLwjDQ8acxlne+GYwrzFBoAOss9PpDAg=", "H23Y6F01l7ttN7R6HwYxIgFMiIJQs4z46C4+VHHvhKk=", "DMj5C6to5t6EhF2hiZv8UkQL3duUCyCDAa6UqVd3y3I=", "DA3PKxNVLsVclxZr40fKL5OwfioQFkCW01P6KAx5aCE=", "AB8SYRepSd/5APpdERoM4mYb2dVERXfEkamVHPtYGS0=", "E49n+9nLke9SBtSMq7JprEK9NSzzceQzEbzK2JrMUJ4=", "EUkrpAZDXzViOQb/Rd8Rw577Wf/wn1AfuJPXF+NPnWE="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon14.js
var require_poseidon14 = __commonJS({
  "../node_modules/poseidon-lite/poseidon14.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon14 = poseidon142;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__14());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon142(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/15.js
var require__15 = __commonJS({
  "../node_modules/poseidon-lite/constants/15.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["EeJ9p7fvlklIozKXTQfM7qd4vDOu280J3iIvoirQsQE=", "H2A4G4O0So/mWg9BQvqq/F+/VfeRM8V0DFPwNqMGW2U=", "D8HhrIrTUk69v6RdzFFXZUgjTQKSrf4c1wpwahttrdg=", "CkB5jq06EreLzY8QuxXLDEJrvSKCqB3NwHAITOeLjXY=", "LcCdM1cFEVWYfqlVlENrbL85OwE19R4vZ16l9GL0qcU=", "EEuSQdU0JkUy7aGB3hoVTdF17hUPNJAz5G3cVBgdoIg=", "EnpiCNmPbNOHuAL6RMqyA3s7kfBiLxcITxuNisnRJpg=", "LQdc7rq1Q0HcAvsfUNk4zh39zeZZlVqTDsGPhiX4bU0=", "BE/VwhAaIL4q2SO+vhWkd/QMYDmj3Q10Q/5ydYBCAQw=", "KzAshRH703ArgVVkxTmay4qPKo63f5bH8ISWKOCfm8g=", "B8vjOduQWZRV0e3tHoqHC9MCySp5sdD07ociLM6Z4is=", "EyZ0kxLG6L1O8kyXyAn3iuVIOUyUw98vKP+oEF3r4hE=", "BUAhQGuNH4xwgOfCRTBOS3p5fNI22tktkpsiPyaXgOA=", "BcDgM7WJ+N2yOp1Vnq7s+YaRqNAY8Seb9AbQjyeHzEI=", "JQiozdRQ+Wm2HHSdVmyUWaFurUMw411UFbEuyjhYS7E=", "Jk3MwC5XTKfnNtolByvY++mQliH9T0Fpsrro02j/EtI=", "KpOMJUDWNhV2PsO6EMGiYAG59L8UGNEJKmsC3aUZXbM=", "JU83C4X1in5KsnpiA/OhYcGwcPqjGFuvKFKnWoZaQAw=", "BIAYlvEmjlq/g3EsdBTIlT1iI+UcRMstyrCynBSVKsg=", "H3GI5NT3VJQ39I/asi6HTnHQofGMMBBuPdJyH5naVh8=", "K5JzcBrgLXsjHORDrx2AvyHWWuphY1MzYFn3Ve3raKA=", "FZciTLjpBc7YKWIKrNz6x25Qmg97wYb7cGAZbbk3QsY=", "HYxaZSiDRpB8/VenUjchloQeYyPpaznaf9F6gsXhJxY=", "G3Xc6VBzH1CCUbhqfhpROZINK+wYeY1Dn1gVcMHcZjA=", "J3OgGGm/mtNZ1a2CCbM3EZ/43t36xuTtLI/QFY7o8qs=", "Gl1HiD8kRiYQy+etDpsbiuWTC9O51MHuAZhPYiZRW3w=", "GYJ3MgWUYeIHPNkKCa1UFJscpZCbligaR7LZw5hQbP0=", "KXyL9UsDpvf/JyRl+4gckYVRu+mEdR8+nysw6jexpPY=", "AfPaNrH/UoOweLafXzp9S6sVowh8Wuim3DB+unci5A4=", "FnztbjndO9bWVe3dKr5saP8kfYb5pqa8vUHJjTe08TI=", "CF0ZsOFvCsKfMtpUFEXoqKbbmnv0XnQfnxE+dSa4II8=", "BPNl9xDprNXBZTzG/Y6TyuKg02PxaX8++Cn3Q1Ul6k0=", "Eo1PA9A9cJfToiza72sR8ynK8PrLwaZ7qR/0k76cpxU=", "KAIQ3UEmixM8n653C3ma/9PmaAXGFnQVrKNuqgLbECE=", "IE7nx9TqBvfKZfqtYx5wPg49u1nEW1Hc7nOwymTUXMI=", "MEKv8JwXZbT9c2Wm3KDxFyZm/cDlSYIrA/c4jqwz14Y=", "I7eAd+dRYCvnd5BFhhzOOtMYZwu4LzPCk59m1BVUx/w=", "DzUeFL06Qa13A8+akGuteRpieZa5NRIebNw79xKSzsc=", "DmewE19x1IWWdJ+fqFhcN4lEECLUW1tGEaUHvUAdDuQ=", "BuhGNJZtRiu9aMFM5u4WYnaeQzFODrhePVkJ9RjanfM=", "F2ERLxXzV8+WQiu0Z5b1fCx9baQBabj1eUhB6FYfwCs=", "JDh6xXMTeZx3Vpmb+sSVuP43enOFUmyKyv4U5a/gOcc=", "HzyBfL+UMCoG41Jv6nsyGKKHoxKZ8N0WK2bTWM3PI3A=", "CxPPJcJy2uM58abzDUPUD3S8C5OO1zvxapXsw8SZb8k=", "LHMeYttMxBxWzUZcSl6NVxnLUK53NwRP5OqFlmWZfwI=", "CWG/6o+fKnCPOt/BJ/2xfr60pWMqgmTxeklMDwYBFWs=", "Hu+5n+nayakZY/ES3TV+1R9Zm5JU5b4sdf0BpY73E5o=", "Av+YY/oqbK494Rax1qpWqK+9k8cEF7igWThVof9XQSM=", "KWVfwDDwoPbdKwDKulJ5OP0P30HeibQuqhbuWY/QMfE=", "LZ/nRPK+rbmJhp/CBelIdpf1ZyG+scojC1m4LqsnsFA=", "BLTD9PHCHW84mEgoDm4AbAVSRRztv1q5be+/DCy575I=", "E6jz89DofVO56VlmKgaWOPvfB3AkVkvCpWdvAkfoQo4=", "GHXC6PQ9lmDhpVY4j9gXQe2n5IbPYkPC/hdS+RmFm38=", "DbepF/fvwdIWdySvTqMrH2pswjwdtav62QINuvW6U3E=", "AcVtt6gfx4uUsmfc5FpNukikKIuZ6r1Qsa3PEy3Up8M=", "HJy1pdAnTZ3DHKB3Q9HXtNQWgB2WQDmFHwVnjkvoKFM=", "AveG2/g72+xmq2VmlNU0iYi4JStPWj9KRSoHX2Df6So=", "GLl4mnpoGDrThOzwOEKfdYFFk8D+of0l8QAcO+xEiMQ=", "KOscNPdwq5ErVUgqlGvaqinfK0yUfCnOt8ihnjiIHWE=", "JunJ2qtiqfHWpMaUuwxv7CdHh6gyI0PAP5Xf5l7njoE=", "ARGXeFiHkUVnW6fx1w8wEpT+3bCoAs+pRKdZB6TC7RU=", "Fk80t8NWuf2hp9hBX6u2g7rGHucMI1c/pyqddWulLPM=", "FjIZylMis3dOdbHm91ZX4LvrdqnjI7fHiKfdZjiys6U=", "BEFZT1nGXRqFdrj7urQFjcOQAqG8Q1cIQZTOYyuWEbI=", "BMsAW01DkxycSrxQtjmo5uILPKWvtgsGFAyyS35KaR4=", "JetQIDyqwXw5nIPGdM/OtOc/InIoZH+dIg6V00NKBNI=", "CmBff+nja7dQRSNSUWnGaJzW0v0HbX3BEnfuEGkxZ3Y=", "CrL+IJud/HyQBySMt8o2tMFNmRqzuNBKFj6w6DakbFg=", "DhRZy1wK3W+Q+UmWVgMyCzE0VOZ0evXzmVZvXSNGEyY=", "BFrh3EqG0eyA3EQu3OloKmFtJudgE2dauwTMpF/OB6o=", "GDT0fBNpjLuRYFnLzIiXX+Fd0OnDMZhl4IFH5NOXqXA=", "IDmhxzNafkx6aUtcW04bRPYglg2Ikz7VI3Qi7VMYn1w=", "KhAxbx5mrPMuKtzcKSo1CgDY1eh+xdu2aUnj8DNQuz8=", "E2C5FBVFnaWEDt8UgmrqBSgflz3BgTPO5cvidhF2gko=", "FQXiVSZ9M2oIHbbwiol78rpA2s1OwdYamQz6pA9qX2s=", "A1DjAg6jDR53nZgToLZQl3rbGEJpHoo2TBK45Fj3fTM=", "Duu9TCsMmzK4LZbWSw0iGo29BkE7YHumn0udQswSyvs=", "FbLUs2HfSeNESiQE9wA+4EMUfKw9FChxHxIms3TYf4w=", "KcgzjFz+mN9/1J+TFrSVCBTd6dZlNe9iToksNdOAsY4=", "HXomJ/Va7ODMgbd1WAzN6V/RDxEvjqcaf43OfprHmOY=", "DNY0wnq0BgWKvaFWr0Vlct4vVJIAVYeu5px+XTRdde0=", "EwP9SOJlZWXnoWyo6FIxMUkwNalyHTVPxE17xZtyetw=", "BS9aQ4bqIvX/Bv/qYXnlhhe8kIo9xrHnRigZycnpBqs=", "B347xe0cNLo3AvwKQsRbpccUprDBC6K02MKnqnWVkpM=", "CNiBYIgvyK/KYESQTnqYT4XJnvz+FHussLfxBG+VPWU=", "HOOyLf+V+DTH5bYyYCnGvLTVrksZ72nEBBnRqteWoYk=", "DU/ZlNvMFSYt9fPAya3+wmg+Pv+/UG5TCdvYwrmIq44=", "K6a+XNea/3RiUR71o4pPjHjHT9BJ5rhlfNBE6Cq9lLM=", "CXZ6LZ36OeZ8lUAEANqWoZLab+XA8CzfG5w53I6Whko=", "AQUhxyP0fcX+/DW/4M5+M9LgRbKgGOEJNmLshPEEwF4=", "FE8JuANGzPvAhl+mTSINbbt7Pou/A2PmL9jMtFe94e0=", "H8C5ky90tNtW0JMVzGqOhiBSdso+OxJJY9roPbXta6o=", "B3bS2XKgBMBKi+e18vzrsC4aOxt4cDbjUUu4+XLINh4=", "Ih1uVg5U6ydmUSjzfhwxJSi+Sa867sydfFZ1XwdnWNY=", "FkGJzf2YM7ccH4Ny6Zm6J7vSDeYvllrUBtiu5nuI4fw=", "Hj5zbs+XRbSr9xpNhj2LbQNSPq+C2SdFJjk+EDsIo8s=", "H/PTCzKGuYj1AeySCxYi0qC6LPqd/FicU/Y503nBAFE=", "ClDZgk/MlanSK8CKWSsabTls02GUCrw/hzpyUjAIOn4=", "LbUKHha+Y7tj1C3lFonZkNLkchuToH7fuijyCJZXQO0=", "EoJZT/ICEuilgaIo+0QF8u59NERVZvyd6gEdibICu5I=", "Ct4nwHeVHNM1/3ibe01j/10Lzq7MRtzO/gaAwOxu8Js=", "JzdK3xs4rGLQePpOcTaSvjJMok8u5D4k62Ktzi8+Z+M=", "Lv91+jbocWybasCst42pKXDPespqDsOzfYbpdTgkLhE=", "GigiVYKh7dRkeEsR7H7/GQ+uM6YaeDuEUydkLoL65o4=", "DhET6B3hvPIE5RqMw/IABH89jYVwTET19axu6GLJ9Dk=", "IQV10g88KBa4BwdOcqZypQc47QxPoJtvlmIjkDpHn1w=", "IeiX90nISsL6/6niZKxhuYPwO/nzN726TcSMWXGhQ1E=", "GlaH3LusYpcq7YXFDnDL61AZPYMcB5Due7zefZc4pmo=", "BBBUmdXP6vEV/gpA10KEToBrEHKWswbE1VbS8kTklXc=", "GvlJenKA4UFJVugPTwcuLya1CgaHaWfN1Xrs5yDGvkg=", "Kg4tPuxiWbfOfg6xZn6O0MFs2/oiR7i8fjCO4y4sYDE=", "LXyYbT09O+jHAQXkhJIWDvhTifHjHbyIFLDNPoSsXtE=", "JR0SMedjl5I4t99KjA9QGScd5eQ4noTAnlpZbU4eIrs=", "JjuNwDrH0lP1y3uL2SKikGdbq+1jZK4Sz6H6uMVsN+w=", "B8WcMfl526kwuUyJfOcBbJ3fxSemlnhrfl4cGTiiwo8=", "AJ9H8CH6Zd5rVOdR3VpL+Re9dXTgcce7Mb8aTmOvIVA=", "HBYAQ9z/IzDORB1J8oBIMpafJzE4PlJMjnqYE/dB3e4=", "DFtolmh/Bmucsj8hsywmkJLNbHEdvma/3gmFhzXLg3w=", "I6y9f5KLvltyp+xELmaEyPDVDPgj8CgEx4UJM7m3DPA=", "DoroodEUHcB4KUE4R8qFcQXlGJpl35rEDq1Mr8Idfd8=", "LsoJifmrkW0HqylqAiT9o2oLx6Wr1XHzNoBU2neV4wI=", "LHbOt9BAtOWP4Gt7D+g+qIt7TPN2KWdx7BXRIjfNjyQ=", "DFOv0bOBFn1z0Uq3246kG5M1zsQZSxBaq34AYO4eMEQ=", "DDZilWKn3GfljMFb/c4jkrOhZzYC6XDxdM1saxRVUyI=", "BS1mthQlOt6PdAACdduFJfiMt6cbFN+diqTs8m9Mm9E=", "Dea6FAkEYFjYMg/Q6/n8UnX4N+5d7CeWPbQUUJ9gj5w=", "EJrgUkr8KxGH6Iwvo6FvY4hWi3+L28SzmfwAole8G0o=", "CxPl8skBtFTKSb7Cn/y12j4T/iN86G7e3BfaQLkEUFM=", "DJqYavKtWEg7VT6Vxou7O0WCnvbk56SrhfFyggnsBZs=", "AJOk4fxGuGohCJDnQaFP/kEknrCwAIJk6m3DGaBzXMo=", "Ab6n5So6yik3VJkj37fjX8349cgSJ2N7MBXtG6cSZXo=", "EeiNwLWQC9KVQvvCODLnSbyaq2NH8L+XzTo2xjCP1ZY=", "E4dB9ey/OVmX8h8hLnY2ZJHw9Y7BlSAPEDOFXOukMC0=", "JEcBKpRpJ6QkC0cT240n4TDkGd9Pu01ooeDxuV3TZtE=", "AnYZOngvbeW5A5RTceU0G55dys4EuXaOZ76YMKL2dNk=", "Dfm9aMT8MsjAZPbEfVF7E4iGd8mF0+8fHEn7iA3te8o=", "KQkcGGE5Y8bLpPTA3vUPzhyrZHqJAZV+4qVTBcKw+ME=", "C3j47MZXeWb+1H7mB+JfIbQf1npUFt42QSg/L+glyVk=", "Lo8FnJt49iQRsBf4fpAP1wyANr4XacU0TupBWcYrazo=", "A+NMKHaoNBMCnLcBj2V7Uqwoe6NR8lIXOK19MJ0bZzI=", "E6H2YKh1V87PAbUFwaR/zda1LF8FoexCYtswjOhvayw=", "AQ6aWZb44zkLa3hhAsrZFFIKjpPn7VUbSPMkVofxTTU=", "C9vumEao1nzZ1U8EMyeQRNhQdgQbB8PiJLONII/0jE0=", "I4Hf3ZvDN9XW+4YeFsoo0RfVhtFtXu63QZpmHHgsH4o=", "C4Vr2P3W67fw8d7Q7xkgRpHhw3gfipxPWFEfH6SE/MY=", "FuwVlZvoNXUTyqij/vCy/BCxaWuBUZsKLPwYyRMXi3A=", "GUPXDA7BPJFCZZEhFWp3P0FG1UjN/ULkCiFbFllIbjE=", "KeUmiseW0m77wstPmOLCoB7/rLFQG4WCzK8eMRry7bI=", "D9ctKOdb5T1iaTf3WvIvdE6ht9z//5TIZvPaiol45P4=", "Gc6fmKNphp7EW/7LHxEqX3Bi/NbHXa/OkCrHDMwM43A=", "CKTRSaiieiFwvJzmcEOO6mTSEdOpfHAsGwHb071ekf8=", "GRUL44+l5f5N5+v5jVn8mvGrqhP1oGjLcWAC86aYORA=", "I8RSYRAUQN7xwMI+56r12LFe578x/3N0q4CDdNja9pc=", "IEqVQsaQ/jOP6rZT6aRqrOuvLfU+TpBeiWQUy1oMsSY=", "Eo79TGJUzQPCGyGRPOUmZfrNDpxG9GXFGkWBJHI63xA=", "MFvs0cugf7dCyVKOS5J22HGxgVr6r2IYyw51iq5ezn8=", "C7FLaWlv+0pG+5EwGvMmgv7po5GlNyrRnzpOMgv6xqA=", "L5gdjuyZUOOcb+2Aef5EovJW5+aGpgy3VL8YP8Ou3go=", "LjjG9qdImlTtmCxIOip5Ues9Cyjkjd+LV9KWn3g2kzc=", "G9cIbrcVDA3OG+ujmmfLrecri3LhwbtvDdtRwT7lg80=", "HItDfyvj5hZx5rYvtpjorxhyAxGWpD/+dtFSeyMVtGE=", "K5HHp4KJp8Q+FjXo7s1QukyWaUMfECQ6ZcyuYDFWb8E=", "C9+Ynn3d2NlFHEVhyne6cHtzj5zb/10VwRDudHE3D4M=", "CtGjIX6GZFps/xpNhsofGa/oWkXnSRLWFqTStDC71Hk=", "JW/40/Uk5OpoV4BEjy+MVbWSU0Lwj5RKx41Kzq0Hqgg=", "IJ16spf1oxJYIH087aey4SFoPSCuVhxtRgwR6/sbawE=", "Ca/OisLCzzr/YAJEG5jqUvyG0+xBEhbj1mm1XOW4v1I=", "KfgrHsAuaMJQmfAQSBWJfjPtnCbc/zssieajRxIiyTQ=", "A833+PsBX2hhMi963CIa2igAIRl723H4AM7vie0CHdI=", "J+smPb986sgk2F8qdTgEaSJwM90CFTNlY23wRNjLC2E=", "FijPCEKAvBSanjzL/FvQhyIQGuSgQ9M7L5iudqnVWYQ=", "KxaL+x5sTO1qRP3VYYYX3LjpxNrXsExKiVUgnxthq5M=", "BX3gcJTcowcjamqMyz8XIHeFSQV663p9r4pGO6GMhf8=", "D7B5ZQ1e4/eGA8YOi1RTE75ef31sGmED/XnxAKyMoQE=", "GNl27Z1E+3Q3MguR0ylcjjNue0AmWRSbLKuusnL7Br0=", "Ht+77xgBQsR8TH860eLMgb0CCr/MtDLuMnyqIuk/9F8=", "JRD72gwbglYpCirTtFGcgV8Dl7uMhVBa9nKut9ofklo=", "FHg86b1Jhg82TQ5G3vpmbTYTjcQGJVuSAJBPwGDPBCQ=", "EA4AR3NpwMZ3j+ZTaXRIFjMb/jd9sz5m9jrOMeO1aFc=", "GuqTtRcmqNcEOd37fi+HdL3plrcvnLAMw9fy7i4MRcM=", "CxTA32siItl3ITFhQBIpdjpVG4iWlN/TDoDffm92y0k=", "CmQ7pyUxoZKx75yCdLqOq3P7GmTDlRtnJynGDuysNU0=", "DDahLIOkRaaXmxOha4ehK8xjXO2MhCHvmoyyg585awI=", "Jct5Ks8UcIDTo8Lof3KcXr7BxDiY4iL9DlCpUYl9XTk=", "HhBk9lRINVSG2/osLINXn+9kMd6sNQRvsne1iFsJv5k=", "JkQO5PxMR303mYDBg0o7LzsmHX7XuRPilQZ27SD4eFQ=", "MArPPpqQG5xoG0Om6ntILL/ESV3VElJH1Mmyq4Q6r8A=", "DSeDPaitzCFdmlMGlsUmk7AE3hUsZHGUXKehcBw4Scs=", "HE6PYCS7eWMz+FNGKileDMFqYJhXLvWNFZpSjPiGquY=", "DbOOEHEhjvDuXXeseA3Oqt8c953J8k0vPJ1YQSsaWTk=", "D4pCPQQK7w7d1u/EafTdnd1/5ZGkruOuOQbaenf4vCI=", "CdpXDVXi9kyU47LnouJV8FndNi95amkUKWZ1b62FkME=", "DXzVwmXPtbAaWeREjGfHrdvCwJsl8HiyPFINeK9ABX4=", "LJxHvEwzKqwVrGi9tGSuGTp0XBNRx9EjCyYfpAuV32k=", "GrE188gfw5WnuU4LkRU1kQHsdedq36FFKXWTk6F4nIo=", "MFIdQIL1i486ErfI5B0f2WgoSs8SFD2FkH7HgtPfr5w=", "G5AQIhAnmkK3+PJse9Bo3YK3bNP6LzMBRWmKEfXtmW0=", "LprENBeQKYJs28YksyCAMNTwsmXkqOHHC4lRMQM5gJY=", "J4TD1x0SVYYYVJbj/Hw2mZbnAK2Xg7I/QftIPN+O7jc=", "AlMFQokh9uNNoqsFw7diJo7Rsbw/BqzdHdXjJpHmK6g=", "HTAG5sVyXhe1gotbWiNxb5ptCkyGf+0swlQ9wKyZ2qk=", "FodnMj5Ql7sv5mgr9qyLtbj5rwcf8mAlZHOZiKOm8Lw=", "Cl2AsgDn7gBQD1Jo3DGeALeX0K01iYmhXYr1UUIeG9c=", "Jdu1Qj7ip9eGH5mC9SKww6rm3P0OkFCMtlUPck17goI=", "JeG5cqp1dv8ACs9+4QEXXR0e8YJkQV1PyfTFwzYqsCY=", "J6nGcOaW7FKHuLYGpcIxrg/jzbdk4u+ZrSVSMbmFAP8=", "Jg1mBqHbSFS7NY+kFc4TzhFDFthxp6K5DREsout73wU=", "I5ejdPhKKaWtN5i7zlZ+tjFzDHRafTieZUII7s7LKPk=", "Ee4cYWME3M8CD4j2pI+kByEm5k4nlv+6id2Ts6kfHy4=", "BVrgEVILTsW1p307Xzd6JS7ph4GowpRNK/CuGGfvkhU=", "FwB/dKL+K4VYGvh50TbVh8vhjpqcO6GsAcUM+i+47Us=", "IUrJZLNLIQ4DKX/s/Ij00GqF/PDxXjgPlIsV+hME7Bo=", "HCFG6hU94R+kgLREKF/dHNpTzCcop5bDdcR8Li1XQEI=", "DKCvAk2YOuqP9jQN7p7IKN15h2LBjwa9qSJZs8FYB2s=", "AS+Czp2naHCmVzVUiYjm4K8YDG1LXZjFrhq4bAVcpug=", "JV9hSjM7E3XpJSbjnTdj+njxPlNffsoqKnuXyg1Ez2w=", "DQNUrTIvXh3/p6ruxEQp/8ieTfYIHASbftPT3ggue5I=", "A59Jbov3a+n6/2nPMxqEjpKA7aAybVoZExG12vwn66A=", "GwsOjdhiUj2gkDzL1RjtxaEpUX+mmJQf2wkl/wPPV5Q=", "IhtnybkjJ3OHuR/UHHZU03zrk37mkvvsOv5uqs8utrA=", "ElJJujyaxMWcHc2qbeKaua0UgPiz8CDkaGCPZb7FEVc=", "AmTpOQt7J4fErjXZ41Ng14B+NBS0B3tTO4U4GBHR5zA=", "Go36F4Oa9c2sQKyJxf8jR+cMF3BuMmiM97GOCdGbdS0=", "At2ydOIvE9HpwYbrcQwrPPe7A3jORiJsG8oFj4AuHaU=", "HtkdcKHg4inYVmu8qvY7CqoyNtxy3Hcv+1Jkw0D5Rc4=", "JY2XFHSMo7rWKx/JvtzK4C+IYWQJBlgNaD8hExxSBbo=", "KAlPsMnOP6Nwc956EmG/Dz5w9jOP1ZjtrvV4SSl68gs=", "AbJoJFlgokLY1g9IMJKP0Qsr2bJ9inMd/faUdWA+R3k=", "HM3CxIJJSWgYYYhzrOC79Ks6Py9kl/k5vnMzCtGL3Wo=", "ENe2/XxxuraIf1HsVjmkR2gtf9a6cQ6PsU+B7XLHH2s=", "FKE2oeSCfXB9rMko+L1SNMwyfIo+S6YADG217jsSV1c=", "KZEgiEL+tcmxHGGA21f0ecMonJu/K21eY5sU13zCWFg=", "CGQnbwbPUFANUcwtbu3KCS8e/R41cXyRtRgcZuqzSF4=", "AdoRFcA1kB1C1RKwO8KWLS895QTK7AjxhDfJA2OlzRg=", "DOTGFSLPEYtm7dLd32g7QH/dHQAhPy3r+ZY7WoopdhM=", "IoIr4Uc2x3DdERAYrTpIGJedoi61Irs+5LPr9PlMATg=", "AkiMLvPOzfmA6CavKYrzuBztSQANCe9szu4ZTBPzpE8=", "IrO9Q70TDA4umJ/QYz41KAXqcsIUQd2xT6Kk1/9bXr0=", "D/6hHZALXBPNjkYy6S0o5V9LArmuGC6yYtn8BUxZKs8=", "FKzcBlk1Iw7+gK27Q7pW5IFcxT4eu/05AEKU2eN2ch4=", "FfwefLgZkktvrqUfwa3sEM0eOtrA0KMkYKDUqVoDxqE=", "BUfRkSg0N28ANXkO5/Nqtzycj0HhxPvNdzm0x2diLFE=", "E1+fTBb5dUW5zbXOulrLmk5SriVeKmniKzEUVzeJgJk=", "CM5K9A195ZjFZPDDjGYg7dyf7YJsQGCqbCjw7bM0XoM=", "Idam2XElkpbtm3KHIQSzQM7bkRnEd0tbCKtLrSnBYec=", "KrxiKsNfUCQfNlKqli1LBFyM4bTTp3xRpcrpmVxu7rQ=", "JUWyjVT9zr5C+KRWLeEGHrIWJyiJU2Jg1fMt7NvEyC0=", "KFQmDmPcRdIq/SLYyf2MIuHaaPQXOkAou4hb9/u0reI=", "CV1U5WiYeufDedzkbWeFN6JtYVWKNwYJ9JHP53jo+5w=", "KsA8RAyK4PdTpPYz5wS7QfjHUcxGO5GXbcYxVwV8+NI=", "DOWXcA+k7wfM79Juo0bDBhjrQr+aS315GpV3NnmJcL4=", "AsE6QCf0FTs2gKKbcmjh6veN3u+fjRrAhmWVzZUDuDY=", "IaZDg5vjUaTzj7uxc7Ww617KxPeLd/aDDaaA71q6EcI=", "BTsHxxzYZLIROr0HBf3yQs88oBayzlRc0Yd6tEujXMo=", "GInHBQLj7fs/IMizL77arVH8atHKoUdVx+3eUuHUujk=", "FoZrZkqj9ijOnhp5iHr3H/G/INTfbnB9UeBf7HuO32E=", "CrR8IBrTFcciBBLhwwS4ElRtSj2E0P9xx6VwGOfceDQ=", "BXe/yTsatQ7GIiV87ts9L0pUhgAvdYHJ/zzSLzpd22U=", "B5AKo1K/lZ5xjlKEpEhfJBp0oLt/cwFmwpfkSHMtbMs=", "JjXflWt98/feKYzp4Y0xCQfmXByWUCxpPRvpVUurRfk=", "LnEV8da7df1a38hyYTkiqhcvrZopSDtIcuX9Icg3QwY=", "KOMwtuQTrPM02+rxlp1WaXfcpna0YYrCelMLbIWeVyg=", "J+ghwgUoaBPhMK2ZGsvixx3lUs6yzDTucnZm+Taw6C4=", "CCImhNgBVJMPli3feLLFZWilnl2dohro8GOtrMnCw4s=", "D/t8w8Be1KMITb10MRLAXyVPz5tZOr24LiXfxbTbj9o=", "DW4R2bUe+PoSsDT9hwaP3CLwpKP3k9xslmLrnrkV0nk=", "LF1t3hjSiwjZGfOYHl8nqZ8sENmvUmd9JEzPZIDGlgw=", "EFgt/F9TmcTJUlUBKO/uIRaaRyftnhwUC5oi227LwPk=", "HFj9pounS9U01RkAbK5xgEwuYHSrph2V99ishKPe8L8=", "JxBEyNVOGmQ9xG3bkJ/0B46VNOjSOowqGRbJxcKx2Mw=", "GGxeJAFfsLahQNf17OwTKxS4WWZ2jOGznCA2XNP10zU=", "HvUoEkO9I+Gh0/DqqGU+KmQlVq+BZkhZyBbF9psTZa0=", "Dpr1MhXiNkk1oCclibXDsMgK8VTPps9klpiF03z6aLM=", "DApcm/EYoHVASFoCTxz3x88GiIJ/bB1tk/YxXGKgIzc=", "AnUuo830EBaaK599lAuTAfhVy4iP9V3KjV+g8UzPtMY=", "H0hNThSvOxHNJX63n8Unhf3Nj/FS3Fbcn4IkdSiePWY=", "GKQuIaw16/MDSmt+g2r2uploa8B7Hugo/RjOJk+YrxQ=", "F7xPz+Fn7XQIABZ+TThkMe8b3yTGEoqWTAJ6r4eSL6g=", "L8O3tBCsrgFcY3dJ2f6Q2JQCtrUMnYRHdTFsIEu0o7w=", "IwULNmZ2j6kRhs7Yh28MNZmK8+5I/7FBuEGnkhUejhg=", "CRuzMrNdbkZHiZURWQA/aIL8hkqHv1KJlxHoTXppbns=", "Lue/bOrbV0lhLT8yN7GB2DmzLGa1HD4OUY1hluP7Gtk=", "DlA3s4fN3suENGy1wEuhyadgAlPHXyjRTJOJFoA8oBg=", "FVbYcNObtQbbtpzfFMwIMIC42BsUUASAkMrdkQ7HOX4=", "IZlN0BLBB6Fl+TrX4ovKtzRoZFJmzhI2QM+qgzDbN+s=", "LalCVthDCU3Zvbx1tsiGNM2qdubSuyx6S5wjJg4oFE4=", "C+CpLtxI2wmAjVCgOVaz6EfdpUgfrh39B314Idm1N7E=", "HTMsfQdcyBXdMWMHGJ2T4U8LueIBY4V5zvP6dFaLZi4=", "FajVjde0Q7HgR+MwuZ65AHtI5cGkimXwTCukDhNrqYw=", "FfC6Ji68XXItPP5nu30vwgN1+vXO54cWoyHqN5B8eUI=", "LPtBe167sAFe+pRYaHzZLKwSudeMZAM26ukZNPs28eo=", "DTMbMiiIUyc3dByMtTJyjezd1+fDxUWdgwqP9Dlbnco=", "GIpIVZGfFLeQAC2busx/wBGYDj9Rl+U8UJubBNcCPV4=", "CM7pambB7X4/l4YHwYj7kGEj00P0u/AtAJIKZtJD6p8=", "ILYcQ+Jk3syl2zer+3F1IeeOzyXQKb9LphFCbxqC1Vg=", "G3C+onOkCqp0ztg2nVYRqtNFKAQZbuh6OHBFDCLBzQI=", "JMI0vWxz4XJU76sBUFCgG3rG3IKjNU1uE2qU91oad5Y=", "KiGlWUcH7vGxBwyjnVU+x0+Pzoj2T19JTjyiuAencEc=", "Cc3P1QOVi5AbPG28FoE4a3/Q4zgxPjveTuTMaQcXXzU=", "A3IT/Wua34uYNgYSUyD3PsOLHjPe/2oOcZ6oL7XRVWM=", "K+W1XYPMb7Mux1joPsV29SHc2x2hN0zCrgIkcl1tXYU=", "H5uYUKOS9toQ/QCI/QYFTkPV4gS646s4UJ2/oYhYkwA=", "CWikenSNsjtz4aEDmyqyUzupGhLtgOMK/kdUwDyhyqM=", "GmJHherkg72O+dga/tDIYSv+RQoSTiZ92DlXq/aj3RU=", "JawkDHEmpkLusSmLwZh22WnZy17QlSzURutUiWK/FYY=", "JxUbztFLb1M4O/RVO8koLBfbu4y0fB6Efqib5D7BZ/U=", "AezivsLeeJEnL48vEfygwAyq4WLj/bBuBUih/ZBf30k=", "J+hW3yJ8/32Tzx0MBaENGEk0XpnWlWpmWeoR19c3TEM=", "G6hZGvHFikXfCQNHdKg24xWIQSfWK6ArTpkVe2K4xGc=", "LxH6lALFhTvTCBgcZZbc53yVpDGSjRa4U0CYDaEuUy8=", "GdzN82eDlhoYyOQyYY+r3QiSzBfL846/zmOiv4RiMu0=", "E1DspajLwsU7ap3xo5rH1y8Bg7/5+/0BdX8Ido3VLW0=", "IwWFr3WCtqTcZiBw6zfrHDV4Vk+AqGcC1aBG/nslEnI=", "BSpxtdrtcNEee7mrGmEwz74Bk4PcFPmf4rUxCO+DEYM=", "B4Ud3HOixvl7igigW9HePciOBJEL6g2DcWTyxXTD0zc=", "BpmVKH/u9buplsvFqDG6ABCV4ms+a141+XZf799GDo8=", "CmkgQVC9x7xzKXqkvxVrB/pYG6Le9pJOKGjH2uhMdKs=", "IP2fvRU2oz3qzfJ2eLcENsuBcF4mfNw7zWkmrSYoURQ=", "LrGi6vFdtdV4qSHY532mL55iKCu7Ap8MskG2AhNk60A=", "BR9VvAl0zLdeabef1pX9VOIQrTcDSDa0AfLyM5edXeU=", "DqE4bXfA+JbQCtor+WMDsX8bQxin3V2VnzyKscJdw7k=", "EeL84Ot+ZOSI4KY5pfHdIPHbkaHNvHn0cRHg4BSLTC8=", "ImM4dPta5HdNHwKpVadHX46SmrZ0mhfLyw4SZj653os=", "HuJhO47V+uqMO7Xzj450J1KOUrNqXNEUyNhGW+3WIT8=", "Gz7yU111mt0Fq/Qt3eKDEpJ0pxMYg0tWGwfguYlayyM=", "JKCE6sYAYS4HowxfFlG5hD++/iXmUHfxu9TtdeR4vDU=", "BJwuDn4XehZmjo1qKDHSC/UskVWGtSvjpTXDhuLiP7A=", "B2nStW0NSAU6LbrR3dEfcmL4DwS8eo9h3SxKk2FbYJw=", "GqIKJeRSZAEwX7JDLIl86DxOTa+dS2/FYJ3w3Y0Mgnk=", "ICFNU0Rp8Jaaj1ezb21rshJeLqYbISYUPPxm9zd2Mq4=", "AsJbn12w/u/HLqlNo1/DBccS4RYrkhyVlLjJs7kJU0U=", "EdBtXNhBSImyCfCCZOH2OLVr79CnrU0cuRqHmGQm86I=", "ARGMZjOtu/ofCLc9woFI71AIEo6UlG5H33jlK1OoGBM=", "EMvQqXEkPBAM/DRH1Zh3kLYEIGZNqWR3sp7VgVnTwLs=", "LX3vpWIYsdAuZLMeDYT7OdQGjn/vL45HwXNAHVoBvnw=", "A1v6Gj8WRyrQlkpmA9RMtwqTD0U4qyNdXLHZDnWoqTU=", "ChcjKXQq3kbn83YS5jf4oCYmIMzYOIkvP8vOD2NA//E=", "LFjEh+pgdpJC0Z3YIwoOEKm2AKBVQWhYFgyriZa9dH0=", "EHU7NhaO9IFMvOipIXb+DQQpKUp7v1YlmekBOJcjRdc=", "Bcq5jfsycLyfJ8YVExXdsK8LKSZCKX/XY0h5SWdas8M=", "JEur0xQDajUwaLOH548GS2w8IaHkN5xkA0hSUouMwoY=", "GJ1uoZdUIMFRCPkol17qT2Na/oD7FUP/ZRjF3ZibTvQ=", "KDSwbi8x4cLgE7WJwwZinViMlnfqO0cp2inluTFyfhE=", "LqZVc8rXBh0gi+6T1vcued+3qbDFjRw8Q7KVt+28BQs=", "Kor68yTcoowzGcZCyTn+44D7sJkr0AwNUHuyROefO2Q=", "JwDKlkRWISLG7BM5qevQYXD9g1Ds2JP0xLVMpxTozKU=", "CI0gumPVI10Wk1HlrlOCpl0KDkVCRmYlxJZITlJ8r/0=", "HjsraSdG2y4yIdMcLJ0q9suuWc3qLfjJ1h0JyrVDZRw=", "AyAUDiw2NOK7xuq9Z+MVBZNAnhfIqLoU1roQtI9Xvns=", "JfzOrnr8RJz2+pWNfQG7V8DK2Wa4nenbBJ5Nmao1xjw=", "LQisfD0e9EJS2jxAqqfclVdgZy+72rysmI+F3X9hZZ4=", "B3I7fzTDGh1YxdZ+jwCCoRf3e0A/Qjg3g97XVQEojiE=", "CPk/EaYoWII7V+vnu08sf98Kma2a5Sa8dWX3/L7VMdw=", "JQXAiWb0GMu3y/GGByzaNHi6AwzAijHU3INT8U9f6c4=", "InMMd7rO7l+mxWB+y+usD7zKCl+qSKs31PSeYD8zweA=", "KGbaj2XO95QXftmcoOXijEXjPwWab9jbi73YPze5O6c=", "LLvRafSjLWebgYY0tAGKAKITqrHfdYzA5e1paRTSeUs=", "FS1n2hbSSgCoKZGIbG4YQbtY8ZwGRhhTH2b+7nI7rfw=", "Bk69nwDTqpJQL23fj+6W56JHrwdJPt/1mmRzzyuHe1s=", "F790ML4O0KWSTsaIm4cOOlrh0AVDLpZVlyZEV746kgo=", "AtjNbE2r+rRqB5JzxLeJt5IbaJCaad7ftkl0zRIo8mo=", "Bhbn/AF4Wu8WcA3XQIYOFEVGTsBSQiF8HXeV/Pr+0L4=", "GNMJJ3szykgTAeDKPUKogDPqg/5rmr4sLn2TBhox88k=", "B1JIEco1f8Ms88VYLK1mKwQNzBXwr6PgRVBocDGYRlU=", "HsBl4OyVZA73T9M324xuD9ehQUFi0dtFu+Ujs3OUEzk=", "JHF1Y4azSWwhgOaMasa9CEL4zyAk1uUZo3ES6cKwEV0=", "FbFnluVz7oSrhnbawEGj0rCIvOWxfvQ3s9zFllMCvHA=", "IY5vCRcxhor9WspL6vlvz6yYrKqmbVc4AU8BOcAv+kI=", "EJ+6nlnPVSA/6XHc8yYIpX5FqtZKfI3KV9tIEdwXyAg=", "ElpsBRp4FsUWa6yzZHv1TxLsKUXKalG8nfGQUc75sZ4=", "Gy5mIdlFjNXc3DDj7/L/00Z3st2K909NdCBJ4VfV7ho=", "Duahhkq4XwzGChk3KxO40WcYIaaBzd9o39gqDprMcso=", "LF6ouNIs9M5V1KOBHqSs4dryEnqSx3uzvKUeY2xd1aM=", "BHaevZSfQk+SXgnS8RY6ZgLyZ4X3AaD25G7vkaebLYE=", "FMpWMfcwnN0nw1Ngbo671IuRGiOdhrRcVYm9Wp1WZPk=", "FwheCRzLVcsB1Fwv66HIwYyjgM8XYV7dENP9uRBA7MU=", "K1gGLgYJf0eEMZhFipdLx7qIqvAbu/q3I1zZkMPsgqs=", "BfGXQra5y/FLYi5Vtb9FvHJjlTPBjJiy3YEcTdZ37kk=", "KvTLo0szZdaPWwd1vc7MbsH0KXKvSNZIIO/xZuaMRYk=", "ME75Zc/AzEzeoA6aK4SH3XkWUrr22YEKXv2uOSwzTqI=", "DGtwBQ4X2V6q5n4DuCC+e88F4OmcQMft46TWlDTCzk8=", "FSBRVnse19b00oZOrx07BS7CgDfOcJrfz+wNzjZPrnY=", "GWp+UMtRfiF2nR/b6qkqu8BAx2QE1xRFVKSoiye9WlY=", "HbpNbS66hDObsqejL5zJeHJkrPaHUErkxpqLGilrmgo=", "EU+zWDndtXw6gz1AMW7rKOMiIdNP+Gq5ZQetdVxNN1s=", "FSCG0SR9qAUDllQSvKWwIPCRjgX65PQCk8XBNWsBWDI=", "JI+GWVdMJ7NJuXw0A91fCPyq/J9gallpO4nXQ66VL+8=", "ISEkzteLsM0LcI0fDdo6jk9bQssyRuemTs75NeX7zi0=", "CdaKcX2EF4ZNpxaz3Cmmqm4t/AtmHMlSa2YCanyei1I=", "EAnZAzAROH17WddYQYyjwHQt1q9+yi5eaImsNlGzKgE=", "Hc7ZBgTSnMZvWBAQhxPAlXn6+rezF1sS91QPGgPeaFE=", "EtQl2pURZXBx83AOc9OjV8HbM2iv9RSNQNOzFcPPTVA=", "AnvcBo8j+PkofIvlVGmAmSXf5SJhCJE3lLR4Kwf/Wbg=", "B9kJGW1svSCR57ZtFVDjdys2CvpPlkavh5ACvSDmdLs=", "LFQII05HPvpyaWBOc9EnM3E6R7VScmMy38WId7r7hPQ=", "CZGpp1SOPFxPCUc6rGCBXG4Ey8cTi/wC1DNG9GpbzSE=", "DmxuR5JtI4aw23SyD2d4xQe/ksP+XrwmMn7xvFqb1X4=", "Adt9f1mVODM7/cG5N2s46M26J+jEm9gZ4I0o4TL/8hE=", "FODSu7WWnB4PhoBRAMKE2Pb2wcEB6Ocjmjjjx6AGJnw=", "Jrp4TgTZLvWdV6FxE4svK7v5nOuy1brCHNhsivUQZ1U=", "B94GnrzWfdWIDQmFSa0+HLvnTyGbjFP4vUkWapcl9yw=", "MCiUmw3TPgFaprRgaR2DfY+5udXnCHe9g98DALSg2EM=", "C18sy4TbPAPuSEL2Y0edmwqMsI0/HX7UEGn+MBIAOPM=", "D1ajDcOW1sGxePaSUwlF0YfWnAgoFBki8pI9+k2T+CE=", "Fqhzw/PNgP1qReeCbspZFRwD5OqMF3eyC0+7QtcRj5g=", "InR53UpehuRN6Abf/5jQXuLFFI9bQqWs0HdHrHHHtHQ=", "JH8XcgTBORpLsCQc8NCE7Xn4H7QElJjAA7obIlUUmU0=", "GnoNPgLd/Whjm5jtzKZAm1EaTFCKrEo+4m3s86t0EY4=", "BhCQdHFfkBlhid4oCvbQyCDI44YqvWml0FCTL0QiNfU=", "ES751GTi7Qw/NIYs2VXSlijDEW/lRSDnYwm3fKkbwv4=", "BSr9NIiodbxE5zxU6uasBcrS1+GbSA9QwoWLjsWk26w=", "B/6okRt8KEH0976k87e+fLVxCmJCl752ezE0R/sqH50=", "JTuIu/RhDRWTTX6Y9KEwNmL5z1R7th+l8QNbEYNzEuc=", "EO+PKh5Uo+CNS2QqW1hCB4hRZoQ3CUaWkdM4NQKDSog=", "Lec4wB9yUitpgsdY4BVAxteSBA8+oVKFx4ZOO/ksjjU=", "GGmgXCQ19O3iyjP62ECweFfv3mX4UJMl4GoG+Jswk/U=", "BEo8WJz/GwCVo7uiGMY8RRmY1UNiQ7oek/cm2uglk+s=", "Dt8VzEerUKkuVAFLVkMWiYjiU62ubwVR4jnSZdEPH80=", "Hd5xo4jhqcsHWv1rahM1RwHgQfw0FbXWthNUHUED9Ak=", "ExAXNAgssj+b0mV+y8Md6968iG3LWhW72LEgyKlF+Cs=", "JaOnwSisb/3f/sTXoXzTBErQqzCLl0Jg8IPDn/cpN9U=", "DFqTg5MBb/oHHjufL+PFjKMIOWeilOYu2L5WVyRmG0s=", "G2OgvuBwct+zozxj/QDS2k5oKtrcZm2xIFMmAIy6bhc=", "JvmaNPwZ6n3/6carlnGbLO+dONQaIJ6+dLUbL4sPYMg=", "HxiEsc8/42zA4KroisZoY3XOZq13AIe2ay0cQB5Jg78=", "DX8OIgbWoJLFAsoltEBFXamOadf9Xk4gXFF3qKTfgSo=", "GE2gn9Rf26Nghh8SX7U5D1pHYlL+cYiVgs17c9qYBQo=", "GEB4FWKVXMGpA1+LG6ZRyDOwcZ/igzM8JJyLJjuwFXM=", "AtB30CfzmJbZ2LGmGepgYykNoUd9BtaiRLSAI7bzzcg=", "LLqPMFsAkxCjYRZ2mioX/yIwtJFeFWxDwrXZyXeBNmA=", "HhxGsGj0gH1oMqlovp95vKqZC2SThErXJPios3u3kho=", "Ia01dAS7jNnbU1XlzEedwaoeSPxsdvYvXRrnaKDhpBk=", "AOGc6LcsZFPHOjU46Rn0jU7uEfZgm2DPQw4Ut0zqxf4=", "D4nZRVZqKGt7xjuTcDbUD+WP/zsTpv0ep2dutmGU0Gw=", "FealfLtTIggDxOkeBmtIOjGLqwviEZqGQ+0c7LphE30=", "HEXIhB/V1OZ1pGyZEVRcFOnkaO+D4efGZ16RcD8OIyc=", "EOqT8CV1EmwjFFiyD0t3SAoPEPU89MW28du7v+jYigE=", "Abu3eEsfSXG4t0txTRcmbjpFAIgFrHQkdxQnZ60MX/E=", "E4lB+09mas83T88BkKQcyG+UKThq18ogT9wsoiTDQFo=", "LImR+ztilc1nFiYx7DSR71T7pxcnwilXdAVSyCWUNCM=", "DeZrJMHU4uVngbxinBs5ideN+tYocWqEOjLF20GMdQE=", "Dos3wW+2KBJVyyd5CsUj9f9cFb4oax6C2XO04BBLsqU=", "D7QQZ9/Z7m6EC4goBZfUNqDL1hUC4GiYz4tf7ZKJyF4=", "ARnBnfaT+Ap6ew5kR5qad+9LjrcNa+4H+8M+96z4V9s=", "KCbA6zrgt1yWz8GBeX9hM9hDS4EgWL0Yh+carL8JV5U=", "HROMhzNBT3AevNMZpoWBeAN6qwgrgE4hQzIqh7ZHfHY=", "IuMsihqeIA1+MdaeQnfD5nlJSx2XDgx5IXWH5JVdfAc=", "LVK2VYK4O10T8ojWes4ixcUfik8HW45tdmCmYK1c9uc=", "Li5wSMCg24kQ4IJ+rdEko1lHyyYGSiLnk7TUq2q5Ahw=", "I0+dls9IMzPBP1IkpA3UlTcNrLe2eZ4/k2Hiq4kwQcI=", "C7PgAiLNPXL1SZonSd1+Nsji1V4lX+gddYoQcHC6SBw=", "GZrlK3VHo9pfVL0rnKncDyHRFZTrUqB5B3Wbgu7nZhI=", "AaPYBI2tCVgcGNGrLhBmbT7M0HaWidYSGZwmVQ86GBs=", "Fma6lKwss6WMXMhu7HUTU6FDkbDgb74mOFE5bezA/Rs=", "FcMDTNecrnXAC3l2gXxZaVmJFu1WNEcnuBGHKvQELo0=", "CGrGky3mGpzkGLYSUChR4G1dcPTcOx4e2Oosbfdbh4k=", "D0OnDIZOeoHgV2uyd2RlYUGrQ7GZJaG006F2i8city0=", "HbOit8a1OK0HBo2XUI31/7NKCeofmO0wOZrymD+hRfQ=", "GxU5HKhSN+6OpIVw11lBbxgmqrNOqH06PMNUfRfn39k=", "AmOqqfnoPCVeZ/mgmQH+7SaN9WFR553zRUJjQeDzjzM=", "LahOw493B9XXH67q7eeT2ZDwTozdAWy7871lwSkTghM=", "E66d7UgS0fTSjTeWQrp7ebstPrgdzSI+iRDFXo93vp4=", "JbGBxyVQACwrEwSTfv3DSg1F5wlRGSnOoGA1n7Ujv2o=", "LRQfh3eOuvZH8tonq74FBNRkQoOPOuIarpB0WD9rZLo=", "Bc+1aY9oz1EwwUv9TId0Ggtl4sGX9ZSDHKQU/1PvVQU=", "D7o3fmlJs5CBVAhchFeimAzF6jRy7DDgmWzI3Z2jHZ4=", "LqW8Iv0+TuhYWsiD5XRQEhWXKyA+IdPKwztIUtm1B7U=", "DbL+hKp9E3Ry5ysP+8fnanb5Ik+sHRs9pu41pcck+Ns=", "EcgEpBnEfcc9sasmgpea/bBCwSzjSaAN/toccvCk2yM=", "FCPfmcie/kPD6Ar2mf76u4Yf4NiXRiTfwZJ9J3ba8kE=", "LgfB+Bu6n44b2JFXh8p0wEYH6Dwwj02iUxQN4OPLTuA=", "G5Rcyxe8J+EKI5JspVN7SbKLYzErMnjNFtsUSrJ/o8o=", "CumCEkPgO36pNzsDInXTLdTLq8k3gfNtUyt8ydt6V10=", "GPLmL56Rw+OZNYI0+moMkHw/NUH8DOjvG1rRNdQcTAI=", "F9eu4pLbo94ZQ8+DNCVPl1SxetelosVyMO734GxASf0=", "D/dfj/c6VdSGvu/Z9di/b2+dMbEKCQOyT0o78hGPmDY=", "L4IZ88fBSNyy84xpe//TEA40sOyNz210Nt436d/GWk4=", "Fuwe5qdPed3Z0UIhZlnZm5Ej99eJAZ7LXPOgQ/fYIOY=", "D+VhLY5f5f9OIkB4y/OQfyUHjSYE2/IKaurxiwIWtX4=", "CAIZd330fOoLw4UkLFJj6uBrKn6qymBbfd0y/gsM/I0=", "COkMBakJEECBXsCOsUIQahsslO7tUTLGN8+cDEBAPnc=", "J50s6DRnMf3uekmQO35u8TYsWZcOMarwGqxR3sf58CY=", "EX4AR6zSK2H7+B6ZzBPiufHY24+zg3hZLUQ3J3m98WU=", "ArxwU9yFKVpR0PjQURidoi8y8iJIfsnsOdWhdlLZQR8=", "B5BoS00muagyJc9y5gwCZDLKU3hnjrjHRN27bmRfwBA=", "CM6p8CUj6dy4dwmBLh94aD83OjOJV3RJHB1gcuOrB50=", "Gij1VI6+LCEPNhDOML/xzV8CM/4EXw2i0qcGH2OtNfM=", "FVFJGqDgNXhyQvW/Q1Ga1WG2YBApxW/IY8Y0dMvGcT0=", "JwXnNVb9KYs4z+az0ELk5fS0V+kOfosWo8m1S0nGRPY=", "Ge24SGKkoRPjcuAcODW3FnvVjW7csDgHjeUH3IlHJyg=", "CTixwmUwK35BSJBv4OkPmt43VRCVDUdSJKCRXb0qNCk=", "BDXWYeGNi7KLuhpGSLc69kRBYjFi5bY2uh37en6IfAg=", "LOcc4kMWYpEeoz+Z3dQiJ7FHdXOyYfnTiVf5yGKGssw=", "F8ddoVIb0/RLLtOXmbdH+0/SgDioelCm79m/OQYPHfQ=", "L6GOiVleaZk+qlf3GroVqLuD6ahsXa93B5RWf/T/GHo=", "Cpe19zB7m2tGFNvdnKBu7YD6jsY2AIYodA8EZzzM2YM=", "L7AjI6jbe6fjvqeGUqPdUP2QcFy2Xy+ZEVzlENHukNo=", "AQmEkV+8vLLH0FHAagAgCCPGQxQ1/zh3iLh4NLRqZF8=", "JfrvtUrn6KybNRbtRFNoRwRfmDUP6AIO2yT9Aoy5XnQ=", "Fj6ahYBRZjhkBq7EMJFlbfijVBBJYKxwl8hdIQfc/3c=", "LgHjn90gnt0AOT28eSc3go+B0KJXBkNsRYaKQMI/5T0=", "HubKAVbuvtQ6fwJyYzjJJZSEY0iD5ky2w0/0tFnc+mE=", "Je/7S4TCwJBuu2Vxr3oVEyXGrWlqwKtafno0NmqSP0Q=", "CQGFCG0M+9+UGvCfboXmyRmdpBwLKUwEniFD4tG/lMQ=", "GWkho3QCDy989r92t/2Nuq4Gzt7Un/lIJo03KNC6zL0=", "LjCoipwaSN62a7H+kjLXOuzS2Bl2gisu1DeqnBEIBXc=", "GPyV77hA3VL03lTNAjsLVS1X9Ums3E+GwWNWhSJTQ80=", "C9Iyawyq6m1RQbO+Rw6GXa6Z2G2+a9eGGiLvbi2VwIs=", "BN4ao/uYB7Iv48UD3LClgyU0DqC1pQcC5idnAYZVqMM=", "J50hZXs5tpQYHVCBgnlA9ubhJxoITFX0Lfxzehh+uYk=", "JZSpQhXcxsc9ZFELrDswQUq84Yzb/rUJr+bXDT3Jeos=", "CVFC485uX726mIWDPGFLv0WYlbbOoQ7fut3bJ23dKSA=", "BPfHEigezFbb+Lv5X8GvRpD0GbhBMDQmR7460bZ3MmE=", "FQwpW7BKYoClz69w3j6Zj4pCRIt6juVtH86oxRX85IM=", "BAsHOuoBtVlIRis8lpZeBwaBukLZJwW+q6fqnOWYN4M=", "KFhUquBCw+phbaewKmsu8wl1qqKpCuuHE/GJxMqjbJ4=", "CrALvuICpR5C7I+5tcth+RZc62UraVbBIF6N1TvqOwQ=", "ARUuGRMJHN5fOKa98KTrDrtQGVS3IfOFmgqiYs3hP4A=", "LfSpOOlIiCWXlELYXdpShQEXG9CbeA1D0bLiUy6KTRU=", "HRBDPmdsCNw61J1xrAJ9xLK8byGi+z031+npWBknmnc=", "CH4qwSzRJnoEkJP3MMKkYa/2pCnCMeX/7bYsxSZ23yY=", "Dzdpc3pENA5vyf7btrdghWgm98OmyouZP7AEEYcYrDg=", "KfbVSiHMAgmADuYTtEWFJS58NdPApPAM8YqCIPNs928=", "ABBt/WoF98VQBMbQeScomF45LWPG0i4YO3bBPNTuRl4=", "MCS2ZT39aKGrhe0k8wv7iGkMULmWDa7Vm0YDMfjjbj4=", "Lxea4/oWc2EQwpEaUEg31xx89dJ6TIPcRHp+pU6aif8=", "BXdA+4jtIcb0rQOtSaszhmgNPQ+13sxN/mXiwYezl70=", "FX+Fc8wfl3OzhSyWW7ALwRibyDNVx9gx8ciBAG09IoY=", "Idrp3oTIlvs+Bg/kZ8fdC3Rx526WGjsw03ZE0g6PRJw=", "LXbro3+QEIu53O0/naGsrVop0qNU7dVCMK+pt25HA8g=", "IEHqQNSR0vEGKGI3JxU4PbiXUIKAUiVbHgcfmbo2AZY=", "Jbk54sQMbgdaQsuJaLv5KOPWqK+NpMx5yb/HLWghxnM=", "LKjwoVl4LSqy/07Nbt+yh+9uWh8g1Qz3p1qLB2Bc5GE=", "COGCUuzVjehadPzypd/YZteA6LP1khU7fnwEcH0vH/s=", "DnQvomuECK2rqhfKfcor/BT0Djq6RqLW6F0+O6DFdn4=", "KHQ8rT2HKEKtI9rml4KV0mF52BJ15S3DCnr4Cjs/2n8=", "K3ikd3LfD4AF5QjMR6PCo3BZ/eNA04hsLq/nmur76Gg=", "FplLgVIp9m+Q6I+J4Ee07NP5GlfdnuXppWKUwvNQr3s=", "Dg8WzXUEEohSDtsYl69asRuFpUX01kL/sVf1dyEpQw8=", "GwHo6R13Pb1Kx1YSL455qp8BfaPhXUhlbQfpj5pz7wQ=", "DR8lJbat9QE+nXYXCv5vURdqRJfBWIyL5XXATlZ9My0=", "CtFQKUWIWdz/4Q8xb9zBNFJ+qx+XwKawmU4tFuP0UhA=", "Lu95A0+Mwu4E8PGIEVwB4itB1Cn+sqZrwjk2HupK9Fw=", "JeQqIeZemfY/BbNs/Ehel+ct46o4qFc9ND+VzlDGLa0=", "BsYsBWQEqjEGGXhhPJuioFLvhTHu3TJjvMNMTxZvfI4=", "F6aYtYOnaRReMHeVEigEAj+Cvjdhis3BINQe7e6dTP0=", "Dhy8wR1l4hQJKCF5Vjqz4nOFk2OwvunP8Ggc5aEfUgw=", "IguOwHxkkZE222v/y6zZvLwqVgv+mLAsqdKhwWIN0K0=", "H3GVs78Ympl8LU1/jRB9kcKtU1K2PREc8UJQXC6jVkU=", "CUbiKl/hJSzqdJcwqmNja3+ZaA9imagCScOZw4tWZwk=", "JHhYdb3snuLcdlYNr53CsBZHIYm3sqfX3ZnoYykxO10=", "JNbaCv+EU/ApUx6akMq2lsQyn9BdW8M84+lJ0tNRBbo=", "GV4+IQeco4CTvduxFZHNutrM7O6R1EqceXOA/StwFRI=", "G/9rQ6RT4WsrEwMjMXzPaMARbMTmmQj8T+qt68AQIJ4=", "Bz+dX1JpTYHvYohPupoxQy6MWQCHYwJmqGuJ88Dpx4o=", "K+P+TauEwYzOQ2+T1JKnPTM1whpvtvPDJccPJ6sHF+k=", "KA91g1DiziKswCIIKMN0ETwKBFRyFt7HZrJmntaHTbU=", "BqS4qqNjJhwrpj/DHnPEcEFSkIJQ6613vXkC44HV8lE=", "BhGBNcaxmX+W0wphlod+4KEDcTuRAEAnQQp23Fvf3V4=", "GomysQq6Ja00RFkXBVuVjxITBfezFIn1Du9HRJTDHAc=", "LjTDokuQ+lr8s7krQFkcOAOSHbS7FHX9lJhBJ6/h9MA=", "KfTNZLfJ2qiMHgy+NsC1OEC5JBr2vj+jUoy9hJXYm3Y=", "ETA0+JnJr4RlTuc0z1kHE0EoUo+MovxicmGt4AbcXaQ=", "DdXkHk0ALRf9MDoYLHzk2hwSwp5SRalOZ4lg95oDwiE=", "CUlSOaT+0GOjwpKKQkE/As+a4IhoFG+ABU5tX/Uxy2c=", "FUhv82tzJVKK/lMpgZhLbAamOgtuJbH7Jx9juMpujYI=", "LYquHQgqYNtrOxqgskSSnON8E5J+jWH7DpGPAaFOSDU=", "AJTrtVAdrlCz2GgxFwD7g3pcaem9CQCQNgFhb2k1ReA=", "H9r/rK2sQbYVSxbJqiyIWcQv2NqQg9KsB8zLJuaQx+I=", "C3WEzuHHjpAwF+Oi6D6BWDDbkRiltHebWU12SqWyQck=", "FBLoVNqKTJ4KEdJ/8MRgm9co8uDVZqVswpNvNwxAyHU=", "A9NNvC5vd6HRKu36XhHeJ8yZHEnt+zlu504mnvXaKYE=", "Ku3VeVBG28bJE3g4gtSkVGOVDRCKfmkQUyuhofTTF8M=", "Cl3OHsXH0ZkdJ1+R7S/qN5PtxK+n07Fx1sotXsiA4oM=", "FY5/ydFZbPBLrICkn0qTRFs3F4qeWna+JNbHCM04lZ4=", "CNcwYdmDYQ0wk+BegPBJTOxuapdS+F5/YEtOZeb6WV4=", "LrFtkjVqnOLHNyAVtfFqsYl03ynPU/F+H2QdU2DX8gk=", "Lpv7HAcv+h8USLzzyxiePI0EVIV6k/LbTB8I9mUG1tQ=", "BNo66czyPEQlDunzIJWy03WMMiOquFzU4heRKHuqTQg=", "FkSVdJzNfq4gXKFPSIK21an4TXCi6xJl5+NhkyJybl0=", "HIGzkz4wLiojBSoe3oDI7ceggw/JDU+WfBPo+hmdupg=", "Ded5AqLaRc9nJ6boeQtLOH0mu+PToQ+PGvfXG+gqzrs=", "D7yPHzn6VvUB0hjMQoPZ9PfFdYvxIa6Xl4oFRrJ1oiQ=", "GxWImN3q9XB1rFoDPQaVQ//ZIm7B/J9f6M0XQo6fnCU=", "EKm6fY/DYkm3HOOCgsVQBHwHI9QySFm48zwHIzFX99A=", "HmK3xT9RDmDBzLeCZRXADWLrIa7gCwoSu+0z8/CkEBM=", "IeKjCXPmAUab049p5r/l/GsfLFRqKY2+S3We7Bg5l+g=", "H0JWwBK9tzzGMktgWbGW9mB8ge6+DO/ON/uuNDoNuGI=", "KDgVQG6AyUWraoC0t5A1kuMyX+//8g1g3x7swBwxCTY=", "DLTODeBf/t5nCKe7FCRUDXgRliRH3qB7vWs+JP/P8/k=", "I/na34LFIt89C0HjGn9rpTIw35BGuKM407NxJ8utloM=", "IRMG4Z+2WuEChti2KdTMe/IUWrds5RPUr8tdBYpc0Fk=", "JvGLsJ7vpwJX2UBsU7FwPtMgLufuKR/2awgHV8i8q8E=", "LWm0ZCP+eaocoH3JokBvJCRXfjv6//WOpQTBBOxPfcc=", "B0ZbozAm7SPcz3bVIVwR/8jHUKMLXZ05yyrTGW0sfjI=", "DkFG3ueM66aIdzgQ5TJ5Rq4g8EesT6ssxFo5C01G1ks=", "FiTpYLHcVuWHbqiy4hFc219gpoiYY0V//67qwCBm3YU=", "H9DjrieGykHmVb+OAkenGev9843w738BLuWl+TWNesQ=", "IFLDbmuJ4YQObRdMlmSaPS57UPJVjL+GKgXDaxd2lqE=", "Ese+gL9/+J1p1i9cJdHLgp9ZgYdXjS/RFYpH89ybGH0=", "HnEiY2fPDmf57h5bubzsCYoCJAA7xyTwRK2mPw3IhII=", "Gxrv3ifUAJ2pyp3RTY2cVGp8hOZ0eosf4qVh1i1HMvk=", "KPtvvoDRYbnRnWTGi/0kZ9sDmUWeTgCGmbujsJAfW08=", "JwNMmhi1X1JZgF+W2KHZt3Fvsch1cfcfE3sCMUkUzhk=", "LmreSe6W0rmc7JTHq5CYnK/ZEdnXT2uWkTDcn2ECyK4=", "HvrKPVroel9o1PMRSQLkgKlBbWkzKRTgw8z6ol6BlmU=", "Hb+hK7HnsM85GVq5iy9P57C1I8Q/YXeLKtOOF7ZguOA=", "HSGtxZW7NGKqOV6drMZxU6WsTiqByLqD/jN+ZNmYHco=", "GDoDH2UoOixXqmG5P3H46iqn6piBsKTIp+tiqZxipOA=", "BVBdcD9//9Mj3FZ5hy2bv96BpYzlosT6AEoftXAFs/Y=", "L6lLk2NuUJpfu9N08RGlSXTq5N+oV7ySfUY/0CxmWy0=", "Lxgk7+5rkMcojbzEF00u6ykWitRoyfNDPRg9OP27YNg=", "L4sAQ8erffElKjZaZTa17kWG15v07dTOTU6hI2p30pQ=", "KgZvqBF1SkyN9ho+7ukqeoBCD5JUHQ3LBuraMSf0s0Y=", "LdSDl1vyEk+oXcpBdJGIxPdNqBJ+zvvnjdlyt+nZ4UQ=", "A4dSJNPQtAoWR0b6MPeDXtbcvOnSPcSjxB5l4KcPeow=", "KYSP7mJlCN4GbnBG2TzmeMc2y/5kg5sP53R3LGUUwcY=", "KKfYrqv8HvqlFchVAkjjRBKifn+my9eNILAGfBJWejs=", "GVB7FWhuIP4rH5jJoeSVs2/8JNwUmtKfIzlh5kFfkrc=", "CmG5aPUF4HBL4vZ2smfqRJCNkp/4Y5vcQUSUWwB1y5U=", "EJdaf3BgswKrxNXNLo0rXTMNQrMb1cikeNenaFkFn1o=", "I9HvO0LQwVPWIWNPQ7JCMr91yQ9zxbwwuF++GLTImiw=", "FbZr0+p5hsfSlkEXiU88Q/4CuCVtLJwYXct/jGO3qnQ=", "CeRqjO+onFympblh+9lF8HJVr1TFP3MtMmGUQrj9+OQ=", "DnLbSHJsMEkSHL+9HAg0WcCmM81pU4y2M7h55K9sa9k=", "FvBTCduRs504rPwd69OakcxEQzDD7URYEhQgFqZNeEY=", "Bv/97rOBy/OXlfg8nWnIs6zLLYf9bOQnD1pmBt0M38U=", "GiUrHzR9jYlK9huy91xlz1/KGiIR3h+QXPOfptOE530=", "IxVhu2h6Wqiq9+HFlb8VWtLZPgki2rMn+5wfJ4dyEO0=", "APjUAw6sk+xtp59jBM2msEvjLwNugLQq3ao1HnAHkT0=", "L0nd9WXLUyTp091Iu1cCLMt7R5vhI+AD3j8symzcgNI=", "Hf7omHaWwy3jBEBjdyWGVTH518PXb+6YEWVqQ1vwaE4=", "BYIXveswZVRokszq4hj3/fOkPCODzu8SOH/CnU3HQ4A=", "BfhCOSqaB9TH1w8cofcrnjtc9WM+GZ6/VLokI1YNT1U=", "GIsIB7eRBdy9XDbsxnbC/uYDrqByt3EvLrtpudF1Lks=", "EQP26gnK5iHsb2leB5KaNgN8Uu/LtJPxCvE82wBVVI4=", "GkD4ujGS8MkpJItK7WGcgaIvigvwN0XRU3K+Q3sPwIw=", "AIgjt2JfhKX1yaiJHL89x6NHfaIVIAukIOUYIWRfnS8=", "BSpJSvPs3vUDHYeZTyZJBdJfxsYme2995ENbxhYfPzI=", "D8jNGe4x2gGNDGxZhW5ro2mlQpIxET3/TI5T1Q8Vd74=", "C+zohwj/RH8mEDVgDZmxE4mqByW0Rsno1UoC6P8t48A=", "K8L8L3yTJF8fXtCrbEzft3FUT43+ygIlDZyhv23C75I=", "IrFvgyXyosaZB69CaAEB5Pht6A2QG7aXAxDfob+AX9Y=", "J4KCPVGIz11BTCgM/Y3sgWrn/zbA/azYcK5kSfJabLY=", "Eto8kKzEGJtFsGofdBWY37LZwk9FkSDevs5cX+I9tb8=", "LYGl+fpBc/WPdUZDSB0ICJcmuse7cHj0ERtVEGta3ws=", "KG28mQFABG4eJjeIXU0pBIdfCvpRIZqyt1j8MstgDG8=", "IOejZ0oGZ2bQQiY2LnMhm1TKakJYJgN16Dl/j8EVGX0=", "IonzIn9M7rrgwdxRTeTGQvFTFOrpN7OaPDwSR2kT/N8=", "ITJR4wp2GZDyf6GXBCb51EoJPdBFJAFnBqEYB1OqRhY=", "CRZVYSqT9b480x2ySMe2J6LfKq+h72n38nZZwT8wGe4=", "GvYPrzSwV1XxlBGVsC5kY7tC33bBKxDxT4sWJQa41ek=", "IbQdDv/SsEQMDTtwEjt3MZA7+0bbPHojrP8Bbq8Qf9g=", "FqCHbJbUW1nd6CyPHhAixcrTFjjE44zs5belbECNhLQ=", "GFMp+eSqhdSdQqYqtPZB1ixf3t4XAVp9efMWS2kPZAc=", "Ej8gjbDE71SVYzXRaucVJTTS2Lp5PWAfFVJJaWOeo+E=", "GqVlQnjeIjgNp2vniFOBwXhMgO9PS7AyrNE7CXOcJjo=", "CVW4oWd6W2MQrY4EkugtEEShTHjKh9HjDg1/MxbqbOg=", "DH/v1O3Uun2SdWtRc5KJBNGPm2/plaV18Oam6I98Dlg=", "EW0YiZfuxqHiryrsil2x68XPpYj75UkPCN7RUD7K+wY=", "JY0u7Swt51nws5S2o8zS2W4osQAY8+f0U5Osj/6UfqY=", "Ip3owpZa6sGqftt4+/tdf7Euf9f/5rmzr7XoiDSabEQ=", "Cx+w/q/pjWz2NyFw1MWVrdpxcCwOnUHGyhoD11GPg6s=", "KFoFvpst/Yry0PKPLjL1zOaxU9iA2Kz2kGeAymNsTLs=", "HYJA6ZAjlO3uK3YJnbA9dN/5GFQ086Tk/oV1lpzk8pU=", "IWC+gjPOGwszGYk0nsS9mxJIZEhRCDHmQUZ4sxLVf5M=", "KSm4OdRL0rP8W/LMgV7nkQ25ls1bXf9CbI8Ypa2rUv4=", "B9DUPD9jNwHl8N6tVRbpS5H5dyXkaYLRmd4DNFkg7Ag=", "C5nCfa/5DMBTs3EyYi/dxf1SvOusEnCxzON4p/Ajk+8=", "LpUt/MkkwIECzKfpVl7t/s54llCDuFOsH0Eox/PXhpE=", "IZC3f5YzkQZtbSbz10Yg7DXlATdrUpnNP36cI7Vcyl8=", "Bb6RnFLS8dwNCw0WH3unGVUQIIquu13OsIFfKpEWhlI=", "C05LPKiqg0Yiy//7dubzD535l9y/k98ip77Mj/mgZy8=", "FiBSKojDtTHEXVHlNj+U+TM1guX27hw8t2QI0RYUT9Q=", "D0QuomiD+OGIcV9YQaaQyys45HnYrXB06JPvGePHOQo=", "GoVb++gKeIatgd3w577dgMHg5NG7AxMOAwNdU7WbpxA=", "Bqk4aGEiM+PWCY3guBJmSQNswUsc48exkUmhfKogtm0=", "BnFCSWLpI9qSZhLpwGYWZcSmfFJCZ8Rag97lKBMNTEQ=", "CxGXmfbuZ+J3XNSnGoxdRVuCQm4Armzs6jK19Eg7bUU=", "JtRo1V3DHNXqFBbcoPfqUZBkK3fK+ndB8SMyE3lsFls=", "J2/P4X74IYGAEElL4K7SSrwaQerKUxx/XS9xKeroAyU=", "I41AyDbbchW+oUVcySttc/UQBWjXGm0egavvwYwh6Ts=", "BkxP0cUO9Yffx9yszUq3rVx82wIwzI4ONNds45n7Sbk=", "A3GGafFv4wrcOEdKdUBq8pQx7LV/PbG6e2aZeweypCU=", "GfEE+Qu8A3YtYhonSjJcSfUHP8UMR9uIXpRWZiQhCY8=", "JIbJPv+iSJC+pO+a5subj2X9dZG9hNU1t2AinAzie6c=", "Ke99PqMtljImn7Aik3x4qR17yqBjqBjFkkt7ktAey/U=", "JtkefM4dje6ryNfFScuxvv8MFSy4gZ6GhM8gUEoCUvc=", "AkjQiZO167JU7Iha8qONPkFcStFU61Nha5sJw5NK0Wc=", "IK5G6itwHTebynQx3NIx1aBTin320l396czX3QJRjbA=", "CkhNb0uGV41JGT5cAkhoC5YUlQ2OOR9SffD0eOxR2ww=", "BnF/W4adJlbCs1wB4oxWlysEv5fsp3YT5bjKkrz4Tz4=", "A3g8cTA45UiS3Sp2/M8BGaMp1jOsUz6BHlEYF8TEo1A=", "DxO7/sHH+puUEjVXGded63N2r94NoOcOLLMfdS5PnTQ=", "JRrczOUxfJiTdw8WlKN4h8/rJvH6rPm//2yuyTphgqA=", "D4JaBvxpAXyp5XLHMueqhZW+b2yqof3Jg7mvEoT2Pb8=", "Cjzy+zCtLHNYl12W/7iV3o/c1h9067JNPxzW0lHrqTM=", "AlGy4GGxLFYBnsBMVNdEbBO7199G0f2RI9b5G5v3ekI=", "KVFwLfoSb1C6bQRjvkyjThLsjeKBgHX7BDykcbzC03k=", "GCyfCICaKVPmRlzNNhtXyiilKbuVGjVWQ7cInqtxVpg=", "DeofZA4J3NaftFAIjNsGHfRjDbYpLx1ghcEdWua2+FA=", "FXQQ6+DooMgexwJTvBYCLdq8znBwxQnniqG7b0nhfG0=", "EXsJs0c4OXxhY+9kfWCWnW95fP4fS0pVtZSQqm/1WKs=", "FXN+WlsxNA9K7FeKc9huTaYcvU0aVLtfufrDZ4p2L+c=", "GWsGclE/J59dsgDRJkwDwexfC+AAJVo9JW7cPrcT8RU=", "C73OA4unkjAM2xjmidLgZ4oJXmnhCjpWu28rGMB29pg=", "COT7XhROLYZ8VcyyzALGZgYL4OvD9vqpi0CXSlPc2sY=", "JUzFOuiu3IMjtUakBRb5rSeirBr++drovafVai1rqmg=", "GixA8ZhN0jON5ygQIK14Tf2TbKN2qL80kcphywAocgQ=", "CwKhT17V++MPmLa77puiXzeUmUKAxjO33AOjqb9TIQA=", "FSKLRNuZFeVq7z/Q6WXyvQWBZj3Nx35baphpSAdEFg4=", "JO+PojIx80yYseGcDistJTLqEEjwpFw+xgXMp0F2Yxc=", "Jc0FqSZ+IeLQtX8i/AfKMyc4pulP3i7HL3Zre91FZqw=", "DO6mttht3o1jE/fW5Rme0jpmNphMi64BE62tmKz3EnI=", "ImPAcBtJMG3x139vGhRybStu9GW95LlQSS6kAvkBRlc=", "L7ZW9N8ChBJI+YpGMDaTN+RD0YFuFqPB8ITDjwBe4Q4=", "Dm+e/rQY+gtAFnV+EuZBR2C81FmOZB2JSqJFxvOpZhk=", "Aklsc5lRJK4ARBUbtpj1dl+CcvOI17US6pQ24s27gxQ=", "DfPEm8ZbcIe+yxlAmU8c3Ouxb08hEho/ZiZ542G9aV8=", "AjQ/a4AYbmyuoq1N8mw3Yoqv9xMXYaGA964oufu0sxI=", "J2uGUuYTPsFkgQ2vuqQM6Pw6MPeCZtjnxhsvsL6FRuc=", "K/CaI1yJ/r5+VvAC33sAQhS/ANoRlAGEZ5CerZXqhf0=", "HvkGTCD4Pox1gbYJrFcr3PS24fs2jKvA2/8IrZW3PnM=", "IQtBjil+7j2k6As8k34ZBvWw9V2sAj4nZGvB3LjPjoM=", "LKnm7lmYwq0GdTYkB13gdxp9AZ6Jptb3av9Zk2Zb7r0=", "F0ripdsy3KTVYiZXXx5cT7D/6n7ndksfUd3H9SVshqA=", "GGIxnO6N4+5NY4mV9pPzJFRqUjXSKVLN71IEDYu9kCU=", "EiGQbJl5jN62bFDxQLi1eeAyEozOCRebsmM5Dsr5zUk=", "CE3SWk0UGnI7Kcac3o4Lu1PQMZJvsNFNCRN+P4oSLx8=", "KTQa0E5zpuadOsZU1EUKOG7Sx5R7AXae0yTW4zE4FBE=", "GqsNyWUWH3fu+ND7TnLka/3249cY6sTlzqF2M5mT3Ag=", "GFLBJoYrdC/+PlaP4nrOC2df1d82FVpmCZmFxwDSaYQ=", "Am6r7lwaXBsPviJBd6x6Fujw17SMTvti7tlqkxIC8MQ=", "JotgenVJiqhqHrZdtfpypUtBw+jtnKWnB9dhE7zapJI=", "EKUFHwZP7cC/wOx7a+Vq3flNEHfdv0VqGA86m9UCm+s=", "LCeTjOTh4PmNXlM1m87KWpwiBmyz3Q92VHHdhf9kEhQ=", "BgOQogNFmWOO0NvCkDzs30kPHCDWBfYrf5W6+9Nno/8=", "IQnn3EqvbLKhP/Yrw8vQ680+vfAiY49eSA0BC+/+x8s=", "AQaVnhDOaBm9r0jNXBlDLTWsihZygrRMsKZwPuvj7Sw=", "J2rPi84muTIVkbxYg5JgW1Dff3Zr6QyDF6Ge6TyNy0A=", "JiXLG+Cf9jxeA0B5jRC3dMBDIdIjQOXujSzErqPckks=", "F1IjtWu8dKRv65kaT8VfAvrRrJuvx1x2yj2zpp3c/yI=", "Is1uF70UJrE+dCITYG8VWNVhm64l/sab4N9sMeprmXA=", "AzMHkX8vBYrmKVYR42A2qr25Gg+586S60+av3yg7GDY=", "DHTifVNqYnSoq5HfevudTr+UTGgVfEE1qBmTYyukEUs=", "EbIhKgjLh3zLO0pWOc54Je90h1+yE/B2E2nKXYepqAk=", "LIyNQggOLpYV1MjcDyDDwwBdzrFpfZYj687rY4um7vg=", "DWESTQbNdbqgjUY7mjo6HNH6O/bKUIOZER4gbcGfe+U=", "GKjM6eeqbfPV6zVAawzUa4fksI+P3JkekftZJKBzQMA=", "AUUyJsdXQrhA+3HxUePlNGZIuaB/wQqsMUhdfA8HGoA=", "DrBfUgZ5NdC1UXrduXrZE09muSHID75oVI4MCM+45g0=", "F4g6D6+jfQP749pkD9zfAv6oIrz2EtfoLgIX0420Ago=", "B1Fsuz9n27wFC9LsIbGLudDqmXF3BZWoXEhjYzsOGcc=", "H4bvlHFEOyalnaZ+HCoiPkV7rur/KunwCQxVDDC/4tM=", "C4TsY1XL+0OraXCdT+2QZoXwJhPZtIYS84zeM8aenwM=", "GsAWtA0w0mcjxb206dL8caG574BlzQjM72bKmM54lzA=", "ELL6id5FRWBhdqAEVozqbDOBvpYS6DgVRnzEv661hfE=", "AL9WdKXqHOb9TLdc5/JnEOUQY5s0NU5Tyi5mMbQE1eg=", "L+FDmZO9M3g7ohxewfKNq5cUej6GZIZt0EZo4EwBN7g=", "L0A759OMpzNnaKOpx/ZWaShTYo9DeKdKUt9Ilv3MQDQ=", "DhwXG6oLo+gl0kLR1wRUuDPD4j/onn4iPUjezYgX25Q=", "Fy/IYcgioEWdJ+B4P8YDQJ+DWRP3O3HVH/MaYvbk+4c=", "G7niRUozw8CMvjHddbM9nWZCzZsKl4wCUfW5HwgjUjw=", "KSk/hCLU+W49xpT02ZhGzNbNW0p4ZiYl78cgNDCNTDo=", "KbN48kRqmjHzfUdcgwaQUymU7bZLqkN5ThPx2caUnRM=", "AYqCx0utiqx7dheUdg4JCs9VqPlVVvKqz8IP2YwZYW4=", "LB/ATe2H432fHGOc7UjdjJ5GYYz0khhjfbVHVZIbFkQ=", "KeoOHgFeXK6z/xzm0nclAud3i8+j3AN3ytfV7+Z0sr4=", "KhdTxqTHxDcWzjNx8UCmWQPSKNWTneqSjsN5aGEPM0k=", "AtlKo7tUmNDXfvHvxZUFGbECk1DUdGOUqmjoUmwJ4d8=", "CPJpCE7mN2IKEXgOq9jo+WwrBLjbYCfuiKe+hQSF2/A=", "A6v1U/taS51Qk9O1+JihEaQmHCQZ8+BVBg37RdgufbI=", "G52E0YnFoivJvikmYjNh/GvnxxTQeVNkJ/x6cL+8u7A=", "I6/CAEFPI+dJa0BGKU22kKYLz1y3LEGmHsc1E2XIhcE=", "JqXObqY7/Z5uGjcxiTjU3aDc1f6dbCrPGr3SfOFFN5k=", "In/AQS9x++SQIlIjeFnwuKaUmQMWkYrWcMNFTvJV+c4=", "DGtEin3q5Ir7/PNMt1jYR1aPddcknepNoJqQ+WxnK+w=", "IYyS455i38EZxMst7ZUS3CF6mQepqLDtuWonUWn46dk=", "EGv5KgF8MI8Pcm3z0FFapv7sHBgCDDgDM892wlAWu6U=", "Hyg/6hckTwQ7fDXqHnGTFknPcABpJUasVDplsYyjrao=", "H8X1jloG4ccOvz/Sosjf/nvfLCwXm4F/wfQdGibufa4=", "ItDXfwrkzZOWz82KJ6JGMDzscP7dVL7vbdhskZOP1WA=", "HOURIS2GiFN6XgOZVydumTWz6NW9RwRcbVg1EI7sXw0=", "HIPKXfasR3rnQjbEn5MJ3fUqQpD5x8HTCSwRMBLRw/Y=", "LnLaDh0dHKzJX4qRPYehBoivCtESlLNQzubRKKl0Qu4=", "BFXujnVSvna458JZfZeHHWECtJ6yzx3bb2gbfgWw0Pw=", "EHhj2vTKwxjdBqsU8TIVl5SQLjuNoXG4hI0+2gTmxEk=", "ATKrr4DjOsSJgtqdXS/pEZHxfxkQ+9wGcxcXtrxjqdg=", "E05FZ7KQ7ZTEexY/owSsjRTwD54mN19imahGdw9KrCE=", "DmwQCKbWzzBKHdnmGUo2DB6aptdlouUyihvitSNRZPs=", "L428D4bNMwij1ZipND1jijwvVulzbpHw931Qi/04KKI=", "Hu2pqcbYoDw82e/RvqfkaEDWxw1/qC4IW65nNH5dp9E=", "Hivco1idIrwJMVYig3/riVVyBah3FM2AEfsm26GuD8Q=", "H+uVkRIXW6byq9nWBR86/zKpxNpFn8XzuqFmt+ASBKU=", "G2pL8vsyAxuYN2VLH7qKygS2RyqR0F+WMgu1vdOt1m8=", "C8IHYmDbeX8E7y+mDGz10BTYl9MgK+AJ/F2Opg3BjLw=", "A5pf8yTKqdzWW4xEvdHUI7bALkBQrYrpMa3m27InPMU=", "HlDB96W9ipZhTqJn4MIgOctHCGcGOLFuTE5rS6CI/zU=", "JDFRQNseA9NKnokNhfs3hoYa32SCEhQb5vAx7dUbjAo=", "ASy281oY2UhccqBzxPkDfdZk2Y0BHokr+gbfi+ortd0=", "FJpSjnMDEZzgZt6dpBd4A9d04/Gyxtq+nt/7OVFIFhU=", "AJkHOP/sxvjcDmtSab0d3nTG9q/Ud3mhGdjJY9W2XTM=", "FbMZ5PUayJMe3mVC/5g8su078wdy5oG63ky9ZGWfx0E=", "FVM0P5Wx/yJqbYUyrz5InTBaCOjVxTJ4fTUaXDC0JvA=", "Ek1AwVTURU0Q4lT843OYboosobQ90iG1Wo+40ZxaIxQ=", "CGMmcvpCNqykP03+oFCMttOJXb/vWMX4D2XqD0jBegM=", "GO1CAuCB7+txBwIa7LcG9290ZuXjYQH9kmdMaQvaNqk=", "IrYtY+Tap8ZnTcl/Q9fsY/qc/gR+rWAeujb9N12EAJE=", "H3a6GIRIwtxQz+KrZcqmRihmxeMbynLRLNfcG+fsFtU=", "JZtJaPnkwyiFkLtSGyvvXzuxswpyis1FYn66RdcyYN0=", "GhryQYsezU660kxaVK3M0AkHKit+26wEoIA4cPzfIdE=", "E8SI77V22YsvWMJloNdtRQx0wBBdIlprERgIz88T6Pc=", "LgJ4kz2UuENMUqNk5ao51MAuJoKVgZuwpMmZsV/ja+s=", "JvxqD1YOV4EgLpXlhm5nnqOqSnbNi9T+Z1ULtObB21k=", "LXzgNU5qRX7V02Ia+5FzLQLlyZJIeGvougxR2mj+lIg=", "LeHbbat+ALgYOFlszmbouwqiaYmmk4bOUGFWDyaTz9c=", "LjBoCQc9SgC6voNub+SO6o5PoTuZMskoZB+rrUlE9Yc=", "Ibm8W6e94Hh6IKiqnvmhfVauKvwde9eirad1BtFrZvc=", "A34SI4Ap+70O9IoyV3SApNn2Y645oOO2xq0PjDkUxxE=", "BiNA76GjBhkQ/shU/1+pA33ddJ2f+9WmKA6UmLt7npw=", "KOLsZ1LQfmRXTk6SQJtBdob3JRJ/FWTRZGxP9Evrnew=", "EIHbOe9BlhqsjP2vuMR4WoR8ozSKm26vWpXg/088RUE=", "CsA8SK3Wh26ouEdc4W0wb4CupiKdCLPJhmYvu7eiI3A=", "CZQTZsVzQ8V9+GB4LVP+itwqddotDxdDZKBVqn6gfY4=", "Dck42mCrkYLHEhyKoEwdlVwfcpt+prvYw3uli3S7Tc4=", "B0Jr0S1HaeF0hA1KOmS0BUHoXtht0h/11xvn1+upMOs=", "LKNFEVOTN88FRxyqOsZgTvBwWz0uSHTbF4d/ajotZms=", "I9scEYAi/KkN/JoqvxGGqsCcIjcrWmgUg1RY0zwYM6k=", "KCtZliYH7TwzqfmjaJmiSSB2jmecQ7MZx4GswCDGhVg=", "HOxxmk6P24OD1URiPPsuz1wIet4DoSzCAgYN3yO6oF4=", "J50UkOgc7rc7zOZuCm3ZhEO3EasTF6MeosF3GMU06kE=", "Fo2oTrswP6k15w6FMhsQtnYHOSVh5v+6M2T4iNKnFaU=", "Fkx74TZ7Ig2qM7X49jfpIAxDySI/1xxB+5gwKHyvNQI=", "HAnpl7or0WJYUsUOHWq+u27Gxhsg0cyRsBUISUIWK88=", "LsOFou9Z9ZQWcRKxSR1Yd1IGNLsw0A3GgtCJ7kWDNsU=", "DPqe/kUHljgG044kZChzaCOLL5DhOublIOxfHl2hroM=", "Ivj+4LMTKpU7sPTUrMYhtaU0QD2SL5v1oi5RLMDBA7k=", "FEc902UKe/FAdDtDxYMhk4I+JQbGDbZp1xxj/Hy7Qr4=", "FvkTlaQvaKkSFIkg5bnDC1NuhPFcp7UJ4RXjOgjfRcY=", "DZ9JTuZ1wlDL3/ScvXhgNtiZEXUTsWDAJxyLpvrzDaQ=", "C/NtTG//QQHYTdB89tCpyeWrNG1fFMkYWvPbPhPWl/o=", "I0UogKfLWdOT5ZgCZvHnUsaGtXqH8EH3XvExiTJXeQU=", "MF8qFN8VkLqk1i2kwWhCNiXj5yHyDAwhoPtFzsovV/Y=", "GUfwF1qKnzvkkPYDiEhngVM6wL/1uHMKCLQ1+KNAes0=", "LeQXqWC1ZqvPhtmr9JrUEUTDthEN609H6jYiVzRedIs=", "E7iHx3WS8V2uDSD6JTMOGSAdVXLfJEuY3CsDvAaDvqM=", "CXs13Qsm5GgF4W/QSQzgVgkW5J7x68oh2rtKvyxEU3A=", "I3oDetlqNgrtWTfTzOOO2R5YkXsUPxcjO8LXVFbdQVE=", "GM3ANlqN+rz7BJQnCvSCLCmm2RJOjBkKnAtIJndK20Y=", "FjQov5ZghZZZAWE6HN7Z8o1ip00AHmaEvD9qR6izv2s=", "Ha4NFfoYIqXlm5QNgbOvJ6W9P33VCBZ+pgZbbUnDMt8=", "Aq3Zx0zyLR5JJ/rGdUtcvMFy1K3HWsH+wF/4/KDZd90=", "HttWLltDdjJKC2R7kGkP4zZAeNwhLeCtNvX7JtFPZ98=", "MB3al+KQp6AewQDlm1nXj+QCGXOvHZ59EBIx7Y/pofc=", "FwoRXn+w52pO2wWsCA3STdtcJ8DJSzs2715uxU65jaE=", "KXY4FVd1nyTamfruLWxQWb7pOaZvsyG5+ypgnk1H6fQ=", "CFjHxvn+x3zHtsKl3y3WMSFAcT+XzHyFA7TXxsge/6Y=", "ElV8YSwPdxjsEScB2AV6HcMBzMMLLIR1pGvK01FNOaY=", "GrBj/9/6IWpbzikA832Bny115vAMZ84CS6P4Mt5k3LY=", "KEk9BGcgaMam6U95yxrx1BUrgjVGNjWJSZwKFBvSpYA=", "Aj755dRog4Dd8sFsDQioMSN+5Yd1eXxn2VxuDY2K80U=", "EJMyUQByL4g2yvML7lPA7xTrGEEL+RVXCzJ//ZRkpcE=", "FwVHnPO9u6941PED0460dBPJM1R4ADgQiT81JZ3ejVU=", "AIlsK3nP3aXrf2+e3jq0d87uKziwaBdPFaOze7izSOY=", "FJ8TvD5OKwUVs3iidH37qQ99XHcx5Z6fNr3j8E61DLI=", "LhQiJEi+UMBo7P6/cJRLWTVAxylcoOR/K7f2MZm4cS4=", "HiLAOWAkuj9tsYGskrIppRhxhwM7E4+yehz39thwUNM=", "LFoeRTQG/NpdWGFDU/CimEL7VK+I7Etz93eFY+BeB8Y=", "LQja5vH7fgJQpmDnGxzTGFPCJ7GI2HVZIWrxxGXYq+4=", "IVUzp3d2ImZkEYqAgdh+ISoSUHZhOeo4x2n5PKK017M=", "HLu7JvmRpyHHvfg17J0e4MB0CS/NvwB55N86wocpLt0=", "CPV73Dx8lWgfAFUAQnrVOZJZ9pEEwiIGrsL5kSKSTo4=", "G0WTjHuE8BdvM1IDIVANEpfPl6pmmWZP24zNde05kS4=", "KusgkESGjKhEh7eRbmtAM+5svvcm4mnQ6RasLP0/ut4=", "J2Nb0q5+DKyv8Lg2WWYHp5JAPboQrDcGyeEZd0A6PrI=", "IuWTt6Z5NQJ5OBSb8W/OB/6ecmBV/AzdB+fqoX/lcwE=", "F5WWK7UQAjahg95JFp1rg6Qn7evSNxG4lpTag8vQh8c=", "AHf8jXzZrbwoPCUyG/N1mM3yiCftNXB89Ih/zkcHxDc=", "CuW0lNFm9qMkQtHQvVm2Xst62PZXG3dIakXs2CfdEoA=", "KSQim21kgYT+Y3Ga2nBB5pJyzf6JVFXXfwFjSouJLIc=", "BR6ECQPdq9vyIQNnSTNoUUKYHAhSpspq8MjRWwaHFtU=", "D8UIt+Ygu2xHqFlxv8vijfYmGcUwloXQoKat88i/L4Q=", "GfdiG71lmyfRibsyAQuV/CvYdzkuK1avtVisX8Dw8iw=", "MD6Y7jW/ytKSaAp5VuC5MvfFcsChMa3sUAbY8pi3Ibs=", "GnglPlf4JbDLx0LYeSOyfFH0pTHRI1qKkB2ZfjGy6gc=", "FeIgk5umSzo6sp3r87CISkxDhadNhF4g40Sef6LzkyA=", "FgSGtuYh36DpASOk5D/WkiHsGw7HPRlkdrUEvM0pC5Q=", "K+60JATbirXieWJLrNthSyG1rjhvLCo0p5j+ynYxEAY=", "JLQHUAQW/7BFmx25dAZwvbi+itu0/Vr4/pxLXsAh8OE=", "B/X9rpiChcSbz//yP8ESO66xA7/8l99oOaDDUGt8BCs=", "LOm1oI3szkuFPmfSivbrTHVce+6BkNeAavBCdZo5lQM=", "HarckRw+w7jl9CyxIwF/H78W5KouMt6UsBgSiEW/0CI=", "H/gLFpYXt+5arvvuZ6pkvWTdFO2O2uFI+ZoW4/IgVlE=", "Kv9ozTjRiLirhcAI8wDFCIJJi1Bo0807grWuAjv8buk=", "EU0LP1TxTeRcxNtaH+scR1DqAkfY8k6Pb0ctkutwht8=", "ErYHV4wtNJtp4PdWhQ3MISWPha6NjKqKOgIc+NAqu5w=", "FMaS680H/O9VCSu+lQWJ9H3+x+xPOkKUSwRCaQeVoFQ=", "Iinb37kq5+uDROtW10bQcGdjfXX/pDnts9daiwgZnyA=", "FvRkisR8GX/FcvWDUeSwB3OtmivK0ErA+HOlVrbs9r4=", "EtkNVcjT7BhN0E9cautjm+pwp+PQE/yxdDfrpmISL/Y=", "BOLEl1a4tawmr52TlBHK+H8VYm7EQ23uvH3AdJBFIW8=", "IZF9cjoz2yZrB/gZSJVcRd1QeFfp5ZgYMdNcVtvQuzY=", "DRO0aqG0EWj4G00jZRImjCPnv8QQiUi16fOl9e4MJmE=", "F71zEnXWAtF8objsR8sS3xpLy7njsCom+GoIsu7x+3A=", "AkDuYBpoI+xpikvHdOba/C89HOwsXIn1vRNim9xpJ0U=", "JmP/nQ6qbpEFk9EQItPHe4d6O+2NAH9vwgeorXW/JSw=", "AsRbU/py16DXokSrOrC0H8QOnMOMu+KU6MhKcsfD++c=", "ELuKdTGrBdIocogPloNNI6MZN2I98/0pU4havd0SIrc=", "IiKVDIoczBwhIqNT0UgnRNQuYSVN1lO9Ja5p0rp5sDE=", "LD0+tyBTfS3ee/uO9iZdJsnW2Rjjfy6XAw+9awRFfbQ=", "BTmmluFRmBaTFClt5W3IdDEuGeWzUY711Qpyz5ijCJU=", "JeKl/h8VWi7ur1DQFmT5b31ncrEIrFxMv6XvWh/NWtE=", "L10+h99pBKvUVO/KnMMPFUFkIgyeP+8n4YEuCHC5D8U=", "De4g5HMcDnVC5OVD6L5sLt5x1uqoIVluT8nmjoncMA4=", "BhRCwTudH7M5YVzYr8C8nhG+dBy/y9KzqSGUA06dLlQ=", "I6VhheEtYjCg66981KAc0YQQ09LKmR95r1cW/iKZMSM=", "AzRLe5rbFaO3w9ZP4e7DU0IgLuPEo22y1J6B5RdCNbw=", "KEt1HtYdSEuitZQKGh7h7FNtOSsRPQbbSZWwirZh5nU=", "FwGtJqQt539NWKTIGR+dRzAwnF9LzQxtw6Cqs5Y0CCA=", "J8rdpRmoNwEI16pukQL2sp6PojhswCllk/L2NEn/PUs=", "JibWHLEQuwOzJxLVnw47Gy9bkFnrmUgHsmfkrSYe1pY=", "HPMzCJfFTyXxX16LjaV77Qhl8/qEHsSEQanwRXkVE44=", "AbW8zp1pnlWkkNPYboySyDpyVqf+uf2K9shNaOFI9k4=", "KhdRBdFbo/7PW8snRrPIH8jKRo0dSqmZ+7qo2BEgJu8=", "IKI4IpXsoKYciIzvgRFa4GN9fseS0w7Kag8pinf5sms=", "BRVJu5rbzibkshiynKeeIhy2kcmrWyeGI574EmutLlE=", "CBylNJ5k1gvKCAv8U0yLMLGL6kMJzwL0THEYX+aI4Hk=", "KFpADWGly9bKe6p8PJrKVQOxf9cC4AQgvOczI4LAuC0=", "BOG/jJVbw8hwgmLj/xSL6iaK22YqwkWUeeavLnNECyE=", "C74ZrE9cZ+nuwyyea33XvIBZyR9QGy8mqSswvCaLC0s=", "JySsWOHqTfGeZkS457dmXZJI00/7v0xMqJNMYI0uj2o=", "BEZ4jZVCav6oMNGmyo0tCFv7QzDLJRTf/WCpq3D/9wk=", "Dh7PJsKGyGq9kQwrN6xAv8DmXLKRQmmmpqrsXN/1dY8=", "KaJn3J89EtYBqEkUiiRJED8lcTCDsWEcOG19DAXqS6M=", "HcNKYOeDtdr0ISVYbqKltJ3Cy+udK5C6iBw0zrmdLTs=", "K5/OWFNL9KSGwyIPD/kCb1eMqcQ12DIQJNEO7IK+Tls=", "L9nJfwEFT+YcpeB+NoHB3ZqdH4umMN0kylo0TD1mbRk=", "AE5qcUbCrAFQN/CoLBvHRr+0ac7J/uN/G3CCOfQz5kc=", "D1vrogIK/ecwE7fv4ME4R2LbhhLa4FjQ+EnHODwHlDw=", "HF4ebvG+Gq9Lbg0y1ZDcWySeGxu899BdPmDGPgoYZn4=", "CVZ1xuHo9tqo3UIGCIOn6XlfG/iBCV6YSX0z/VyM+nk=", "BgCTzJ4fVPe7p0r3GOGaEPAzGYwi0h8+6AJxJYCZ3Mw=", "LESjXKjiSp9Qk84cuSyNCknFM3zDYBxE5PEuBErODcE=", "A+iWI0d8XxNlu6FuyxqKWnDj1cg9UPMHFaQHQ0Pmj2g=", "GSX9WG5ngzTRYYp1Y0mfa00AHL86+yAjKENfLUnPc0o=", "Ghh9Yt62ObggFo6Lclp2yW5Vam6QMEoayn8ZcQV3Gbs=", "FyON3kR9m8bKtmOVf/VMdLR9U7rUJdw7wRSCrUSEqg4=", "LXoFk6Vr0zfn6uiphBgad0ZYkctpnQae+7zocRNXApE=", "J4OHxO7uas4S8GUxoxK3d4ley0NJW/kKdAtf8linM68=", "GBriCXCZg72QP0G1fu6gVoSfSobT154SiSpFJQ4B9Hg=", "KGeTTr5mwzVmOwOMliK0HLa/iEAsBJ6RgB1BbXNEGmg=", "AWUYcNGg19BaIY2BHkZPxHZ+eYBhUV5DvgFsZnK021U=", "DxcJX4orIe3VASbSdRNPKc+5EaeEbVzy2nlb4MGnACQ=", "DynqQAl7NPOdAc2InmMZcx2ncwIXFxPimQ6Djty1HOg=", "A0UDQY8nzPvcDuJSkRLVdoCHNnOGMVtTCi2aBStgiQE=", "LaZYruodt7IGbMmCo6SmL8Iu6papVrjI1Pa58Wm/NPY=", "CZiR6PIgW57bc0+wvGyOFNTPLreFClSW/7RNrPvuaHc=", "IrKFJ6nifWW32dQl9LL01XvNw5AInTqyEM9GNzVlslE=", "JKxBwh4DLxIF9Ik4obqJJxaujUxyMIZLhvO3VXbSSfo=", "Dv3hfFYYm13I3T/J1Hlu78fdUjR8DdOtBlOMLLzNhgE=", "AfMhob5V5LQcXVqZhdRQ9sI6LbWAzeH9F98eoW85OZg=", "EoRjXoqhfjS6sWH8WKPoXsJpEjWTeXpEYi9rxbFKAoo=", "GEA6Xt8wy4aA9+uGJkqg78ZCLqbzTv5V+Xg7trzKr1w=", "Ka18Xnxe6TyWHUtnDCmYBHF0u/p+3P4osrTRnzyV2ZU=", "JoW43scQnACMTrVZrviyiWSHOAh3cNZaik9h2TMwnOE=", "BtGhvKdSLWl6k7RIrBHZWXLic3yfbal4lAjvSnAcA+A=", "FZ+GKURrJhsX8ruphnnNIV/xio4ioK3a3KoITKcoviw=", "IQDBYFtA4WRMUnVx0fKiaNF6icGwJ0/ePBhWdo4TQ2E=", "FM1YN2PFqqWWWmzYENOqcI6hsB6GWthJJrbdigwpfzo=", "L5r98ldfhESXzPckzcBgFVsp4vRSyVAGv+VNRAIGgnI=", "C2zj8G/CO2HmlJCGoniRyyEycw1dl2xNA2x+Wqlg7NI=", "IJakrOGcx8DZTJdYT4vR4aoPOKBbpESxWMCk8z3vZfo=", "F0KQnSD58X77XGzosj9rhffbDgERGtgOkQ2nOHkmvsM=", "EzxIbDvp05kXbIl3eHL29lzEv6QaALEaKwfbeVQaTZ0=", "BgtbyblPRUldbj+tXvfCDB0wTD0LXb/pMMiuIiM/w1g=", "FsD5KGdpUfrrsal/cN2GuyQ5xPresmAo1p8zEHlJ3Kw=", "BFf0Lb2nyzjeM2m60TtoMhdiR3FYw9my7cZXMdKwxD4=", "BbxT9L84i19HfVv4xd4efzjvD5THddc337z+QKf8ykc=", "INBX4w4lY9fbxdJkEibG9gALy1Sefc25t9+Bn/0QvNs=", "FvBXTnwTtBxezsw2+VkHGcMfKUNac2wzrZrBr7kodYM=", "G5Yp1WeLGOyl+cUkStvCh78bGolGjlSdF2WDXbX9zn4=", "J9gPFWSI/ZA9B9LGRGDdZE1H21lz0Mc22RTj+mD9ux4=", "IRl7s/2LZthzUBnN15Ec/Oq6Y7SdzQeRDkjJk/552VA=", "KPX0lyjallMqZqLTd+spnekcwdeHAdRKClpcxn3ev54=", "Flu84NYtaEESQnb1PLKIg6xefswS0SUU4v6y4Zt5E/U=", "FJN4B6LZ1y0iNGmcXzsS8bcuKCshb66RDbVvaMraS/c=", "BxQvxJAfDiFOxMdPFoXDWwSFUWt7gn116huAHnjwRF0=", "JxTWp3rArHZsTaLPRoxZ/Me+OckxKbnZJ8Kr1oQ7ulM=", "HTEQN52Xxcpw2nsEiovIWVh6+Xe1+7g+rw+VGx2yzGk=", "Ei+bSABgw15rGwuwISKRsK2+JxnGYOqxB6vV5jLiuW4=", "AoFfdvPuypS48sQpgs8YLJN69e+8gCYhxK2Qh2A+W1s=", "IorO9ndGa7zoFgvVnJOMXTQAwkoQ0aPPFFUZzhOXkEs=", "L28IAMc+C1jE4xY5wdmOV6odezjyQZjdq0072tixsdI=", "EtywC5bpcp4+RA7qtW0jtJWSyNMGgm7hjvyPf7EfzT0=", "FMk0/duek8G1Of88cmkjF9DDZf16cn8rDUDgRC7mzYI=", "H1tI+7EM6g71mtmxJIPte+XGAVE7DMzhzaOoDEWoDGI=", "B2iriqXNBA5e5d5SYRENIru9MMC12co9KwdasLDejzg=", "K4T+AsME8k+twe3AaR9b/7BQH3voo4HQmaZ6m3qHA0c=", "GCfRGRsV3PUaIAvZaPXKnNH5bD/Xnt1kVAbKDK0YJRw=", "AWlQoGuStUhe91nQpDlFxIIxsP/eWyKB74fsoBgL+t0=", "IRKX2k1wz31D88zXCojBUiTPBD9vrqaKdNb+KCqDFgc=", "ChgSF9ExX8P+z16AGBS0Bgp0L4GGiT25Xzn/IXIeTYU=", "KGBY7WME8Syde2BT5tInnTSgwYfwKYEIVMgJSG2DREQ=", "LNClYhMmePX4QM2iTaTTBgY5hB9TxgOxp61Fn4Hd+ak=", "Ic4m6OfIMEXZ55QozZBa1InfvnXKwf5YVAhnyG7zATU=", "AUrdxnqekj/4kO0nm2opZWsRRe4qIT48BnV4wXdYxRc=", "Cvq033kR0RVPm1ufnUTQjCzpSNDpKgbjpGbBKTYY24A=", "B1bdxGhmuiiuICmerFjD1Y0HwMaPhP7Zy+MGoLmgAig=", "FeoXfYvB8lTD0pDnLY6+b55fZy7E+lu1O/6vvTDEEic=", "EtQZkqzMclhnHh6mFn67Pcmf5idcOPEvt/zJlOMmMCU=", "BXCgcCHn8Ml5rkfUL54+NxJJ6ypYO3Bggi2DTmic+O4=", "IbbpxNbcd5gpLkkArIn1um3dw9J7u1DEX372P2Pm1wo=", "C9c4Pa6P0/GvFpaklzusWjSgHFStxz8a7/1fMfAfwfM=", "Eahm/Vnluh2Qw5xaSkFeyDA2EfNFDVLwSHqnrMgt7p0=", "LjMOD7KVXYRzrZ4bpiM/2vRP3S+hiNSkrtFcgpebM9A=", "LsYUFHZSRPa0Z8XyTkQsk5wEw4Ebmd72TVKxpPF9nas=", "E3p3CDjYUjcE53aCfcNy5VqQ8gui3VEyDArHg7Ajlns=", "HWrlI3u6a24yqJ8wIAIAr13K8pQBmGjk4VKzMnZeDIY=", "H5A3+RiaU61Xc8kT6IrnkQ/QICmaw5TuLk1wO2L6ad4=", "LGASJZwzKBx30CxhvytLPbOzMUZVd0d0bJ2x6ru3z30=", "Ehffgw7FZEV1IJp1q9w1+mBrJxd19G7be3dCtXPSies=", "HTm3IdSNO+nT1RVcWMVFSF5x0APxmp/AxmP/9X+Py9M=", "FE72tSmhnFXAfkHShZ099ysPdWAm158y7rHa5XInwjc=", "LSZpB9mG1+BzA+LrRbZiDQFkTLjDgeo9FzjXZ0co79Q=", "GzG2O5yXNjZS5kzgS4RO/GpjsSLxZP09L4fUnU+w/mY=", "GoxFKjGv3GKiU4DXOMbPTlhBxWINqxlBAigJRTfs9Tc=", "DZ2BD8faWTHHpJB5dre3f7aM5/qGBDWRDKNGqqiyrKY=", "FecwiEHoLLRK0AukrvmkJBAE+K30loGQMjdaEP7NyKU=", "Lhf3GK6feJfnK0gfDHeahMQb+s7bE+CVMKfRb+NV92U=", "En5//G/4uhlMlCLtVPYbY+WMeuZykoDRtuHogdTQL6M=", "DHMJmevawVC21ef6adR/CQhj+rENGUmRGgAVbTKFk/I=", "ERQYJUudFu+NZJxaL8QTasV2IZHvYfHvRtNe8Zn5Kic=", "ANDjIy976KlWmbm9EVCP5JXgJtqrue/JNe58S3VLyEY=", "JRMOl37E9r60rk2/ZPGW9I1g+Av4DI1fIoEYODeQySc=", "DL0iynAwAHIWPsG2GslaRelZ9qaEPR96j+9rWykNtMo=", "DE5ccbRuJmO8iTkutXdcd2nAgFUdIijYED5UVUi1gSw=", "B2O1VzHRBSIL277T4PPY3JIbSrotW/LVmVMXo51Do9E=", "LleLnDUnUCws8kj50l5ySyUrH+pdMLloQLFCsGas8UU=", "LXJivYnnP2T3hQ5Wq5NFN/Ysr69RFhS8iGmHXjOmk4E=", "Iz5e85dmHHNDP6xJC3KjdfMcb2d03WkzADOHPFmo24U=", "IEeIHVQrv5dLnp6SAUU8grV0RzDueNL8Imv3Pcckv7g=", "E5LgnY49aUN3j1AjrFd+1YVzZA36jPsiYd7lbwIMrgI=", "ETzlZB6MCEAe2/jkClj38ZhIbJQ9mItXEmXaO4AJiyk=", "Bv40ruljMsDbqnVnBPCsym/UiLehpCS8UHWa1m3z7PY=", "IQ7tqQ3waI837n9NsBL6cFHar9PU5iqKdarXPKDEWAg=", "KPVTEcpSbjnibjjiBlhh887B5ijeRvQ1ZEHI7NtxYXg=", "D7OoCktSiolVFC5kIZSsSmT1s0XIbgzPcCUAFgUtlTI=", "H2eKV6dXdbuzypX13sB2G7casUffEH+nX0Oq+TCuo6U=", "Bz7lGpiupOnOXd75lhtZl3DlgN7lyykWG/gcCqdLpsM=", "EjbBqSWazsUKBPGTUGkYmQ2hvMnyO6/HdIA63qQX6bY=", "Fpq5pYNVV/UYoXdW21V16agnMRL1Sx9jR50mGq1deAo=", "Ij3JefKDNWnCQTD1mTagXaqkm2EMevHfNzyBrUGHbwc=", "Kn4HxCsmT4hHUI93Z/rSC36FM4p8x7jbnPBhWmFLKnw=", "LTdMnsFIL017DPRbX2rlsJ+bTF4NPkKGRoIv/FgzILI=", "F3IqbJevNhHDHi6cinwb4s8bHmeSDMYZJSKLtrFxn8w=", "G+whvSt5vwqrgk0sc0Ob8waXmVB4nHYtPyRu8XJmXGw=", "Hk9cTBUWaysNDy4SQ85eTX3w5AhvG2wTwkdgwjs9K5Q=", "GyZtagP+amZ+W7uu0kB6ygQvxl/1h6N0WSQuNH2pCKs=", "D4LrtKOi2cBhIx0HKXTaeGdGTUWgksNpM31vfzjxnU8=", "A18PUQ3wU62Y2VfNY/LFEay41j+O5zTZuc2dPNpxfFU=", "I54iRkEPkKuq3CVtCtZJRY2KLzqYtoC9yGSDKHBuWdA=", "Iwpk4OOVMbq2noN4vsXs1F3QT3uRomTUuFKxcFCi/n0=", "IB2TWS5j3Y7ZftoMHvj1SuM1VugLpR7Gx9TvU3baJmk=", "G/54xQ0LhVqmmIXmNTfuy5hMGOLJ/99vdqDTjNiqJKA=", "MClwjH87W6/FwN3Nhl0XThuexxJq1zDBJCdMVie4v74=", "FaBpLid4DMFU3Pt7zKfYxp1hPtcaxznojMrVMR1Bk5M=", "FYWAiFtFIfqx9ZJVvHSsRty8b2fkxbvjwEB/bnn5lmM=", "IuVCcJ4Taxj9qNHFnl34qe/PImKWzmuZ8MWkxtjFv1M=", "AAmE0YTCCQmxibVtieH+MQdLcRsQaBPjGkMPkjSEX8g=", "JguywvVhr3tLujwjrxRGDmP++RkTd51quHgAk68udsg=", "ACbi6jcrSYIa5Wu+GXhuvyHEMmwYjEe3D0ey0SB2XK4=", "C2xNnTb6wwM52Wh2owQCJLrzi1n5b9CqAq6jCuGi9NU=", "LPX8PXXvQrWzdDv6vCFJC6uai9nTgob41uxls8E3U/M=", "CEaqaqIfGMdAAPBEFD+iZv8ee+e99gC+Fs5P3ED/HmI=", "AC+NDsjPBr2z5MY4cziU1dCpUgTWSPvOraBTrNnTukA=", "HOj/m3S3nEzqC83VgGP3RNuWMPO/WWPxy92Vn2ESb4c=", "AX15ER44VFLmFcRCxu8IMzOoqeCGKLvh6E9N7nldwc0=", "J9Bk37CcUTSMlpKr5059t9iZsG1jrxA2q3SVPAizxVw=", "FGh0po3zNGFpJUa4i8B52Flh6kYvDEgX5RIddOK/L1M=", "BStjUsJ9CA3PXR5QuHcMG/bP3lWbJOff3RfTc+mpSFI=", "HnQ4lG15zRkb7w95q0+WBGaTZ1ciUuuCyw87GdRpEVk=", "BHCdoXNvrvQ9YW1Z/hAQyS6R4UEOXdmsN278c4ZwJCY=", "KDgdSgKopV+wa7aWxefsILNjYviFt1Ox3cUX24E/Yvw=", "Fg7PkLTieknT9Assvp8Katf7qCVrmlL7TL//FQekcRM=", "Aw5SHZGh4fiDbzmydzN0X9+W0IZ7v9bMqrzJRzWkcEs=", "K2avMxg6pOU8+2ZSFvhrRY/T6QnZo7A3WLrZ5EZXxDo=", "HoUWsKInbcupLYuI1v2PmwTWGrNnohBYylvIp1Kqu1M=", "KyFytzMR/07r32uJr1FtKuC4q3W4rfgETrfiDVEYJrg=", "BkwuBjaEWjsikSyLqpTDnhTn32u21Sy4kUUhurFDceY=", "G9T4ln5EPo7+WhhgG/7X0r1Hs0xg3/Cslk1qTrBZtBc=", "BO/CNKFzY1S+EGIOrbD6+/AwCS4PFvU57alYJ01UNDA=", "L0L8HwXZDbzkE3d/dKNTxX6OZjLTDiiq696IuHjfRts=", "Cj/cay1GsAR3MfWZTxk7Nf0j5tTUkG0GIr6W8p2bU2k=", "Cpo4Gm8r5bcUUDFPNW/M7v8DGqRqJ8ks7O0s67VH2WA=", "K/Kg06wAvp5bwGCjkFPYX0UV0+zG7m2ZJcVX6z/6SHo=", "FJzqSsydNFr5uqCwqp27OidTQUh7SAmpctTKSf0Cz6A=", "Lq00OkKw6lcOGzWvGck7DCX1DxUDz0pjfbuby1igvyE=", "HBJ1nGwzycv2rYka2xzC70Mt40JRhlH4sVdzlNdSft8=", "FhkjD+r8gQH2vHmyxyBOuKiwg6OMDUuudLMfzTU9h5s=", "K9xLuH/s7KYazgmwq+i23XXPr3ulkfAu61Y1gI7NtG4=", "HYM8cTXSdhDmly/fAFeArkHw+Y42tiUZeLa/ldffaj0=", "H/ekWVJueWOW/MoZbdBPgbo0Af7Ge2ttg0IumHeCAJ0=", "JED7tIds82p3GuE1lPMbBvO6F0jMsG86Fql/lNjWayg=", "EOXYSxGrhkh5/tBn2igE91yadSc5Ec3ti7VRz/Prs+Y=", "LlbBgw/mY3AwZND3dIC8eLTx0Xk5Yp/qLp45KE8/YmI=", "CgmQJ8pvXBAIei9LOMrds2a5jMTdDqdPCIGedQKfRvU=", "GpdGjY2bhBpX3sJt1PF6+GAt5pX8U50oTueP+FKUmQQ=", "A5SmRYNJpST0mVx3trf5zmRVohYvE3Q4MYenUakINY0=", "EhbPjweaCYhSY1KWQy9XakjG3N76rHC9Y8D4bXnelZE=", "IcU6nuHY9xCZ/RhavpdyYjNDuLpl4/lpq2ZcxYwKYAM=", "DQDh7JkOvVIlxwmQYzLsIYRZ1FKjRWDAAKQUH+kqEnU=", "B5A232swo2tPalLMh2sz7IzBO+7T5J2Za8MRMOmUL9k=", "BzFskNVwl8IUB+ZHwSkKQtV2bUOo8yRzNCDKvazBZYA=", "LKqF87gTIAG7D89BFNhNuo1qxhyWoh8xlddIA4VwhbM=", "GlsyoSJpbfBDD84jOr/iH80R3Qcx+Wn5Xy6SQ/3ZjfU=", "HUanYzQXDPC1i6DN11sx+Ds60rx598jJMKXqywugLho=", "DZm/BIQ3o8xx6mmY+JClMqs6EgJOIw6FNtiovvCE6VY=", "GvwvTIuhJuMExhcm/sIjQfRHMCoka5IuM5zYe/Le9WA=", "HJ8R6GMc1GZNqbz0W97B2SuoFAfnEyHHJ7FMTFP/SRw=", "GZJo46wUtgwqKe/hjqh+wQhyHriB9qSenWuhod2U0+A=", "IsM11Hv2cYAx6D3kLUergFvc4D4+rLLuil3YjK9dVlc=", "EWC/mfD07Ae47y0Vvlo6jRz6GS5Aa7717Y3V+3XbQbk=", "IlTNMv1Ah7cTh9rDVUz8neABlPdHL6Qd5nTYygHL8Iw=", "GRl1HDeKglBv4wlYo2vW517Gc78l1pPZgDNgLnPWR+U=", "J5FrPkoMiZIjgayUzfiLOk6CpTn89ciZpRIKY8tPdo4=", "Jo0/+eGNycNzYWpqWhuByT7CCNwENBRVcxDHSbd5hcg=", "IShtUdNQR297Oirj7ARsE9XJERc95BrB3J5Zu7pmnyw=", "IPv41oQ7rIRLbLYyT3BUNEEl21TVYAoG/JtyDyIplB0=", "Gi+1dEOjo9cDCquBslbIuahNpyQDagA9Q168rMx3T0Q=", "IbE7mky46XErvOMvF49ZB0o1qM8HcQYcoHZLaxkPoTk=", "LHoRgVpCADj3H9IBuqZBKsKSpj3Z99MJC6FVc7ujxdY=", "GMljgJRibbfli//XF7EofIrOcGgjJTv2+Rygajf3+zU=", "E2+0q8TglPtLW/8j3g1Bu0dkSB3nk/govz2fnfGqHMc=", "A+wPeb93ML2hiKARCJuS0mr6pbrWdyTY4ZMlcsZXlqg=", "BinzBtixoGgsd5TDLala2uoL5IP+T2McK53CUFQSV9A=", "HwhU7mhhSRchaEJwh532h6EsKKCnk1wLrAly6jmEENY=", "BYko98e4UDolhaxDmuTtqTENh/lQQkAv+v6Y70jqcTw=", "L+Wk+siIz436ms/O4kn3iOhsBDRBzTYj+5cu5Rms4XI=", "KelUBFzMq5YS/4QCrSIsId1c07NNQVZUHVAk3IhbjZg=", "JRo5YroPPp+N6IHRBGQ8nDknIJIxKip3HxF5HmOVeyA=", "DrBPiVmcuhAO5bvEcE7GONECxnAQg8av7o0mzcZLEB0=", "LSBX67SHjEcxMwD4oWHG1rMAjCY+c47Rt39uLSNosII=", "D1N8doHqrXUgYfWUahDySPiv4C76pyTZfnY8yMCXFVY=", "HkC5qgANcNbuaA8j00ugfqBDVht56LbDBvp4eCMvHPs=", "GqOPShGfqcPj/5nQrlSqbLEYDEHXWF704DNnj6yEsvc=", "BWYcAjzI/63EJa+O28WkWl2vZJZ7qwO5HG8jg6YZSak=", "AjxNnYCbDTr8HCfLax3sZj6WJf1E8fE4nNGyni2xUOA=", "CfrA65IxhQ3nllOTqL/RXdy78mWWJ43HibPkBwPbQrY=", "BAuEqwBzcQPtWsMS9dROJ9R0nNGRBRv4piMbtHgONU0=", "Li60uDVFcsJnzoRsnrIj44GWKLJkVtckSJnlfXDf+Ts=", "GYco7Jlq0JU8+Hv+uIEL5cWIrBC3OMytex+LrVDJfjU=", "L4qO5B2QqsKpHBzHB3Ltb5g0AFJRazpUvY3ziIcMWyQ="],
      M: [["K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "BpsXed7D6t7T8H0MPmzs1s/+eNdH+u2tnJBmWqLZLLM=", "H6Tv/INJjRmqpZi3dx+IoFVN3dqJ0y3Pim9M93bRO5k=", "AWdvXAdBerVMN+yK4agxS97rCZZHaYgVkgQ9/8smv0E=", "H057vI1Cd55Yqge/VP8yS4FP5oe0yOuBubfnREjuJ/8=", "D2sYyY/In7+pmgTIyWrl2zXClkefSEtoDfkF1MvR36k=", "AObNEIg+HhHGwZHTYynzDrAEWvBsLYbQxDn1wfT+9Us=", "BCWpZB+wFVi8cXCi/8JOtqUUGYspahYpzChNmDvKh1c=", "ADl6fXQ0sKqUE0jeRa7EQs1crSw5iISVDoIzxY3VAzU=", "HWbyCPwEQRoThcIuID3AjwusL3zZ36zN7CDTuTJSrQQ=", "DsHtOuO+rE3dH9sXucfGSOfsgYhaB6W8vZZ+ajZ281Y=", "Cz5gHjal2C4CFDYshBlHTcHMLA7YEmU01po/eQsnxgM=", "Fjy046XskuV7JbCVo6qoz9xM5ZJncYzGCQoH4UrxCw0=", "LcqQ8+WhWymJX0jXoSkNejNka4liDdCozN46o6UdQcs=", "LHjuXqFtOPC+udwHM8S7GJPLM/9nG3N6ESLWT3Kc/yI=", "KvMk7E+ed4bc8AQ5x1opS/91PjKSu/YuZkcfpzDxnHk="], ["ER0EwIP1Gm/fh0EqU39mAQdtYfQ1CU6haUbvv6SJPpc=", "GHquJh7z7iGzcCNRigcWdcbQC96CvX9UQUSKu2Mqdks=", "DaKO3n9j91WWolaLLdelhFduWygvKEeVsaeqIWY4IrE=", "IEO/5S0pZOSjstpeMBB3Fsx2T5sci6Rj8hWrH38DSYs=", "J7SKY2o5tRqTiuo+tVIJFVn7++ceCW1RjEDZCN0lcO4=", "F/51o9EbS50qz3hW1t6ju6xireDFATR7FoZPPHPrt/k=", "IybD3KeqtrGFJlT7E//0KhUsqWMhJCFsx8xvbTdSKlk=", "CAxEKQkif0qdqS4zI3+agssMb30MQVW96lxlF7BG654=", "KxwA6gCJP5+RMxvJBzl9uGXDfTvGxLObgc2TFpb9eDc=", "CS8Dx+mOYcKoWUP/r5wE27AUX8IFXk1b6Qu2i5AQl0Y=", "Kg93uzYk/EgmyaKma+TsddvCFkKhb8xBgtLWXA/Y1/8=", "EIO3QtNTMqi3m4Dn3ASnL36GaS5Sm2oexWhzNLYH2nw=", "BT6V+UVbxkmdRHts7dC2qtnLztl8zxAGDzye9R4o520=", "BZBNrjRw1AzhJ0myfWRuYg6FGeKxfPoBbK64nZ407m4=", "LlY7ncWj1NWpP0drRm43EBnHf9bupQYSak95J08va5s=", "FFYAg9mA0XLdQMlCbP9BRnrOpB1/SP8RrF/MCHui1bg="], ["ATPFkT8l/16qhg0DGPaktDSf0i8tU1MOXHhbcJiKOog=", "FpU4CU1PdSUpRx4/3cnvmUz61PltzH1jbw/VCbjrnDE=", "GZg12pX26yLFkevlFMfyg/Z0/Poet4ff7leBpk8IJDk=", "Db2GYlEd1wAJkbOdoSn50DtWWgzS8hjW6ru0miXxBeU=", "DdDBGPFa4H5dtVB336RuCBCZVNmeGNcs0sr2E5IOOQs=", "B8khv0XjVISKYLDl8pK7A8JGlJi5weTTIvSv0YZ0CMk=", "H2lNGsuqsOpbwCahhk1Wi+VVuJwPSbYTTpuJWuFB2oY=", "FgTeai2xIr3V2DlUChAF7UAkJbrDuF46ciJNM3QCvew=", "JZcM4xt7EM7yISZ7sb4WVuwpFG3wb9tbT2/mYHUjqgg=", "FJVvgKZbAfnul+LrBw6d8nEcuLy1ON2Y5TJjbMYHgug=", "AdeZroPvZVLzDtxHuegq3AUD3Et02kC6C70syesbClM=", "EkF8ABvoYZcBOytIccTpsNzrg5kZGanK+s/lRmb1kK8=", "IXH9EflEhUZqgZ4k0KzvCLDIfXi0bZO7lGK0Q/pAzcU=", "Ium/KqAv5l48x0+z2D1OM1GGm9MFKMN4lYr0Yu/WRf8=", "By6i9c3Io3ifvOpBSpHnsnu/sxUd9RDQgP9O98xz8Nk=", "Jg91HHgjq65huPN0jIR5HAvYSs9+toVIcCUBeOmlLPU="], ["CIdfR9b1GMjC31Gnhr8iB6reKEBnIo9EDn0DB1IKVs8=", "CmiDDxnApymy+Jvic3PTl64RV79QfneZ1CIBZuoJgtc=", "KvVgYAs+JavMf3ik1uLNP9mby6B1q4K1XphBvve5IQ0=", "EbM6nxgY7X9YHKwCAFHeJv4o3AvYyxpEV9WoRHvb1vw=", "BFxhf2BMGsn7jXbo04AyLlo7afp7fCriyOxZZtakx4g=", "DmGX/lAjKNDvf5uTA1UxKzRyBLh35/hdm1adw08GTBo=", "DN/gmeehVCeN+2wDiLnaoej/Mjogvmpqp6hDgzP4ecs=", "Fd7YWdUBwnM/6t3eIv82+oroWAOux6IE9CsfZVO8xlU=", "LUAmv6ezehmjAKuvLh1cMtvNQiQO2GD2gfYd1tYhTO8=", "C8y2acsBbUmEZJRPcZLs/2cW5stfiV0nFby7tlsSiMA=", "Bd4QmcZfCKmQrA8fRewvuHLHceECddzPpPzhFGY50NU=", "LEZdm164UteTOLQnsxhNlB80BGFyqCzOROK45cQ3lHg=", "I5GAdcj6CSm+/CsXH5nr6d3WaDWU75qD+E1Kz9lZLVk=", "Fdf7piusV75dl0UqPAbZ+nV/FE3xZkee5zBpZ0gKKH0=", "Arbxb4ErqQOQE1WVXMTduZ8k8cbiZDCUflGBGmgxG78=", "D2Zzt/tL6M3qdKqngCycc/8NU6mOlKK8YGhdiQok/es="], ["C6n0ShB6gcsj+6ZvK8NBUnKPX1ymhAZkmn7+R8lHPyE=", "AYrjkIbuu5jR/F8F+g+H3csUmwr+ONG7uFplaXiV5j8=", "EBVE0TFFTyC1SbJKZeyE8bMiH9m0NGHdxtFWgzs0xSo=", "Am8vWNY8pu9Zu5UgbOPtMSSIXsIXYrux2x1qd3HsZlA=", "Jbl0/FEp2CrkxiRuNfgC4DRA6tCZlYZTE8jKkcggwtE=", "LUCb94vW9qTspzl9BlAj8LtnMiB5JdPOS+759iHaK6I=", "F/cyzBNUsftHbnBWjS3LC2aD0wsCQV39OFUEc2qobeY=", "BA2w3v5rpHl7dKQxJc802GorM+eiLicQsPt6VWiJOqw=", "KeiQNJQkFKH/aDPW4idC1BBuD1830fKrgOVETlpSycc=", "Eh0rpb2PIy7PRKrPEETNarb5Px5TfX0VQXVP1J9RsiU=", "DwkT607n08AtjOc9HOwrbLsXapISmzSilK3wZiQ/9r0=", "Cg/mbA1N4AzHdhAIcyoAl/sU1kZfnR34NeBCP7IH2Xk=", "CJjtHsGkNof/aroy3l+BlDRSigdSs5KDMYmbBkay8GE=", "EeCyND7zcdLW0igFl08lObblENdh4NoXDQ2pAJWhMmI=", "HVnVwQsMndNHiZN32jW35nfH057xtJFmuXSn8ryZyUY=", "GhW34t4nEl8uanT07HzSRV8bv66xFV8a+Bm9tf5UJB0="], ["BUKDKrI7bHpLVHoQZgNxUqJELpmMU4G6l2mEExU7pvE=", "BMXrx3E0TMBhJ2VxC/yxwuYJerw9NG8ElJX317fwbLE=", "GlF0DNpeRepNS9e/XOVGamahGvtbyTzxDVMJ4H1BDk4=", "LrbtVoN3tpatPLI3Bk7GjjkMJIhuHxItIdfPMpDcbQg=", "GBWJsUDJEJ5JL8PsfYyo48JafOWN8G8T70NWHVjFkm4=", "IFptWqstIktmjHD8tBWC7p6+H/CZKStLxQr4spLA6kI=", "KCOaiC3HsvP/e5qo3p49ga9zbU7m7ZkdXGtPpUAUj0M=", "GrFfL95vU1535hXIwmAhk9RYYMwBWEnfV4+f75pbsoM=", "AytiZvJAF/3hsoHQ/iBt/zC1OdXFuhO1MS5IjY1vGUs=", "BONY8lmjMkT0BYoFYRCiaBa77Dx2q2pfe+k8ngyS8+s=", "JamsLR74Sr2YkntSwk84eW6mDmOFjsW1AZbX4WnJO4Q=", "L1IfJLwCKGriv4SE+7w5hDiGdV9Sv+x9PdXfeNNAch0=", "HcP3pllTChOsytGBtuJlR0EI2LFGkmZVLfvDjLZ50G0=", "K6OYRTk/zHdv04PlNdVnYhx/ZABag6b39IIivJAgkqg=", "BHMP4E4BCMmlFFpcSOYMVFfkcIUiFXv+D4KvXGZNbqI=", "B1oJ5B503ooqx/7ydZHnanfIUeGlEYXzHpm14I8BzHQ="], ["C6H3ZDZzYJUpQsy27fBRyPk3kGqBZkHg0eni7SaQb6g=", "Kfqn2tyLfpWI1KYB53vYCq3ycqG/7DxEPKPMrIHZ4eE=", "EyRVi4pdS6YbF3kBKL6fJEDACF3V1gZbiPCjslN72t0=", "GPqvHJHgAvfbvRL0CL1cW5LzjgLONjWCSCHgNH+vU+w=", "DuEoiymFXi443SYpKzniYFKYQTRFONZJmZajLnzFI/M=", "I4CrBR0KxYCn0Rb0qTN+sxCQpMfsvU5jjncXt6Ur8QY=", "FYkmuelLEPyzIbKTu4qGR2J6W9MTFYCNOXwclPZQ8s0=", "Jk+tzHkaoY52dRqJUkLDDNu9EZepCkVtwnjhC/C/9eU=", "LqAUth7VdTkiOb2UEcCmxCArczTPLg3YwwQFKOSj39o=", "LaJgOibU/ew1MYIEulBgZj4VoLHk2TlSWNXm7srqj7E=", "IKDj9OEknExq8QDf32P4vcaex4hbzQ0sLpjZj5u50QQ=", "AvHT7tNgGPlnlxHgML265RIkte+4sesc3KiriGIS8Ps=", "DjiLsQUkJAbjcggOmXoxOSz0/72caUFj/DZurncOQ10=", "JRQ2ScE+CNSwC/NNKqGo5FD4l4jid2aJYhcEcVXFvx4=", "EuwkI5uhsPyflSVQoiOlLSCdjSK4shrCSIGicZJ2vg4=", "B5wElE1QtHd90L6+lTYAZFzsqdZfugIPlzZRRr75xs4="], ["LgYR+kyjmF17+vUS8hpAgRQfTtDcSwIoNNPLbP2Lf/w=", "Ks80kwErvYGHJOfO2iQx6XyJM7+utddGO1Eubo6Pf8w=", "E0cwJLpBn8KndD59+PyDdaqxUNN1OlQlCoCNZvLQa5E=", "KUN68bFPY3ofDjmVXyYEvyBDn8sqCQ40aqZanr5peI4=", "IG5NRFMVt2QoDMZDuUefSZRuqG1zBLaixpKsNNfJjTQ=", "E4LDwkvySJ/p79gKFj5lARH12YheWKntcp3KH5p05Z8=", "F80Rhk/Sxz0IZ9NyZLTKFN+TWoLypvQyxJmBNfpfSqA=", "LeJ5/Pd6JwgjqRps0ar7WOnjqzL9/ws7BcmNVU22+tM=", "Es7VJU4mCp23q+DL6iY5ZoD25X3AdzKnVdQJ73USALk=", "DvX57muhrh0SZM8aNuD+S4BDqwvd+bnDIA+2h6jqXIM=", "BrfhjQG0f/jk7wgHjoEooGaTvmV0iUkqxBlahUcivf0=", "I6p8zDdRt0DuyfNaKZhryVik28fEsS6rK+g3Zwbesg4=", "InPDcOtYEMA5A2BdfMlNWpKvaqqnuETzUYnndAan6Gs=", "KnMQ51+v6QLiAoepGr44iq6EILHqRmDdfBWcJrljLNE=", "IAmDmXJe4V2T/9PkgeSnuVyMUIP51pv/FxTup8fYLUk=", "AsorrHwaoMZOaEEj8P/iIXOSMFK2oB88Kb6AE3/Ylyw="], ["Dm8jwO9vFZ3saDQah4MPuGS2wIy5VKFKJQCHZpeJf7c=", "I7NGEufQUvazEsoODPcANK0jLZv2PIiCEIU4O29uxKM=", "E/FbxkU99vk4NEZVBTTcV67bEBOeMFPoO6/dmTVhdfA=", "Dt+GvxsVmf4nxm80lIYtdd93ZAcKgmPPiHePcoeTjY4=", "FkFkjCa1otwpfaqm1N22ovJYunOPkJTnxc2m76jJk7E=", "KAxFIq0P/ZLDkelMcPhxILg0GJDDMprwUGJfK+UvOkE=", "HXcgmLYVSSHbjnUG5vA3LKRPIK8zhuE7z3H/XcDWGxs=", "BT7YrVUNiZL0uYFJIBg92Dm/NV6sqMx7BwIKImFKgIo=", "HU+bpP2M5O8ZO5+HD0SVYHlTjWO840T5AWrF7WOpml4=", "DVPWHIpSFODEcVJ0rWel1qLPufw8HnkdQd4iyLqEaKQ=", "Es+HJTkT1F0ofpdfK09bkJ0WqH2JyIkFf2Zva6YTibA=", "KwiM0woQiZurwyW7oyqjQ9Mp+ah4JGnE0l8PI3/2B/0=", "GZcv/d54mOyL5Pso5LGe+qQ8fuIMiOKQluvocuHBlHU=", "H6aURwP+ABKhbuYEJSn/AryAQxPvjG2LD5EKdeb0dzk=", "GCN69zO8REGKyE5iP0g6a+KLjyHQM/vwmdZFuiDx/CY=", "E9kDWg3HmLBNzvDwjt0kFST9yg6VupysBdIHvTF+Gc8="], ["AaeipKCNh+dfcgMCvq18ohyPfC7S3rrO2bixstpGHLw=", "EWgMxugLDkMKTNNgcBf6gzHYbE0DqW38GHZ8l8vgoZc=", "ExS1T4eGCWJEUyyfBUs3ljbitYv9zrPUjfsiELUptOU=", "EzayCOANjrrIMkapbr3eNRBj+j9jWIfnU6DOPinH7t0=", "GIe+h/ejUkEEgu873PfvF5duCH64mQx21+lxxEwEgjk=", "H0BalIMxHhSXVo8b3NbVjNa8gTmCoOcVYbYgADuIggQ=", "IJV2vnLbewyf4rgykSXn3/BImo6QCl8UwebkhgQTQmQ=", "ACeXArE10UTt6UMZUmnAC/Yg8Fi/AYbOn/88s4siJFo=", "AsnDE1z2S4nrW3FNey682B/H7a5jfMYRZZHfIItrJYM=", "JS54tIOK1QB/UYu5xqTOUBhx9xEo7uPwyXhM1ksYP78=", "KafVVOn/vuY5hnhC/Q59QeqbG8liG2VPyzmPcclbZo4=", "MFoMLCxNNZmOmROCn1YCUENj8hvXIDRzULYEGT55vD8=", "Bh144ZU9GUPi2WgzW3PhX+zviQdelslD05cCshTdxfo=", "Jh+XW6vXaSgiRzuOOflIuc+YcwqXhd45MXnUu5nazcg=", "Hj1s7zf5vawj0bOBpsWNDs8Gpuv1jfp6mVpEPtffaOk=", "HWZX15GDEWnFa26aIB+LeyQCRqLQ+FRDBIm5g0VAMtQ="], ["HYAF30jIVlmH27RCtILK5b/BDuSG7MW2cM6GE0WXnR0=", "H6dy695vNzJERiPWf+mREWKY+PMKLRAQyK5hMqPWkH8=", "BWqOzSMqZ0xj17YD74zQYyHFYN8v0/bCZJr1dkZ/15g=", "JkY0HrRLSADVYITLSFAPrEj8UziR9VfpZ4TMYATYkos=", "Ix8smL2o1Iu0ptnJi7vBYCcjWiKh7U+IvI06blgiCfI=", "HK/Ptikm+8BIV7C9fXOSuNit0WtcvvtUtNUxKCbomUI=", "C3qx7xf/YjX3c38EQWGQLwPVlM9KDMZ7T/tHEa3h6w8=", "F5qCt38sy5SzjrWCrEq7sW30KezCJHG+c8x3ZvltmUg=", "GLY2hfb+0qoZBIVjeEQhUd0foBx85hIdI+Hp7iC0JVg=", "Cieo0a9qBGCuFyTzLyGgawNmaNCoY75Q/MR/7FdjzpM=", "GGdWd1BY0JxjnNq7rNAb88J0QVIVb79+jz6Zn7YQ7Tg=", "CL2d3RkteXoZ3R2gSb6zn6ZZZZiicDHqHCsolm2WGAw=", "GUGEqCXenptj7Xp70HElPvWQPh51pQU225PCYxGnIBc=", "Lgiyi9zEF9lkOzAICFon9KmHZ5LTkVyLnaNWem3WzoI=", "KOVbC+1ZGRIW1dvh3QWyLACbB53od/1UqvVAHSyGfgI=", "HInY+XXwMEKCrY971BwSw7GKxrgOQGX8zaQju7P/p4Y="], ["KBIiVII/iSast+mPVX55YoLl4ScWGIWOdtSdCIbaFvM=", "LmPxdAMy9X6DF/JZLr2NsIEnFNZgQTLVJeM+GbPJhJQ=", "AJi3QJdsKhAx51Ey4FC/ODi3OdBhWCVDwcf5XBUu4mI=", "BvU8ef7Z4JhI4RKgdC2K6EoEvZulqidlseXt+xYCFA8=", "H86okobcHbYf4REWBq85bpjLU9q1GZdQql5dEVYfsUU=", "ChLhYmIOcb7rIDvlZZRBawg+fpTuwj4PRKX/6eFZUIs=", "Gxu/Tp9wYFFxag4omQyvF1cwhqXYGMA4g2aWgIsS2OU=", "CJ7+0A6dmT9fwdWvLytdR6m3Dm1aYD+6qo9lECEj79c=", "KyAuHSYmxnk9aKrPnDqP/7J831oLg/+PNQT5qyakPRU=", "AwSKJl0O60DlpTFjOsIruCX3XO6QNuZqBhvj1NJIyGI=", "JTLddIf8rg3Dp6xQuA7DMMb7bUz4hfETWYi/bfwBCm8=", "Es7o49HKwcqEUXqz3vSHxGCuwFg0j/IgyAG3iXmvnmE=", "IcDRh03sr5BhMYPqgnuRwbKVGDn3HzKcucmwdT/67+4=", "AX6e0ZHFZB12iw5V7A1KhfblQZ0y9WaNOX1bbLgFOH8=", "DGyewxyeO+B0SRn8VVx3wMElknvRbeKAdxKzXKJt0EU=", "IIKe89+cGD+JZeScjzFcKZWmRGp2BTVD63UBRfGndAA="], ["JBTUrvx7SFffaBMo5opYLSOy3P/Veajmru1sYQUOBc0=", "EgLjSdHXuAWEbpCDTvyRHraxDCoJ6uqintKIvXebFPE=", "AkuW2+v6ttI/oywsjndYyyQLrNgUMyPFPNtI3Itl+OQ=", "KjyfVa+s7nNaG1FVJkJjhK0EQpH3aRl02cBcY0tDlH4=", "D3v8+rF9s0wUTO5EY2verfq0Smv0/I7zhOyJpK6e0gk=", "FyA8TS4aQooXviwn0cTFlg38aqNvIr3ei+VqDNROcas=", "IqjudDZ0E+zPeqA/3UIMa7YlWm3YIIHWsU7ampdSMps=", "IeJfCn+O3DjeJbpgWobMCOCMywPnfF4Lntq+dHaLYMA=", "BqeN/eFFjuNBoInBX5U6IZNSff+0P1Us2tWV2nxv7MY=", "A/2U5Ru9poQ9MaKCUw1UJAqklhZdZE1ddzex5afWDVI=", "Au/lKdsd48Adb+f7inHx6qtq8WQfsfeq1PK4jNE8n+U=", "DKtQSyKjVz0JUJ+F0/vZTpRBesslOSNCus1oQAbDcYU=", "HLM60rp90MIGNENDKoR7zM53Wo2vho4MR0kFpPo21w4=", "Cq830fU90FVuNH7HBZYjeQd81UMZjhwnWT9EVFISYfc=", "KmB/rNOTb90OhOm8PktLrIboECwrWtFcrlUNKLNlTnM=", "FKK9Wlb4cAnbmBVGUzIC86+BLS701rA38oMIU7n5A5w="], ["L3EMctbaGcfYfL/9VWZbRysCZdE+IyapozuW6V03RrY=", "Fo/cMtSqjckDStSk+v7onw7VyYDT20JNOPjOXNBMI3w=", "FbvVYZ8NWXkIBPK5s34Gn8kJonltH3fQxiYJ3totAng=", "HhbpyiUC1pYCO840JyRK1lU86Gu8TDSaNLphBnxrbWo=", "Ad0KVQJ0OqqfWDvQrTXeE62NX8mPGWHyYSrUwo/Z+fo=", "DtLPrns29HCn0faUD5FOjs0yK/1rUPmtn2oiJuepXbQ=", "LHhfnYg09c9dCPEG1fmRg0D9QUq+JPCp/yuOBJK0TYM=", "DY28P8hUwGZcMMSIRte7DrGNPXik9w/vB/JC5FuGXqo=", "IvYuReUAhGlqwlEqJduZJSRM8CFLa1Q9Op+DuOjlj/o=", "Lya8E65IUgpDnJ9Uars1oSIqMH44+vw+f/yEP2x3160=", "Cvgl98oktKKF9UR2LZ3v3JnyuFwbifxf8gedPVDm1Oo=", "FgWQloQp9ID1VhHGRIkS/fQj03v0g8NqzMwayaKdKlM=", "K7Ms9g+NRp7bG2xWST1Mkzi0BRriUU1LYILvGLHVIoo=", "Kkpy6d/lvyX2/edQoYR+W0Qpi6WPtQS+V6WV5/zNxAQ=", "DFCaS/SK126QQQvqNKiRl0Fgi7u2tVA8k+cyA28HnRI=", "GZcz2kru2NbNFIRhYX6ORt4i03IEMfwWBWGbEqf9Tio="], ["LihUQdC+2Qu0HWSAg2hQ5NdtqCEbBKI228fDwwMgwA4=", "C5rp9e5q1wplG0tm409SGxMNGMSUZNhv5dSxggSJAo8=", "BHYAVL1dBxMlSL7XZX8XxhwDjrzf3UAlx7gC4IlI4Qg=", "AqTG0yWXecOW74Fzrl/oe9YR2+JdHASK2pYwbbHjpA0=", "GVnbAfXIuwz0g0kDc+dbBFG4e0PlkYG+C2AWZ08/Xvs=", "GEnNCRDXLqzDLYkbcfr1ALy5PhzvJQSvRDuU+LHOchI=", "BLXcIFe4gXCnGKEC4MqRd6/HV+4mdzoCkMa6sVnKT7k=", "F73zOAcohLUizjxQ70cRCRudr0ikM3S9wKgww35dzcg=", "LZN55psXggi4SWuKCgqQ1XiyHwkMUwQr5HZ+PBDTtA4=", "AUBX0C5evPM8Fm4Y/pBN76njQqGeiNQjNjd/HF5n7DA=", "F4GN0CVLKR0Nj08aRYxqIdiEEVNmGBK76YaxQDzycN8=", "HJXCkXNTxTtM2391Cg/obOEPjVvbAYAy0/eTeX18CjU=", "AklbPBv+xgdBgIFJMz/EPwTXnexWWCwpKCn/37PBo8Q=", "Kt7IVJ3/3nI4sr2m53MpkKkRcAyNNSiLqjnmcBWVMjE=", "F4B0MDuQ2JheN2WEuLjft/lS+PTPhNgV+Quqo7ZExMY=", "H1/AYAKLoH0R/JR39Pr/55qBBA6poExWgmdkSJXmc38="], ["KWSQGitC6a6hplk2Yq654SB3oodDS9pOwgEuNqGdyVw=", "BsIZSvcvrFjKE6Kl4yIxBO9JpUD9Lq6g1nqSDYVnBAo=", "ClSUybz6Bqpyw2/SLZj+ctwU3A5OdOA9F1XzisNAUK0=", "JlyiERgLASw3jgGY8LX3dYwVXjZ1+t+SynkVa9Vv4zk=", "IfZZ/tr2wmF/F9Y3zW9UoneC9OhDH4evXIWRkyzn2rc=", "HkY64/TDvQR6oQSfTwkaLx1dNVDj1YAfz/aPml5oKPQ=", "J0EhkforLlMnoR0pDktDmkEk9IFFxh/07OhEikNz6t8=", "Czp2nIs3FWImA5XuTzSPiLsFai8OwPmOTmM799lDYV8=", "GttMh0M9hm6P5a4m0BR345YoecIMjDoXDAcnFnwG0Lg=", "H8Ju0Cfbe55yQcLHYBdmYvY0ugWpynqFDhhK5YjL4hU=", "EBdftvgbFkNq8waC82+6s5bt23gppQ6UbHXyfiYJh8c=", "I9MANzu46/fbzzFKPAsf3s1criP357uRW822pngrV/s=", "DwQX+mI3Fn50FSUmEwbBdmTcPvqSR6oNS8//OOid7e4=", "Ho/SCoAw/dlOLENT2PgrSyEr+Ie8WWFYFIkLD5KkfZA=", "GFcoJjhd/G7spNPHHRELBKuuATxUUNnklHo9AZu0G28=", "IIt8jB/4Qi1KG9E6AqlGgc4hfZJfQNKHX3Pe8U3noiA="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon15.js
var require_poseidon15 = __commonJS({
  "../node_modules/poseidon-lite/poseidon15.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon15 = poseidon152;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__15());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon152(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/constants/16.js
var require__16 = __commonJS({
  "../node_modules/poseidon-lite/constants/16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["L7WDdis3WSxsWpXrHQZpS2xvncTxrUhi3Y9eZ8t6P1w=", "Eun0bNgjG7A9QCi/ehHXwOMx3AXAiObcPR0AHaWLhaU=", "EnXNcDJvUvgWp8U/5i4yPv5hpbjTdH9t7Fg3qCWHOvw=", "BufRZbV7ApnSPnUKdeouEsnHoWlUxApNEJBKYeh3NUE=", "L2fyOpPvHiFaSt0uy0G+9LnYXvkTUGXZkoAONPqYEIs=", "Fp65lS4qhiPvON5X4V4kLfOIAZSJ4Bt8hPqDnYZNzRo=", "D0zUBLQCTKE6UTujFW1N6cs6okDGg7Pg63JTvJjItfY=", "HEhr+uOrAy/1GejcptxB6gYLDvkIMSe9fCxOCJ/UWso=", "EC50WGQlHOlAxnseL0vE0n/ThRVxzmgTuqxmXozAx50=", "HmptYgQz0iKTBE/+NqXypynBKczj7rC9r9zQ1SvDurU=", "CPOr+XrY0Bz9hlH/LVduPWjsxHqtgrQYjZITi65gO20=", "KD2j8c+Ed9mCHuYDeLHDnHJChRGhudZoPAMCk4wkjOY=", "LZnNjYjknguryEy9WK28FDp1omuhb5ZGai5BYpc0Q30=", "Fx7danRWpMJf74qm2LdI6thpNp9ypOUChh/QN92o93k=", "L6tkaUNp46K9VzwMw4NpXAKjgeeFeSo/q9bhyo3y06E=", "DGFVlE9k92lPyOzSormiNwVow8iY25Ux3BjHJHT5r+c=", "HuDlz64DBiIkkhDNzacUN/KPCxcwZTwJFe+/wIYHw8c=", "J0Hhp7xrossWKFjE6EVNug0OEtzZVtEnvtBxc5ul74Y=", "MBGUpmMwmrjYCkNIIqb2VSWF6IjUmFgYRfVL5jTryTo=", "GIrSU0fsJeaoobWZGz6W34H1XL4sUrpIdBwE79Rx8pY=", "LRoKAyVUxQsiaZSW3sSHsBQB8lKC9YfhtXX8mMn71kg=", "LEf+ZTO9NKdgCE6NTEiMTKKzvRHCJJMXmsgamfikSp0=", "L9tBTrgGm1Vz21wR7eBFpgCfJnqNkI29fZDWoPAo8o4=", "AJzr+ettBvsnj+c21roJ+T4N8qBA392l/n2a0PuUv2I=", "AdVaOACmTugnA6sVkdGK2wAlnRaCduGw+tRxjL/gWWY=", "Ci9rBZJV7e1truR0PAj6hNw8UbrjF5BABWs6jfOJgq0=", "F89JwFaDhOk3+BtBxixHbburh7vW9NkiiwRCkpnMgbU=", "Kyj2Cz7hKEAdrdPZTclvABuUMvcOobOzIZ2A02mSGqI=", "JfDP0zJX3izDJBXmXr/sQkbZChgegUX5OH3vPExeDYw=", "EXw8K3AuzA0SzfJk/Cb7i07GCrN1LSDx0tfEQM1GEnM=", "CshgPugZJ0p7rGE7bSZCC8ppodFHBy3pCqOdSvgDds4=", "EsOx3DfWZRI/p0ouaO4ymkL3XbQtKxwFWnHBbwTURVs=", "EHsPVQb9wud0Zo5BkrlZQQpKjgyegtBcXLuovpPXPzc=", "G9ufXiz3rvabJvC+yLvVALo6Vq3cslUFyHfGYqgQiZs=", "AIIkp0ao9yy6YZWCvXIEuOIdPO1zcLt/x37lEkHBz3I=", "DS+1yHl6KKFb0nZl3FEP96+66Vq9MteIbSI9GuhuwvU=", "ITl7RcAk9szuu7nRsOQ2RPbKdtLenrBQXIYvBdczBYY=", "DiBzBebTAotcRZ32CQOW/j7tuuDPiIThX6W0/Zxe600=", "HNpkbJTDJPhNzMAvd6cW2qhudnfFcEfKoAJnJMEnid4=", "AzktHBKe7PiA373X0wtKjTXFc21x5uGHn64jYiEaeu8=", "KkZ3VYXMnlvOpIIWTmaIGOxU/XbZ0sfZM74JD3poeLc=", "B1bXkce2cN+9GOu6/sVvwUg2Xx35lRi2NKSRoiA8njo=", "FoLSgf3d9vNLQqS60LJg1ZfoI4h4wdegIYCmmdtPqn8=", "C6Bp3sABImKcLuu+b5hCBApA2KEjJ7wITvNP0ULLoss=", "JdGQo8HiNNF07BTajbkDqN8KdukSF/kZPciR8ZZdGrM=", "IgYnDNf2yw9GklYK4t4O/x+tn4YQAFOj6lLbMvbekt4=", "ExNbQXGtdS85BvegInQG2MUNyuWHtaZxxj6uwLQu/Yk=", "D/mjNDKH/120lfZC0ypx8ZPOJWUO6aPws81wzN8R9M8=", "LF+/hrLfdcnxTuILMU/ks9f9NRlZOtjHOs5pz/ZAapQ=", "GtbfqrLL2zUK8PK7qDwhQ4oHjwnW9Qp2UJZGkHUwfIE=", "Jt7zq1T/4E0hbXK98+NDRcIfKccV28lkpw0VZSJKYv0=", "GtgCs3yWxq02CjFssIg6FcPW6VHz+Bsp8tpRepMpfDA=", "FpYxd7U7UWK/L5gpUUyhrGAZa0KKd3CoC+ASpC65hOM=", "AyBlKbcj2ASrWCxEY+HTnsV59kFeDDwQDE3fy4ehtus=", "G3CA5bNrimeCMHiC7da6nENxSjGVRDYHJfEMvkA21Wo=", "H1Ad9mfOQPICMnKzLsEjhU/eyoz6jSH6X4+R9LPG4VE=", "Kdz9IEisC16y2yAxamy4BUkM+qp/fFLP4yXQ7j88gTI=", "K1wKTzrElHHe/0dmLPQMIFPhq5vYyQJZ/TmViBnxzCY=", "K9FS56cEWrZKlC1q+QLMKZXOyj1fpSmPEL3kZ9IOs4M=", "GSQYD8YIww1xymvBlva2tlkV2Cq7aqpm30FUCI2+8rY=", "COeoSj7J/qLFaWkENuG4n46Xh0J8wur4lfhr7zemprw=", "G7k2zYqS46yx1Ahhrnq117Cw5NFUjhNuJ1HiYWMs1dY=", "L2/bBKbdug2gPvcKNsiRLOQHuB6WP0xOxKBeHBr9u6o=", "Az3TdRfE4GVXozS8TCcqvBmIU+OBWZpfCw8kjV6U15o=", "JXvZNqpW1xsNZLqYAG04uoX9B+LFVkQ8EQHeuTDWJ1Q=", "HBiZckZp7+Gx2bF9Vib6fqUtYri8k6Uvpp60paDWaas=", "E25AB712nQWQltzhuNFujV69kmLWRjg7gMzsw/Zwji0=", "HN77BWYYtShiZffRzYXNrZRdycbSA7l3VnAKaKfjBeg=", "E772QK871o7duZ5lMuBfp4cXGrIQYfLVEoJQVViw93g=", "IixDtExYH6+SRDD+WxZ04V5fYrF06TYpno+kGu4ADBc=", "DLdIkUnXh4S1Xe7xaFPj+vEpjnjaXD0Znk9iVu7DvJQ=", "GYjPiwmCt+uzxd8b5KoJfKWTEYFqwcUt+H9gR3nl2Bo=", "KoYkPVU34OG7lGuoevwEFBpPRoO3OopkL0MBE7WDTXk=", "CBDkdnwPg7CO7kXHQ6KPaqD2xHgXnckjpzDACnd8CA4=", "ERBRtvbmRbER7hb41yd8VzZUQle5k99Rmh7CxWvNz9A=", "E45jcYahrqEM0ZKfR4vnXq47qQiDdaXxAy65A4n70W4=", "HEjofDpfZYXH/rkAn5WRJ1E5ZYafZzErXcSuEJHZexM=", "G8keOSNznYVXpJ33PWsY6s0/HYQ9L5oZ1aVE0s9hux0=", "H1XLhtROiXW8FIPlb9uNp8SuU+HsMbhLstoCcAXUUn0=", "J99CgNwP6eQLPGn4HuNbnRDDp37hqlaMuZ3jwlozxEU=", "L1yfhyYGTZ7yrnC5yLm9jGe9C04B4z2hTusIyehJALE=", "GAOfya3Wnhw4+qMgu2ob8P3vRP6wk1iC3wGZIMh6+C0=", "AyeQN4jDJF2mqwCx3QVO8KiQnHRjgdNr4yxjVA9q7dg=", "H56dGukMGPGLMzhuGQKDzXlbAKXnANm0UL8wWXv94yI=", "EzXyolHZfB9P6Yyd8vXgtJqZFbY65qyGBxWkUM4EXGk=", "IW/ePEfUTbEsqbOJC3RlUeFN5h1h6tqoKHK4sC0IwP0=", "IK6l6id9XBeZvwVlA9FunBgGfM5SNlVSBQCkUJVY1t0=", "LJhz/uTzanZORjPK5Y1ZdXkOiHjQL2aH/Vrs8P6kXHI=", "DFnQapgngRiqMUwKLh/xOHgqEBZZJkMUH8EerEWO+gY=", "IO0ooOXdbTUo9t20cp+tQhrQeIAvKDUiizjASs21yz0=", "JCqEygEoZH27PvPaJcs4fUIvVxFx21CEXVjqa+q5Dd4=", "KawUoLErWB2LdrceIZet/1aHkJDYTlw5lS+R8r+MOXs=", "A33N2yUw7VzambOJDJ5+oLCRoA9QaHvaC2Iz2gu5tCI=", "JaiYf7b0wYqgHS5UKWl9Ye7EgwowGmDDVithrjKQypI=", "HJv3HxE7Yce/cZ2Zu1rr8Mq+hxKzBPHh7y0XoJjHms8=", "BKDJ9Zr0M/Ry8d6SzDnWBNTOg2npHE35/rbXZwbRDiE=", "DTAONScK3J5F9DFfPD2dk5rp5t3RBe1PftOAXSn7DXw=", "A7PV/pjNPUHWVgONhPP2PVA2zoOasQyshtkxvG9Jxx8=", "DU/x6OX0ccDLYMS2TiXUYFimS6MNn9Umtt9SjzalxYU=", "DmmDM3WYX2yZ8yz5BH7XIxmnjRzEUldLFgrlAfkQa3A=", "IYotoacb8tlJVDXBOCboG8T7xS9+nnaAHXbvptFQbV4=", "Igt8XH3yWdKO9ch4GNN7Gu3TMcXtZOK+NpY7qm8OLt4=", "Beb/O7LDw9Nv7jCXQ4HH6eQlfPyxdSJpdfgMeCZgHX0=", "BuohMEdQOEgtQ7QNcB8uVxn4tSkeMucOfstnyElSwV0=", "Do6j4yo5zS8FJBYJE0JO8BqZtJDs+36shE6b+Fi5sBQ=", "KU5cuG5N667g1Q250hgo1U0plqbSycGEFyxuWPq2bxY=", "G3am3GGPcCOy6SAYFrVuBGAKH2AHcEdXog3npFMTfuY=", "FYuH4ftO4DoM82TXc3/qW1BcjyZdheU82LbtIbj34Mw=", "DWhF+P+oOukFyQuTm8Ahe5ahFOrhkRQreznMz2oF+Rg=", "AecLh6pe7DH8/KVvAd5vDhar1o6UAWpoYvH9hKx1Prk=", "Fa/QjZzY8Rn2uEwbzxvYMhv8Jp98pLoxL3jBjO4GMyo=", "DooYr1CIjA5nihjbA16V8+UU0SrdJbMSn8sKEXW/INY=", "BaQjt2oGb/2Gv6ziSmnuoBnXQqwlZzz7zi1sjY+pWfk=", "HNZjP8eBdp3km7BgIi9w52TApZnPpj3KVGzHcKjJbgE=", "C97GiPtlGkGoRUurcrzre0uaTmThWndZr5bDkQ8a8e0=", "Fv4vZ8uB30ChOu4Gy8o5GqnzY8i2ETlw2ld/AOy2hjI=", "DZ4wMWza307nhhu/BY+YZLpBlJqX2A9XL08yHFyBwmY=", "K3JQ3itnAUPSeVdnvmK0AbM8qHMX1Rd0My79wNVh4uw=", "IRkRB82Xzm2C2PJFgNPzEjhP+PfDcqam+EvqRhlDISY=", "LT0U0BmQO767OESVH0kq5kA07/MR9vrS5+4iTfEiq/g=", "CxdhU3q/5SMT0phHlODwy1pn+rbH3mBkqbI6nBaC5I8=", "JkjAIeoiNA2cFb87TeEBnKW7KxVPUorL7IebowYMXnE=", "IQODuSlaz7Cv4KJ3mQT/aFEJecuDCM1L4bp01Q+OvS4=", "I2a+ufsK77KyeRmpNqkOUXi2ySCnza6ywk2v347sT2I=", "CsC6u/6wWsoLr8hqE3NFAIpHhYKK7K5udXJuUrGUc/U=", "FPTj+Sn6MJ/3a3cCL5g1WIHTpGGYJvj0bz8zB7ftfL8=", "JsF6cFwfsW/JO0mRKjsCYjmqNxRxFlSK8ixQsXxj0vM=", "HAQbVgUnV6qLJRyc+TrITxY7UClEa2udX3NzjHFWnBs=", "HbhHr1X03uSwSwfYx1be0EsQw4Qjq9qIz5VWhuGbTZg=", "FKn2tSdspkxx64VCEyTqItqeWUGMPz0Wii4lYUqrslA=", "Gell2AFPqiFSCoefpwYvjNg+g9I9NOuW9hVctpj8xa4=", "JymDtHuYfJSqcEoByIaYwof2bNajWwxTsK4kglcyhJE=", "F5CCRF9+kAUPJ1FhOhi+fGFUQ6WqvZ7jDdWuGu0UHQ8=", "KkXZkXZdaBDnxt6Vt1EHf/Os0ani7YQdTjUWQbUxr3c=", "DOgGAK53e3V33LDDjjAX3bvLzoa+2qePPugP6PjtnEY=", "GDbv0ynt6ZntoCmsdpM+UdN5wuyfgRBgkdTdgRhLSpA=", "I8L59cMrn8nYoPBqH7lDQvjg9yhxUyrmIuac0mmDy9Y=", "Ippg3p6nuaMa8FN6FfwMyPThh0sFsCmheqYGm63HBwk=", "J8HKzYR2NQS7namV+5wR3+HeT5tN4AcMYkWNwG5vcYw=", "Imkl47KOnTWDMGERQSx/sxJaYinVZJnUrUzidfuUWm0=", "LUw+9rhkn9UhwxfUQPDeIXDH3AzirP5VR8liZSNyKaA=", "LhYzUtPGwgSk85xjR+0qFUbaHBYsF7N/5RItvgyjjYE=", "HVCUSrUmFOz3lKmeydk2Ssl6yxc/AaV5PVX5rb6kw6A=", "K0vXC18fQ09w8flS0CsDFyP3aa4YIHeBs376fYYLajM=", "AdqEGUvq5ZnqvN0NnKKc7gXI1wEYryLXlJZmS6Y9lT0=", "CxRpwUhq2DemSkiJwkrNYMeXX1mnAYG+vemVD8BLlNo=", "GR4tz026QQrFD36apJelx4O/+9zC24Rxy89wtW5QEEA=", "AWaGB/34ZNVPS8YqemS8yE58mSilv4IV/fvyKHdnMxc=", "L5lnIo1wVCbVASx2ThdU4fQ+HLnb3imo2kuoYq5GSRY=", "AXTBUUjNZMapx+Jb9+ksDu2Tup2dINydmRJ7mDf4Qq4=", "D+rgvM2QYfAVeKegAzlN8CDQmLG11NmU6cewHVwqbj4=", "Ds0UaPulsxQta2o2mL0n6ylh8iMtpWFIkerm+y9QH4M=", "I7i7K2bM5xsIBVhsnQH4LB96zWYIuhQ3cFKrUii50qg=", "KWwpQsBBc1qAaH55sDFZ6gvMnIKIv2HpMrFtmndBhwM=", "Df5/nJQXyJKhqkJeNuq9GoMHvxQXjMG/8w3icIBKxrQ=", "D5yAwe2dv6UmTsDKfykHtFWCqhqtyPIkTrgm82MCB14=", "E8dqng72oq/hJFPVLFreB5yUXeZwCt6ZnSZU8A4OHbA=", "CNFJNsUcnVv6iTTqaXUlYOf3LTPG22gsbuqo03r+crM=", "K7/SnnEDK9bfNibK541dfZULglGqmtOHuv8M7MVa54o=", "IK3Z2uKMC2xWrPjdj7+Lgq7oueRkcEJDB3GFRoxseiU=", "H+yWuqhth0FG/stJUwi5J8vGPvCs8kgSUs/ul313oFE=", "EH+ULNH32wKoT/QQkTsHyhQGfAjjzuaIPIKfg4PbVq8=", "IERqVIgCRjLByloD8+DZkn23kRtI0K2jRc9ELVdPcI0=", "FsRcbuLgm9hgIEoSVQz+3xwVz1rnkhD/VsOgZ76YIjI=", "CVr6yenA5786N1ev4aWbHNLIqd0KQBanaN5OOUxa/0o=", "F4m41QxPRwogQKjJdUBTDrSkuhiOBYxc+Y7v8phjY8s=", "GuSgk/H/BW1D6x8XbvrFnmTbsLMKF7+c6+c5ztAtfuo=", "IHhmSFKSOvjuBaw5O7G3F3Gu4jesS8E/7vXt24JLUhI=", "BFwmO/0sgM9WP9HdCTkZ5hcCxBgGZ87UcQnyIpPW9jU=", "Bb1orf6SKepfkbm5t8ZIkwJ4/5zUI1p03aopibjtG2g=", "K6YUe/YfrG/p+J9dA0JLvT3SWr0bqAmUmM3eh6g1CKY=", "BsKcGpZDFuX/RoIB7NpcXqso5csMvsH4P79V+RHb9uY=", "CzpC4QxbMqTbSuV0KRe9KitkhNWNBpmI1A9LLF2SNRE=", "HvBcRB5cRJ3N4rAQTMDPCTOMh/we8knkchm+AfiQDUw=", "E0a5dNNVkj+IErG4HNac6sArou1CB+B4sbzdZbmcHEs=", "BkG+hD3FurraKJOgAIVgOLDEgMc7sSIiQvXBgrA2ZWY=", "Dgq5dU+lVBhXYznHSlGNoj2kUS70TZGPPOetwDh3wOg=", "BSTtqajPdMiu1A8n6AShGPR52jYzECnY41+jBnqKLmA=", "LZzCaWi5VtKC2IKtJgYmkq1XVBriB86Qo260CP/MHC4=", "IIvoFELw7qIAFNfFDP4/hJfD7vWdI6x1Z22G5t9nIXc=", "ChA8eRgp5fkekUOqrzc8Ewvov8NXnzYIsu7yPdonJ3U=", "JMJQ6163stAMKQ9UjyWLQgbaBQ/P7EOTIGmBRqaHtNE=", "BK9hHcdWIovIfHkeq8lBK03FOeSCsRNg3eLosVxc6yY=", "Lt2kwMjNtqwfdmrzDylsMLrSmn+jRcSSxf1GHIOnStQ=", "JKV8yXrHE9Ei0goPRa8yoZLVfuLfAQoqv5MtP+3FMaA=", "K3hpJW74RJ7xYyaGwuTuv2x9wBkl4XG2owU8AMf9k4w=", "H8LK3B1CWY+or5oIffl9EVZPlhJEhvnTYnSlKQdxY38=", "FyGDB0DqtdPoJMpQHZ27J5wzzKRtlXz03/2GxGQ4Uvc=", "Blusw4Renh2xZmZ5upGYllqWBPnQ4XpQnTQ1Rhvdqss=", "FLRpAly+OuaVSABKdauMynPmaPP9vlsEEhSdohK4YpU=", "FpFVYZXK7m258+kqdAuOPfl7pluUAdZAcXIPw/W5PRE=", "IEN2DAhG7xqDB7iJZAw0lbzRe4VfrSOGbNyUCp6b8gI=", "JUw5qTN9rgd+NO/8sr9hSdqx/0xHB39WWhFkzBYGXfI=", "Fv/4G4Tctu6BlfyaK0MYPvLJPrpp7QH9ZiFa/UEYvHs=", "HdP99JPld5HicM8eRZMqA4ca50nYsHGyEMETx0bO0+g=", "GfNMMNKeKy5x0Oe1iXW1LliVEApkLlJQn3NJlHBmTm4=", "DlM3irUk/eNbr79bBz9gM303zHuwJOTXcLR4yrce/e0=", "AmV6Qvt/5w9p+900z3fizB2b5dq1w99URoQC6YI7cww=", "JweX4YETGuRU++A1t0yBhXTbSwsUYXFFYUv80X2Gb10=", "H+hQxu6r6MwyQQX4eA14ArNSY2OcwJ18J+LD0zn+xTA=", "ETsP2E+Jaxcm7X4yTwN9Sbz8YRBzQbpQ5s5Ge9T7A5M=", "BFUwHJw6lXaGTlNJuduqJLtacxlJKeICL5+UYtxg/Fg=", "Hniv6ec/T6w8BgPxqZRPrJU+hkmmOrnKOG4U92zJgD0=", "Ki34BizU5AGev60yavdfB1rZkQESyeVtz1wUAq8utac=", "IxmdLj0hPFk+oFDFta2fafGwywo7x4WSdQlIHZNlp5s=", "ERLz9SBsrW6gb4Hn6T9tomBdEhEffYLa2rchqGKCBFQ=", "KnhQl1ND3S2XNqQfrZYXOr347JVaXb8P71mKNCewbNc=", "Do8My1VHOG+zd/jrA84xov2ZY3yCiKzIJLs8fhGXYkc=", "Lf+gy3mCohX6o65Yfz0Kj9s4vWf+SX1uxqmvOFp95f0=", "A4EE2HWGHBb4aWYw//D1ZKtjZ+67VK7ABESr98oBCX0=", "LhwUYFBST80FnlVElsc2XcokmDH4884ZFUo6TyXAoV4=", "HxsAcROyVxY6Izj33NMQGYmLyd6M1DPG9NKg1htKiVs=", "AkXUFMAhPSs0GRg47OUkg7m4I61fxgsNG1+qGdxJlCg=", "J7ibKusgSYz8TqELcFe4U80GDZ9Dq9oLYuwKy1DvsLQ=", "HHfMxlF4netarI08Yzrg1hAh+ST9Feo/ZLIZBpLwuEo=", "E0SrlgMQg2SnHNCPKROPF7gTouUHxaNxJlCUw/8JFzM=", "CW9H2kCb4rh9cqW03/52jkZLnzQxSFYcyPf2WZZHMzg=", "KpY6LX2/G2ZIMkylyiAQBXB8aPGQM4YCEG/3ocgYAHQ=", "CiSh+/jp6l4O2bL29FGQuvmOsTDyPjpZuYgAR0zObX0=", "Hvw5MmWT2zVx0fgfbiOe+7tiWEjiBAQ6Pq42G3hNqMs=", "AoePGZQ3+AzrYRWkzGmtQwbLkMr30zpX7ix3L8sOfEM=", "FOcUEWrwLqxoyi8tf9xWAtFLDjFWv2id2K8CIl9n1qU=", "HMT4laSURCpMa9C5vkTqjVwWTqCuvc4Ra/biLqnJ3/c=", "H3LZ9XzOaaepU6nR6taOD+5ihHjVmzf8zx5xByn58rU=", "FQQSJFLtH9ACHCdLL5DoYNYhxTA5fUmZYlcyhBwkF1w=", "D4TCGF3yV0JsxxYL4AFm+r8nk/F7Tc+VVTeELMOevsY=", "JiEYdc/rHwhAKQa24QCD6r80GIwPHJ5u5mZvx0mRYbM=", "H9r5pbfctIfrQ06uOjobYyBFxPNnJ6FgDaXGfXFivsY=", "GoLHxA4LM7w76Pg2xLWMEWe53TuJpkpA8lD7peeZJgM=", "Jqgw1Vkydf0Jg4ozfc66nXO2sLzeV5TzeVosfZoAW+s=", "HKG1EDG1TWwgnGAJXrpGPPJ6/B2H22C4UnM2WGv1rDc=", "Au0LLA/ATpndNz8Ro/zlKAApFyKk9g9p3kSwvjabQwE=", "E4v5Jsn32Z87NWeG7KBtA2lsNKKz5wRcz001A2uo9eM=", "FMkATTqkeTLsxDtk9IASKW7sYXWZiyfUrp5nrDfiUt0=", "Lo/OHavgzfP8Xuv62Pp63G+K/al+QpFy2bdT3eS5j9U=", "CG2Gw8cx/kVya6/FF2tYQ/0E3WT1gIBnfbGsmf0nnDQ=", "B8UiqpWCMTwQejYpQD9Uafd36GuD6nLVBghxh6jnK9M=", "D4rhHY9vQm+vhRbjUAE7539IklElgO0052DaHCmLaOk=", "C6WqDms9x8Z4BP24S8G7zB+ETpBGpmJKkQFzzaQVS80=", "EloFfBCeRshtSgedOqQ5aviz4BNlVWobVPOdjt5m/SE=", "KMpsEBAnCtxJYaqDNc6DaWskvttLtHPfwV6C0wW5XXU=", "HWNpN4YdqhIhXwMd0x713bXSmP6KaH8VQcET3GpvmC4=", "LnVTNeQCLXusCE3M4UmFIPgK6T2pfS9lcVAn3I8G8N0=", "Bx8nE7GnkzoKIPUHuRIFZK9+OZvss8Nk3E1P8A6CyEs=", "L/1dqCgOMpmeGaFxfhDImvzgxvgfXTKJ49X85izg8yg=", "HdFP5jZelBUX3bj7MI46k/VAA6tL9fKsx6e8KLUTPXc=", "JxARKfx/zmIoDKLFiOwVfZblruXCsNvyBJ7SSywTBdc=", "IZGf4lN4Tw2zltT55MdzUjhrm3JIkEN1S6iisfSsEmo=", "BwJ5WKj1MYd9HOus+CjdiwF6ElydKHWVNzpaOeWM+NQ=", "D0wSt2gUrcHN2zr00c5pAJNO0hQgPP9Nqjwyf57OVFY=", "CNmIaD6vSRWKfJrocUYGj24c91RVqdgiMWRfcpDRCzY=", "AnLnRCbQdNllj9lSa4YWkH1Wc6707jNnhQf4K87vWGg=", "GkcJ3640z13fcAbXwpC7WMdCl8jEgY/fXzlQtUySRSU=", "IgAri0F1dQR6DtXTWRQ67aGeiBDFNJnqS1fehtRBraw=", "JFdIaOyKSnAuoM+lW94uo7+yKCH22IpmGDUnscf48Ok=", "ENlm3n5oCIdBLu/YfYEdxGsCQIhtaFSTQzjSESGBl5g=", "LufH4+ipeQh97e0C5yVewGexxGR8xxS5bhooJY1waWY=", "BwKfBnlF7R9pRolNZuKo8XUTt8rr1Aya3K857O7+uoY=", "I4+W3OIsEMmsqaGYLubuqHt86/rlo4d4K0mmL+paq/w=", "C0aGbFJIL9SSuqM5XgoskEcLQC5Tiz2NDFByLlYh3R0=", "DXZt8qEQ7+JaPZwAcJz1MJpxw+2nmUGfw8uw9pzOKuY=", "BwFDt0DFTHEI9fYYPOhDcfdwdQ3aBLp2Xvg72j+y1e4=", "FwC1efFeUMKtGM933d1UnaAApsg5Del+ftDY5o3XfVw=", "CWakx2cB0JZ2oIbpXZC+z6B7uANGQiRM9q7wClQNI0g=", "Db7+i+8K8lWY9UEvhOAKPdTofeZTB1ugxdp+14OXC/Q=", "Fm2GN0w512YAlshyeOJwJMqDkZfmXNLzQeeliMU4f6A=", "JRWDve0VTrI5YlF1RYhxLQ4beMKc/US0Xymp/VLOrsQ=", "EE+i82HPaWCCxfztR+eKdfOTYxQuh3s9gsVcaG5SYno=", "LpN7+Ekwl2WjUO2HkalthZogNyKbtqZSvGre0mTHxbk=", "Kx2f9/twiDUIxWAh9X4/nqHbrGynQRaxfukmwewxkKs=", "BfY4TBm+migG6JLIEJF8ECJBiL9D8EGk6WM/Nw+rzZ4=", "Ls0yEeBe8npQ6M68Qv8LGDz+Id+rI46p73Yimz8QkwM=", "E0zEJKJt8n0G3+zc4mQaAb0QLn/xoHmi9+AstcBND74=", "Bkkb9t8DhQmZJrMiGX8DZrJ1fX3WLuPCoE+bTJU0BRw=", "GV/CWg8OUYk2r3Ouvf2W2bOKQ1NQSw/4wUGJhlUpIMw=", "IdkFLM4oz25OlAc/hjzo7fEvAuwyhiN/nSI7YjlmYoY=", "C6qPcwyjHwP+7PrDSpbDrHrxSAeRB70dFyQZF5FzIb8=", "JVgTiSEPbfx3TTcW4ZeEmE2Tg39G5RncdT026yrH7Ts=", "JOAOL8sZ9kJNcjoC3uUDlrd5okbaU6GiQPG9iJqJcKY=", "CD1IVLMO4GedLbQQsgfg46Z1eIYxxaNWzIdzKWATTHo=", "AK9UQW1zQzyi7S8WE1knJ3C24wCTgdcSmPgiPerPrxE=", "DYYRLgtcqTj6ftvsqewW6enrRYnHdwb/OGtPEh//EC8=", "Ii7rCxapt+0xCIkX6+HNPeKlHxXh45IpoIv3NPss9U8=", "JqsYh5evxzMiywL455V44OKW+ZG7K8/rtjXRISEW9Do=", "AYmjMJViSp/oQ+42frIyJNuQyNeWFJQfQwCSAr8/dpI=", "DLEW8FxbGI1mChUQDk5TIT+ckaLHzEhJdGjuAJIEFV0=", "BncWe6Zc4xztgSxXIRYCER/Domu+kiaRingZyUKBGWs=", "IDhwnnz8w6H9UOyER2yQhwdI67MPZDG9E2/emc/eJS8=", "ETBLRx8HhGS8IATCJNwFpMTsXbCg0V8yQTDhJ5Onruk=", "Jdjiq3+HqtN52j4+t/XTXyl+uAxDDHZa3sf2N8T1kuw=", "AlJwX1TVW/KbMCN/jRKq0rIbSl06eqrpgvfN49pjCGc=", "Hbnt54rw6/JtwYj2+nVmPuyPZbbJpe04+7NCHex9fkQ=", "KJFb36tyNThKAFLtc4OfO2YAp61jKCIqW1z26DOiN3g=", "Ckj9mw4AJ59R8kC0cpwTYHQPAD6ASglXnijAM8R9WyU=", "AEqolejBJOpiZD4dR7KBYsQEqjkP1Fwy+coAwID+wAc=", "L2/yw9uXFHrQRZTRhYmUtBb5iqEkO/ud7qZcEJ3ydxw=", "JPT0+vfOT0BambmXrL6U9PdWRv59Zpd5c35q6npZMYs=", "LG3og2GPYb9/P32NJ6YH1qfER3SRtKUFlVMSoerTvBA=", "CE5tTjgh4TP7kd3xfFKjw+BW3FIR2ZxQel+OsBDyBR4=", "GCaVd4rCUDvVqyMvega/ZwqVD6sPUmkeZthdZ49+xLA=", "FgMzRh76oqua8MgxCE1U52adijnFzbZ7Lc9B08T8XgU=", "LNFBQmrvg7YLrySpGWT6A6ShWpVtuWuf+LGALPeIaQc=", "Hvz0beQNAx+EM1A/NbV+fgXnMzKS/E6H6M9pAWcXYCM=", "E1ZlNMYh2AbtFi7+ht4T6Z9boLh7dmK7x7VYq9R/ty0=", "E90PPnrXCRhA8PpG3ygEKXpgoAr7XLTK3mLvkwELkH0=", "BjB01kcpgHJ0uVgvVFn6XxOlcKoMjBzflw4KZ2z8a+0=", "LPC5RjJAGJ+RsNAIHx/fEXAT47v2ay7CB2i2GWynikA=", "JBS8CGmJ2cWktDiSMWcuEGcPqg+kY5PtOsuPdZLVPP0=", "A1w3UhDEA3jedjo6HKgLb1nucuYLzNyrmYdWdgenpmE=", "JGSbIkhdQWSlhJ5v4J5JGAC7l1xMGNvgduxMhDCUQQU=", "KP8wFUGR5zS7+INQhtAmlYdw9YwFrfKrh0UbD1tqW5A=", "EzPgaO7CRJ7J8+wlCQM6le7n2Ts+IbrL8THzUwIers8=", "Gq8B/vA2jabsJdQg32K/f8I47raPnAHv4ICr2SGWmZI=", "GoFY6dbv/7P3cEMBNnScE6w7V7CsZ7fnkLh+TJUzFk0=", "JnpLzkZEjSUPvEdiQL3ygIK7ez/U/fa0lZ0gLKXCLMA=", "GQks4XnGgs5lSFjzPX23U7mmhkJo7qw+AbnHSZ1mk4I=", "LLyEM0UFFByFRGo2i9zm9DxMcwArnH+idVuv08kTzeU=", "DyKQ16zcJu8g4Ov2x5CyJuwnYYeA1ps0I124BsLPf60=", "CJl9j+mKOweyRauxov+STmnJTsUS3YcX0m2ROXb3AJo=", "KBJXppMEQqBLYrcu2F4GwmUQ7zVyuddqWkfTnMjs/Rk=", "G+0+9Z1ST9OOsoNRrNiSj+aDfO5ELNQSjhfkzqv1xeE=", "JFDEIi+SE5HC2IDQVJpmh5sfA25hlrDtBLb2XXUBrog=", "E8vIFkUvGnhZxaFah96nxwdLBvUGI7jVNa0x84CGIBQ=", "KkR9q2Dpo1beBOCSN7Cl6COZcHLFV8KDmNw0NJzmsQM=", "BAOvsp1YvXqZhcR/j8XiMGGcMGvDueUAHlZBeB4qJ2c=", "AfGzTXTHuksknp7RpAPt667bfN1omX12lwLGFnXPn+0=", "Dl48VO2t812YSSxGl128ji/wjBOFir6PzeX/dAGCtkI=", "DWO6ZgA3sJrYkfKnPuaHzZP+JqzRAvkK1ax/zm48wk4=", "Cvty7Pj9AuFpmAzY9NaSzu7O1/VEBqZJ2gtUITgXdQY=", "ChjRgpO1OwQwV8SMrudS93fry77Wysh4rm3X+CPa+Ic=", "A0GHWGAUm4AjiZ2lSZEvbKYz0M1kMIF4ta8wWDECXJs=", "HnT0f0MOHZ/k7a/PZIQpPUddu9MuTbevsQk0TWshfKE=", "E5POMDxSwtcny0AERGuOKtIsGPPGuq9/C5gHtNyrYO0=", "KZaphoiziWsSv4RGMASx5s/UH+v6gqdsOYKcAKWQlWM=", "EQEniES7HtFTKojJRe6j8XccC3F32ekKifwU4Vc1wPI=", "D/lE5YSVw/rPnovOPqfmO0XgCURT1t46R2808Ly38HY=", "CWhYkrFkeTai0G7CkEI1oqRzI2+64AB4E4MrOyh0ehE=", "LflZVmp/dPB6bY2w7kjM4z2D122Dzfty+OYBy9qKYZ8=", "E3HDDfhPb6F3F9yr8hJAsfYrag962I6pdLdEJFdr2y0=", "Bj33il0q5lk32GX7ZlM1jxEKFiC0YiIfxTci4+WRS/Y=", "BpQ8OzuTpR91ue8Cfn5InEAx/5LfyebMjBRHZe1FWWM=", "JYpjAeHU7Yb0MMEhuKegKsQaRTENbsz7HiXFDhRNVSo=", "FpRsFgUJvaDmoosxDR49RlSW9Q8zHroSo9M16A0Czv8=", "Ioo3fcBj7pXqk4MgPgnNxE7orUzko71qzPru682zr+Q=", "KdViyDM1WhMkbq/tnLgWtwDkMmiPnQFh6zRfk8htHDA=", "Brwy6FGfumNkr0jGPUaHlOQ+rwRKEi9d91BttzKBFXQ=", "BbX17k4d4BZUhe0uiJ3mUkRZfOl5W9EwKZXWRItwmcw=", "Io4PaudZArjG81Hjr+kRhS+3JZTaxthLslAfbB+2K3s=", "Gt7ho1f5vQe5ql1d5sHPE6uF48Y3VyxEBRgCVaayYss=", "D+jiMPemU+cNfma2jN3jsJHJC74zku1wxlfMGFKcSNA=", "F/Ljt+Kl6VnKxLLiq9WyBO0dHaeI7LYB4gnpE1tCd24=", "Dl67jZq3suz9dPXH2FL7cu6h0pQ45YSdYMO+EQ3M138=", "EXb/YLCakw/DeL+lv64TfX6RSywuXUFxi75Zh+pCBKY=", "HCieKo9O/FvwJyv0UBLnxTsuolk1PKX6wTRSVw8Owwo=", "CJcIXKgGLfQ0pPlSb2Xe9rkN9CJESFpy4jti28OtSy8=", "CHAtd8brSFSrmg3CAKlJYCI4Hh/DNgb4onbK4KAIbt8=", "LVV94ESwupk0tOhMFMJ5C3ff1zxglk+sQ8EoNK4WAjY=", "G3xxtUcpVIUlGmAeeVpb4pHskxDQmvTL9sbx2dl/B1k=", "DC/6nQjQH3hjrPMnQeb0D1phTVtbyWgNRFC8w93P5+A=", "FrTfdglIDcSWycgMIFyxMNx1o2vIbtOXU3+4Yhu1Wqs=", "J4hwKFAiqOYsAH6hqA37mDEIkzkWR01wWX6yI9s40SA=", "EtCG8kJwmVUy9eml/g9FQhHfbg1wpPVkjewVMrztCCI=", "FAUbWyRscGFYGORgBypjNTU+0Lqv7nyifdHtMjoaRgs=", "ErZPP7NJF0AjTEsqnCKw02FeZAk3Tb1RxoSA/+2DxXg=", "Hbp3w3FVz8OkDmCjyrIqZe09CzueFKCI2g94I183jEY=", "LTze58IOmB33hBSvvBGsC6VTiwXYs+5k6T3fedFq92E=", "HnLsZFkESoVFzwT8l1zqQ5aTJBGYX2P2nPWr/Qeeozk=", "Az3kKq3zQr9juN+ojxg0MW7AoaIDH+a5kLiTnq2QI2c=", "AQM6+kIPwxHfhzz6Zisap0wyk7Mvr7bdi1CVe0DkU4w=", "AyRgifxzWioQ7/gZiN3fa/bLNspMlOX4EdNKE4r3aV8=", "GEN4h33CnqyW1w8sPCPQOxW7XMM+9Gqk19i8dDbi4TM=", "JKRXCcvP+4Zl4Abm2hOHGLlhoR5fgzr8FN43JzoU+rI=", "Fe35xWurzM+1l3I8Ti7MTp8npmIsFh6Q9qoYnMwoxHk=", "JKWzc6QbYoS1jf/IU+V8HpTdgBi/YVXc959TmtOPBYg=", "ISZngWrfs+quI39LxQA4NyR/8WbPjLof3UMkTzSqVA8=", "HviT9jcVg2jpqWt4k7E2k9GgjaxPRSMQiwqZzWDWJ+c=", "Al0U0dnQOarCrNTS3aP3OoCIRq7XFZgXKJ24/wGlEsI=", "CdGHCdXNHmajClrypAICoG4sS2RW++KMVQn8+PUBAJc=", "EOSeRRWrI/EbqZsKjrK5wMAP/THil8wOv/S3ChkISgM=", "Eg2PPeU00550poZqCVqjA4zVqKbaLIw68RxqV4ePvSc=", "EIahxnDAs4pGFeK1ydpFJDWyjLYYp1XLjk1sxKGF4Ng=", "FD2k8eVsKZU5DebVwgOoGg+FNK5v4bVIvAbtZu63G4I=", "A/Z/DGgudBhvqKQxha0QWJhteCkDfJvE79EzA98lZbk=", "LMyCARXxc9bfGQY3+GD3VZg41i2khHaKqRR+OHGP5PU=", "FseMAD2xet5JZAJtnIBfmPa8wY9asIS/bbR4MktMu/E=", "LO1z/vwsyvZbKJ6dvFZetxGPlKHlW0McF2ZZpOIDALs=", "CANV0mdEbmV/T6SERda765K9ByIiS2I1QQL6+ZXIzw4=", "HXsDXi40RxELVpoKKF/MdYSOntsF8mB5CxhCgnyqacg=", "De99aTIZZXTfqju5PkVeswc688b1sjUQrzBORK+dRes=", "HXvul7g6UIqvq8/CFelL5sMZyRoGpEbv7qXS62Qz0B8=", "KX3yDxFo3zUqwvby66N8AfLh3OjGyatv30vU9zqKphs=", "JwTaahciNWNVUD0saP4bTMgcfsjseeYCk8br4s0Pu+Y=", "LuHJNiFWkEL8tXh5hrFix3E8P0a6mA+Ew1YF85xr0Jw=", "FD2tsnApQ/DBq19NvFRHQScbX+rMQQd4ORu9Md8n1Xo=", "CStIgNYpdRyIDFKlg+fIl7lvjkAX0DYVJAtYsJlxA0c=", "Lfu54w391qYQn/YJb6eIC73KYwr1hamN3cJsPAugax8=", "GD9e+rzQuztbzcMHowAECP+iJ9fqCdHkZyi4pB3BCxs=", "GI7BG45Cef5daIXK5otHsOLzsbFJGCPVbUW37guBm+8=", "A7ky9C8FdFLPfmO+HXkd8TWxIDoFoe6HGBt5Vp3Zyvk=", "DwBOQRhmvzgn7od/8muQMOgjSvkc7Bq/Sx5j7DdstPs=", "B7KaK/JsMlNVmskYZuGL0kIxhzxijGxUCFAg6dlOTgY=", "DdSTMkR32rP7guv5u17LJhsWBT/94HgMehA/UiTtDZs=", "FaJIHZoC8PZg8m9zGABnLU8BOGqIs5pIEwBST/fW138=", "Ag/Kjemx7BsTBgaUWRNDhexzbOPUf8/jHJA23kZlmdU=", "E/EwBswhxEE9EmuQNDDH0PkYQ/zIyp1vKeCI1T5tVtA=", "FWInAyHzUdGf8DDNsQYZBuyvHVRahCYR39L2K1F/rcw=", "KhusDRN2J3FKZNJc/4A7Vjl+t8SfkW8hLDJeNuCZohs=", "CmJrhBPENxb7OUdareWl+mAyvmWHChTHU225aazNn08=", "AdhhSnUBuFCLlyuzqYZdfr4Q2h9++aS3yq4ujb6v3jg=", "LEzVQhO8nBGFhJIlc+3Ql5aH/+YBlO5heomXEJX/FxI=", "Jztn5Eu+DzbgP+G7fQJtOuGNdCgOpmD362revxNiQ3A=", "I0Xtw6SU/QhicN+OwzNwIbv+2zE+Zm7RM1jYCNf7lr4=", "FOMkDUALLzfEYnMeqxq/oxIf/0RSrfi48eotff7+W5Y=", "Jv7RAML+GK/UVY21aQ8fXBrkhI5F95hLl1oSeyw+Q/w=", "CU8MBDLj3WHdWfePPK57LOrMfqUuHkKWGBMtKZNWGz8=", "AbaVKNHLBl6hu4y0/81vcnpDwYSZioxSKJcT5S8aTxo=", "J/QeVT+dWHqEes7am8N0raI/1aMQaGQM6IUfKslBa50=", "HnjcV5njGuAEfsQzjM+LU2Nc6/7sfeBQmKyaSfUbThE=", "FAjbI6AZUWP1f/VzObxpV3uWqnyfWyNHz/7nxsrNOJU=", "CkXtKHS6oeVYU8qGnYjs4LGPknUqamIpkvLECoD6G9o=", "AIxp4RYo718lz1qpqGxYGSKT7ae4A4sPzb6exDo4ezg=", "BEGL3dG2N7Vm6YOvcXSEDzEW/u5j7PgRujwYMgi3NFc=", "IVzaZHhzXrFD/7kGdPz3W6TWD4Hy4TujoUiuMvctS0Q=", "A1V3pU5RZpYzSUTTVfj18ZzcAAaj2PGcv1KjFfypJlc=", "FAB+CPIFCmcmetyJma+r8t9AjFJLYtZiQuB7yoRrc08=", "HTTcFvebbjDtWmYc03wZF44bm172gUEEsPAbMEL7wfE=", "IQKHOD+OqdAiMwWDA3yXx4vGVZsG2pmNNIbHhFGOKPQ=", "JPFOhSkNadUBojR1cHIP+4Be36PEJXTxDBc2MdwVqTM=", "MBFiAkuye7y+dgb1D+f/Yfnvb+xscPrySF0RhZ9ZJJo=", "ARLsfPGrd7qI3wvyucmtzVu9OQR5hVex+xfJ8JrrwK0=", "AEBeWIiFRoQ5jKoKRH8Qd/IpTSPE/hiL0dkCS1x4bJ4=", "JkgTfW9I6S4bzKysvjCERzmfY1g3CDRuLr+Yfzl8jxk=", "KCjtcDkwPNKrGsB+JOLKjfE1YvGXSyyfKz+udC6twjo=", "AV5txYPk4fRibYaZkQFw+qMjXVTU/awkgAEMvEODc28=", "Dg2QHxJhNtuK5AgDU4puY4pnvklaiw2mUj3RUr4kUU4=", "FfHWuIcX83YDH0yduTiZIsgyda8+Zb0G8WOUV9iuptI=", "LUotS+9CCUUS2iXx/ERRl9pBFsvxpfGd7acTKbP9PMI=", "K3VRa5DIMYdaUu/sZjs6wkQwCkrqM5DLt5yrBKQcnDc=", "It/nuhqLg7T/nlmOT4U1aOSSEu7AvrVmy9g6WAyRNRA=", "FzVtIw+dpNJF6V0xk5xUaP1rT+HUOl5qI8MlvreBjoU=", "AHcapaActVHWdOzHekVm0wQT88bz+YiD8il7sq+QFwA=", "IDjCvcV9kv0igm/Hbm0Iwrnw38UoT/+SBnyncRhp8fc=", "G7steDEp1WR9zYaNQGi0yykXVTQvTRiWZ8q3P1iRPFQ=", "DPo81ioiVpvZ+D2sdZgvXZrnP20R6UXbTxaR5H1pDN0=", "ILi8r7IZwOjMdMVkw2Xn8arc6+nR3jB6fYv+vZpZRIo=", "Ez+PSTJM5Vq+E8UgZbn9VSXRmuH9lcloQA78LTKj5Vk=", "Hjk+KBbRhLtv0GJPD6fQvix2fODNqHqiI1hjVktvDsU=", "Dqn5ltp3eSlpf9nAtweBKOcKzkTg+cW9K0CAlrpqyrI=", "H5mCObsTWZ2yXFYhQ+En2H9/epTTIXesRszrh8uZArs=", "JzGVT/P6k/5hE0ll0/LboL+sz8kep2ylljjS+pxKego=", "GNB6mTn6+lEuLbP1I9HK1d5e5hONwtaMjKBtWrtK5lU=", "IcUSLwDw21/YTOHXwjcOAZ+oJp/nYxVg8wpMeR8ijg8=", "D5TL3knXu3R/G3qDvbw/u6zJXGg1V2e+7QLWj0RFBMs=", "B3hlhVd9gWOMjfbG++lP1jL3rX41zv++Nn6co8ozwWU=", "E4mfobQfEvm6nYW3K6MQ4Chzb1IAKTvBXfVCwfP986I=", "Gj4rSjQQuBDQ2NjpG8CrvFhDyQ4fGWkCkkkB5KQj3ME=", "JGk81SmIhlA0OL5oUnflgMqgxhCQzn3g59QOSdErkZA=", "HLiHB9OFBIgo7kpP9GUdJrDGzkQDgBtw5l0DZChb0l8=", "LV2ONshy9boImQXnSLAMFzitUQPlYzQlDbjDT4n0y1g=", "HfSP0EGw53Yv/3hAhwZP27uvKSQqNb3Gokx2TxIB450=", "Ia6hjWUmT0hsmGs9zeery8DOH4JBi2/p3EIO9yj5pa4=", "KVqXjWsRQ9403tb4Hir1C7r56To8T5jwe2mpEpeCGNo=", "BPDwtU4vmt1RfFPxHehlps403zUtDIt7Dqj8oFIaO18=", "DE2qa9iigGlc63c8I+qTbq4wua7LfSlzLz0AXo9r6HU=", "AnW1+VDla+0BMgnjTJiVn61Rsr3rrPsVHimTyGkeHxk=", "FC5iK46wlNFWR/1pEW9ZpSfYmEcQq4Q3N5IGvJW6sGQ=", "CazJD7pSV0I1t+vpSzr7EHpou37W1gshcUIZ/BcNVbA=", "JlErTlNZHxhxCbK0829BMfwLzRzGBraFOqIFJrlZHd4=", "MEy00lizCmeYz14/yG5JGAnKculEBmFgon7GDGaH+u0=", "CfJNhGlxeiu9s0dAlCy2aATtZ9kyt2jIe7a07PNU7M8=", "MCpgTRSlzqSdBBHW1ml5dXjePt7dS+5ZUQmlCfIAX3g=", "FwV6kv2C8ndjuYwBN6Papq68gtHuhNwoZSHEszrRas0=", "F8mMPmsU5cOL/T0ZGOezLYXUMk8W5DRImS/xK9AGOnk=", "LYW6ppK74B7o7Pq44guAuMASyW1p9pS67vwlO7mOSec=", "IqcTrtFgfTbKrrRv/0EeZMG7MWDbPzQx+swHlp2rTU4=", "L3rk1Kz8hJf9pKwNCCytOBlvJlyGCJI1CT4arFPGfoo=", "Gv1SlEYoye72pNXPIanc9vpJsdofvZyXaXqlDc1s9xI=", "GY6HTrMYdbV5bDCBQk2nOpJwjs106A7e1cisSSqAEf0=", "AU6ht47GJHEU1GFc4NEeKAwzsKH7rGNvVfBDpevwTKc=", "I7R5ezv/sh20J35OsTl55ndKzwRS3qs9BX7WwOtfFxI=", "J8hcHBRwds13f0G5nS5VUw1NQ7NBEhGH0BBjfLtmroY=", "H4RoNwl2OfrUPA9AakApo6ttgJwaJ8YeSLFcG3E2Xx0=", "JrM4v98VAxE1f4BkSe6Bsv0p4/L0O638eEiUjdd4GvE=", "LMxueXM3Rfm3WcHrX6NnHcPZkGXoQT1lPrJIN6m9xUQ=", "G3+6a9KFte514ZXeK7sYnoIt7RmihnxTI8f2xXXBmNo=", "GEpchYWGmW8IrFz1tfZzZ9kc/NcbNeujd4fkTnz8YbE=", "I5FXa6kRjbEodOUWnpPHKfiq73HS3tyB0oPdlT1Z4Kw=", "Bv1hO+9kavpPHVf3EoUY+DNQ5e/A5B+BSNLru9kZQFg=", "Hs8UR5SHrY+OXkZ39z2+gfPON37Hvtn78MCg8WuRJxg=", "Bv6YcPA6j4NJjnPs8uIUUyuLEUoUzzs0LXYj6dUZK2c=", "BLjac5elGRU/B1b3LJtiZw7V6YPAKkEJEx5yddfy0bM=", "KxxA/L332duF+Biq1/szO3JJ23kdH2X0P1Kad+MRiZg=", "J4+yHkytEQCRcC5cjNyEQlvKCIKGdy8YFzCPMQl4cFc=", "F37wPDQzKN79UijffU5E1M0jlW37E0RIpIWxllcpJbQ=", "DSAWVL/N1Ay6UuUb1BnA+VwSEB/BBj67jYFVTHHBYVM=", "A7IcSjcCasXZYhGVcti7q7RTND91wNVcdAqtE5aNbgk=", "BypSFk4xdfY1BPvnoOAlCdBQ5VUkkOI9fJyCQvqHDOU=", "Aw0MGEt0PjQBEUsfOVsS+2qWIZHHfFvf7xZZd836y+g=", "JLo797kTSAOrPch/2enCfxKXZPkcNOtTtVfvP+qHo5o=", "E+BdXE4dutRohd/yevvwIffhu9Qy0Knxo9/88zAKekg=", "ETov5ukBnoPg6JhBDDUybBDN0BQprLsfq1+qnPR03i0=", "B4rryP8poC6JUU6aW+tWkLdeWY0q8vkBa7+9rAL0fRc=", "Ld073wTX0UScEuYAMLlxtExld6tWD57+joZygu8RY+k=", "Ig+vNqAX/v2d9CgqlGUTWFpPbPpbxfl2aGH7+kPKGKw=", "Drai6p9oJwZf5mb/PRMYKAkjpjT5HvqeQ6IjBgJXiB4=", "C+lFjpz9bMZInX8g0XOPPlGbXCKtFTUstEQQXvS4moo=", "GSXSRjW/rAlDGxc4Njb2nyJLrtNXdijeM9Gigs0Y79o=", "CkCYiUcp1Eu5aksmXPmAkAOe/2z4sXDOPdb45CVm3Zc=", "GcnUgO84qhMQW1dKQZUgqn0JKmjtbnYXEGWAPaUEgr0=", "HApsB8vA1quJSGTfzp30BrBLsMP319TwCzQDVRQRwHs=", "HUC9QM2uZHz/OLSSia0szP/Gab2UpqpyT6L+Iy1OawI=", "KO8tS7NPtP9nMWmqHN/L/XqGmXSVf/fse+9Mcx29tmY=", "Gy1daxcbAUiUfVX2GwaYKChWcPS4Q9Kap/RJO8xaiSM=", "DqCmflBKVeB/yGjthfPLJEMYNUCdteZlPMMfwwfSnr8=", "FKmbvLj/8GdyFJ377QED3ueLViKvwNmcyyvN4GcywEI=", "KPcRZ26K6MJEPD+CqLdl7cF8/G7SVLfSM4+SK2hDqOY=", "FF7voBSgLZzvO9swUgbfsdzU5Li7kVE+rdE3TDjpQZU=", "I3nSnV6cadb7qMomFlbJ0DcCNaN493zKKFDPs9X8IXA=", "LRLOT7Ae1e5sRExZWDzRom2OdFRDpnIatIc517JoXh0=", "La2l/KznTXTb6+iNr9dUuFmYmwkkC0OkbgPcb7psj0U=", "LiM4ZXXi8PH5fk+whDihNyjf1QMNOYGS/6qh/G2l0Vk=", "Jw1YkB+Iig0zMTkddLctNf50mEmt1kGc10fWzWfbLVI=", "KeSLFXy0B/nOBp0PgKRTfNnocXnZ7sqzUMeNaZCk4OY=", "HRXVBjG+cj4s6L+LVZ2XWvNwVXq+4ztlFM7RvH2/v3A=", "GalUqlVWlpcILZcBfLZsxnbQO+1lQqWKIjfnSDro49I=", "EUbYzULm4eR7UdXYBmDX4Xq0NGeipbXIwNJxv5KDcVE=", "AoGjvCh3uC6al5a+++jbNTaq/xK7zr2R3miHQy83u0Q=", "JxkE1vmN594ccCddPjYsOYWy5+vAc65ZBYrCtOcTlOs=", "Gwfw+IHWC3zt3+Tf+Hj8cWLJLYwje1JBAX/Aoq70OIE=", "K80nAaY3Nec7Ale3PWOsfNd5LPlu0KD6POO/YiCDWus=", "Ex8l6KqWY8/4/NxPMlQ0/hRAVvrauwHU7/wCAUjwdWY=", "HgPGJFHLv7gqakyFE2i5qc95Nmvkx5N+8W6JC8ps1sY=", "Ko0wF/KyGoGNPIyTJWa9G6qqfEVgC6oJkKpnpJMJyzI=", "AXTCDhENEG6wOM2TGNRmkaaF13e3HYhS1FYCRi7F46Q=", "JjnfBz+jJ4nQ6a+rDzRCJIjq4G/XXvVZleNp4bFdvd8=", "DBcNaPEzEldjuncUYksAdHX7Z4ehsXBDkmlj2tFq/R0=", "L7KZNASDoXObAQjmMaxuiRc2clOna555k7Gq2faU7Ck=", "JYjP5CGmBwIhb6C9VnyyZq8QQpI7xstX7Wi7kEiPNfM=", "Isj9RjhWS53pDKNeZhll6m8B83/2Fe8wgEb+E27l8Bo=", "AXzvCcmAqAxOU9coS1sqEN0c0KtBJg0zzBnfraiOVEc=", "HZ8KMCLEdk+eXmQEOXu/RL4EnlGFysSLxymslIqwEzE=", "G79rFK0+dma9WMfpdQ97ufbW9wxMKr6R4g/FHMXsKMU=", "FMjSPnsVeHAkeU3DPFjauMEXtRtFiPXsXNjFn5zDDcs=", "G5H8jmKnnpj1Rc2iYI8ppBaWQaP3FerXi/SUgiVV9WU=", "CukEFHYgvPBKS0qWebJxP92M1QKW1CyjGFSOMrgeOzg=", "Fm8+MyV3zhDIc4kbXMdC58NLtNYrV3MxZojlEPTYK4s=", "AUHgiL/G4Aei2Cz3F5VHIMspuXswyMgSXV+bRsLiZiE=", "EY4O5CAtEnoFd6buopu2FNmcEDT+Di50Zekel8g3qik=", "KXC48x2bmvs9O5EtkFlKhHugSD3aSwk03xJ4uhS8Lsg=", "L0peqkt6/z/NBsnWj6LjLktOYprrk+zLVSyflvvaPd0=", "ApHWzH6OUVKQL1sFwTACu6lctUZX7zk+krzCO5u/f/w=", "LiIar0BwwsDXNbWwpSCZxllNOJNpFMk5PY7NIycIjEI=", "ED1mn8RrB6r2zESJ6FckGBUDAAgX+MH7XUcbKzYXnyI=", "ENvjc+1wZ0ATqTm0agfuT4wZHj+2OfjQp4HR/7qC/pA=", "EWIpuhz1gP+G7QBrkgcDbmnMDxtV1AiKs04Bo/JfpTE=", "F5uzk7m+6O+RiiuiI5/x5r1j1tSMrUq28tMZ8pmb5PA=", "JXqN0BULElS1hRIph+O/zd5/kU03TSvsBZXEavvAmXo=", "EBX3+IcdurDRIVcLC6ZBeYCi0RspL7KjesdMim4Zjfw=", "FgrPPcmNnR/7FersIofVzHQ+89FvuL1AlGokYz0jgl8=", "BjxzVSsZ/m9o6d+UOKWBgn7ObDFSARfCNTxnzwcU1bE=", "A+jIDa+IeTjNNV7HEKnjL0TEdSCqul3P+cYsS8BBKoI=", "GsP3gc2WdsQeoh/St80/OMx5Xra6RaUlspHGa4znumg=", "GJ1xIUkybXGwMn+bcQLKD5MEP9vPQAwY479wEGSTNUo=", "JakSdh+Ni938+8CZvJlKNVF2xUoYMfjupVcsR2WSwco=", "EVjJdY/bvWVR/SzNYV274L7elpps0PKAQOk7UjntouY=", "KOe1bNKbFhM+Zjg6IO2qanebavuCdyNEzSwll5qaXu4=", "AsNZf+rxA67wzw2pbHgXv+VxOCjGE+MmyXXKEwmSdwA=", "HEy2AxVUovQPzRtxIjqXl13en09cJsoIZ4hwoTntk8k=", "Lsco/ntpzEIfGNlr96gmyhsEJh8kqY/pweigpBtktYo=", "B54zH2XIqCuHWSLIRJu96joRGmgXnl0t//9gXhykfco=", "AmzYE/JIBwM9fAJEyfB5D7gNow5ePB5F18cDLyqqGDE=", "Bb0RwrZN4ac2+TrI/34MFm+MVwpvBo3tr3IifoXBFFE=", "JeFuxb5ojhN7LMzug1Qo2rk5NRsyJ+i+v66F86H5wnA=", "CzgHOYGwr0GP5p6lXtob5dKJsvDeO93kfuZIPwM7Fs8=", "G0C+Ux7froGjPkBjj+hfiAZ5GaFN0d55Po6xUg2zor8=", "GzQ30PQFqyfBhWVpmcU4pnZUQ48oVis6AOrDlecTODU=", "JavpbdwhssF7a/s6ipCirAUbOHHIf7njU4PPbXIjiIo=", "JeP8k7zf/rQovfjBJJGWPkrKGEdYRLZ/xWdsc/0Os1g=", "A6+WtLlywzcbB2ghNZz6rq+WOKByxPk+CKsRnmx0Kac=", "IypIcy3yWZsJ8fFjHWgSkwP/bUAJj4smAJg+VTRDXBE=", "DN1RipGzj+2kaB07yZIYLuER4EQOmGDNxxzbNq6Aweg=", "G4IYmMQ7TzriAH6ZTqg6hNP6Y+dZXbL0ExLN+tHPJJk=", "E4YgOuQTwZQqM2svoIA49OkuWVLlI7vffPM3gRPvDP4=", "BCVlflepQQ66A2Zc8c6O/z4N6UabAy1Gi6Fdkgj8ILU=", "J4hK3ky07sDJHIF34Jcb1am4RK8YjSisGYDMtCX+aYY=", "DsgXMN4IeJQq9LOCe4vZrEy7Hzq3rpfNG7E1sLfHj0w=", "CpPxyWKeyQceJoFIxlA84YAPTMPFOJw26e3j7rq7cCU=", "B+nFjdfEdn/KXMvNe92KT0vqeFhUKymHQ2YGVAAexS8=", "CXXgdhTM/jzzn9AgjpfK1JxlowrzWQsk3xAW5qetmzk=", "AoPzAsmJdaQYojLTJj2A3XQwARPYUd5te17zx/kplFA=", "K5mZP4EnLABVPHGCfp4ksycFSecDUVpnBDk7OJSn03g=", "A8zmPO8LzuS51cdToZDCSRJ6YotO/11Vfy7AW10DPJ0=", "K/TOE0Ch5xf9jfUl1GQ5N16zZCIoranbrKWATmmYUHo=", "GulFPcuIkM5XiyIdhGYSozlqskrIBX7Uggnv2/MRZc0=", "J2TT43yCx2OCwsR/SpPdjnP9x8rb7Gi9OwO03XXAmHE=", "FQ+UGaO21G2v4FKULhXtSW5bFiZIt93Tz1W/HlL3Y28=", "CHbcJCyNKqGD0YTLvENA1amjpHTqhKmQRpmdlceIS88=", "Ia6GrQtprmnkub4M6uAWZ4lanZOBocDebThk0ijo7FU=", "C6CudfPHYunvoReUyBIdK3vG6+448QX+wANZWZJBlYA=", "EKFqv9azg2DU8yV/PFHJ+5TsX4Rd2D4MSsT3eY8tkHc=", "CdzZsAfQRQfAvHcsDr+WTUluaXRhdTvRu4G7w5WD3jw=", "CxuyoQlmGO47riJWP2P89+hagX9jRVAUJsJxos8ZdeQ=", "BEx2UgaPuwmRrtaURUAyG9awmh8NbpGlS4r026GEccs=", "IU6pVcSypRB9iFo3c03lya/O90TEgVWT+XC72sUdtV8=", "FoTTbc2GQItoIwyp+Y54SVe/t1UqklPq7odoIL7jEKo=", "AWZs652c+ky+0VmuaslFUWsJPOWJxZ39Wr7/bGwu4Gs=", "IVGpnve8B3B+9+IjhkyejFCDYwLymarQXeNa10xAna8=", "L1bhUyYpW9cBpAMU5CzP1cpOCBT6VNMS53F+SI2gWVU=", "EWrgCabEu0wowBZxY2T7fnvjshcjdV4WB7GiYrkaFq4=", "L9vnH1PVTls7y4UM5hdD1nW+YB10Qw2euAc/aBQgUYk=", "ARqR875CS5VbIkHXU+PW1bDEj/nGi6ho+KYRIyukQvU=", "HHyc93USVQcOvdDj23+X5dlVZNM9KzKTyv+gQ05teI8=", "Hrl5Ihwx9peNQ+dWinzudwnWi4blbXfsiVh9+qeCYbU=", "JjtI5G7f+J8t5dzSWIUNIAVD7l3eMUWbb7UkGmvO/XY=", "B4W5VZxdoL1XqAFQwim7LXX1EJTI4aEb/qU44hfS7PU=", "I88a1axXZYXsz5cJG+V88Oo7uy06+RdPgEJYJCQyHZo=", "J9TbS9sw6k4HVQ2eB3uoqdXKodQYwadqEtxx7FWIEYA=", "EV9iQv1UErEgjNQCPYz4f7YtM6gpKyMcr42CVwGraBo=", "CJu8gwlPZOKTyRrnmot+AJ0PZ5xn3BnGJZewThQVxCQ=", "HUobPnptJqjIHX6fS/CK8L8TcNzQ0hAUae2H1GnSRq4=", "KGhYPpvesQU4Ni1/7YmX6c60tDq421sKSy8UCUOuUqg=", "C3lFnqgOcVOegHnPs+quA85tDjyFZVfD9x/JgwlbQ08=", "EZEZ1O0W641HZsY40MNKzBWaK44k44kow7qHWJDqGYU=", "C/2+S0N3IFN39pw81ek+zSqcs7SuLBVB2OdLZOllp80=", "DUEXTNa1xMDTSy9NhB8/naTxAOIM9hQIZO/m7uVMCKE=", "IcWRW4bSIRBn0Z/poxgjQEO4C1MxJ0mJi1N3g8vk4cc=", "EDikqc+iDKui0j7wZOdBl5LoOjHwyr3k7qsuSZcv144=", "AXzAB5+YYxdxR4WMidPX8xra6/vkyeB07KvSC30iQ6Q=", "KU/35eNvdpDWD602uATjVlnoIRfs1E3u63nli7jIdNg=", "HwP12BDfpi7dMlIavR0oPCQWoo/KokTTZ4ju6xlakEE=", "ACET4nFeqJPQDRAbsw5uFwIVfRD6/+hQlUJ9ydnK7sU=", "LpLCm3okOimdkueBlfMKmWo/U01XkaMqC+KLt+iWDH4=", "ALswCsdFZESfhyZ039nhehhUMvH0YzF8351JnIfPhZU=", "JQ6DXM2g5Gbb1ZpUHh0DxPvtY3rGtxXILDKvWI4bsCA=", "Brd2xQJKtjdMhPVSjKeTBDnaAS1BL5Np7jbbM/xDWCY=", "Id+LMYpEzF+dVLvvyXqRt4eRK91c3KlfR+ucyJq80eI=", "Hk4er10XKdVSMLr7F0PeRzKhjWapaShJcB+aJedMqbk=", "JozrN0lxk3mxTqBixjs1lEnnCtWBbfAUy9ECrGR/Iig=", "DiUrIxwfDvGMjWr72Hnqp/nmHepzJHyjr2Kzweh5T78=", "B5nBTuwgQ4oOU7aYgskMbZI5tzZ75Q9kzpLZl0wr2v8=", "D8BQAAyCGkz07mv02RukbSysIwURjrwZRoSi3LfXOD4=", "JhqM7DHBKJ8jWMc1MO1+AcLu+Iy61AEOwJ0DblfSqcQ=", "D+U2ycfdpQcKN/0xE193pn+fOphrHCPeuD6FeTzzz4k=", "Gf/drv21ADK1jgi083exwOs38GN1/3jnq3tgV4Hd6Nc=", "LiBEE8U0RTUQBDFhEPU5hJrnlx+Hf7CEGxnudT7iCD0=", "Kq2YaC3+CK0smxX0RVogHUqWOsfbsYmkLSs+HD4DERo=", "LIn4VVRFlLCMpDp8MsMcDZCurzABMsi0pMxmhDoYGuk=", "F6ofI24OidbIITN+yQvXp4sy65uv3Z6D/4x7G5eEgos=", "KQ/qrv8pjYh9WluqR/4uhAcOt40gedeRrLkGepeawaA=", "JhA7hziWhnGJdBL7QkbahurGkjXEoacap6koA0kV9n0=", "Aopw/OoPJ3l4Eg20vUeKawnVTqqKl9Np2seXFpibQ8c=", "JJnR5FRMbblOne2bqT/ZIWJobkEgmd5brxIyEbQTjKA=", "ChqqaqqX4Mcij/rlF7WTkiEa8476ZwqgYgetfwW/Cvc=", "JbYYnM9qs6dZZBrnk4Xz594ON1phwmDYTZGzMPg2Fto=", "F0awuYL+/Z2Q585yzbX5LODGmQ60OifNU++hvOiB62A=", "KJ6V2FjSur4lJlF9hQWHw2Can0rTKmRt5R6Ga7oLQr4=", "MEhBGuIc7Rsx1D00lskuZqJtU6JPJQ4X8yjDWNl8Igw=", "A37HEXkLW5gZ7S8g2gkqa++pvETL5sHCHzPT77F2iPs=", "LUAp3nK/AeWTe/o0/01eu+rLAQ6oFtn81uevkdmmcUo=", "BGb9iyODbY5FoXUaHQ0o2wA80gVFqI5BMYxXHDj9OxI=", "Ay7fXfbYM7VJCEDgFAJHIY1iVMNpfQBw/c+/bxFo6EE=", "JAmOcz4wem7knjj/0BBYmlHB3yEoLYJ4j1vQz4ko0eE=", "LV4vpeYwBCoHMeyE9KVIQg3VZ0thSz3oPlynB+yzJwY=", "DnchDcnyjwqguTML2mmCWOQpraPhDwhPUGaq3IbX3gE=", "AuvaoJk/anAucQ+PxHOS16DlGGKUunjMveKRNRCHtPs=", "BWZ2VcL1SyQThbhvz+J00fJFaZzWqmC2/lFRAubtnA4=", "DPl666gk5Fhcyec8YvAzS47UzOEna5OVAfwvv2ss8t0=", "Gw2B1YuFqA1f0QtMOZ4LqWA+DWDHpjyJyDOd+ss92Iw=", "FlJhgG1XTgYS2TXv8wZHVK7w+fyGmEseMdqZaWG1Ze4=", "JUPBIup+CEBrfFqJ84VXnFhc5kfZjsRAC2247L5tr8g=", "GKrB6TMywGlWkYUogLMI8GnYdJ+UySNywTZ7ztFx7gE=", "G/Y8/7Ra5vCDWN8BUqzhcFi7OmOwsfJWfmnUK0QEi6s=", "ICg9BEPIQ9+izMsoURn7ShIJTJDOatoPbe8R7Gyqa5Y=", "HZVP3WOz7hOmyhPf/pgyqp2eXy4ezT5AcnLYfCgSULI=", "AxuA7zDrD2OcM/1OfVt3jWB85iSrfAu82bKSG23QsWQ=", "G65vI0YfaCpjicYHZwyiyXW3aLpJIlQ9/gx43N4+2FQ=", "DBXTS07w1t0yTx+o7wWL8ktXQZweSTlq7MaylFVieA8=", "DJXZH0brWHUGxXu8LM+HoPxTSKwNrTdetAmqZM+S2pY=", "LR2hXKUiqhhodAuegBoAjdt4hGV66JUH+5lFcyZ4bds=", "BXLM1/xv4Gvpvyv6i0iRo35yiAXGCfHigqAhRIDmKJQ=", "IBa6dm3BTr6yack5+YjAsOXXoW8mSeOId/L/ilJaiKY=", "HVcLX/hXMOmtjDJhtq6FdJmSIVdP2oqX8ZutUNwuxyQ=", "FDIj0CfLIvQrIKJYYDM2V8JDoF4W+KD7B3hKP4s/g7I=", "D2ftUw8xUEv+O4cyVoKl6bkW11yqe1s9XiIsf4ZBfc8=", "EBOFFkaUeClP7wUIFR6oFk8UbI43fpBjfEYw0LRd5Tw=", "KG3L25yF5dbGgGa2lyC1UPRhWDdLiOdrpICRZhtZHhk=", "GJAXrQ7GWZZV+l9cBBsYnUpQVag5FOXrFWUgnUQ2bx0=", "EjvOn9QMfxli0AZoVgzDGSQovCKWyS/ROkLXW0G0QaQ=", "H5ql4lOHmFBzyiINp98qbO+LYKCJ5K/ZPhTus9XcteY=", "ED843bbhpmmqQuoce5qwV2HxgEoV/iLya9NDZ2VDJqA=", "EjieAQk3eq1Ca+RxY3WEHC/Uq1mLYLaytOei74pIrno=", "IE7wpP5o2/ISNxQxJlRg061jaRJFxWzNT2mQuYlTfZo=", "FCXH4fX1pCcIYzQ3Zy+Mz/HBe/dNvvoemc0EDNGT+5E=", "HRsl08q/9YQo4mluzqmXWpSEMC0X+hLPM9hBa0/h0pk=", "I5CBhnZ/B/E9CtrRFihPLxeRRHULDx/9zmLrR5fsIOY=", "DXVEc9fIdX6CKolxjLfXxazRElyl4NEnGEhlUqN0GXQ=", "LVneccZbhnjdedns05FRl9FhslORMpkjjvjT0ozBLWc=", "Ky9jjc5sXcBL/L+0DW1UflJzDN+8p08MC75f4l4KbkQ=", "IIMfMxiNqt93xILB8667/MubwnVZQGhEQSdvgAaTx1g=", "G96gOocRKsX3HSewaQ61eL4gp+qwLM976UqbUEMGv+8=", "B/GQYmxc5ANnCrsj9zkRL/uR3CNIGRgNg94jTedDox0=", "IdA6isxQAsdWXf2E/jAB2dcCWSnHF0neJTgr+Tg8cM4=", "A3+OH58xC5CQhc7ZOLYA1N0GoUfVGDmS2XkqxEWPeTY=", "AmgMtCDqSuScIobkl608u1U2CHWitp4X4f0JbrrFMcU=", "E6OgbR+4J/8UBhkhYusjs+J+lM/aaqBahqteMl5d81g=", "BwYJJ7PGQRF0ZkjWqEM/+PNzpFNIQeXL/+W8QbnmiPA=", "HUFDUmBFxsQYyn7fv5hQ/SYNIxtSsgl/0iQRBBy+744=", "BPbbJTC3GaN2xufUic1/vGUufS0JBk4+lESXjJvhl6M=", "BULvw99bzvaZ8Pp75ccc0y0lPyBIi/cNc0JB5DTb8J0=", "J2lCS7lqbCHGSlBhB9SIX+U2A8Cf+7AYYGWDMKsbV/w=", "EjvNsM9uevtHuGaCfbcjMuk8VxUG4HPEmK0akr766vA=", "FaHSWrZNsDU7M60QCahnJ2CX1aYLSxjdAr/oVaSVKyE=", "C5y2/X5v+uyCRqzUHkPgcS/XbVyuVqlAds2BY1TbMb4=", "HzjB/+VHDINnZ3yMZbP4MZTNnH0ugIChwxUTosI5Esc=", "DzIjfS1u0AscqVTfN8MMmI+JQV7tgpEz9ac2NNBfDGA=", "GQX3boJeFnH4Z/tYWPJeU6RfjzBqmhtt7nAzZH/IrRU=", "CRx9VOAgZ63AeUSU79CtkG6MM4pSTDf4JfkAOsMS0Cw=", "LbpaIZQ1mAQfkIYMjpIiPXURx0vrRkjKquS43jhw8/g=", "KTo1C8PHidv3wuWgFUgGeKdV681o4csp5B0dKULFedQ=", "BJ0BmbbA8rMSLX10sxrqj8twGiT0C6X+aY3mMdIvYkg=", "K5MlKRyhSMhuq8LrMsrkd93oMPAo9Ui1tcbhQ/uKto4=", "CWpu6YxWhr89WGoOVJYbCjr9bVLaN3Ei6Fo1UAn0pWA=", "E/zHfMtKCR6kUqP0oQ/K3bqnqxjrP4hQi9EorS6lqBg=", "CRmfBhVu2nyBAzQ7NEurEfQ1UbuVB7zNR6KSrz1Pumg=", "L8QXxXbj+ptrOKguAyhCLC0tq5CHnkL+pzAzp1YhZrA=", "J6gaDJ5dDJj8/mea/eDK7c4sX9ZnQkkugNzpX8rHn/E=", "BGe/jVN9voI9an1kyix6JBei13WPwaif+TME/etNB5o=", "Bx2CvKkq7+djbxDJzhb35bQTFBKK5ZB+GIS6oYNEJGk=", "FHPkQ07uMLLn2zTa7vsN9H0fXpOayiU5SqEaaG687LA=", "IwNAMBTt2DM7h9XMTLCP+inudS9qNnxcmRj447gKzUk=", "IT8vNBdJ3McC++uOuRauZXVEXNnU5f1b8Eerp+wl3II=", "BkNpvqTGdtN+/jpl29Qxbg4ba1GsSL+cAbUsFbJOihk=", "JhiTQVCZUeY647AiOXCY5fqTU2JSgBMbMdrDocGDeWc=", "KMUatGMBLYup8Lf47skczXaR7wVwIXiS1XSUxvqmq9M=", "Kj5aZgdTwPczgnYgzz0jUeTxcRM/dJ6uDKslrFqk8Ms=", "C/MU2ddeNUhs+fYvZTlYTQ+W/P3+oWF7dqRkCZnz0Qk=", "LZY2hFbF/ibRGaV0LQFNuehv6w4jFcKje/v34CygFJQ=", "Htjy90Pkr57dYtmt1jRHTVQRNxLl6UjwW4LQbntZkT0=", "AI1aBHojOWq2scAtEIl0slrhNeTw3mgFYnygdPPFiok=", "BH2KtsUjUNZU+GuJQvENLAAhv+nf+h2yVNzFAorvcQA=", "GZHIV7MPPtilj+Ip2lwT/gfXUZmZjfEJIQaK/tCaajY=", "Ai5IZrivFs63/UVzesNSgFscV1RW4VNanp2fenngpbU=", "CghAzDcg5lnzEdrM/mNI8ofOHdRzkSw0l5pI5psGqlQ=", "Dk/5EO45IMWH0GENsfvgi/3C21OBkmJjsXdpiBDdpX0=", "FV0nsESFaSC721Zn02GlNsP4xaXYWZ4qeVXf/ud8Jm8=", "DNwAXVX1dcYaQ9iij9u+8+7DXlakOKuZaAxNHvrmTns=", "Ix6Hupimf4bVAWUfW3S9U8/ia57gnAep2Dcba/fEK+Y=", "BrTYeAW/t1+cN6YeEOVXkSLTaTJ8NE1RbizmyJOYs3k=", "FuZtFtP1cK1do9weyz4Ys4642OBbLo54hEkaLhsuViw=", "DGamNAycIM9m3j1u651J6Kc3wjM0PfjYR+WnGO1RGKs=", "FUpLGVdRR7ZnK7CnIc5AlX+uPjNsgsf8oZmrMOdRInQ=", "FeS2pwzavyxN6YQZ2oEdBiyo6d/L45vHVC9m97YL9j8=", "EWGtj7ogdgoTv9e36h04JX7f+oxSvo9BAIfJFvUEr74=", "J7g7x50q1NpLXvSYLpG4EHSYXPIzEaZY29DtMB6Q/Fo=", "GkEVcw11FeiujQAA5I9s78yJMZBWbZTTnbFVF/QB2d0=", "GpwrO5ekEIgovXa8QZaNMUArQEGq3EFtZcIJlu5qxq4=", "FWrrUOEcOa+UbFMS+w4U226RlJBXHg7WtVVVbDH5fZA=", "FNJVB9uGnigtB1nN8W6BAG+vnxDmY4gwMJl6uJQUnio=", "AzaXe6VRD7O4Er85+hlGWUp4qZwAEB7xAXJ8Lo581oc=", "B/i7dx5Y5XYQF6lWLGsoW5PWtwmu2hhtlmFhl1efG2g=", "FUxHiiVmKU0vltg0MjAJrw2+8V2mLe+BccMJoF7R3Wo=", "G5OL8wbef0gyXeWYd6vL/i7qCJ6rCQOALHvz+5UyYn0=", "GqRGiQz2W+bOf31gO9QuA7f+wNIBZo92DdYJ0xtYfiA=", "F+t+5Bw4dHN0p7HxRXh6x1uNVC0zSU1l8O0Ayk7Rft0=", "HRuV6eTc89+QGq/hvaLMgjcDL9Nu1QjGHItBCfggu2E=", "CZ19+XyrUibMfjo1zqpjXCKrARDpOmJRbwNwopZ0KfA=", "Fh5TsvEO6aryJZbGIUgOHeIJBQP8xVqClcI9Rbr2j5Q=", "C5u1PWYDZM4aUiK9zyqAoWGTTj6S3lBX1mjc9J3qmfU=", "HIRXomXBdW3nVxswKQ3LSPoL6yt9HkQRQmJRWFSAgyY=", "J/nG/QuQmDAQ1go32ApYq7DzUA1tFsm7TWpSrJHEpJE=", "JogM+gTsre39o6JKlWc01KvIri+SZENpyEYN9fIWR6s=", "LztY6by+N+lc3ZmQrrJkgsVesqlAnijlbK4k38643eg=", "ERcQTezGeaZq8udYjZcYBbUYrCGfrIB4zVIqyJgMaYA=", "AcdFQY5M3YDqGKM571kOWDYrOCOx/tLWqO2UIZB3HPw=", "DK2KlU7GZ2tC5DyGkCQyoeF+LPSvWjJ0vBvmcm4dvj0=", "GzC7mJ2wM30EMg/M3H1m8LsVtDd/zhp1tCeL+qYdX1c=", "GaVXoXIAX4QkLUDFa+fDeVXPdNoiNVew6t3rW1XGGB8=", "Kh+IPF6ttpZNSEdHn1LIJQtMzKD9spIji5N13MIY9Mc=", "FioORNuPqgLb4apSsWgHEKjcpgkTh2lcsiwf+ESSg0E=", "DtmUS/5IVC76EMnyC33UxrFVhOEmvywByOBFaLyK4h4=", "HVPAdsEF2mf1z9gi/MnCkd+ikjxMbSdd20XZJslxHC8=", "Byugos2uV7WDuh1y8Jx0XlD04Wre3WSIyti3k+PSrc4=", "JuctxgnCkBhz1Ap+c59wr3IqpDmg/kF9dWjDjjj0fOE=", "HzyrZaq10MxkWFGaFNKw3930wAWmMwPRc49W1MQWAr0=", "Hfs0WrVllw6VyJuil7Y1XesvIwK2YXnh3FSJg6rgLXY=", "C2Dml1NSFb8Q8csSCODmmb2IWYGZxtjWUuabkK2A5sA=", "CBWTeG4wJlA5awpF/49iNmMQofU4adBVcoRIGsS+4lg=", "JgJ2pG5sYkeB86d3qbRbSDWnUcawFuWE2jWjwwmEQ1E=", "IBILQEUWcxN4TQwstO3gev5/sGBVGPb1DOwbiktorHM=", "AfweIpJnivjcXcHy8fVzw6xOGVxamFfkD66SMJvHaKk=", "FMAEetALfXNqjYF+Vh5YLpAbRIHjgxZWixviZ+d1uTs=", "JQtOatHH74ymwlHCev8QHXvh/CX7xIRHfLvk6Q1FbS8=", "Ea77wMSh24Hlt0WB+B96g857/u/Oq3SrS2raDYrKKsw=", "EAkX4IhnJIHIPOnj/LPbMvtyqDMy5bJ69VpIxzpvmok=", "A3te7b9NqXYX9TuJg3CTM2diA4jTjhagvaandZcUu88=", "CvmLGoVsUTh3Z7wmFGiIsoBuZmQ7RG/MP5GFn7Oc3bM=", "AP3QCLysaX6BE+ccHA5JBPUln2CqQ+1Eh5bA7ZSPutQ=", "F4Hh/PUEbibxm9rzQW6mBEVOJU/rCkk5BfVmtRUQtZY=", "DoDu8U1c4GhHpRsOnkVBs6uUyufKKlNtqaJkyDkYWUw=", "A33KA6a14VC1BWQSgILmmApncD/LeD4OPhIDMAT9drs=", "EJwo3LhzsyctQL6wo/6PT9seei7Fp5s8Q3wZ3E5WH2c=", "GUk8D1w3LHrQxPCWv0wgZgLq0j0Zdz9nZvE1px4Be+o=", "GxC+lly35G8VTjwIo2ZWwuiVS11QfJSfdZe5ccA94yU=", "LeJucAMg7UzJhlUNnk1qFlYRVnDzQR9fUDQERFtK238=", "Edhqxx3nRgeFner/PPCT+AdtKGIKiGIcCaeqsSCakaY=", "LDw80T8jE4loFwEkGlT1jJ9q8ev9bO9Pow6fovpOAqI=", "B4hkvnpfNsB/qSSOmBgQQPxakRgVmEuHUPlEv6U2UDI=", "D9cYfLYJauDhLk4nZBmgPtwNMkYgM2LVg80GSmx5//A=", "FeYmWWgp2ALwrb8kdulWbhw2NIsCJe6ufji9Dj6y3aY=", "DUbe1VIdFlxPsHJWovf15IGfbYit6RC5rT+mxdffqxA=", "B5U5e95Gtal6I/cqi5JqMp880rtiAFBufoMqu2RTuKc=", "EwCOFRm+MCk09CADKduVG3AOMi2xqH3VeYwrnhJZ6aE=", "Gj9AP2RHN6RmFeBHpCrK3t+z2E/MtzmZyrYn+2BQEj4=", "DJIbwyqfyerGBl9dxjRhWe+fbc7ZZJiWsU7b86qCZPg=", "AHj5ejfVX1D71juH1ZXcZl/SBu1siHUJrafxrw0eZJM=", "G8Y5MhQWKlICbQf+dw5TB2PHJbdTnZshnMV0lDl3xtY=", "EhiYwBLsiFFPFViAw2wXVcFYk5CJ+KiVtWVAHeB7xg0=", "DxvKRmuyTdzGDOkrmu/nv/Qn0eV+VvZU+9zDYuseDWs=", "CvN57E2NZTMiGPUTjcEo1BsbNaM6XQ78XbtsiBREiQ0=", "BPIQhjkt2+Iika+QBwm+h/5OnVKx3WWexWO9hI1C3Xc=", "A1iU9YDIJsZp2RKmlmR47PoZqxu+gOWnDGoYZ8AsjZU=", "LOuRXS5Hh83I6Uik6jWuBLtqAsByDFHs+ZialLiXlII=", "BjPXfaXtiPnBJ8RZow1fjMC9hTd6Y8TnVB/3NSceZvc=", "IvcTdZVFF180PQAmXDrZFWrpmjXzBFoDRG/NiP8zFo8=", "E+MDRTfiuCB6ItF1NHTyxLv7ED8kc+xQg0jdxQ1gKXo=", "EiNoZ6e94hq9KXp3AY7q/kuEDfZ/eE0baYHX6R1wQks=", "Fa0Q1oCTRP12o4uZ9F/D0Q6Y8LTRr07t9GHEPpKmwOY=", "Bec1LZXcHHogMTpT5m5pUlkCoX4e1DhZRTFC/ElSm4Q=", "KfbibY1hQeGVXZ+zImp0rHHzk7Fqr6tB48eH5x+/4ZY=", "HKPAtAVtureXxUaIg4oHTP+N5r1qdce2CB8ROx/jc4A=", "FB0xvXHca8jErVlYL1m5Y8BWI95GGZQ4un7b5L4qRmA=", "EGNTj6RGVzmeEll60MkiD9YIF43jmeWpj+ir86xBDIM=", "ChrvcGTMmqMZNd2lfNxO4PEQTUNFvPLkKsSKyj+5FY0=", "CFKAeTEo4VVsu/s1yaqXqgdMSmDYFpQn39o2bkJoaqw=", "BqPI2ruaAECvVnHLHdv3JbSExoNg71EW6bfsBf4KaWY=", "CaX2WW4IkdzF4no7mMz1N6zJqLt0+FAiCbQ23AcbtMk=", "EWIEEpQ8V7kCrzYm7P9gj3Hj+VjIfNABSiH5TJ/zVek=", "BSFE17lOrjPeDWzOsuJsgpt/ci7S+bYBBgb8bzi3zGM=", "B60co0bW9MwXv+WCdMGzVWWQksWCleTA54ERo4euqx4=", "KWMFLdNtM4PzWMgCQwja4hJyE2QMeF8gKo2DJRJE1L4=", "BIlpCl1WNytFdjLXfMyLgKokh0c36aBd4mnhFhjtaf4=", "HAH/8Gs3pRfTnsev2mbudo/TnsVomx7N6/MSmcN2zGY=", "BrMMFYMY2bXIHt7oBSKvr3LogPoyfMsH+Nh922bxXt8=", "FtVx/HHl5KljA3PRK4WkEiaDIs2UcH7uDWeNK2Jm6ew=", "Bn3ZgdpgUgh7vkTtNXiYvowQj7ftahNIGmUJATAM1YQ=", "ARRPM78b26kD6wtDRJskaHvZlfDbvLZU44rrlKbZOhs=", "FhQDZ4W6Fsw+FYv3DCFPwFhOQz/RQAnVdqZ4eXDsC/0=", "JXdVIoMAljWBZi+g52f0LVvG/WQvBANyxT06H+6Wkt8=", "DehiiitR1w4w//0lHbTcYY33MIHQHfFhIYKy87wHuhw=", "L7PIuW/hfMFDJ+hIphAHrH8EMtO0DwgC92TOfBaGZCg=", "G2gDdhfqZfhj2Cjyu+RBIouddtlGPYPXeeXuoN3JIpc=", "KILBZUfLaPiAa3etgT7jY3I1PpvRwAb9GWECBQh3RBE=", "C78J74OTmJ0opo0eC/m0m5M10MNhETZJThKOX3tk2LU=", "AscK9tNsB/TktlSz+K2Ysska8Jt7+3QHmXeqh/mbE5Q=", "A+ft69GMw/+CuDWtCLxMM3G31VKG98SMdH2TASf2K1o=", "LQJN8EGVS6I0Qd2SezCh7RAo6S1MNRZDKWdCqXQTm28=", "KYwNH8Lzbo//M0JWvFzX6eQ7iSyhdikrOmTXYifMSak=", "GOZBaViJjsiYhTU2MElsLF9XLsUNwtBO8XhpeY+a7+o=", "LVOifCwH+5YFi4jJeJ/D+OHTYaQSvxZLKqDmbnALNng=", "BVJ3BBy3oSKxYYsF/7k/cjQW6o7raBMIXdVKmds+sT0=", "JkPm1d7QajtUCjoX52y87Qbqzkx/jpXpnbCaHPZ0+yU=", "BMfQDNd2fhwKgzdaexHUO8L8LZrT/2NmiQomHFPDELI=", "D4nR5TENBnZ7LwsSZtVr5lPYNkiHjqJdecS6BdcZLiY=", "LmqQRKX0j6m7de46dZnacX3MiZbOwAPSbeh+SU7U6Xo=", "LJnB/2padXKVQMQJs5+u2Th3WbVzHwQB6Gyd+arQjKw=", "E+rXJn3GzWFikxg2sHdFvxQuvzj7sWwDCkEAVar0Hmw=", "F6hxBclsICbHd6ozpTKS7iAMu5+FXZkJSaNtVdV2980=", "Lq07bdr0lmG9S/P2zR8SEnuOJte6+TZgBYYdCKur1M4=", "GUf4wNssWCYEeSIqcbaS5O6/M8yiz/gvLtYvkPUfF6o=", "K7gRDSEJxqHy7Fa/cuBaFh6UkZu7DYVdW7NRYlpAnoY=", "AX3XbLDbpJVvi/tTEagyIuYL9d8uIDFrM2aT0ocadF4=", "G2of2ljAhKkJMuJpuOVvtRy3dB3jJigOA12diZJaRTw=", "F9lVEURpczerLcKULLd0vEJECN/D/hgZs7sw/K9AS2o=", "Eqtou3uio2+mRfkPxyINT4LoOE4jGwnOmTk4o0ng1bU=", "Dajf/Hvzyj0q3L02IDWuySlrx06mfR6Uovb332oNkhk=", "FJbLPsfNpR2F93bYYTsEMOl018OnpqhD5m+iUx2idXg=", "LoGVfS9zqrRKWQMK/8lFsmFy/OCbTUNRrlPs2sgt2Z4=", "L76Na6UCcpa5jwJ3sn4ofkxZ6bH4RiTgCX2zkPplwJA=", "KATUXJbS2EIsjB3a2MERXZKuwrFpMM1wB5vUTPQf2Y0=", "K3uotkocsv5ndFvlI/9GpMjAQICS+qIzPEXRg0ghFBU=", "D1BrHbsbXt8rLZO/vCl8EX3yEtYSfLKcbuYKL1e54hU=", "LptSx/BQsueb03fUe9wdgkb63z23mYJjZMS37iEzIH4=", "CBUfrychALRZ6jG3LDq8KqDM1xrdouwBlolcmy+abDU=", "B33YpUYUG+CNrKFkYA410Q1NTp9TYWPUHCcMev7bWOc=", "MGHlVZBBHp+BFHbW7ni9r9iPT8PUvmC1Yet54OF4MeA=", "D1AAwm5zgkpFMA0EIOgdjP8+hYA4fpMQ1PRpCM3pqS8=", "CR2DHPFerUdRG5OvdcgwW1VhCzEW0HoWT+62rush96M=", "HTo+c11JmRAwWQebWViNtfoHa5TqjHCsfqbNun96lVM=", "HonSs+MOxmTukpw4hCchwHRFCgy7QqSpKWVLN1bQu7o=", "HEu9X3Lzun0UhOUX2lwK9yI2NBtqjpkf6eAqGcskv3E=", "KnyB94E7guOyY/xXOcqyPF6zXYTH2CEj8IYl23tPuWM=", "ANSOQGLPJe1gfRebw9hOH0nTDiH3g4OGrDsgNwGumIQ=", "F/QzBZQvNWYmWXK6VUPUqIRdrAyA4svLVqqxedKFQVc=", "CNh3F9Xqzz5bs/tHN3alzEfS74Bb2h53BZAmx8Zil0E=", "GebidVAL0OgCA6ogwP9l95hUVcsAlgiKW5uN4xSQCkc=", "CW0PO238XpIz26qs9pvHCgqqob9sDgTgLew7XPiIn4Y=", "ALmlZDSbrk/82wRTy3IwrsWhXxjszfGRDBDdetOu+wg=", "I31EnBVI24mHkXV0zlQLHM0k7v2Q4oEHhmoXXHwWrwA=", "Eu0I97nRK8MEVr9CTywFxryRKZDecxjiJX2YpBPkfes=", "KWEWAavhjSb1wZgmivXzKbJfQrjwemWEn9vfkAOECOA=", "Dhcofut30IX+egsQ/hZUA2jksbRXQlv8qGOO0Q9isgE=", "KdFYE9tmZQ1ftjPP4PxW4kKsPQOdHeIFsKJheMRkNOM=", "B/5/e+H8s2quFaMxcenQ1/Lg4ZPnieV7y48BbggRYYI=", "H6h74Zb5ONoinOrETuND2o8sP5VsjlAJXTa3MSO36w0=", "JP/bUvT0Q+38BrjzGpNXJTxqFXqg7TURlDcZbCMI/S0=", "LUvKd0VxIyCP5FCOpOtJxhcDK2vHNfxTmbDC/W4Lb3c=", "AjEdfwzldj8EvhIOgE1+iU94nbnr4vhaYmWalKJ9O/c=", "G2vvjVHpRR8A1frwmng5O6g+WO0iSi4hwAOWWL/3mZU=", "CQjWBF2W0RE8T8MDNt8wEbzFa6ZuyofsjSB1oXana94=", "DZTz7oCDMB+OOIEAjGZlHDL3QyTUFCOuCFnrwJb3a1A=", "AeqJ4RuH5v0AYjSJ1t3am/Z+/XSnA9O99YvAn2igES8=", "DQdFfcPuz8bud8etqsofWjaeCW3vNp5mUZqIcBuqt4Y=", "JgRho/drsGYJTXZAZYerY3chf+1SgiLaKb4sx7kPHS0=", "GiKeOT4tMMeXglC/7zFl8mdkPrPCLdnxyxreV+wb3B0=", "FK4jSWlFSE4ViCJFC+4dWd8opVKvydvc50jjZVPSF4Y=", "AKKHIAq32SWpRVPmk60w1ReWHXtbopPZ1rpnlTQ4unI=", "F4uBh0hjNhTpIt4xWD8nxBfDZYGJU9QM1E8YBC7h0dc=", "AISuiu71+3ksNs1XOgsS8N0MkdbUR2d54dmbKSWgVDI=", "KKaqYNVw8Jmbdy18g89Vg8myPf859jOI3aQPbqStzvI=", "Gv4qSDkTKwyuSU929vuwn8l6Lc/8PPRV9kTfoeieAZ0=", "H10AwMOiS8EVeYcgsfm6a1L+qkRSKtH+wsGsnMLPqa0=", "KAwgMl0Qxcn5UmV21gGdwCSPEFigr9XaWgzGWm3rzpM=", "CqNOA687Aoy2fR9N7H14lHijy3OifwHHX4S9Rm7Zsyw=", "LeUe/rNt1/W+6bZ6/hkq1+9Kv2O0YhJHvog69wiCgHQ=", "FDy6YVsGIj9VYr0KKKYaM8+N2hNMK0GVThpWbdMLvwE=", "FDUanSfWcLeuormZuxh9fssFKfkgOqA2FC5Sd+aBX24=", "BGkikEKUkn5rWAKAUBOQAYQwMvaWetigWiBEJXEeGOw=", "LgVuHONp6pA8Rzq/eYiiTYL+n+DIe3yaYFxlbazTxao=", "ByRTk5EvhTAu17XTYB/Lv7qm81kgFF7wxZzojBpqkhk=", "Iwn+bDBu9zb2Hcr2W/bZs50Q0un89o7eN9UR+ku97hE=", "Fw5DMtohfLNWLiX14gChnPNvhMmGKW5x3h+yYSW254o=", "Hj6svBHpyBkCdNcLvV3QrGSjdFlct33AjjPuXg2Cxgk=", "CZgya4+T5tp6RguvbL/R0p2zdzBwvsqwAcW0r3bMJOk=", "JX2UDtDNdmR+LT9io4kZs8YjJqSUrJ4Dn4KiLvHmiJE=", "D0M10Qv8Bal58DjekNr3AnK73CQm5JiGRmUOFkxWJ7E=", "HeKnKunSpWMsPmI55h3ng7e4TIv76X35Zcc53KdgkoQ=", "EvRLDoxpTnu9Vpnk/QynNKjJzD9Zui6rSjKc9csikok=", "D+JpJnT6wv4Bf+59kiko3L0xWOognXlIo9dppwnZDUU=", "EHWrsOWiCM7hiEETGrTIcwXxRBqvy4CM//aEd8xPssQ=", "GmTPjAIOcSszTcgWTyR975CYVT3K16RAw0n+kCQ56Tw=", "KWpRpKuZDFk0kiufVT4FMpPK9GMW4Fi8ea0To398gtM=", "E471yoSYDhHcm1TOAr1RZiG2XqeK4JdMHbmmcgwAIjw=", "KKdc2tU53DAKLpUYu/tHz+zOXaAc8ekCEHgmBRgTALg=", "JtK5IznY1Es2h3CaupXDgEODYP34i/x6AROCvSp4WeE=", "HfEfvLd/Dt5QZQS/tAiOMnmnn+a4TDpRr1EqX6nirjY=", "HCR4+nYqvGB/sKFiokc7nkyYOFngzPUdq95fp8jWd4k=", "Ld/gLN61dZMy6uTite3VOBIFUVZTt6dmlnuCnKuA4Y8=", "Bn+dCCxK5S5T6wKsEIDTGpNTfqJNdKUQyJt9p5vDFY4=", "AQ9WNJFpqYwB9+jaYuUV5Vrr1NRMRQN4MBL1iKN8coA=", "ArA1h5scVwSVQ20lCipFvYVRC4prlRYppKW/76pxF/w=", "EFnk4zILjC1mpraxUR+gnmGcSydCAe6HQb53/Fs5prM=", "B5lLkTaBRGnLCihgZ/Yys0m1riTa54sFbORdcidS65A=", "Jp5HDojL2Tb0w17F8AQrnW/BOPPcpd46g6mTIcjB5Kc=", "Ep8/CXsqpXRv/ISuF6/5qJKmvEvJZatL0cZa3e/BYOA=", "GfObQnz5SmWqe/dqQFtDwNC0qCTI5g3dZF1m8Kkeu8k=", "HLgvfOSHG0qwT3dGnQEAhX6Y1tlQ2+jvZONWgc+IjDI=", "L86ga7PE+ckVhBiSG4xKsTgNFVoTmJRkiuzuiRJBQTs=", "DIjS7R1v/FhEVQJ1IkffU0wld7GPyD+EGf6jNyflb24=", "Ch2lgaOdtOjb5PX2hjJ+fK+84HjKfN/inKXTrnSrHSY=", "DVbxHRkwCyFKYwl2nCOBbZEJtBX+ax+7F95vrX1+Ess=", "LldFvY5l3y6MSQRl2Ok1fpr69Vqhgrikak2LR8o+a+I=", "HagDw9CGBkQjGpWLF9LCLqStoTR8V0j4q2ikAud/6Oo=", "FGptH8hCjKZ5++jGlhb/Z5j1moJ9R9r8Fa80/lGC8I0=", "EuoHMe/z5TyIGqzA6nfBY+MAAc50oPV3N3kFn5Y2D7A=", "IcRVkQmWGH7Gd8CDc+IMQaMKLUwGzq8huR8LFKE8kEY=", "GJiQxo5g2XWsbkTTQ7Kc2h3LoJ4KZ+YeLOyLL7n22Mg=", "IRLflsv1uR5PGSaej8dPJP82Y+1WMqJsnDtyUrUCz9s=", "BcS4Kr+wwVKSPVbw//BBGjtdEb8AU5RF/xg9azFw+80=", "J9iP4o8SxR6Ur5srPxQJmvznOjc2qf4cyJsR/UuERHo=", "F0ULM7A1qX62E9KJ7Pd19AAwRNhh60GWOl14ME672QU=", "DumIqevI5gjWMf5DJP14+nfgDkAvW0sEdHI+5H3cJv4=", "FKiVZtwvD/C2Tfr12HA9yfdKD57jlZYYMsGU4yV+Dt8=", "DOZn2TF349rJkB7DI4+w9AO33rNwvAaVE0KL5wATRkw=", "AWqsQMpF+Bir/vnBWHBKl5syogixVXZHxgbehoWCGEw=", "B0Xyzr5MfrOhcLOqtYJdXCvLqMBNZt4QB/WHsqHlNbU=", "MGHxiOtU3HGhnGmPGTHuJh7Gkpf3nEIIBa4HUUlnA9k=", "G3GkF9Es5zo7enAloU+PtRqQ/eya+bHc2AZ/WDD8F/4=", "Krqtl74ou/Qzm1pL4uJLV+jZzBR3X1txeujLInyMWB8=", "FXl8WgcssAzao6l86pabzVP7KYTCO3rbI3tgZcZQ3HM=", "Kd9+2ss0okscUtgULFM4uY3DQMDPJ7zaloiR5juKems=", "JAI6xCCyf4OBS9GCqEP26+Vzm7G5xob1nOihqUeNcEQ=", "C6tAXtEcqlQ/nNbYhjpl3YAN0I6MlJnl1qWEdIADOfU=", "EnDROaDdima9nTYKngERzEQLOa17OrRpSzzlB7pkqSI=", "BNciUDpzQaaQ8ziXe4CtZtBxCqZcbye9SYI9fBLH+PA=", "B6CDAM9VxgGR656etjtASXmAiDeWhWrOthR+OQ31cUM=", "FDbqOgM5mpWHENSnb6kUCzLVGA0W3YN9ozXff74Y3EI=", "A+WXKp7lRz0r7nBoOkBUCY1B+vikTAPqnQnMpGCxhq8=", "ISmJ1JVA/AvGsaLRUOO9dqYhuizbRHWrG3KwtjkdiKM=", "Drf0ALDpoqRjVRClN5tKA9+NVsVDNPyMcT25a/s6XZk=", "IzjDSP2VavbhkZCaIqmQCazFO/2BgJJvWRyn94+PmGo=", "Amr8x3YBHIvsXjL1bxSaUR0GTfCc2yjwlltwFVjmODg=", "IdpIa6CqRXcEFXiycWIh8VtbsFTvJ2zZpDg+ZGo6I/w=", "BKzNu2ylAy+nOWwlb92PUr90EtEfMYwvgpOqHJgyuEk=", "Leio1JYMEO6d/oqwGP6jyHVTmS9ZvLrjbNQq9LRVvFs=", "IVrh9X4kIbszwrTC6FQITOoLErz2GlOWMFep6q+hmn8=", "GoHfPHkbsIdolIrmP9u6G9Qu/LAJ/7B6rYgLMbuKpoo=", "FBmDRxyXwN69zU8PCFFFNkkA+6hCnh5Vg6TlYd2tW8k=", "AXbLembFhuwfSAzu7fMyzWzVUI1LVaGjKGKJoXiGTB0=", "A6J6E3jmARh7gd/dduP/gZDRcNHM1/fPMzy2H15qavs=", "F+HYkZtq2njJ0YI6/oJHFP0JSEBjEbIaK5TToNHAip0=", "Fh1kI99k4asenbYEgJ06xf7HZ21X1C7zE40/DSIRb6I=", "KloYPALsR8AisvZWQqSTcw64bZd+WZwNV7HVfiHLq7Y=", "JzTMM2cCZFpXaeF2tiYnsK2Jno0+8k6ENXIU3qBnXho=", "GaC8Wk7WW1GJDGCZRib4bXytNxmHngD9F7Tbby7wmqs=", "HbYIfqn0JoUmWEfeE93xjcRGsVj4S/ogpSfWLsmEE5g=", "HVRL3zwvELSu7rhUOvVDCXBfeidfCT7cdpAZe6Oly6E=", "KxqHYSeSG3Xb9Nfadaa+23QUvF1VyZjb7kn0fOIA87g=", "J2qzNQYuNhl/5EJET52UUMt24XHADD6/t2F78K+67qg=", "Av7VjVkgsFvHQstlodflDdjmobrtwntt461qT7vCWbU=", "H2AKUp361v9i7xcZdK1w5283M/DJjg6xsQyV8TZ2CVo=", "K6NersLDj0+qrOUrvMBo0wshFJpgiNBGeVJULp3YMds=", "FmMOQqqrwCAWPofBv3RjwQB9/c4+HOnFwo/mTBt98JM=", "FYXjxpKyfn40K/u0vUIY5+0B7+E8ldqqymLS9UVfZQY=", "GNfPnAmPc02ioE+Town3dIIOFB+aqS6M/KQtjiLGHZ8=", "BkanMqfVLoq8BEHsmwTSr2/36qCFoiwM/YKtAkO25k0=", "BP+pV4ReHgHykW8iQ4Ffjl48djYfNoDiWSGMDSjznxQ=", "I9PIkP1lJbeBT9PDJd7i/6EfZ+FMuL894ispBYJ20dA=", "IAAxVyOlbL1naSFGz0Kc7kCVLrxgezEA8hNUvgYFwt8=", "Dwkr2zmVMF6/5ydRLr7sHqSNKazJd8/RFpWIMm9Q+Zk=", "G4BZ5hYie5qDYJnp7jcyn7WiQX47W6/tcx2q7hK5saY=", "HY5gsl8fsdC5faDxfglCWK6qQLFCyXqGOyRfeHx12uM=", "HNc41lGdPoIqZ2en2/0jQo42HjclqVv2LTByOkFO0dw=", "IyyF1JJZbTJDzXIInFDzppH9efvWC2y7rOFmGibHpek=", "DeYL21ik58fvvZW1UBfTIBt0bnippvS+vrUcHW7k5ko=", "AvwQGgIwYFQDXvWbYOHj76ssP2UCf5PaIHVuir7xIFc=", "A/U+us3vVytzvqmVUAZHgtKRlDag8rXZIjstqXTjygk=", "DieDTMj76jiBzkPZiW5gebjoydtNdxktqria3TJq7sg=", "JNQGFscTuQmffI86q7xzHvUuDpZpOnRqOH2M5nbW9w4=", "FJ0n0MsBTlzpxBp4p2qP96N1Ad72A7Vr8Dl+3RduDGg=", "ALzJeO9pqAUXOnvx0dVlGIEwMlAuSh13Ktkammp+cAw=", "BpZKCvuryGovSR6GJw6tRPSfmGIriPTET/hoMPzOFkA=", "GTQhInE7ZiMbCny6GZPF2QTUJ56XhzX6B85oMtpNbmE=", "JvU1wgQkJnqRAF/SJCMKSu69OsB5pYp4pjUg1YcW9x4=", "K8Q+kwkFIWdkiBRFTL13lW9zqmmyAclPtReEWoxxmLY=", "DZkio2Q7TJ4XW1ffWX8QtwpG6e2kGVZMM2dbavt/6/E=", "EbQ4+x3wpFV/5rFAW2cgrUoVN/4bQviEuEEAf1XGGv8=", "FJXer6G9Hye3VBE46uIHc7oB0NnsELdxcHlV54/a6jM=", "Jqc9ShBahmEaAb0i2Q4OtS3QNAunR293EZDP5YerfZM=", "Ft2rzm5t3TKp+KOmdIUe2JduD1PB9/bG9aKMywDZcxc=", "BYHrplWgON5JbHhdMdZakZQEvCXwkip3S8OZpn/hIvc=", "BldippdOt87YD/QrU0vFRe1s3ghD0lg+5wIrnOQP5vk=", "F7/xpw42toSi7Z29lVMMvps4uH126utjNZ/9JQt4xeI=", "GOaCie01IZSRcvBuilndmwdNw8nbyCA9j884GMcKGp0=", "AqjY7gPV8DppwLDSsfNXknR7NCnwC24BH0oUE0Xlcks=", "AwAkOr7UsY4GH7ERCrrGMo/1XcUxYjiPnbx1N0mUa48=", "DyrOIYdxJc8ueKvpavt5/bXVcqNp8dpPLde1d29mUq8=", "JrfpK59Ph3ayua8x7YUPyB3/GPcLFlyERydfbqXBuoc=", "GHizpPrh05glOG+uXxmaGztfj1BFWrUAJRfL0ut7X6c=", "AGLQ2J6We7b6TJh8CoP2W8x5XA6pd7bdY9Yl4G/7ClU=", "CgOyeLJa4ufTGzEIKg0MxXyOekMvJM6f28zZNHXz0TU=", "EA2hIOwq53KSHHwEuD7Y7naC0gd89HdACGyYDgTjj2s=", "I0IiOyBaKwJ52eXwzn8Pm813KDmjTFLFfQdQvh5ROF8=", "Lff0OXv8QtysWEgPVzFod/mqIbqQj3AVPfoZt+UvNu4=", "I2IlhMhqirWfuvJWlIHZZNHhX4BzuvqMbpL8LAsYf7Y=", "Br+AjM5lH1gaGrJSYdZrdPYEtwSAr2BUzEX4HaMpCsQ=", "D1PJcnAs3uD5/KCnBQXLqvbJYFkJ3eA8/kwzczH9/XI=", "KYixp5+NIml8DVG1N6mzCPl5eSscpHzECLi9i6b2eQ4=", "DEG+AQxBiWCS90CTeR2QyFwEBPkoYfdLoXdt5toPPoM=", "L4jBkqgioqCy8SyzSeFeorPzscg+or9UYauwEPgL8+8=", "A6RDpLBwnr1AiRxZPtUoy56fZe7MQK8fIxV0t8lzgYk=", "KPghHsGaTcGR91c3Ht+3iGlu/CsLWS1l2Al/OOcj8TE=", "CruqfvI6XZhxDkKmab+kIwWt/B+OSeBbs6vclsjKc+w=", "HwT7VKCe4t8oa2xeCJVguPph4GK8kPtymNUhNJEhGrA=", "BnnBu7/X9NDywsGNgpSNBg81Y/KKGmMsmfLGSkYegmc=", "K0TXDr6Web92gbLhoySeKbXYABCTZ6ekj//1PpaaE9Q=", "I/P54AkTjwmYtT+EEJMwekGsOANI72YuNI3ignykmeM=", "JIEacM66Un6mx/r1di9YE1kchlFw0oeaCLytSWsjIBw=", "AapTWBH7sT/jFfQRzuA+IKSjxI7G2vp1/tDhI1LDS7s=", "CuPfPk5ZyZmxZgb/OJAsdhY04rSdY+pxaSmmHotXMGs=", "DsGsyquKduQ8SYTzgNL9Sh+Lu/SaFriJRn90JMsGlF4=", "GxbvxXKcgVZZvLG+z9HhlIZW/63/B5eNE4tUNJ+Xt28=", "EfsVFK4bA425dQgV2rXX7pKc+4BnSsxUG9BnmxH/B10=", "A+igi88J7sHcLq2XhKkZgQzsZJk+tAzUk5nC6jHvJ/0=", "Iy3AYXtgNcmPZv/EqJRdH4eN9eMljptUIXjWuhtoTkI=", "ErLF1RoULX+KBUAiji/zzsd46R5P9wHe6iNexxQgR/I=", "CdbyIorNudSgZXesn4928shY/1MblX+JuCKo0o33Dws=", "JuYQGP5LPvbZZpVMdMY+HhWHeE4nbsGYIytl49HzttE=", "C+6WNbmsUQCZucgt1iIgXGfxNhlyJlk5wMGX98SKDoA=", "Lvx0VngrkCY/V4U+soB+Z6iM8V8sx1a39KlXC8w443k=", "KD+y6NaxjsP0EV0EMXU+tvrP6Z8JnsZ5q9hWkX3CL44=", "KIm4cO6YaI+u6IY6VISvy2eHSzOp8MF5S0apJj4YGrQ=", "Bde9vz3w8B+6+cH72H8NjcNUh15FFnhHaupLDuDAFrw=", "GyMSSjZ4Adk7j7/SIusn0UmuLumMa53DC7Kc47UB96c=", "E/Vzuq7TKqY+8u5RydJamWzJzbMzv73SuV4qOjI7n00=", "AP2GxjEq5TjFgMb75n4HU5ZDln8HXIHPxQTUoLUdTVI=", "EdB+GQdI0V0ARHtMZTsFWIdnfR0MuJmkpwkOoHqgs5M=", "G4++s8cVB3sKCU1241cC/+vEdA/syj+u6WCNRgwc3q8=", "ApdCPiEYB4RSe9kL5j0CH76MS9uLIEOY7h3m89QfzDk=", "Bp+tSy6vmp/UiRvl9PEo70zBHkWXysfFXjsr7e2MBaQ=", "GzUfMOIEwhKl6oa33imbHfdE0HyP9/f0lEUUmFFgxJ0=", "A8gUu3Bvc/kzuwPTv/g/tbeT2DjC3gAInV1YIYPJVKA=", "JjwUgq+SZy8o5kyj1NxTdIYuLmCwLJ4vqV3sqdlbn8g=", "INU2Mti9UkLZ3JrY+rxIxsYMb3GiNYB7GzvQ1C4YfAI=", "ExKDOEbU0CHmuFRHjajZ1j8eH+NqCMapWVLuTRuCRX4=", "I6vlmMvJcf8LZiXkQQGOH/hOoH7Fo32zrX/y4Y0e/fQ=", "GJsTShqnLIBrqQ1wWA7nWNlowaCsvB1f06qYgedCt4Q=", "IXOTlvgZPU7AFUy7MC1yJudWO4A9m2Y5p8oGVynYem0=", "DRe9pbDysI8spHYPvI/sGclhwOuCGVZaIBfBm4/q3c8=", "IpT9ILYqGFSBlUDlVgMCtFQDFI226YkL3gsKiD/hkJs=", "K8qhIW1XN0dcAT28PYxU42vgGW3HHqCYGwFgk2nSBLw=", "D/xi1Zy473HwPVt8/73z8eios5Bsj9Jbm6hbdW93TlI=", "KCsplkSICQaMJfs0MNu1vbA46cOBDVVNerPKH7JbCOU=", "Ixt3Z6TLsAiPzxVv/4xxy98Csn4x37z3WXr0n8yZ1hA=", "DVLpcD1P0LQkY51LgXO8jucwvD2zyVncHx42c3ur6GU=", "Do0SBfdokOlL60RglVrpe1vylWccsdCcWBuA0Mlyl1U=", "CbXivIKKvvqTpQG/dcCmdob9igzxBv3PrWWo8guos2M=", "CO5iC7c0IsazyVBqlz7Q91T52BBhSP1ibNWgTUOGgA4=", "FN62iYOvK9s3a4czA+B/RnLXd5j4+opIGiLCI+s1fRk=", "De2yMNlVy5sCuopYYBAETkxuyoNzGStf/9ElKSfOCbE=", "FqbpAIDqGqTg0ZKqE/cBp4EUI3PA2amFpMpacObKIPo=", "F8/kbtZEHu4ems+/z2ae+zhvJw0UJCmz0cao89mEz5M=", "CdQ8vVQ0hrMWlLsfhW2HbPPxNbhqoOL0WImWaRIoDzE=", "GBRXZC5pFlfVskFLeoG+tYQyqxyau1iMfhstofHoqpY=", "FAUEYUg5/Rb5DxpaKknxnIsuCjoKxn0foqMc7UPzons=", "EgSHBhyn0fo0DxGy1scRXq+5cVaVKUJBcbsdPxD7Kv0=", "FnjqHJqfY/H/DR62X/fH1ccEsqDaw7FVBftFIkzM44c=", "KYlkwoKNUqF2S0G1+0YHUq4birEI+8BwvRvhW7b67XM=", "DOl7byd3w6Xrhv7GoOplqCPLm+5lJTFXoLlzOsakTAE=", "Ao6BkjG1VB57UkPP9vBEti5uxfuK3t0rar+Hmt1fj9I=", "HQSikXB3MHPDaAoNc7oHWegGMLuyeY9KbnfAA6FFttc=", "KsMuXZB7ySF3lSW8ua1K4ajHgv8Kvu3tMnh+slJ1rdo=", "H3YA5zbfg3QE8MMnIFz7kxzqSLsUcsoLRal0trWZi5U=", "KSHcpcDcO9MX4MoVV+LnLG38SFb/9NcF94p+H1X1o+k=", "FPgL/FIfULjXlFekwunXVT8/M8N2Se4YpDpICrLNW78=", "La4FmsFwebFfa20N5kemzpr5zJtd9WWfFpvoJuCudFo=", "J60fxtpUZbi5AT8MzpbbSvHdDRjieZtzzFQWNlCEptk=", "E+qyP9At4BTjBVtKtCiBUJxrYl4ESI6O6ThVfGaIJh8=", "GM+17HdesWg9t6cyeUXfRFAuRBoAgrv3YIJf3AUFTcM=", "Jsu/vHGc8GV9mKb8p40lcq2yMBk4oewZv3NBeMIghlY=", "DM/i+XbOK6QI5DHKMZ6Vv77tWSdB4Lsz2mOgP8hALT8=", "Fzh81mghT3Nq9YLcv4bACoDct3JQvgMcLgIHE5HVN9U=", "LZrPjqptFebaf/qxThY1PPc39+VYXvni5DrKxsyHl0I=", "A5Okwe6DevrrEBFM7RL5a7kITdSkwnUNcA6Ha2yu+/k=", "DwQHpxGLaRDdkJ6JSWa0JEDWFtpAPgoHs/hvS6gBHfg=", "L3c1dl4nif1NBceDUMNca4SmmnTH9p4K+pk0Lxxs3Dk=", "DbqReNLvavHgHNwt5+hVeEGMJq2/N20GPLa1sRgfQbQ=", "IUT/1Wk5XIMHP4guz8oNjJQosyyUadt3YNN3hkn+J10=", "KYQTfF4gEti9ebHVkIeRW5l6iq9WjfNVvPUx9AFDd6U=", "CTTzshkSkc8+YxgiCHwZ+DWijMSbmHQngyJM5s7oWI8=", "DgulkYqky8OMR2SKWyjYPHrC/2ikEn7OmINrVCmsMHg=", "BJo3NKjiov8voKAeWmw8z+N9Cf7WyPXbp+9MRrXTO5w=", "Kf/4GSEo+uvG+oQywVYrwBtyibP7UoXinRKjVWzArEk=", "IgGCDePPpKohY3vHQq+qOcNhGVEzBZjmGtPc2BkIGOE=", "CUghUnZX5xfcF3EnobEFMaKp0Y+RQaEujJ8C0ffsGh4=", "ELWNqjbFbvLypN3hhpjichEvzAHmh2mGjp7xte27T8Y=", "KdrWjOWIJLpdibez5+wf3ZXCU6a2qytsQY1TpX4+6PU=", "HvddDfL+JJ5vzsbPVWmbvWFrux29s4TWqiH1xrV5Om8=", "F1SRQmewsJqUhoX9fWBpLabGvJkNO9hsBdFAkTKSCjc=", "D1k8mXrgqUJrT+MFS2BjU3SgSbxVr40Tc1oKkDkZpm4=", "CqkYVMq2enoeKYKo5RWEWnGRNTD/Wu6YyR7r9542GCU=", "EvLmU6c6kHc2e2q9416mjLoUEGKt59NYOwXaLI8Lqtg=", "FpLDf5Zmf6YsYZ/hoOeavfhtm91yQXKCKNtgCf/b9Dc=", "BOgzYgsTnVDgM9/tOzk5RXT2MTceMcK7DpxEq4oWhJA=", "FPE9/T5Ygagg7OH+SERiixTaq5wPvv6IrNGJXENXZhk=", "BFi3gzDXkCtOhPcMJQv6CBySuh3ili4ZyrYosYYI09k=", "LFIHflutps71OXAZORcXJkFAuKmbfS/eUg7InTEZIxI=", "Ad4vV8KBMyJkUAGVMa6G0WCg5ygJ8BWTwXceTsynojw=", "CnYfzSNMK71mG814j1sUpe5CVRkLgf0xU8AD1ooxmac=", "DryXThf3E/PqDYsS5GP9WvBFAUkGbW5yMi2NDh4baDE=", "G5bgJBtyIakxJSFSVqtggTWyIU4vBMEno+RR1/j3eH4=", "HfNiOoGs0XsOtFzuZjjR3R6Elm44zerYjKX5+QlvvM8=", "II8Rk7dPSPUAIdHAzZd9vGpV4vaO8O8AAM0ho4zlvwg=", "JGNSuzbrUS/082/Y33IEL2nPZ/F0RSGJihF7bvrseJU=", "Aw6U/0AYpalyUwDydKYZ3kkBd9FATa2agpnvKeCwTxo=", "H1I1QDXkSsBQ7obKYxwORetfdbRNbn8BsIBeKAZqzMo=", "JlklDk8uzD08xaHHQ1WqAfK0w66sYH9983LBW4Xsvj4=", "G+IxG3i1wSRvrYqMNG6D5sCCLfWVV1iLVRG06CHivyw=", "BQm13k3/cy2kNDcpcrRm0RVNGU4QkVtDR9/QZlpyv58=", "AyR2gIUKWGLAj7yw/vbHOd8eiAQ8Ol5zUx9oL5P46XU=", "LREFQO/2h6lFAQ4EDcQEl6PRNguZBzur1pEVQdML5fM=", "B7ohs61PEz9pYnshHBLzJE0atVOubWodqoiNAECwd3k=", "IAd9tlFWqN+3wxYKgdYuEZsqhhEYvj3VCc3M7/2ojRA=", "HP6iuJhLYrKPvWuNvhNCQOK8ENa7vTwvc6MIhxCwmXM=", "FUm6l/xTiGdQbzSZKafRuGITiG6NKr+2D84DaHmP0pQ=", "JGJSq3zzRemCcXIl+VTnTnMDzgybGySx3Ab+EP3O5KI=", "K3UNd9qVd08r7hKbMU0cPdXjArZmwr6kbPiGWF1atts=", "I2/UlHd0OV1/lCNSfFujTKvW96lQHM0zNTI0ki6JbhY=", "GKSRev+7d1Fmf3Yp7Aha8akC6bVHGgLIngVnjWILsNA=", "Asz7d/ndl9fmqLqe3kI2QhTFKgLIoKQgzNB2jfyhcaE=", "GNtJtPmfaFkG93KTiYBoJXKDehNw8CPQ+jefzxweyFQ=", "IEDcCeh3y6AE1AYbNwHGqSsD/KQcHcbr/1JcdqH59+s=", "C+xcRJTAtd2728vG+oj0ODBVJbTAivWYYAVcH4tz7Nk=", "KHnuxH5ylznR956D96ceYx7M7CyDtD2t1u5WhB+DofM=", "AaUMOgGAWQQuXOlaeJkU5cKAC09O/hczbFsqIWQQAY0=", "GVC5jCK488yFXBZ8fZu9/U6jeqyYsSsfsBclfD5/KT8=", "E7dxDZIYwLFp7koSdnFSdM6aZGhzDS3ncxNJrRrp33w=", "HvgNkIBe0oL6T14ShD7Uq8jyL1tZ8E7hM0kgmou1ge4=", "E6vEgtQe8ituPQ25J2t1WZBEQ4r4lAtcjVjn3+gMRMU=", "Jn1hZw5T3QNOeVuyDCCRIWOlgkhwnVq6ipXA369QsCw=", "JEQc0c2BReQrRx+C5Pf5wo1FrCxV5OYNPmbXTotWORo=", "A1X+iD91waQ1PBwNrO7y06camnTGIFMZnkMbj6gcuNI=", "BVG1P8kq5jwrLsvfQM6TeiCV/OBkdILmSg/fUVz0Lqg=", "KLaqpK7iVgcdmYi/8bzChO1op2FGIjkuU0ZabqkSWLw=", "LfMdhH2//LBEQljmmHbtO3RjpJRUvmq2JQqERsagFwM=", "G9IkU9NpUP8bobSbzEP5ydS6OIt4DEP0rTIWudqNoSY=", "ITq+J5y4l/p0m26YGAocgiVVis2IZnvfoUBwuqZdyBI=", "BIU6jq55DDTldRiT40upMgJNnFScendR1Ta+nMmva5Q=", "FSQvvjFHfZ3gxDHSXQyONdSJ3NTJn933LE8K1MSS3U8=", "EvYyPzHhRXYyiVep85NFHdyGiqV2ksoye8Whaek6ujk=", "HdogNbdYDmO6soU13DkvJAhdWdC7+7VJkbo+6VY6GJk=", "EyUbtzoo2ua9SYUB255sWMT51FjoaVWWZpss6QAHYp8=", "AjHs7dKCgTag923c3cWPnLOnfKBcTA+5XdtpYEA5Eyg=", "IAKnGpJvziah537kn2iEbDcbdMp63dZtp+xShrt8VKs=", "LKtvD5i/EH80XiLb7xaxXq2UQHCYqTOtBZGzxFACOKU=", "BAGnShe1FPBTLhubSqRCGt3+xyafk0h1s01Pc8+eh2w=", "J8eL+j0kbahPzHZcqLAOzfa6yiyWd5ao6MjhxQG/W0M=", "GO2YrNLI8UCtPVZifZ8Oi0HoTjDdHBZeQEPBxD4y9mM=", "GI1R995w4hiFPESkDlBbOPRcrKjJLVCQ1HTy0BUw2xg=", "GTC4mzMDE08fkAiA/Xw5x7oAqWqXL8T0Oxfhnj8fPUo=", "H8yEJqSTZzYZnuaCnF872UfPYt0KkuetSvTLr7SQsKg=", "LThHlx4zaETWJrbDntJT1plAAr0H7JRrUh4G6Zk6LUg=", "JCF9aDuYydYwpwTDvEVQy/cOoU3U3XcKukW0H/OsAwE=", "KK7yaeCj3uZaHfQ00bKtTcr46ECxodBns1OimG2U01o=", "I4s9InoBKuE9/LbwsGURuaHX3d8AkymfBACoh6kOBw4=", "GX16Y0k/Ies+mREZRMwTAmlGH3vYjTAvizV7t9aGgX0=", "G9ysmI7bAKNQVWfe1vlEClQt8J4grrATxDlyu/s8p7Y=", "EWkXEWO9zCwMi9nlax/KZuRL9h+SQzQ82x4THMA0sLU=", "CrZqvLeGlDeyT6zs7hyJsY/40tAkBGv5eLhEoaXdEjs=", "ILmlVaiznwz7xgMafM3mwRhavNBuP2+ixmhQOLh02rI=", "Ay4HAo0f73a3zLncVP9PQdoQMf+olSxkpUN5g+g4zOg=", "FXNpQ3MJW8MQbpK2tieuTH0P+OSZyy6kJtBE7tgYzwg=", "AaYC39NS5D7LL2n8vVaLYKFAq1L6n2W1OvExI9URywQ=", "Hiv0+ldOqQfv6yhfZ2a0oX2zW8thhshKBGAtQ4puMhY=", "JQXI1BdznyHSFiEQ22Z3AXvdRunhBb1KPVYUfDcyegw=", "DmVFSc19oVooCNBthhF5bAAChvp30C9qAjDevvyIwhU=", "BvunMsYWx4KM7FV//s1uOuIq61LHKiEOAH/NxcN0AHk=", "FlgyGtnD0KNjnvu54jr/MJUSWZ8N8lGZi7OwO3ylaSo=", "KzMFLGGDh7i2Z3mby4Vmprb8Xizj+UQNAl/akVDUqCs=", "FBCxrp2yGODKZU3nDwXOzHlTznEK76SIXwhjuOA0cMM=", "GEjoDtFEk24xIt48cGz7cH6j/OMQR+Yyx5Y4qwHe4ek=", "J6J//V58+h3FVB28lACFvT3FkLIUc9BThPjEY/srqTY=", "KblBJvVTaojHY9AwGuNmq/JIa9MA2zEjdi3zy5PR2YY=", "LVuWzdAsYQFKIo+rraWXpl4cV1d3IkgAmAK7pFC2BJw=", "AgLFNQpqN8bxWREu+lFr6XDC+I4WwBqoRi1i7k5SBD4=", "LKxxjYa7aLgM/D4Xy3QGCdQlqlR67hT5EFtNqUkNqN0=", "KD4aOeisCxkTlD6GGKGcicXHS1jVkpmxH9En8Cz8mJE=", "Eaa88O5rC59vYtwMSBaMrdV26NhjkPhcR0S9cOPB6Wc=", "EmghdxQRGGrbVe1+WeWEgyu4w1RN7XIn6NcHpbNNYTc=", "EwHSgKEr78AvmhPzqSUB2nIIJ5vAPZnnctpJDnrgack=", "KOcpzZyicWz16CsMFUf/PEiVjMxJ+Ab5381vjZCy5CI=", "EP+SZ8OxkfL7N0UNTgFaoTeyXxIpRDDpNujRJKH5jV0=", "LBm0mdPcT4VF0xzKalimJAyyzVzgIEI5387dsrd9FCM=", "L5JyeBLIYvWrJUOuiLtVOfymqXzTMfpOXgLvcjEBfuI=", "K5vM6hjQP13k3Lmk8QrID7RL50b6W/MHJP4EwNV2gUs=", "HIW7F2HZfkpXb69cU7m9tHmg+8N4GN2osqvLNl4Kc/k=", "B9rp6H3zekAU0Rh4tJ4FcWKKIP8+ahAikdIRuPux6o8=", "K5s73+NCmHk1ydeA3xPwYfbOmk5rRwzBvHx6qlMHUzI=", "Eq2r4odJi+nd+rJO95m8Sb59WPBpy0m/AcnEsVBdBYY=", "KyBqEaku21R0rnq2W4/oXUUD3jtvQzB2f5OOfGcGD8Y=", "H1QMSDfEpKddj4MJNcbS5Ncx8jDdp7pQUqUNVyQ5wBk=", "BU24cmBQr9oOigxrXq9fln2A/g5LhRecFj82lwcA0qc=", "LOqa1Lr+E2zONJ/G6q4tsFBxEYtLgvJZignNyNsAWvY=", "JS9pnqc51VZC74oitFtY7qjVWQD47X85H7Hwd9E/lPc=", "HwYbBLX5J7IQjHtr55XDyTFJZRBwALE7tjKD9BklrYk=", "CEWe6nOpSvNh08ZW51+X0n9vHkJQP86Oy7rxmikYaDU=", "Gz1wD+f1GVPiJ1YE05HxNsH9qYaj0wIB7Q+hQCCKyBI=", "KOVgKHmBlu1esNiO2QXVsMR+nWEQx1YypaLuioakhh0=", "Cb2Q8jM8TCy9S/ft2t0f56keW5iQivpVl4HZiiV5RMg=", "Fbwabmuq1fawwq4zeKJSsUKZ4K9m7MtrJmgUJ47RJ40=", "GcUvDcyqRBmaf0/DO7R9Qdaggc82MX5/4Vno/msfCok=", "JUe7X/INteDFkpg+VPyWLw9l9HhZiyzF/s1y8WlImpo=", "HvC8pwA2878dfT8pTIsKEFdpEXJ5PFvmWLjVX45TN6U=", "BBmNWOzc+vC5wtas7e9SU30QQxNrYkpaH1iKQM3spSs=", "LF7fVl7SBl19BP731PfhsXIqLQZMAFSXJeBxWUfCb0s=", "K7oz+9SosZ1sxShZJZN5o7Rqn6F8xcRXCVZQPvNOuLc=", "Lpj62COrqap0Cq4ISGDwQIGljeObuxAe76EZzWpHH7A=", "LSDCzQkKvQUzqgXksl7ZR56exLIetZx2VjcIO4epWSE=", "EJZ77unaJQXNxTvlyYN2cujzcpxqeEsBOXnYq4o8Cok=", "Eh+3rGhe8T90/4Kc0YrxQLvtJQ21iW8P/OukLV2AOj8=", "AULghYdohOZXLIaJmKDqMXdvOKsw5sb/dMu+8UHckG4=", "I8oEH/4SMfzKEtYwyNtZe9hEGRiVcU3RYj6vwgVsG8s=", "GjB2e19PAdAMKwGkTwG18TalJY96UT1vfQYn93iXDVE=", "G6D/ZTrmvYFXP615AVM8x5SAaqYW8aJjwG/N8HA510E=", "CUpZRaiBhC2AZ7p36eaZzPx07oUXYg5rCQ9WJ7/XKT8=", "IchPIyiDwEGgeOHPYI7B8woHuIWfbrju9yKfxryobwM=", "EPg/5Ss4oJG/rQfey/KV6GEMYxEoc7sFt+8I9wQ/e84=", "A3IzQB4D9ZBxkuR+cz95LBVSDH9Jdagod9tt6mOP1Ns=", "ExdD9lvtot5+S8+qekvco50Gb5ydVxUp5i5/XOR1EqI=", "LD5vtwBwI2bdRtN/llpFSGnWo/G479kM6pC+DcFd7sE=", "C8oujdVxnySQaZ6sa/wrPnxlkTF8dv+xUW0SbOPsFiw=", "CerS6+oSmlYCOvpy/xt3xuhnpy34GDn7dsJSP5RSIFo=", "GaIQ1742Buv5rs2bDI86sLsECZWEvOWnrio1oPgIzmo=", "G0TfBepG7BIxgYAI7M+DjmJ6+yzkt3mKqob2CcJCNjQ=", "Dk2Xj6LtBQffpH3RVLUQBtJVeOGNbJ2D+HNeagy38cQ=", "FU5NGlBvwMEAGfL4nRhvSvii0basOtqDHssA86klymo=", "I/J/JGTBFvVaW3SCoc9ebHvJnxLij7rcb9SCYHLrduQ=", "LfGWyS1TVYF4BcbMPKEClEDifbg7F/rkDDX+NRiVR1M=", "K3qJrRQZ6F9NQU8aNy/spqq91p9yH2hPNP6CmyBIyNA=", "IsKddIJIF6BCOrHXDVydUkmxahgQNFUGaef6NX2dwz0=", "LURVm/ZTwRKRj7AzyBU73ORJsPHnaeRruR5frJfvfPE=", "IdcPGBsyL3SrUMQy3flzah43OMTog2JYiUNNpQ2ITI8=", "KkN7lw/zJkW9UwP5R0tXQ0JzM8ZmPRf0TZGOnyygBdQ="],
      M: [["GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "FEDcJXj0RpTRjCX4ktmMI8/bh6dyIAAg6JeCPUvITTs=", "I67rDGSZuEv8Mq48Qt+XKHmP0u93TxUYuHC8V9E4WQA=", "HtnT6Sdqy3tNrlProUiAb9m7B7LdBhhyEvq33L5j1yw=", "L/V/P36VsDQR23kKhmR0Z1gRlxJNIXUg7y5jMqWzUYU=", "Ffrvv4WEo4lptKcZ/+XwLCGRqMztoLd1FiID0wuAIIs=", "Hm6qsRkVk94NicuyOZq4qpVdgprZWUKM1Tm+MLcv3pw=", "KjuwIMilDTEO9bXHfMQIsHf+JIFFR1TEVo/2aP5fCXQ=", "BR+BXEVLYBXH6/kMKXuQ6WBM02rMavB/mbXlH96zIjQ=", "KLdcKsFn/fGEclMXx7u4CD5axbupN7z6bO/LaeQEi/A=", "AjrzJFmWg9m3G2HQk9Y9y72X5ElXMz0ml/3QYMHktYU=", "BaB4aKfJX1CgFYef583x62wxfk1InUUVII3fQKMjKeo=", "LFtKZbxVrF++695Tzl+miIL67SqSp7P1cygyxy9/LDA=", "Fz+JXkcsTrFqKv87jgQX+zK4PrHjIzRxx2oFUFBdBgc=", "IGywOMwyhSbQw9xa8ZQ32DIZdRxe6PYbDp4vWIE2a+M=", "AkDFeJcWFmbyjQALiNM1OSHZZ0IPQBzoa77kK+KHpPg=", "Gq78Lpkl/NRTmW/agEBj/asnazfF9R39/vklW07BDMA="], ["Ew/FRHf9lTN3/COrvXpBvmdkiSqHh8dZwUQP4BM8hS0=", "Bl4TTLjYREfW6h4XkyvUo0Hr7yVoMTwkWU+vnX7KIRA=", "DnbEA5K9X0WLwYe+VAmTEqD+//RLRBY3Ag65JnCm/PM=", "C5gXZeyuad1687EP+kJLiusgbMT0klcmXGdTscxU688=", "Dk+wRKn8tAh+NRNB8l2YsTmbV24tZlRTTzSCGaCs34Y=", "MD45yojo2m5cljVkcS34p/hQGnr0qZDkzOwZ5fj8gF0=", "Abd5ldvzDMVfnUzUhJztlJNJ2oEjmgFUQP2zi4dqvuU=", "I2Q63TC+IEc00CnPA0yVgURVEGDBkBxCCijJaI7DaoA=", "GUaiariVP5vlWBBfpRefF152okQp2tXVMsLOs8/qBck=", "JItTP4deXujnUc76Sx0HMvzTAVHDpcxKu7sek7RlXUU=", "LnocUdph3SFKF4nW8e4pV/adIbHxbR+UWOslpAZQC9M=", "IGXjdO2x88u9KRncBNFK2wcGLdAewVAbhVIufg+vkl4=", "LzZTWoOgnPCfw4ogpyVHeuxWZo8DSjZKn0pWBf/9M8w=", "ESPTyX/45rWJ0Ri8QMoLmsEq6QlVjyWCVR96QjRbRiE=", "FgswyHTZwGcEySwmbHpbf9lmpipdsAjxv/30Q7EJmoI=", "E2HSfEKntL1urrmKM5WSYWwNTY/Orf2xZGgWK9+ojUY=", "APHo+Ghgw7XHi8FN+2fSLGvriZISNliELyP3WuOpLpk="], ["LJyR9IZhdxuu72d0V4p49pw1XI6QcVb98m2znSRGQT8=", "LGsTPoCr74SQT6SnX5aPuqvviQKG1f0RuHoeUrfrbQ0=", "LOhUbLWfQg7eYWkudk4On2cVsWosgEfNgTHJdkb1DSQ=", "Ctrq8od2uBPVGPZFx5Ple/FgZ/2A65Id1aZ+iVZGycQ=", "IIagG4FkOKKkHFnkPXP6mqzwwk5Pa6winWX7pZkiVUo=", "I0hYDeSarAHOj8taorRn9nh92Klszs1vtH331aQwc5g=", "H7a9bfZQ0n6MrAWsC0Xu8HAOMIsptL1B7s/1gCftxFw=", "A+lxgjfBcA190hPgJvMH6AALOFFGf+2eb1H6UCDCNpw=", "AJJa81ozZoAayAox1j90X6gHvaEFYDRa1XK+9M8s4NY=", "D4aS1kpbaalWxOIAa/7DREd/318MmquGZgmEK511Jp0=", "K9/n60+oA7wdwAUqRthQ7j4JHrqKfxJXloL29v1QRNQ=", "E72swTe7z1HYvJ0oGTHW5xEi3G6T5//ouDXjOTd1w9Q=", "B9eM4MHIc5GgagbIPTANUlJLKfGDiE4wDg6t2s0F8Gg=", "CYTBMrKaBfK1BsoHwG/pplhPNruHUG0tMWpPNTysXx8=", "GwD6qFE2sb/EluDqmmKEyuUlqpZhL/7rUUgIlVaTh54=", "GeHkZTZwTOzqw+q5kb2AbjR75AoLeVbc1wNzUv28Q0c=", "GcJUC7sc1OCPEFQ3BjyUXP7yiundULl+C3lfjcWuNOI="], ["HewLr6PoGQYh5eCV73UeoDyDbbuARbKnP405fPuBUZI=", "J8cjMvWaABNbqpS94pSRHRNdHZX1PFLrizuVWUN0kG0=", "FuZGYRRNgWiFsy8/eAlwNHd4gmjVfBSx2TmiaynLfvM=", "IBjbOGo+Tlfq2o2RQIsVUGHfBQFA+yL5pPNPtOLQJCg=", "EiY7fj895giZosIv7pGZcs153Ciah/MfG0S68kOdyHw=", "EOQg7cttp2Fwsk13fOnTFhLtsVk+ptMOjP2s+2l0+ZE=", "DryzWPlfhLcZxjHUBFzvA6xvwjj2g0Uizr0C5HQRu28=", "DEji8wT3MNSOg9rlx4pGGIUAvIBApJVC7qXvGiG50iI=", "AOdm8Dr7t69jDqqK/0/mDzgQ8w8/RDhJjv4BhjM9rcA=", "G4p5CdfnvU8LzIADlo44SsLotAWtBc9hA2TT7LmC234=", "HZLkIT2ECjMOy9sIaT2/mpcbvWIpBH64igPzNMre8ic=", "DTs/uGpEt0IkKaJJiEyFZErxl1ZBIG5hAHDALvWp9M0=", "Jcfo+vbEihVsuR2BqZfGZz0yaUo/3WT16VlOn1BLrYM=", "LXr4NMnN8bOMjP7SGPHvDOC5kI3p56p6VRDE+5F6AoE=", "F1r15Q5Whewtuxz3os0l1FaA9s3faNfAeV3smLh/anE=", "Eh9KGNe32WUKq2JevoaVqAeUOfKrAMCQJ53nRyYjTm4=", "IfCPmzwj86AlGBFKlpKbbRBW600dsUfODIiC4bD3vRs="], ["Cl9SrW7EqKo3fY3SrjqvbuoMaMY6HQNPvaZxM8oLhcs=", "CHSI9zWx/i+jxscUjElo5/NHmxQYoaVmdDwcohXc/Pw=", "Bs8NuS+GsnMu5fuIHvAXYBLcSt/YSbm+TeF4RqbOXZk=", "BnxEEXRdtsaqZZ7HN6WGqPShzeA1LjCqAGN5SGX8HAQ=", "GZCSQcrFAojA0SND4MEs+bl5C0Be8KkAGqa+AokGOqk=", "AdJblLt8ScAXDuH7Klgktw5FVLzFS2yPjMDMnXTxml4=", "AydOc12y+vGGeHUoJUJy7gGWfmrp2CUUE3i4NU2EOWU=", "DKwyA2LiNbRY1tNkzQ//kU88BWrbsDjcKoYaSff3DiQ=", "ERHtema6LM1L6g1D7shuo1q0AlOhIJ42N/ED3LhPxCk=", "E+c2zHC3yCijjdY5Ts52ucza4spPQ5Y0MlAv6MKtGf8=", "HygFCEl2sUL3x0pBb/Q5/xvNi457BXATAEB1SmG3GRI=", "J6pQoOXVWIwUhujn/I3aZUif/7hmdWwhj4fnKAzd+mQ=", "HzzG9l2dNDcIJaOP0fSPUJ98VhcbnnpiTZsOzfasTqs=", "GxFxN5HqTLLhfIxYZ1AgQ9Coz5VThMHHk8UGt1/A2yk=", "EEVg6VxJ/rt6Awhi7bOjPCsqPUFLBTay5U4lqzbo8oE=", "CMRfPExIb2tTeMd5xge1FyALtwtVM72s7xhRn2Jbkls=", "LSGTxne7zVanT8KuUKtPLMaap3zPwzx3B0UtWtrHfts="], ["IKtzlL/as0TLtvISOACg4jUI4hJb/nlatKdnzstNkwY=", "GfDi4UGJbq5tVtGCtoe4psZMu1ngMbdJ81gi/H7jU/4=", "GPdUqVsK8ORwb/kCS7E1Fkq9b8Fu5AzC1oUtiKL/yfc=", "GT/g6bSAEPoxnDO4a2sY9CjzI/ojfKkYo4+qqRuklWc=", "AR/wkd1VG21YYgPuDK+uL3ZS6SOrqCV0pTtjKgZvSIQ=", "HaPgBgHKP8DZCxl70qR0tG7+Ov87LPrx6+Ffoa+t8ts=", "AE70GUVVnB+wshFssr4fBDv86NvJb+7MzaR8v2i+WbU=", "LwU/3xpy1q2Mnfl6BNY3kW8l40JbbcM+mcp8rFzH5Mc=", "Ha90hCx+eRBDSa05lZLFxMzhb3nhqG9Q2UFZh3LMqVM=", "KujajQsSmiL4NNDSNMiRfC+Hf/ANwWIVSY1LdI+0DfE=", "CZsKYzCSakoVZN/pT5oRBLuDdLtRioneCMWRwX36oFk=", "C5rr8EEUbBGRmXV+qM7uWrzqnsQs2yi5IcryHoSEeFE=", "BV7yceOIJ4sayjTTywARa9b3y1hLPGnw3ip6/I2Y3rg=", "Jvvxo1GWP7vatZDb12DOYoQnNSWhtGxB8pImxlM59LM=", "Ev1nhjsuA7b7RSJPsEH/KA6TZ0K1TI5U04I+CQ4UQWk=", "AGAM8mY1stVGQxUHWJc5AQ0bdXzqrmF7+VuOHvqYZD0=", "D1KPWRK+SUVdQyOyWeMM4phNgXBgHutL1wlrRzU6t/w="], ["EQ6jIrDCZHbGe/osG50XE/k7O5z4Mgzg3NS2Qoi9oHo=", "KZxH8ePsxVerHJq+NvDSug7OAQUeB/CFjpepzhb1Zk4=", "HMBTpqTW+W2nfl5zrbnUm8TQ7yzC9p+t5IBAt/jXE4Y=", "CVWOzFi+5PPFePYkid2QCECpiJCWwKYhFKotsEWh0DM=", "CT19VWPjzNC18VqbCT/muGOqzM+a8R/+qbKVt91CsfY=", "BF3AV5ymbn4JbU3Ya4guaK8tNdcM9eOxeDyqoOxCQlM=", "DaAvZBDiQFih6QQSzVMCxXGX97GvKplJb5z/P/1YgI8=", "Lftt1ZitpX6nGo1o5pJGCPDseDiAhojuSz/NUh975tI=", "EFcGK0C9zx/iqu9FiYyHEUZ5mpLIfQ/OZDAta8gxct8=", "JubRiup1qUhhoCMztTZM7Oqnit+7dCgXIYyjr2B7kQ4=", "BWW5ZlkCWTXZwCXHqyCxYR2wC2fsxRQms0L4x6F/7YM=", "J3a95SoSWUcsHMAg5xn4IZHew6t2mbfQ/Xad0/45KZc=", "DBoyTEnRX4eTGCGYm4yEN+qetG7Tqs+Ilf0cwxEFPmA=", "J+aFaOnP/Qf5JT7528NWJR3GstapA9bHBGtekOG83Jo=", "HbDn4BciqtIQ5SlsNukQPoLRV2XDGBNNF3FGodn9U1g=", "Cu+KTkfV7HYOBWWues2r5+jpiXLeht0vRHqvIWq0zBc=", "CMAMTls0Z/AZAfZPn4nBW7C5CRjUiLcwyswylmkekgA="], ["BU6r5hMWgfoB+8bb8+fVNZXQ+ICZhxghQriQrIr4nL4=", "Gkvv4RwCMMYt5E/6/qDekDujKMbWevc2gDEraPms/9o=", "AeQGZfW7jFwNycEfOdR+nTPnF6+jG6dPkvhzelXv4TQ=", "I8Sr/rgxkjYqriGy6e5c/HZb8QAPeYw65wEzVWq8eL0=", "FmnkS/AiOnf0j/+8n08gtYFPYYWuEaIQ+P38tfcdYD0=", "LVs/UjqWaMvkiHiBv3tAGE+XhxPjWN4nDYemAOXFyS8=", "EMGFbygvVW189tSik2IVBnJLptPFguTCYYQvKkvbDsY=", "IsxDSfa6o6jgth/ECrlyEOS9Oz3sfwW7jvg5yEaSr7w=", "EtAZ43zRvXb+4GW7c4CpvYMxpNvNHJx3Z5K8GQRcI7Y=", "J6o4+gUcQ0GJ31e6/YByPuKb3M1Z+8GqmvEYkdNyLmE=", "DwuTNttcFtRy/aP7msE7EzlMCaufSE7PatIGAhe1iWo=", "J1pvWWIzVNcdOLTiAM4ulnaqt06ouDZvzjO9vEfQWG0=", "Auu2cw17r+rCP8C0V+qCTu6jxV7KY0vySyrCqaIUg+E=", "D/IV6x443GdDLiYt8n7afDqpQZ1bbimb2UjpcPw1pi8=", "JH+cf6YQMiU1/rBnbP9UnxwXfQ050/Hu5kLpJTqvuC0=", "KtC9n3HieFCEqguEYWt9raBTIHxBjmX0A1vmagzcjBI=", "D8PM7wDWpkCAq77U/tkLacXlgDE0witCzcoKYPA+wzw="], ["Ik2BH73vjsCgBtN2oBnlfJO9WWIToHgjt9Srzh/Y5iE=", "FAdi0wxcOgsHULFACoap4vXPwlMbcpNw862f4dzUP5Y=", "CXbXw4RLyN7qDwM3+JsqExMC/9LQqHAYHKX9X7bU+2M=", "AVJgQgHKffBZlOnV8FjztnSc6mOqDLW04cOgC2ZnlY4=", "GrbY/jn4e7DuW4g+6iclyqUsV1dA1awwsFj3cRPQUjk=", "G2K6gDeoPxJhVEwwfwGdvqHMaoTUgeqJYLD8ZwdF6K4=", "I5q8fJ+GauwoaFwm9OBGqS1DYNNstQiQ9CLhjtb4p7I=", "Av7VoDIAQXZkU334+jAna4XZG9LtId4z2QH7TYJDmFc=", "CZbK502WJ8o8VsZGCV85cwJ00l6CxCziHPeJJT1Io/A=", "ME28CTaGI1bgAksqMt+jCFq+29M38iuJBivmFNg8sIM=", "Kn3o9f9HbYHTk/HSdGNsqVbwW9QivJ88wPrABUtYywI=", "Esb2yDo1MPrO1gyI8ZqC/RK32TinmGTtIKVFpS/c4R0=", "IB4D8f9nJilHOiTzLS1QKs3I/dKIMBTedMmPQKGVs+Q=", "EYw+/pIMnD+QfIZ3Q9NdLMv/fInpwxu2oXxVLvkrbAE=", "D3Bf66XwHLJ7J8EEvJPwyXT1Yfom1WFPap2eR9A7xlU=", "KNMnocLWAS2eaemjtMEa0zbTwNzf9MXITd3fkR62RfU=", "G85n9NyZVH8sr/G1xtY+PuJWWkBBkGZFM8HGXdnY1TI="], ["DmkfykIxKKfUr8qlgrGpR5m6H10qXVO8K7pWu+yyJ6E=", "GAqkur+nU5dT2cIi5eM1mspZ4Gu+/Hzzo/+k+WH6HVs=", "LFQofu42jV1S37BoKC1o5rCbdr0bXJMzs2hIrCd3RPU=", "L2U2GkrtMg/NA6RcRN2nQCE1cfOXXOILlr/9lgy8biU=", "I1vxeLW1YmLZiL/GJwiw+F1XOFzeK02s+ebVkt6yr+Q=", "F5TsKw7rIvvXU7IfzZSee+2zBfFaWer3SpYcMEZjX4U=", "CD4c1ZQ0YatQWyADEb3kAD+09+0WqljIvCjy4I6faSI=", "IqZ6iHdpgtahX1d9z3gKxIXrqub99vvlC5XqJmp7YFk=", "LRGI2efmrCTEssncPfz7D+R4LWifMblLH7Fe8p0R8Z4=", "JlxDyIbwfQJSANVs0kawFnCz6Cq0gvWHmxBgjMBaN/w=", "DybQXpOPgxe9YI7/CJXTUtynErZTsUkvjC6payb5OB4=", "JXaJpOIvaodoqv5UIY0x3k5An9v0IxlYJTa7WDMTo5U=", "HtxX8XThMitifG+dvieuJwPD8Rw2SzgYi/QdjKDBcJo=", "F7OfOGNtXv9eBu/wietWBRpgK8j0vxuwrSss0QzwcTg=", "MGCU7P5jMAsvlbyYoEBseJjYaFIzCntp+bBLVASz7vM=", "Ea/syFWQVDvS34q5Ur4WRnCj8yWT6WLUvUk7zTyE+E0=", "Gouk830jFTichWDXTaxXKkRHoCFFUWKHBT5rnt77yi0="], ["GJ4nnJLeC6tmcH5ubjEFJOYVzUxqrMZlNyo7jjctjOY=", "FyCOqc1Nwabe6+ao0noxgatfhsanBub9AH/B62eOneY=", "Ioo0iMq7+fKe/AvOIRoJAxlys38l6jWsqEDcIzGgzzU=", "IhIsYxP8mkxtD5RNPOI4JyvzUUext4iqsrjbzrYCTHY=", "BmSaE+ZQI6cTqu5Th9OI42Ca6bFLpNoQZC7gt7ShZjQ=", "HtTJXGKDtF7AzYj1EZdvBj6ivrBpW4r3zBBYlZOnl4w=", "Ff5ippsEOClDldob/JMnLYh5fO7vZmuiRD8MFG+Kt+4=", "KweaHQm51KdtTlDEXAH7dQixxEOo+yHr0oUz4F3viGQ=", "DDRJan21q7MwsvbOmtrvWubjCMj8LFY0CXrjUqp0V9Q=", "BP/iepLLQwDndDiO3DFHq53MSrNUw4D1HKei5/4EY8Q=", "KLc7M1xy8HdIcaIDDUROX7lUl5wcVo4RL7kRpGxmZ2g=", "GVghuZrywhdATuWC4piJByujzZlLdJVcJhta02Tlqcc=", "IKVvzjcSK3QAq2GmXqyBXdGA9S+tKDX3/ZZJBjUjiB4=", "I1EykS2y2gekdQxe1d8lkOcYQErvxIvmlTQy9kQkBC4=", "EFnbXpfyWCawu+/Wv6pulJbFXvWoj+/pcSaR9vvfQpg=", "CwUMiCBzpYHnZyI3Bc2VEMBMMBaMUP/gyYdaKLaTgpk=", "EV5gxOKTfrU8bkpUiPgBJm6E0HVHoLHNkbGPSe/vmSA="], ["HZvLvRe5OxkT0vec3xKEREEjcgbwKUdG2T+OW9zrRyU=", "IAB6D103eYeJ4KjvaDU22c9IMaZWbrcntBGR2fKXRxA=", "Frrkn167H/6Ia2NNIV3mHr9PRNHNxPhGcN+O1pMQv+I=", "IpqltUemN4DY0SniCf25L4VmJhbVnakIB15mj9gXgi0=", "KaWx5OLyVEVJat7CMO1To1mTs3YwrstdduVmCNG3jMY=", "C/znsSAGi5owAp29s2vgHQcegWP6FyTxPGyom+Kbcp4=", "IAVVaLMzZ7wSv0rtegkJwXNYildjxqGnWYunxsfjwqU=", "LfH/hmRPzEKhkyzxXTFO7UB2CCRvFKgJhyX/e+gJyH4=", "HU+w8Y8xyCcLRjbmtdejPkVbEFDeEWQYLPy3OczpZdo=", "Gdbx0RDZ+HPbAC/y7YKJBb1sxdeSHCONdWnaqbJAHTI=", "KCoB6PLOCcvdhi+Y/auj+a8CRD7cliyzSALQRHfeHiA=", "MEtnkAjoofCUSEI6BYieDfZjorZQVcqe5amd/hP7mhY=", "GZgUftrzqSqxecYawsNq9crz54vL+2hM/qFdsXuDWQc=", "AopFcstlQmHPk1hDWSPmWv+PQDk3UnSLdqz9Lj9XVck=", "Fb2ZjCcp2+rMwptdbk8P2WrQpgN8hKGhp4UWn7M2+24=", "B83zMJ4TD5zt3WiK84hTafus9tikTeTUUGZ8DXZBIT8=", "FS1HrLmwbJ0SwhOKMUFru7uZGmXcTU+O+Ro91yjmO2o="], ["EXkYRjWpeA7hMS3MPRXH7wQrGK6UCWcOKMTH8PubYI4=", "Ip2kQaMCkpsLrpN0G3x14RM3x5flch+dfuWSNc2ppAw=", "Liadx49w+RA7K87T7b1B4VbmSRCIe03d+KPu6WD2Abc=", "Iakf7YvtFJFMT9SRtvpNy657O4s9RWMDr4hsMoq/Rpk=", "KfB8Hv/GW1WJ4cpSy+AL1l716WLQEgAwJnC23Oee6wA=", "BQanpd5rVuvsXnCKcKPOyzos/SXnog7UleKVqTAjxag=", "DAKxSPShVZtZfNMg8AwCuWp/x8g4Eb2GoeecwxBrIgE=", "JKRm906ZpgKJT0IQEPQ6gccIsbStB2QlGQuFNH9oWxo=", "H+4YiIQlcklwvSiXtUx/qOnDZ93byEhNo3hk+v+fkFY=", "GXEcQddvZKNxq6YvP0ZxDe4MOq0he3ywC9EmE7JO9Ss=", "J3DRSiIBUvpwgwQL6bPNOMis6eIHBzSGvPr8rXBnSLE=", "CN/+aEqjP5EdNemmRLS9v80VpNpJtlMYFrYOjOT2teA=", "HL+rfLBeLyglSyML/OAX8AX7Ty3Yk1rRF2WzR9IANmc=", "IdcmmlPTcSsgVDsAOa7MlGZSATPSmehEIACzMYSjnoQ=", "If3lgKGYhrEzWPGKMtWv9oW0vXfZTwZ/RPbnqTNQ/So=", "BSMr+VgH5IrYKh60vEgemwcg6VGW3+Nh9VxNHPx5Jtc=", "E2AmRriLoxwNVEx1e9kYFyeDXb5pDDBYOiPzf1L+Xj0="], ["DkhGYYKugzOvGJGmqhlzZ0HtBoDVfJMe3hP8B66C6Is=", "ETe1xhuWhL7EHk36p2Q4JWYipDeOpOZGooRLvIW/gcw=", "H0uFVSuWDRwYt7j2avcwWmdz2bBfr1Hg7RpfLvL5Xn0=", "C6ilSRSIb64WcAwC7993Z0E6C+xaGe0M8KfYrGDB8cM=", "MCiclnjAMw+Fz442JoOmFE8iuEGqCPWG8hndntrveLw=", "BIkASPzb3mNmdhzVj8xqwKM2DZpkIz0+pNjWvooj7EU=", "GkFi6KdwREe+DB1NXPL3d2cPSEHqJ6wnCc1r/+7Szr0=", "LpRLRJwTac6XZvpvT5modjC1wfLWNnekN6U31htsdHA=", "Itbnh/RNqmtlk9/eVXbS/fXcBEfmWh1edxLk5iw73O4=", "Dgjdtp1e/ZScPWceTnjk/HYoxl7Bz7wYumoQGqGdv2Y=", "J6VzA2UJqKKakOqjTSra7V7R7GsgcnTzxcoj2tOIDlc=", "ByNyCD9iGVvMK1r6sQOBmKPwVGti0XHqIcN8jzFVEXY=", "FR4LwhEOQwDdgqTJJELEdRxlspRCbIwyDGnmGDGVjOs=", "E/Gsw4nE+OdSzH5LgcN64hMMYN+ci36H3F+3RZyvSRY=", "BoI6m6pVYjcysC+icLL4h/04BKhcGn8qNV3z++/GncE=", "HkGTbmvAw+1mXC4kZquSFrmXP+E22fmq2Vh4wbVgfG4=", "Bldm0pgDMaVcCjnYO+eL0Se67nfVOiQmjgZMcdqvK2o="], ["HJ1W9xwvIsRNOowXv1tARS4FRx8Lbf6f/kcl6yn3NGQ=", "ETADwdx7rzXkU2+V9Oqy87rdosehxrWvyVYjSt4+cSk=", "DV+5sOFQPyuSaXxHO2nPdtOPwSkS4sPLM5ltuwzfqjg=", "LhZKUk7iLrWokD+uHzWjp4+ILz46mJK2/0dTuqyTSUk=", "AfncvefQWBNKUQpxHQNtHxgA5HOmOzOn4PsE3C4J468=", "KFsgeZlwtYxjrJ9K9WTODyggm2GAIhTaW/r9DPJMZxI=", "DOPdcn/dEai8cxUA7/ojdjCJzjMyy3MPn+VxRu4gSBA=", "AQeXRspR2VGKDDCSlspIIGKSeYkQSUJ3viu2WmsTSzo=", "I6hdT5Htpp8xDEUdfUgML0DA1TOC3dP8qq5ie5YXFw4=", "JAZX1n+SteQmGs5DT9KGIGwxVWU3jOi4FmFSPw5t3FQ=", "I4SjhLzCxKF/98nj59Ex05FzxDEzOpx8HW/XEQ4lkCs=", "JVR7UbLGh05FOMqbNAk7cUrTao81bkx44NZrHxkAOPs=", "DlnhqZDsAPcu3Dckg0nXpab3vK7xWBEEUPHlmF8KXZk=", "BmxgkJNvawVPF96pFoKVQzKz4y2PIKCuFx1BcxbTYi8=", "GyVmKEOwmGqxpOmnZhk+/KR8cNSTZPA9UMXttbVRfr4=", "JkdjVHfuX6nnrFmD+S2zTXM2ZGxjxj4t1T1guHFL11k=", "JtsuhakAbvXBHNZ1omfULv759a+QRmsqr3XuqAJLALs="], ["IjRUb16FQej3KteUiRlQsysc2JHMZndcW2NZYWQunBU=", "G2FGj6tZySXxmGGGvLl5ZahYUjolgtQ0MZqVJa5xFY8=", "ARKR71FKENbwZR5K0NpdSkieMBiSeHnalC3v299wHd0=", "LfL7LC4yHjzOE9FgkXBaQMXHlfi0G2Hf1q59l9Y1eLQ=", "Abqvj/lrsiJLw0z4DDi/EwhvHkKbzuwSCQ2KfDdqmoI=", "B7DXDM/xtw2tm7SwFC4/bcW8ldN2av+tN4zFBCSE3sk=", "EfKO5dqA0Z4xWBtWakOVN0ZtnKf98UtwhoML2KwTxMs=", "ABPXsD6Pyfpkf8ps3KlxRpAd98Z1oWSRPCvSo7buPLQ=", "JEDnhheaf7z+jSmrGND8bPo4PPt0f3otFbd9gtmw2dM=", "BWFJIhcSuI7CkfwhgyQULQKHPN1TGZZ5/OTfy13akRY=", "FixbvIG0RCe+ToLF5SU71mwwVPXFtzsospI4SHhJp5Q=", "F48qqN+aEe8zVY3Mk0lx92l+Ymz+8A/83rbzycGn0Qo=", "JK/ZL4Dld4j0D7srefKUVNxIX7r7WnJj9GK3yEtOUAs=", "BJKuX1rCpRAuqW5grIN1VTaHFRrkQELb9YmSMsjyEAo=", "ENyxH4FcfinGa+HdPF92AsmOn7FofC2CW0h4nFIfvQs=", "ChHVh8t11IVE7sZirSfKas/smPeot5Y6KU5LsymxcN8=", "HdawlctoRZ3Pa9rdQ0qoH4ClWgjmeCxlOpOv2KZfMmc="], ["FMCdFVxdQoGYwjS1U9ozjyJ8vBKw5C8rnOcVY+4UlcA=", "EX/VKHcPsX9xjimi2Rpj7Hw57x3TA58JQ/cX0YBCU9U=", "Eg50FtdDCOJAR/aCjGiuKLwoiyFuiiXosOvPc4SA45A=", "BpleUQ/XZpN0w50nkD80KsW/ihRkgH8wi+9hC3bLaT4=", "HYFLPBdlbCMn+UzAJHJ4C4hriDlPGly+NNxPRP8TT84=", "A7kNo0sZjLyhfjSqyYsWmHXs9zrrXG/x8Ayf5TWqmQI=", "J/p3oGWHkeZ1V4HDZ2g/nJMzpBNk94cO3/GTWjR0hdg=", "BtbuUxuj/c7QXiTPkQPQli3SJ/HeaSwBmUg+kqskulk=", "HlB5Ib58dhJIef/OW2LdDpYlnpjMZMJyCNYrQL/j5II=", "BoGtrqec9FfbVwGTHw7i8V7LsVntUM90ahW4XG+KU3A=", "HmGWFHUIvy7chyxOiXqWd3ixGfaftDGn9kbSAY6rQBA=", "Bo76NbxiASSrfYiZAXG65BAq0h3937OH3w3gyKOhiek=", "GwEiJKTwUN+EESLRfF6k7e18jsIDR0OkMqLO6JOXbyk=", "II2BQVG83N38+DWpWMJZpkd7/kszknEO352AeHolxdA=", "KPkB/KqGCw3EGSre+OpK5Vr2zkMsheDOTQc+UUqyQlI=", "G9Y5h5cxgjyHH5zUcU48xWpusZiEtzZk7tJLEZKRGaA=", "HT7oXwePvuzaJHPvwr7dG6fsb0eV+q6uOw3kjTCAxiU="]]
    };
    exports2.default = _default;
  }
});

// ../node_modules/poseidon-lite/poseidon16.js
var require_poseidon16 = __commonJS({
  "../node_modules/poseidon-lite/poseidon16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon16 = poseidon162;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__16());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon162(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// ../node_modules/poseidon-lite/index.js
var require_poseidon_lite = __commonJS({
  "../node_modules/poseidon-lite/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "poseidon1", {
      enumerable: true,
      get: function() {
        return _poseidon.poseidon1;
      }
    });
    Object.defineProperty(exports2, "poseidon10", {
      enumerable: true,
      get: function() {
        return _poseidon10.poseidon10;
      }
    });
    Object.defineProperty(exports2, "poseidon11", {
      enumerable: true,
      get: function() {
        return _poseidon11.poseidon11;
      }
    });
    Object.defineProperty(exports2, "poseidon12", {
      enumerable: true,
      get: function() {
        return _poseidon12.poseidon12;
      }
    });
    Object.defineProperty(exports2, "poseidon13", {
      enumerable: true,
      get: function() {
        return _poseidon13.poseidon13;
      }
    });
    Object.defineProperty(exports2, "poseidon14", {
      enumerable: true,
      get: function() {
        return _poseidon14.poseidon14;
      }
    });
    Object.defineProperty(exports2, "poseidon15", {
      enumerable: true,
      get: function() {
        return _poseidon15.poseidon15;
      }
    });
    Object.defineProperty(exports2, "poseidon16", {
      enumerable: true,
      get: function() {
        return _poseidon16.poseidon16;
      }
    });
    Object.defineProperty(exports2, "poseidon2", {
      enumerable: true,
      get: function() {
        return _poseidon2.poseidon2;
      }
    });
    Object.defineProperty(exports2, "poseidon3", {
      enumerable: true,
      get: function() {
        return _poseidon3.poseidon3;
      }
    });
    Object.defineProperty(exports2, "poseidon4", {
      enumerable: true,
      get: function() {
        return _poseidon4.poseidon4;
      }
    });
    Object.defineProperty(exports2, "poseidon5", {
      enumerable: true,
      get: function() {
        return _poseidon5.poseidon5;
      }
    });
    Object.defineProperty(exports2, "poseidon6", {
      enumerable: true,
      get: function() {
        return _poseidon6.poseidon6;
      }
    });
    Object.defineProperty(exports2, "poseidon7", {
      enumerable: true,
      get: function() {
        return _poseidon7.poseidon7;
      }
    });
    Object.defineProperty(exports2, "poseidon8", {
      enumerable: true,
      get: function() {
        return _poseidon8.poseidon8;
      }
    });
    Object.defineProperty(exports2, "poseidon9", {
      enumerable: true,
      get: function() {
        return _poseidon9.poseidon9;
      }
    });
    var _poseidon = require_poseidon1();
    var _poseidon2 = require_poseidon2();
    var _poseidon3 = require_poseidon3();
    var _poseidon4 = require_poseidon4();
    var _poseidon5 = require_poseidon5();
    var _poseidon6 = require_poseidon6();
    var _poseidon7 = require_poseidon7();
    var _poseidon8 = require_poseidon8();
    var _poseidon9 = require_poseidon9();
    var _poseidon10 = require_poseidon10();
    var _poseidon11 = require_poseidon11();
    var _poseidon12 = require_poseidon12();
    var _poseidon13 = require_poseidon13();
    var _poseidon14 = require_poseidon14();
    var _poseidon15 = require_poseidon15();
    var _poseidon16 = require_poseidon16();
  }
});

// ../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports2) {
    "use strict";
    (function() {
      function is3(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        didWarnOld18Alpha || void 0 === React47.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value2 = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value2, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState25({
          inst: { value: value2, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect8(
          function() {
            inst.value = value2;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value2, getSnapshot]
        );
        useEffect30(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue2(value2);
        return value2;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React47 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is3, useState25 = React47.useState, useEffect30 = React47.useEffect, useLayoutEffect8 = React47.useLayoutEffect, useDebugValue2 = React47.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports2.useSyncExternalStore = void 0 !== React47.useSyncExternalStore ? React47.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../node_modules/use-sync-external-store/shim/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports2) {
    "use strict";
    (function() {
      function is3(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React47 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is3, useSyncExternalStore6 = shim.useSyncExternalStore, useRef21 = React47.useRef, useEffect30 = React47.useEffect, useMemo11 = React47.useMemo, useDebugValue2 = React47.useDebugValue;
      exports2.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef21(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo11(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value2 = useSyncExternalStore6(subscribe2, instRef[0], instRef[1]);
        useEffect30(
          function() {
            inst.hasValue = true;
            inst.value = value2;
          },
          [value2]
        );
        useDebugValue2(value2);
        return value2;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../node_modules/use-sync-external-store/shim/with-selector.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_with_selector_development();
    }
  }
});

// ../node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "../node_modules/cssesc/cssesc.js"(exports2, module2) {
    "use strict";
    var object2 = {};
    var hasOwnProperty3 = object2.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty3.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc3 = function cssesc4(string2, options) {
      options = merge(options, cssesc4.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string2.charAt(0);
      var output = "";
      var counter = 0;
      var length = string2.length;
      while (counter < length) {
        var character = string2.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value2 = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value2 = "\\" + character;
          } else {
            value2 = character;
          }
        }
        output += value2;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($02, $12, $22) {
        if ($12 && $12.length % 2) {
          return $02;
        }
        return ($12 || "") + $22;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc3.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc3.version = "3.0.0";
    module2.exports = cssesc3;
  }
});

// ../node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
    var x = String;
    var create = function() {
      return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };
    };
    module2.exports = create();
    module2.exports.createColors = create;
  }
});

// ../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value2) {
      return isNonNullObject(value2) && !isSpecial(value2);
    };
    function isNonNullObject(value2) {
      return !!value2 && typeof value2 === "object";
    }
    function isSpecial(value2) {
      var stringValue = Object.prototype.toString.call(value2);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value2);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value2) {
      return value2.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value2, options) {
      return options.clone !== false && options.isMergeableObject(value2) ? deepmerge2(emptyTarget(value2), value2, options) : value2;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object2, property) {
      try {
        return property in object2;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module2.exports = deepmerge_1;
  }
});

// ../node_modules/@cetusprotocol/terminal/dist/cetus-swap.es.js
var R = __toESM(require_react());
var import_react25 = __toESM(require_react());
var zm = __toESM(require_react_dom());
var import_react_dom3 = __toESM(require_react_dom());

// ../node_modules/@radix-ui/react-dialog/dist/index.mjs
var React27 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// ../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value2) {
  if (typeof ref === "function") {
    return ref(value2);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value2;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i10 = 0; i10 < cleanups.length; i10++) {
          const cleanup = cleanups[i10];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i10], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}

// ../node_modules/@radix-ui/react-context/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createContext2(rootComponentName, defaultContext) {
  const Context = React2.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value2 = React2.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime.jsx)(Context.Provider, { value: value2, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext23(consumerName) {
    const context = React2.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext23];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React2.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      var _a7;
      const { scope, children, ...context } = props;
      const Context = ((_a7 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a7[index2]) || BaseContext;
      const value2 = React2.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime.jsx)(Context.Provider, { value: value2, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext23(consumerName, scope) {
      var _a7;
      const Context = ((_a7 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a7[index2]) || BaseContext;
      const context = React2.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext23];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React2.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React2.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React2.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../node_modules/@radix-ui/react-id/dist/index.mjs
var React4 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var useLayoutEffect2 = (globalThis == null ? void 0 : globalThis.document) ? React3.useLayoutEffect : () => {
};

// ../node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React4[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id2, setId] = React4.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var useReactEffectEvent = React5[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = React5[" useInsertionEffect ".trim().toString()];

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect = React6[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value2 = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React6.useRef(prop !== void 0);
    React6.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to2 = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to2}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React6.useCallback(
    (nextValue) => {
      var _a7;
      if (isControlled) {
        const value22 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value22 !== prop) {
          (_a7 = onChangeRef.current) == null ? void 0 : _a7.call(onChangeRef, value22);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value2, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value2, setValue] = React6.useState(defaultProp);
  const prevValueRef = React6.useRef(value2);
  const onChangeRef = React6.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React6.useEffect(() => {
    var _a7;
    if (prevValueRef.current !== value2) {
      (_a7 = onChangeRef.current) == null ? void 0 : _a7.call(onChangeRef, value2);
      prevValueRef.current = value2;
    }
  }, [value2, prevValueRef]);
  return [value2, setValue, onChangeRef];
}
function isFunction(value2) {
  return typeof value2 === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// ../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React11 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-primitive/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// ../node_modules/@radix-ui/react-slot/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React7.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React7.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React7.Children.count(newElement) > 1) return React7.Children.only(null);
          return React7.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React7.isValidElement(newElement) ? React7.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React7.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React7.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React7.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React7.cloneElement(children, props2);
    }
    return React7.Children.count(children) > 1 ? React7.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React7.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a7, _b3;
  let getter = (_a7 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a7.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b3 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b3.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot4 = createSlot(`Primitive.${node}`);
  const Node2 = React8.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot4 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime3.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// ../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React9 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React9.useRef(callback);
  React9.useEffect(() => {
    callbackRef.current = callback;
  });
  return React9.useMemo(() => (...args) => {
    var _a7;
    return (_a7 = callbackRef.current) == null ? void 0 : _a7.call(callbackRef, ...args);
  }, []);
}

// ../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React10 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React10.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React11.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React11.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React11.useContext(DismissableLayerContext);
    const [node, setNode] = React11.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React11.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React11.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React11.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React11.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime4.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React11.forwardRef((props, forwardedRef) => {
  const context = React11.useContext(DismissableLayerContext);
  const ref = React11.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React11.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime4.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React11.useRef(false);
  const handleClickRef = React11.useRef(() => {
  });
  React11.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React11.useRef(false);
  React11.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// ../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React12 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React12.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container8, setContainer] = React12.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React12.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React12.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React12.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container8) return;
        const target = event.target;
        if (container8.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container8) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container8.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container8);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container8) mutationObserver.observe(container8, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container8, focusScope.paused]);
  React12.useEffect(() => {
    if (container8) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container8.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container8.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container8.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container8)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container8);
          }
        }
      }
      return () => {
        container8.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container8.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container8.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container8.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container8, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React12.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container22 = event.currentTarget;
        const [first, last] = getTabbableEdges(container22);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container22) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime5.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container8) {
  const candidates = getTabbableCandidates(container8);
  const first = findVisible(candidates, container8);
  const last = findVisible(candidates.reverse(), container8);
  return [first, last];
}
function getTabbableCandidates(container8) {
  const nodes = [];
  const walker = document.createTreeWalker(container8, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container8) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container8 })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a7;
      stack = arrayRemove(stack, focusScope);
      (_a7 = stack[0]) == null ? void 0 : _a7.resume();
    }
  };
}
function arrayRemove(array2, item) {
  const updatedArray = [...array2];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../node_modules/@radix-ui/react-portal/dist/index.mjs
var React13 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React13.forwardRef((props, forwardedRef) => {
  var _a7;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React13.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container8 = containerProp || mounted && ((_a7 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a7.body);
  return container8 ? import_react_dom.default.createPortal((0, import_jsx_runtime6.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container8) : null;
});
Portal.displayName = PORTAL_NAME;

// ../node_modules/@radix-ui/react-presence/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var React14 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React14.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React23.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React23.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React23.useState();
  const stylesRef = React23.useRef({});
  const prevPresentRef = React23.useRef(present);
  const prevAnimationNameRef = React23.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React23.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React23.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a7, _b3;
  let getter = (_a7 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a7.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b3 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b3.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React15 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React15.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t10) {
    for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
      s10 = arguments[i10];
      for (var p in s10) if (Object.prototype.hasOwnProperty.call(s10, p)) t10[p] = s10[p];
    }
    return t10;
  };
  return __assign.apply(this, arguments);
};
function __rest(s10, e10) {
  var t10 = {};
  for (var p in s10) if (Object.prototype.hasOwnProperty.call(s10, p) && e10.indexOf(p) < 0)
    t10[p] = s10[p];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p = Object.getOwnPropertySymbols(s10); i10 < p.length; i10++) {
      if (e10.indexOf(p[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p[i10]))
        t10[p[i10]] = s10[p[i10]];
    }
  return t10;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i10 = 0, l10 = from.length, ar2; i10 < l10; i10++) {
    if (ar2 || !(i10 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i10);
      ar2[i10] = from[i10];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React26 = __toESM(require_react());

// ../node_modules/react-remove-scroll/dist/es2015/UI.js
var React20 = __toESM(require_react());

// ../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value2) {
  if (typeof ref === "function") {
    ref(value2);
  } else if (ref) {
    ref.current = value2;
  }
  return ref;
}

// ../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value2) {
          var last = ref.value;
          if (last !== value2) {
            ref.value = value2;
            ref.callback(value2, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React16 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React16.useLayoutEffect : React16.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../node_modules/use-sidecar/dist/es2015/hoc.js
var React17 = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/hook.js
var import_react2 = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a10) {
  return a10;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x) {
          return cb2(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../node_modules/use-sidecar/dist/es2015/renderProp.js
var React18 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/exports.js
var React19 = __toESM(require_react());
var SideCar = function(_a7) {
  var sideCar = _a7.sideCar, rest = __rest(_a7, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React19.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React20.forwardRef(function(props, parentRef) {
  var ref = React20.useRef(null);
  var _a7 = React20.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a7[0], setCallbacks = _a7[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b3 = props.as, Container = _b3 === void 0 ? "div" : _b3, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React20.createElement(
    React20.Fragment,
    null,
    enabled && React20.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React20.cloneElement(React20.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React20.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React25 = __toESM(require_react());

// ../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React24 = __toESM(require_react());

// ../node_modules/react-style-singleton/dist/es2015/hook.js
var React21 = __toESM(require_react());

// ../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React21.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a7) {
    var styles = _a7.styles, dynamic = _a7.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs2 = window.getComputedStyle(document.body);
  var left = cs2[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs2[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs2[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a7, allowRelative, gapMode, important) {
  var left = _a7.left, top = _a7.top, right = _a7.right, gap = _a7.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React24.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a7) {
  var noRelative = _a7.noRelative, noImportant = _a7.noImportant, _b3 = _a7.gapMode, gapMode = _b3 === void 0 ? "margin" : _b3;
  useLockAttribute();
  var gap = React24.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React24.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a7 = getScrollVariables(axis, current), scrollHeight = _a7[1], clientHeight = _a7[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a7) {
  var scrollTop = _a7.scrollTop, scrollHeight = _a7.scrollHeight, clientHeight = _a7.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a7) {
  var scrollLeft = _a7.scrollLeft, scrollWidth = _a7.scrollWidth, clientWidth = _a7.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a7 = getScrollVariables(axis, target), position = _a7[0], scroll_1 = _a7[1], capacity = _a7[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React25.useRef([]);
  var touchStartRef = React25.useRef([0, 0]);
  var activeAxis = React25.useRef();
  var id2 = React25.useState(idCounter++)[0];
  var Style2 = React25.useState(styleSingleton)[0];
  var lastProps = React25.useRef(props);
  React25.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React25.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React25.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React25.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e10) {
      return e10.name === event.type && (e10.target === event.target || event.target === e10.shadowParent) && deltaCompare(e10.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React25.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e10) {
        return e10 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React25.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React25.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React25.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React25.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React25.createElement(
    React25.Fragment,
    null,
    inert ? React25.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React25.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React26.forwardRef(function(props, ref) {
  return React26.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e10) {
          console.error("aria-hidden: cannot operate on ", node, e10);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React27.useRef(null);
  const contentRef = React27.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return (0, import_jsx_runtime7.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React27.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime7.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container: container8 } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime7.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React27.Children.map(children, (child) => (0, import_jsx_runtime7.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime7.jsx)(Portal, { asChild: true, container: container8, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React27.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime7.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime7.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot2 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime7.jsx)(Combination_default, { as: Slot2, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime7.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent = React27.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return (0, import_jsx_runtime7.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime7.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime7.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME;
var DialogContentModal = React27.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = React27.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React27.useEffect(() => {
      const content4 = contentRef.current;
      if (content4) return hideOthers(content4);
    }, []);
    return (0, import_jsx_runtime7.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a7;
          event.preventDefault();
          (_a7 = context.triggerRef.current) == null ? void 0 : _a7.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React27.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = React27.useRef(false);
    const hasPointerDownOutsideRef = React27.useRef(false);
    return (0, import_jsx_runtime7.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a7, _b3;
          (_a7 = props.onCloseAutoFocus) == null ? void 0 : _a7.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b3 = context.triggerRef.current) == null ? void 0 : _b3.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a7, _b3;
          (_a7 = props.onInteractOutside) == null ? void 0 : _a7.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b3 = context.triggerRef.current) == null ? void 0 : _b3.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = React27.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
      (0, import_jsx_runtime7.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime7.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
        (0, import_jsx_runtime7.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime7.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime7.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime7.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React27.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime7.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React27.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React27.useEffect(() => {
    var _a7;
    const describedById = (_a7 = contentRef.current) == null ? void 0 : _a7.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root = Dialog;
var Trigger = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent;
var Title = DialogTitle;
var Close = DialogClose;

// ../node_modules/clsx/dist/clsx.mjs
function r(e10) {
  var t10, f, n10 = "";
  if ("string" == typeof e10 || "number" == typeof e10) n10 += e10;
  else if ("object" == typeof e10) if (Array.isArray(e10)) {
    var o10 = e10.length;
    for (t10 = 0; t10 < o10; t10++) e10[t10] && (f = r(e10[t10])) && (n10 && (n10 += " "), n10 += f);
  } else for (f in e10) e10[f] && (n10 && (n10 += " "), n10 += f);
  return n10;
}
function clsx() {
  for (var e10, t10, f = 0, n10 = "", o10 = arguments.length; f < o10; f++) (e10 = arguments[f]) && (t10 = r(e10)) && (n10 && (n10 += " "), n10 += t10);
  return n10;
}
var clsx_default = clsx;

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_react8 = __toESM(require_react());

// ../node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.28.0";
var TARGETED_RPC_VERSION = "1.48.0";

// ../node_modules/@mysten/sui/dist/esm/client/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// ../node_modules/@mysten/sui/dist/esm/client/rpc-websocket-client.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet2 = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod2 = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper2 = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet2(obj, member, value2, setter);
  },
  get _() {
    return __privateGet2(obj, member, getter);
  }
});
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _WebsocketClient_instances;
var setupWebSocket_fn;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url2 = new URL(httpUrl);
  url2.protocol = url2.protocol.replace("http", "ws");
  return url2.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd2(this, _WebsocketClient_instances);
    __privateAdd2(this, _requestId, 0);
    __privateAdd2(this, _disconnects, 0);
    __privateAdd2(this, _webSocket, null);
    __privateAdd2(this, _connectionPromise, null);
    __privateAdd2(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd2(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params, signal) {
    const webSocket = await __privateMethod2(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet2(this, _requestId, __privateGet2(this, _requestId) + 1);
      __privateGet2(this, _pendingRequests).set(__privateGet2(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet2(this, _pendingRequests).delete(__privateGet2(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      signal == null ? void 0 : signal.addEventListener("abort", () => {
        __privateGet2(this, _pendingRequests).delete(__privateGet2(this, _requestId));
        reject(signal.reason);
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet2(this, _requestId), method, params }));
    }).then(({ error: error2, result }) => {
      if (error2) {
        throw new JsonRpcError(error2.message, error2.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet2(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_WebsocketClient_instances = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet2(this, _connectionPromise)) {
    return __privateGet2(this, _connectionPromise);
  }
  __privateSet2(this, _connectionPromise, new Promise((resolve) => {
    var _a7;
    (_a7 = __privateGet2(this, _webSocket)) == null ? void 0 : _a7.close();
    __privateSet2(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet2(this, _webSocket).addEventListener("open", () => {
      __privateSet2(this, _disconnects, 0);
      resolve(__privateGet2(this, _webSocket));
    });
    __privateGet2(this, _webSocket).addEventListener("close", () => {
      __privateWrapper2(this, _disconnects)._++;
      if (__privateGet2(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod2(this, _WebsocketClient_instances, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet2(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error2) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error2 }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet2(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet2(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet2(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet2(this, _connectionPromise);
};
reconnect_fn = async function() {
  var _a7;
  (_a7 = __privateGet2(this, _webSocket)) == null ? void 0 : _a7.close();
  __privateSet2(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet2(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null) return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params,
      this.input.signal
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// ../node_modules/@mysten/sui/dist/esm/client/http-transport.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value2) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet3 = (obj, member, value2, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod3 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _requestId2;
var _options;
var _websocketClient;
var _SuiHTTPTransport_instances;
var getWebsocketClient_fn;
var SuiHTTPTransport = class {
  constructor(options) {
    __privateAdd3(this, _SuiHTTPTransport_instances);
    __privateAdd3(this, _requestId2, 0);
    __privateAdd3(this, _options);
    __privateAdd3(this, _websocketClient);
    __privateSet3(this, _options, options);
  }
  fetch(input, init) {
    const fetchFn = __privateGet3(this, _options).fetch ?? fetch;
    if (!fetchFn) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetchFn(input, init);
  }
  async request(input) {
    var _a7, _b3;
    __privateSet3(this, _requestId2, __privateGet3(this, _requestId2) + 1);
    const res = await this.fetch(((_a7 = __privateGet3(this, _options).rpc) == null ? void 0 : _a7.url) ?? __privateGet3(this, _options).url, {
      method: "POST",
      signal: input.signal,
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        "Client-Request-Method": input.method,
        ...(_b3 = __privateGet3(this, _options).rpc) == null ? void 0 : _b3.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet3(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod3(this, _SuiHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);
    if (input.signal) {
      input.signal.throwIfAborted();
      input.signal.addEventListener("abort", () => {
        unsubscribe();
      });
    }
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_SuiHTTPTransport_instances = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  var _a7;
  if (!__privateGet3(this, _websocketClient)) {
    const WebSocketConstructor = __privateGet3(this, _options).WebSocketConstructor ?? WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet3(this, _websocketClient, new WebsocketClient(
      ((_a7 = __privateGet3(this, _options).websocket) == null ? void 0 : _a7.url) ?? __privateGet3(this, _options).url,
      {
        WebSocketConstructor,
        ...__privateGet3(this, _options).websocket
      }
    ));
  }
  return __privateGet3(this, _websocketClient);
};

// ../node_modules/@mysten/sui/dist/esm/client/network.js
function getFullnodeUrl(network) {
  switch (network) {
    case "mainnet":
      return "https://fullnode.mainnet.sui.io:443";
    case "testnet":
      return "https://fullnode.testnet.sui.io:443";
    case "devnet":
      return "https://fullnode.devnet.sui.io:443";
    case "localnet":
      return "http://127.0.0.1:9000";
    default:
      throw new Error(`Unknown network: ${network}`);
  }
}

// ../node_modules/@scure/base/lib/esm/index.js
function isBytes(a10) {
  return a10 instanceof Uint8Array || ArrayBuffer.isView(a10) && a10.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n10) {
  if (!Number.isSafeInteger(n10))
    throw new Error(`invalid integer: ${n10}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id2 = (a10) => a10;
  const wrap2 = (a10, b) => (c) => a10(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap2, id2);
  const decode = args.map((x) => x.decode).reduce(wrap2, id2);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l10, i10) => [l10, i10]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i10) => {
        if (!Number.isSafeInteger(i10) || i10 < 0 || i10 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i10}". Allowed: ${letters}`);
        return lettersA[i10];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i10 = indexes.get(letter);
        if (i10 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i10;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to2) => {
      astr("join.decode", to2);
      return to2.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn2) {
  afn(fn2);
  return { encode: (from) => from, decode: (to2) => fn2(to2) };
}
function convertRadix(data, from, to2) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to2 < 2)
    throw new Error(`convertRadix: invalid to=${to2}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d6) => {
    anumber(d6);
    if (d6 < 0 || d6 >= from)
      throw new Error(`invalid integer: ${d6}`);
    return d6;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i10 = pos; i10 < dlen; i10++) {
      const digit = digits[i10];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to2;
      carry = digitBase % to2;
      const rounded = Math.floor(div);
      digits[i10] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to2 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i10;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i10 = 0; i10 < data.length - 1 && data[i10] === 0; i10++)
    res.push(0);
  return res.reverse();
}
var gcd = (a10, b) => b === 0 ? a10 : gcd(b, a10 % b);
var radix2carry = (from, to2) => from + (to2 - gcd(from, to2));
var powers = (() => {
  let res = [];
  for (let i10 = 0; i10 < 40; i10++)
    res.push(2 ** i10);
  return res;
})();
function convertRadix2(data, from, to2, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to2 <= 0 || to2 > 32)
    throw new Error(`convertRadix2: wrong to=${to2}`);
  if (radix2carry(from, to2) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to2} carryBits=${radix2carry(from, to2)}`);
  }
  let carry = 0;
  let pos = 0;
  const max2 = powers[from];
  const mask = powers[to2] - 1;
  const res = [];
  for (const n10 of data) {
    anumber(n10);
    if (n10 >= max2)
      throw new Error(`convertRadix2: invalid data word=${n10} from=${from}`);
    carry = carry << from | n10;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to2; pos -= to2)
      res.push((carry >> pos - to2 & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to2 - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  afn(fn2);
  return function(...args) {
    try {
      return fn2.apply(null, args);
    } catch (e10) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s10) => s10.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i10 = 0; i10 < POLYMOD_GENERATORS.length; i10++) {
    if ((b >> i10 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i10];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i10 = 0; i10 < len; i10++) {
    const c = prefix.charCodeAt(i10);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i10 = 0; i10 < len; i10++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i10) & 31;
  for (let v10 of words)
    chk = bech32Polymod(chk) ^ v10;
  for (let i10 = 0; i10 < 6; i10++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s10) => {
  if (typeof s10 !== "string" || s10.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s10} with length ${s10.length}`);
  return s10.toLowerCase();
}));

// ../node_modules/@mysten/bcs/dist/esm/b58.js
var toBase58 = (buffer) => base58.encode(buffer);
var fromBase58 = (str) => base58.decode(str);

// ../node_modules/@mysten/bcs/dist/esm/b64.js
function fromBase64(base64String2) {
  return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i10 = 0; i10 < bytes.length; i10 += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i10, i10 + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// ../node_modules/@mysten/bcs/dist/esm/hex.js
function fromHex(hexStr) {
  var _a7;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = ((_a7 = padded.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : _a7.map((byte) => parseInt(byte, 16))) ?? [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// ../node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift4 = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift4;
    if ((byte & 128) === 0) {
      break;
    }
    shift4 += 7;
  }
  return {
    value: total,
    length: len
  };
}

// ../node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value2 = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value2;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value2 = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value2;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value2 = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value2;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value2 = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value2;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value: value2, length } = ulebDecode(buffer);
    this.shift(length);
    return value2;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb2) {
    let length = this.readULEB();
    let result = [];
    for (let i10 = 0; i10 < length; i10++) {
      result.push(cb2(this, i10, length));
    }
    return result;
  }
};

// ../node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase58(data);
    case "base64":
      return toBase64(data);
    case "hex":
      return toHex(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i10 = 0; i10 < str.length; i10++) {
    const char = str[i10];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// ../node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value2) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value2));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value2) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value2), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value2) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value2), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value2) {
    toLittleEndian(BigInt(value2), 8).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value2) {
    toLittleEndian(BigInt(value2), 16).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value2) {
    toLittleEndian(BigInt(value2), 32).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value2) {
    ulebEncode(value2).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb2) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el2, i10) => cb2(this, el2, i10, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i10 = 0; i10 < this.bytePosition; i10++) {
      yield this.dataView.getUint8(i10);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size4) {
  let result = new Uint8Array(size4);
  let i10 = 0;
  while (bigint2 > 0) {
    result[i10] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i10 += 1;
  }
  return result;
}

// ../node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value2) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet4 = (obj, member, value2, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class _BcsType2 {
  constructor(options) {
    __privateAdd4(this, _write);
    __privateAdd4(this, _serialize);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet4(this, _write, options.write);
    __privateSet4(this, _serialize, options.serialize ?? ((value2, options2) => {
      const writer = new BcsWriter({
        initialSize: this.serializedSize(value2) ?? void 0,
        ...options2
      });
      __privateGet4(this, _write).call(this, value2, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value2, writer) {
    this.validate(value2);
    __privateGet4(this, _write).call(this, value2, writer);
  }
  serialize(value2, options) {
    this.validate(value2);
    return new SerializedBcs(this, __privateGet4(this, _serialize).call(this, value2, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  fromHex(hex2) {
    return this.parse(fromHex(hex2));
  }
  fromBase58(b64) {
    return this.parse(fromBase58(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase64(b64));
  }
  transform({
    name,
    input,
    output,
    validate: validate3
  }) {
    return new _BcsType2({
      name: name ?? this.name,
      read: (reader) => output ? output(this.read(reader)) : this.read(reader),
      write: (value2, writer) => __privateGet4(this, _write).call(this, input ? input(value2) : value2, writer),
      serializedSize: (value2) => this.serializedSize(input ? input(value2) : value2),
      serialize: (value2, options) => __privateGet4(this, _serialize).call(this, input ? input(value2) : value2, options),
      validate: (value2) => {
        validate3 == null ? void 0 : validate3(value2);
        this.validate(input ? input(value2) : value2);
      }
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(type2, schema) {
    __privateAdd4(this, _schema);
    __privateAdd4(this, _bytes);
    __privateSet4(this, _schema, type2);
    __privateSet4(this, _bytes, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet4(this, _bytes);
  }
  toHex() {
    return toHex(__privateGet4(this, _bytes));
  }
  toBase64() {
    return toBase64(__privateGet4(this, _bytes));
  }
  toBase58() {
    return toBase58(__privateGet4(this, _bytes));
  }
  parse() {
    return __privateGet4(this, _schema).parse(__privateGet4(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size: size4,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size4
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](value2),
    validate: (value2) => {
      var _a7;
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a7 = options.validate) == null ? void 0 : _a7.call(options, value2);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value2, writer) => writer[writeMethod](BigInt(value2)),
    validate: (val) => {
      var _a7;
      const value2 = BigInt(val);
      if (value2 < 0 || value2 > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value2}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a7 = options.validate) == null ? void 0 : _a7.call(options, value2);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type2 = new BcsType({
    ...options,
    serialize,
    write: (value2, writer) => {
      for (const byte of type2.serialize(value2).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type2;
}
function stringLikeBcsType({
  toBytes: toBytes2,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex2, writer) => {
      const bytes = toBytes2(hex2);
      writer.writeULEB(bytes.length);
      for (let i10 = 0; i10 < bytes.length; i10++) {
        writer.write8(bytes[i10]);
      }
    },
    serialize: (value2) => {
      const bytes = toBytes2(value2);
      const size4 = ulebEncode(bytes.length);
      const result = new Uint8Array(size4.length + bytes.length);
      result.set(size4, 0);
      result.set(bytes, size4.length);
      return result;
    },
    validate: (value2) => {
      var _a7;
      if (typeof value2 !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value2}. Expected string`);
      }
      (_a7 = options.validate) == null ? void 0 : _a7.call(options, value2);
    }
  });
}
function lazyBcsType(cb2) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb2();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value2) => getType().serializedSize(value2),
    write: (value2, writer) => getType().write(value2, writer),
    serialize: (value2, options) => getType().serialize(value2, options).toBytes()
  });
}

// ../node_modules/@mysten/bcs/dist/esm/bcs.js
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value2, writer) => writer.write8(value2 ? 1 : 0),
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (typeof value2 !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value2) => {
        return Uint8Array.from(ulebEncode(value2));
      },
      ...options
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size4, options) {
    return fixedSizeBcsType({
      name: `bytes[${size4}]`,
      size: size4,
      read: (reader) => reader.readBytes(size4),
      write: (value2, writer) => {
        const array2 = new Uint8Array(value2);
        for (let i10 = 0; i10 < size4; i10++) {
          writer.write8(array2[i10] ?? 0);
        }
      },
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size4) {
          throw new TypeError(`Expected array of length ${size4}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(options) {
    return new BcsType({
      name: `bytesVector`,
      read: (reader) => {
        const length = reader.readULEB();
        return reader.readBytes(length);
      },
      write: (value2, writer) => {
        const array2 = new Uint8Array(value2);
        writer.writeULEB(array2.length);
        for (let i10 = 0; i10 < array2.length; i10++) {
          writer.write8(array2[i10] ?? 0);
        }
      },
      ...options,
      serializedSize: (value2) => {
        const length = "length" in value2 ? value2.length : null;
        return length == null ? null : ulebEncode(length).length + length;
      },
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      name: "string",
      toBytes: (value2) => new TextEncoder().encode(value2),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size4, type2, options) {
    return new BcsType({
      name: `${type2.name}[${size4}]`,
      read: (reader) => {
        const result = new Array(size4);
        for (let i10 = 0; i10 < size4; i10++) {
          result[i10] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== size4) {
          throw new TypeError(`Expected array of length ${size4}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type2) {
    return bcs.enum(`Option<${type2.name}>`, {
      None: null,
      Some: type2
    }).transform({
      input: (value2) => {
        if (value2 == null) {
          return { None: true };
        }
        return { Some: value2 };
      },
      output: (value2) => {
        if (value2.$kind === "Some") {
          return value2.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type2, options) {
    return new BcsType({
      name: `vector<${type2.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i10 = 0; i10 < length; i10++) {
          result[i10] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        writer.writeULEB(value2.length);
        for (const item of value2) {
          type2.write(item, writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (!value2 || typeof value2 !== "object" || !("length" in value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType({
      name: `(${types.map((t10) => t10.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i10 = 0; i10 < types.length; i10++) {
          const size4 = types[i10].serializedSize(values[i10]);
          if (size4 == null) {
            return null;
          }
          total += size4;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type2 of types) {
          result.push(type2.read(reader));
        }
        return result;
      },
      write: (value2, writer) => {
        for (let i10 = 0; i10 < types.length; i10++) {
          types[i10].write(value2[i10], writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (!Array.isArray(value2)) {
          throw new TypeError(`Expected array, found ${typeof value2}`);
        }
        if (value2.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value2.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType({
      name,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type2] of canonicalOrder) {
          const size4 = type2.serializedSize(values[field]);
          if (size4 == null) {
            return null;
          }
          total += size4;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type2] of canonicalOrder) {
          result[field] = type2.read(reader);
        }
        return result;
      },
      write: (value2, writer) => {
        for (const [field, type2] of canonicalOrder) {
          type2.write(value2[field], writer);
        }
      },
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType({
      name,
      read: (reader) => {
        const index2 = reader.readULEB();
        const enumEntry = canonicalOrder[index2];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index2} for enum ${name}`);
        }
        const [kind, type2] = enumEntry;
        return {
          [kind]: (type2 == null ? void 0 : type2.read(reader)) ?? true,
          $kind: kind
        };
      },
      write: (value2, writer) => {
        const [name2, val] = Object.entries(value2).filter(
          ([name3]) => Object.hasOwn(values, name3)
        )[0];
        for (let i10 = 0; i10 < canonicalOrder.length; i10++) {
          const [optionName, optionType] = canonicalOrder[i10];
          if (optionName === name2) {
            writer.writeULEB(i10);
            optionType == null ? void 0 : optionType.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value2) => {
        var _a7;
        (_a7 = options == null ? void 0 : options.validate) == null ? void 0 : _a7.call(options, value2);
        if (typeof value2 !== "object" || value2 == null) {
          throw new TypeError(`Expected object, found ${typeof value2}`);
        }
        const keys = Object.keys(value2).filter(
          (k) => value2[k] !== void 0 && Object.hasOwn(values, k)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${name}}`
          );
        }
        const [variant2] = keys;
        if (!Object.hasOwn(values, variant2)) {
          throw new TypeError(`Invalid enum variant ${variant2}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs.vector(bcs.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value2) => {
        return [...value2.entries()];
      },
      output: (value2) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key, val] of value2) {
          result.set(key, val);
        }
        return result;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb2) {
    return lazyBcsType(cb2);
  }
};

// ../node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value2) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet5 = (obj, member, value2, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _prefix;
var _cache;
var _ClientCache = class _ClientCache2 {
  constructor({ prefix, cache } = {}) {
    __privateAdd5(this, _prefix);
    __privateAdd5(this, _cache);
    __privateSet5(this, _prefix, prefix ?? []);
    __privateSet5(this, _cache, cache ?? /* @__PURE__ */ new Map());
  }
  read(key, load) {
    const cacheKey = [__privateGet5(this, _prefix), ...key].join(":");
    if (__privateGet5(this, _cache).has(cacheKey)) {
      return __privateGet5(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet5(this, _cache).set(cacheKey, result);
    if (typeof result === "object" && result !== null && "then" in result) {
      return Promise.resolve(result).then((v10) => {
        __privateGet5(this, _cache).set(cacheKey, v10);
        return v10;
      }).catch((err) => {
        __privateGet5(this, _cache).delete(cacheKey);
        throw err;
      });
    }
    return result;
  }
  clear(prefix) {
    const prefixKey = [...__privateGet5(this, _prefix), ...prefix ?? []].join(":");
    if (!prefixKey) {
      __privateGet5(this, _cache).clear();
      return;
    }
    for (const key of __privateGet5(this, _cache).keys()) {
      if (key.startsWith(prefixKey)) {
        __privateGet5(this, _cache).delete(key);
      }
    }
  }
  scope(prefix) {
    return new _ClientCache2({
      prefix: [...__privateGet5(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],
      cache: __privateGet5(this, _cache)
    });
  }
};
_prefix = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
var ClientCache = _ClientCache;

// ../node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient = class {
  constructor({ network }) {
    this.cache = new ClientCache();
    this.network = network;
  }
  $extend(...registrations) {
    return Object.create(
      this,
      Object.fromEntries(
        registrations.map((registration) => {
          if ("experimental_asClientExtension" in registration) {
            const { name, register } = registration.experimental_asClientExtension();
            return [name, { value: register(this) }];
          }
          return [registration.name, { value: registration.register(this) }];
        })
      )
    );
  }
};

// ../node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var MAX_SUI_NS_NAME_LENGTH = 235;
function isValidSuiNSName(name) {
  if (name.length > MAX_SUI_NS_NAME_LENGTH) {
    return false;
  }
  if (name.includes("@")) {
    return SUI_NS_NAME_REGEX.test(name);
  }
  return SUI_NS_DOMAIN_REGEX.test(name);
}
function normalizeSuiNSName(name, format = "at") {
  const lowerCase = name.toLowerCase();
  let parts;
  if (lowerCase.includes("@")) {
    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name}`);
    }
    const [labels, domain] = lowerCase.split("@");
    parts = [...labels ? labels.split(".") : [], domain];
  } else {
    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name}`);
    }
    parts = lowerCase.split(".").slice(0, -1);
  }
  if (format === "dot") {
    return `${parts.join(".")}.sui`;
  }
  return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

// ../node_modules/@mysten/sui/dist/esm/utils/move-registry.js
var NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var VERSION_REGEX = /^\d+$/;
var MAX_APP_SIZE = 64;
var NAME_SEPARATOR = "/";
var isValidNamedPackage = (name) => {
  const parts = name.split(NAME_SEPARATOR);
  if (parts.length < 2 || parts.length > 3) return false;
  const [org, app, version2] = parts;
  if (version2 !== void 0 && !VERSION_REGEX.test(version2)) return false;
  if (!isValidSuiNSName(org)) return false;
  return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;
};

// ../node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value2) {
  try {
    const buffer = fromBase58(value2);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e10) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value2) {
  return isHex(value2) && getHexByteLength(value2) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value2) {
  return isValidSuiAddress(value2);
}
function parseTypeTag(type2) {
  if (!type2.includes("::")) return type2;
  return parseStructTag(type2);
}
function parseStructTag(type2) {
  const [address, module2] = type2.split("::");
  const isMvrPackage = isValidNamedPackage(address);
  const rest = type2.slice(address.length + module2.length + 4);
  const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: isMvrPackage ? address : normalizeSuiAddress(address),
    module: module2,
    name,
    typeParams
  };
}
function normalizeStructTag(type2) {
  const { address, module: module2, name, typeParams } = typeof type2 === "string" ? parseStructTag(type2) : type2;
  const formattedTypeParams = (typeParams == null ? void 0 : typeParams.length) > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module2}::${name}${formattedTypeParams}`;
}
function normalizeSuiAddress(value2, forceAdd0x = false) {
  let address = value2.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value2, forceAdd0x = false) {
  return normalizeSuiAddress(value2, forceAdd0x);
}
function isHex(value2) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value2) && value2.length % 2 === 0;
}
function getHexByteLength(value2) {
  return /^(0x|0X)/.test(value2) ? (value2.length - 2) / 2 : value2.length / 2;
}

// ../node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// ../node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type2) {
  return bcs.enum("Option", {
    None: null,
    Some: type2
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex(val);
    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value2) => fromBase58(value2),
  output: (value2) => toBase58(new Uint8Array(value2)),
  validate: (value2) => {
    if (fromBase58(value2).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef,
  SharedObject: SharedObjectRef,
  Receiving: SuiObjectRef
});
var Owner = bcs.enum("Owner", {
  AddressOwner: Address,
  ObjectOwner: Address,
  Shared: bcs.struct("Shared", {
    initialSharedVersion: bcs.u64()
  }),
  Immutable: null,
  ConsensusV2: bcs.struct("ConsensusV2", {
    authenticator: bcs.enum("Authenticator", {
      SingleOwner: Address
    }),
    startVersion: bcs.u64()
  })
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.struct("Pure", {
    bytes: bcs.vector(bcs.u8()).transform({
      input: (val) => typeof val === "string" ? fromBase64(val) : val,
      output: (val) => toBase64(new Uint8Array(val))
    })
  }),
  Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument = bcs.enum("Argument", {
  GasCoin: null,
  Input: bcs.u16(),
  Result: bcs.u16(),
  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  typeArguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
});
var Command = bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs.struct("TransferObjects", {
    objects: bcs.vector(Argument),
    address: Argument
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs.struct("SplitCoins", {
    coin: Argument,
    amounts: bcs.vector(Argument)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs.struct("MergeCoins", {
    destination: Argument,
    sources: bcs.vector(Argument)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs.struct("Publish", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs.struct("MakeMoveVec", {
    type: optionEnum(TypeTag).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => val.Some ?? null
    }),
    elements: bcs.vector(Argument)
  }),
  Upgrade: bcs.struct("Upgrade", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address),
    package: Address,
    ticket: Argument
  })
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  commands: bcs.vector(Command)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
function IntentMessage(T) {
  return bcs.struct(`IntentMessage<${T.name}>`, {
    intent: Intent,
    value: T
  });
}
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.vector(bcs.u8()).transform({
  input: (val) => typeof val === "string" ? fromBase64(val) : val,
  output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});
var PasskeyAuthenticator = bcs.struct("PasskeyAuthenticator", {
  authenticatorData: bcs.vector(bcs.u8()),
  clientDataJson: bcs.string(),
  userSignature: bcs.vector(bcs.u8())
});

// ../node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
  NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.vector(bcs.u8()) }),
  UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
  PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
    packageId: Address,
    ticketId: Address
  })
});
var ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
  module: ModuleId,
  function: bcs.u16(),
  instruction: bcs.u16(),
  functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
  SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  MovePackageTooBig: bcs.struct("MovePackageTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs.option(MoveLocation),
  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs.struct("CommandArgumentError", {
    argIdx: bcs.u16(),
    kind: CommandArgumentError
  }),
  TypeArgumentError: bcs.struct("TypeArgumentError", {
    argumentIdx: bcs.u16(),
    kind: TypeArgumentError
  }),
  UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", {
    idx: bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs.struct("EffectsTooLarge", { currentSize: bcs.u64(), maxSize: bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
  WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
    currentSize: bcs.u64(),
    maxSize: bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: bcs.vector(Address)
    }
  ),
  AddressDeniedForCoin: bcs.struct("AddressDeniedForCoin", {
    address: Address,
    coinType: bcs.string()
  }),
  CoinTypeGlobalPause: bcs.struct("CoinTypeGlobalPause", { coinType: bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs.struct("ExecutionFailed", {
    error: ExecutionFailureStatus,
    command: bcs.option(bcs.u64())
  })
});
var GasCostSummary = bcs.struct("GasCostSummary", {
  computationCost: bcs.u64(),
  storageCost: bcs.u64(),
  storageRebate: bcs.u64(),
  nonRefundableStorageFee: bcs.u64()
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
  sharedObjects: bcs.vector(SuiObjectRef),
  transactionDigest: ObjectDigest,
  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  deleted: bcs.vector(SuiObjectRef),
  unwrappedThenDeleted: bcs.vector(SuiObjectRef),
  wrapped: bcs.vector(SuiObjectRef),
  gasObject: bcs.tuple([SuiObjectRef, Owner]),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
  PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
  inputState: ObjectIn,
  outputState: ObjectOut,
  idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest,
  MutateDeleted: bcs.u64(),
  ReadDeleted: bcs.u64(),
  Cancelled: bcs.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  transactionDigest: ObjectDigest,
  gasObjectIndex: bcs.option(bcs.u32()),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest),
  lamportVersion: bcs.u64(),
  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
  auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
  V1: TransactionEffectsV1,
  V2: TransactionEffectsV2
});

// ../node_modules/@mysten/sui/dist/esm/bcs/pure.js
function pureBcsSchemaFromTypeName(name) {
  switch (name) {
    case "u8":
      return bcs.u8();
    case "u16":
      return bcs.u16();
    case "u32":
      return bcs.u32();
    case "u64":
      return bcs.u64();
    case "u128":
      return bcs.u128();
    case "u256":
      return bcs.u256();
    case "bool":
      return bcs.bool();
    case "string":
      return bcs.string();
    case "id":
    case "address":
      return Address;
  }
  const generic = name.match(/^(vector|option)<(.+)>$/);
  if (generic) {
    const [kind, inner] = generic.slice(1);
    if (kind === "vector") {
      return bcs.vector(pureBcsSchemaFromTypeName(inner));
    } else {
      return bcs.option(pureBcsSchemaFromTypeName(inner));
    }
  }
  throw new Error(`Invalid Pure type name: ${name}`);
}

// ../node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  AppId,
  Argument,
  CallArg,
  Command,
  CompressedSignature,
  GasData,
  Intent,
  IntentMessage,
  IntentScope,
  IntentVersion,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  Owner,
  PasskeyAuthenticator,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  TransactionData,
  TransactionDataV1,
  TransactionEffects,
  TransactionExpiration,
  TransactionKind,
  TypeTag
};

// ../node_modules/@mysten/sui/dist/esm/transactions/plugins/utils.js
function batch(arr, size4) {
  const batches = [];
  for (let i10 = 0; i10 < arr.length; i10 += size4) {
    batches.push(arr.slice(i10, i10 + size4));
  }
  return batches;
}

// ../node_modules/valibot/dist/index.js
var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
var store;
function getGlobalConfig(config2) {
  return {
    lang: (config2 == null ? void 0 : config2.lang) ?? (store == null ? void 0 : store.lang),
    message: config2 == null ? void 0 : config2.message,
    abortEarly: (config2 == null ? void 0 : config2.abortEarly) ?? (store == null ? void 0 : store.abortEarly),
    abortPipeEarly: (config2 == null ? void 0 : config2.abortPipeEarly) ?? (store == null ? void 0 : store.abortPipeEarly)
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a7;
  return (_a7 = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a7.get(lang);
}
function _stringify(input) {
  var _a7, _b3;
  const type2 = typeof input;
  if (type2 === "string") {
    return `"${input}"`;
  }
  if (type2 === "number" || type2 === "bigint" || type2 === "boolean") {
    return `${input}`;
  }
  if (type2 === "object" || type2 === "function") {
    return (input && ((_b3 = (_a7 = Object.getPrototypeOf(input)) == null ? void 0 : _a7.constructor) == null ? void 0 : _b3.name)) ?? "null";
  }
  return type2;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = (other == null ? void 0 : other.expected) ?? context.expects ?? null;
  const received = (other == null ? void 0 : other.received) ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema2 = context.kind === "schema";
  const message = (other == null ? void 0 : other.message) ?? // @ts-expect-error
  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema2 ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema2) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The error issues.
     */
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
function check(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}
function integer(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "integer", dataset, config2);
      }
      return dataset;
    }
  };
}
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}
function url(message) {
  return {
    kind: "validation",
    type: "url",
    reference: url,
    async: false,
    expects: null,
    requirement(input) {
      try {
        new URL(input);
        return true;
      } catch {
        return false;
      }
    },
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "URL", dataset, config2);
      }
      return dataset;
    }
  };
}
function uuid(message) {
  return {
    kind: "validation",
    type: "uuid",
    reference: uuid,
    async: false,
    expects: null,
    requirement: UUID_REGEX,
    message,
    _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "UUID", dataset, config2);
      }
      return dataset;
    }
  };
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;
}
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    _run(dataset, config2) {
      var _a7;
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function bigint(message) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "bigint") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter,
    _run(dataset, config2) {
      return this.getter(dataset.value)._run(dataset, config2);
    }
  };
}
function literal(literal_, message) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message,
    _run(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nullable(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: `${wrapped.expects} | null`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === null) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function nullish(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${wrapped.expects} | null | undefined`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config2) {
      var _a7;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key];
          const valueDataset = this.entries[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key,
    value: value2,
    message,
    _run(dataset, config2) {
      var _a7, _b3;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            const entryValue = input[entryKey];
            const keyDataset = this.key._run(
              { typed: false, value: entryKey },
              config2
            );
            if (keyDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues) {
                issue.path = [pathItem];
                (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            const valueDataset = this.value._run(
              { typed: false, value: entryValue },
              config2
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_b3 = dataset.issues) == null ? void 0 : _b3.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function tuple(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items,
    message,
    _run(dataset, config2) {
      var _a7;
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < this.items.length; key++) {
          const value2 = input[key];
          const itemDataset = this.items[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              (_a7 = dataset.issues) == null ? void 0 : _a7.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
    async: false,
    options,
    message,
    _run(dataset, config2) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema._run(
          { typed: false, value: dataset.value },
          config2
        );
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if ((untypedDatasets == null ? void 0 : untypedDatasets.length) === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {
  for (const schema of options) {
    if (schema.type === "variant") {
      _discriminators(key, schema.options, set2);
    } else {
      set2.add(schema.entries[key].expects);
    }
  }
  return set2;
}
function variant(key, options, message) {
  let expectedDiscriminators;
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: false,
    key,
    options,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        const discriminator = input[this.key];
        if (this.key in input) {
          let outputDataset;
          for (const schema of this.options) {
            if (schema.type === "variant" || !schema.entries[this.key]._run(
              { typed: false, value: discriminator },
              config2
            ).issues) {
              const optionDataset = schema._run(
                { typed: false, value: input },
                config2
              );
              if (!optionDataset.issues) {
                return optionDataset;
              }
              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                outputDataset = optionDataset;
              }
            }
          }
          if (outputDataset) {
            return outputDataset;
          }
        }
        if (!expectedDiscriminators) {
          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(" | ") || "never";
        }
        _addIssue(this, "type", dataset, config2, {
          input: discriminator,
          expected: expectedDiscriminators,
          path: [
            {
              type: "object",
              origin: "value",
              input,
              key: this.key,
              value: discriminator
            }
          ]
        });
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function parse2(schema, input, config2) {
  const dataset = schema._run(
    { typed: false, value: input },
    getGlobalConfig(config2)
  );
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    _run(dataset, config2) {
      for (let index2 = 0; index2 < pipe2.length; index2++) {
        if (dataset.issues && (pipe2[index2].kind === "schema" || pipe2[index2].kind === "transformation")) {
          dataset.typed = false;
          break;
        }
        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
          dataset = pipe2[index2]._run(dataset, config2);
        }
      }
      return dataset;
    }
  };
}

// ../node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
  const unionOptions = Object.entries(options).map(([key, value2]) => object({ [key]: value2 }));
  return pipe(
    union(unionOptions),
    transform((value2) => ({
      ...value2,
      $kind: Object.keys(value2)[0]
    }))
  );
}
var SuiAddress = pipe(
  string(),
  transform((value2) => normalizeSuiAddress(value2)),
  check(isValidSuiAddress)
);
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(
  union([string(), pipe(number(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRef = object({
  objectId: SuiAddress,
  version: JsonU64,
  digest: string()
});
var Argument2 = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number(), integer()) }),
    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
  ]),
  transform((value2) => ({
    ...value2,
    $kind: Object.keys(value2)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasData2 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var StructTag2 = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBody = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBody))
    })
  }),
  object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignature = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBody
});
var ProgrammableMoveCall2 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument2),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignature)))
});
var $Intent = object({
  name: string(),
  inputs: record(string(), union([Argument2, array(Argument2)])),
  data: record(string(), unknown())
});
var Command2 = safeEnum({
  MoveCall: ProgrammableMoveCall2,
  TransferObjects: object({
    objects: array(Argument2),
    address: Argument2
  }),
  SplitCoins: object({
    coin: Argument2,
    amounts: array(Argument2)
  }),
  MergeCoins: object({
    destination: Argument2,
    sources: array(Argument2)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument2)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument2
  }),
  $Intent
});
var ObjectArg2 = safeEnum({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg2 = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var NormalizedCallArg = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  })
});
var TransactionExpiration2 = safeEnum({
  None: literal(true),
  Epoch: JsonU64
});
var TransactionData2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration2),
  gasData: GasData2,
  inputs: array(CallArg2),
  commands: array(Command2)
});

// ../node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var UpgradePolicy = ((UpgradePolicy2) => {
  UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy2;
})(UpgradePolicy || {});
var Commands = {
  MoveCall(input) {
    const [pkg, mod2 = "", fn2 = ""] = "target" in input ? input.target.split("::") : [input.package, input.module, input.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: pkg,
        module: mod2,
        function: fn2,
        typeArguments: input.typeArguments ?? [],
        arguments: input.arguments ?? []
      }
    };
  },
  TransferObjects(objects, address) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: objects.map((o10) => parse2(Argument2, o10)),
        address: parse2(Argument2, address)
      }
    };
  },
  SplitCoins(coin, amounts) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: parse2(Argument2, coin),
        amounts: amounts.map((o10) => parse2(Argument2, o10))
      }
    };
  },
  MergeCoins(destination, sources) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: parse2(Argument2, destination),
        sources: sources.map((o10) => parse2(Argument2, o10))
      }
    };
  },
  Publish({
    modules,
    dependencies
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: modules.map(
          (module2) => typeof module2 === "string" ? module2 : toBase64(new Uint8Array(module2))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      }
    };
  },
  Upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: modules.map(
          (module2) => typeof module2 === "string" ? module2 : toBase64(new Uint8Array(module2))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        package: packageId,
        ticket: parse2(Argument2, ticket)
      }
    };
  },
  MakeMoveVec({
    type: type2,
    elements
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: type2 ?? null,
        elements: elements.map((o10) => parse2(Argument2, o10))
      }
    };
  },
  Intent({
    name,
    inputs = {},
    data = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name,
        inputs: Object.fromEntries(
          Object.entries(inputs).map(([key, value2]) => [
            key,
            Array.isArray(value2) ? value2.map((o10) => parse2(Argument2, o10)) : parse2(Argument2, value2)
          ])
        ),
        data
      }
    };
  }
};

// ../node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef2 = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number(), integer()), string(), bigint()])
});
var ObjectArg3 = safeEnum({
  ImmOrOwned: ObjectRef2,
  Shared: object({
    objectId: ObjectID,
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef2
});
var NormalizedCallArg2 = safeEnum({
  Object: ObjectArg3,
  Pure: array(pipe(number(), integer()))
});
var TransactionInput = union([
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration3 = union([
  object({ Epoch: pipe(number(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint = pipe(
  union([number(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val)) return false;
    try {
      BigInt(val);
      return true;
    } catch {
      return false;
    }
  })
);
var TypeTag2 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag2) }),
  object({ struct: lazy(() => StructTag3) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag3 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag2)
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(ObjectRef2)),
  owner: optional(string())
});
var TransactionArgumentTypes = [
  TransactionInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number(), integer()),
    resultIndex: pipe(number(), integer())
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag2 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var SerializedTransactionDataV1 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration3),
  gasConfig: GasConfig,
  inputs: array(TransactionInput),
  transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
  var _a7;
  const inputs = transactionData.inputs.map(
    (input, index2) => {
      if (input.Object) {
        return {
          kind: "Input",
          index: index2,
          value: {
            Object: input.Object.ImmOrOwnedObject ? {
              ImmOrOwned: input.Object.ImmOrOwnedObject
            } : input.Object.Receiving ? {
              Receiving: {
                digest: input.Object.Receiving.digest,
                version: input.Object.Receiving.version,
                objectId: input.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: input.Object.SharedObject.mutable,
                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
                objectId: input.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      }
      if (input.Pure) {
        return {
          kind: "Input",
          index: index2,
          value: {
            Pure: Array.from(fromBase64(input.Pure.bytes))
          },
          type: "pure"
        };
      }
      if (input.UnresolvedPure) {
        return {
          kind: "Input",
          type: "pure",
          index: index2,
          value: input.UnresolvedPure.value
        };
      }
      if (input.UnresolvedObject) {
        return {
          kind: "Input",
          type: "object",
          index: index2,
          value: input.UnresolvedObject.objectId
        };
      }
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: transactionData.sender ?? void 0,
    expiration: ((_a7 = transactionData.expiration) == null ? void 0 : _a7.$kind) === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
    gasConfig: {
      owner: transactionData.gasData.owner ?? void 0,
      budget: transactionData.gasData.budget ?? void 0,
      price: transactionData.gasData.price ?? void 0,
      payment: transactionData.gasData.payment ?? void 0
    },
    inputs,
    transactions: transactionData.commands.map((command) => {
      if (command.MakeMoveVec) {
        return {
          kind: "MakeMoveVec",
          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
          objects: command.MakeMoveVec.elements.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.MergeCoins) {
        return {
          kind: "MergeCoins",
          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.MoveCall) {
        return {
          kind: "MoveCall",
          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
          typeArguments: command.MoveCall.typeArguments,
          arguments: command.MoveCall.arguments.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.Publish) {
        return {
          kind: "Publish",
          modules: command.Publish.modules.map((mod2) => Array.from(fromBase64(mod2))),
          dependencies: command.Publish.dependencies
        };
      }
      if (command.SplitCoins) {
        return {
          kind: "SplitCoins",
          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.TransferObjects) {
        return {
          kind: "TransferObjects",
          objects: command.TransferObjects.objects.map(
            (arg) => convertTransactionArgument(arg, inputs)
          ),
          address: convertTransactionArgument(command.TransferObjects.address, inputs)
        };
      }
      if (command.Upgrade) {
        return {
          kind: "Upgrade",
          modules: command.Upgrade.modules.map((mod2) => Array.from(fromBase64(mod2))),
          dependencies: command.Upgrade.dependencies,
          packageId: command.Upgrade.package,
          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
        };
      }
      throw new Error(`Unknown transaction ${Object.keys(command)}`);
    })
  };
}
function convertTransactionArgument(arg, inputs) {
  if (arg.$kind === "GasCoin") {
    return { kind: "GasCoin" };
  }
  if (arg.$kind === "Result") {
    return { kind: "Result", index: arg.Result };
  }
  if (arg.$kind === "NestedResult") {
    return { kind: "NestedResult", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };
  }
  if (arg.$kind === "Input") {
    return inputs[arg.Input];
  }
  throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
  var _a7, _b3, _c2;
  return parse2(TransactionData2, {
    version: 2,
    sender: data.sender ?? null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: data.gasConfig.owner ?? null,
      budget: ((_a7 = data.gasConfig.budget) == null ? void 0 : _a7.toString()) ?? null,
      price: ((_b3 = data.gasConfig.price) == null ? void 0 : _b3.toString()) ?? null,
      payment: ((_c2 = data.gasConfig.payment) == null ? void 0 : _c2.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      }))) ?? null
    },
    inputs: data.inputs.map((input) => {
      if (input.kind === "Input") {
        if (is(NormalizedCallArg2, input.value)) {
          const value2 = parse2(NormalizedCallArg2, input.value);
          if (value2.Object) {
            if (value2.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value2.Object.ImmOrOwned.objectId,
                    version: String(value2.Object.ImmOrOwned.version),
                    digest: value2.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value2.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: value2.Object.Shared.mutable ?? null,
                    initialSharedVersion: value2.Object.Shared.initialSharedVersion,
                    objectId: value2.Object.Shared.objectId
                  }
                }
              };
            }
            if (value2.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value2.Object.Receiving.digest,
                    version: String(value2.Object.Receiving.version),
                    objectId: value2.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase64(new Uint8Array(value2.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod2, fn2] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod2,
              function: fn2,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod2) => toBase64(Uint8Array.from(mod2))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
              address: parseV1TransactionArgument(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod2) => toBase64(Uint8Array.from(mod2))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// ../node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
  return union(
    Object.entries(options).map(([key, value2]) => object({ [key]: value2 }))
  );
}
var Argument3 = enumUnion({
  GasCoin: literal(true),
  Input: pipe(number(), integer()),
  Result: pipe(number(), integer()),
  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])
});
var GasData3 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var ProgrammableMoveCall3 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument3)
});
var $Intent2 = object({
  name: string(),
  inputs: record(string(), union([Argument3, array(Argument3)])),
  data: record(string(), unknown())
});
var Command3 = enumUnion({
  MoveCall: ProgrammableMoveCall3,
  TransferObjects: object({
    objects: array(Argument3),
    address: Argument3
  }),
  SplitCoins: object({
    coin: Argument3,
    amounts: array(Argument3)
  }),
  MergeCoins: object({
    destination: Argument3,
    sources: array(Argument3)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument3)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument3
  }),
  $Intent: $Intent2
});
var ObjectArg4 = enumUnion({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg3 = enumUnion({
  Object: ObjectArg4,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var TransactionExpiration4 = enumUnion({
  None: literal(true),
  Epoch: JsonU64
});
var SerializedTransactionDataV2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration4),
  gasData: GasData3,
  inputs: array(CallArg3),
  commands: array(Command3)
});

// ../node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()
    }
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version: version2 }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version: version2 }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};

// ../node_modules/@mysten/sui/dist/esm/utils/constants.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// ../node_modules/@noble/hashes/esm/_assert.js
function anumber2(n10) {
  if (!Number.isSafeInteger(n10) || n10 < 0)
    throw new Error("positive integer expected, got " + n10);
}
function isBytes2(a10) {
  return a10 instanceof Uint8Array || ArrayBuffer.isView(a10) && a10.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber2(h.outputLen);
  anumber2(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}

// ../node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// ../node_modules/@noble/hashes/esm/utils.js
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift4) {
  return word << 32 - shift4 | word >>> shift4;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
var byteSwapIfBE = isLE ? (n10) => n10 : (n10) => byteSwap(n10);
function byteSwap32(arr) {
  for (let i10 = 0; i10 < arr.length; i10++) {
    arr[i10] = byteSwap(arr[i10]);
  }
}
var hexes = Array.from({ length: 256 }, (_, i10) => i10.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  let hex2 = "";
  for (let i10 = 0; i10 < bytes.length; i10++) {
    hex2 += hexes[bytes[i10]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n12 = asciiToBase16(hex2.charCodeAt(hi2));
    const n22 = asciiToBase16(hex2.charCodeAt(hi2 + 1));
    if (n12 === void 0 || n22 === void 0) {
      const char = hex2[hi2] + hex2[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai2] = n12 * 16 + n22;
  }
  return array2;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i10 = 0; i10 < arrays.length; i10++) {
    const a10 = arrays[i10];
    abytes(a10);
    sum += a10.length;
  }
  const res = new Uint8Array(sum);
  for (let i10 = 0, pad = 0; i10 < arrays.length; i10++) {
    const a10 = arrays[i10];
    res.set(a10, pad);
    pad += a10.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return crypto2.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../node_modules/@noble/hashes/esm/_blake.js
var SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
var BLAKE = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    anumber2(blockLen);
    anumber2(outputLen);
    anumber2(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error("key length must be undefined or 1.." + keyLen);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error("salt must be undefined or " + saltLen);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error("personalization must be undefined or " + persLen);
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    const { blockLen, buffer, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    const offset4 = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        if (!isLE)
          byteSwap32(buffer32);
        this.compress(buffer32, 0, false);
        if (!isLE)
          byteSwap32(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset4 + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        if (!isLE)
          byteSwap32(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        if (!isLE)
          byteSwap32(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    if (!isLE)
      byteSwap32(buffer32);
    this.compress(buffer32, 0, true);
    if (!isLE)
      byteSwap32(buffer32);
    const out32 = u32(out);
    this.get().forEach((v10, i10) => out32[i10] = byteSwapIfBE(v10));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to2 || (to2 = new this.constructor({ dkLen: outputLen }));
    to2.set(...this.get());
    to2.length = length;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.outputLen = outputLen;
    to2.buffer.set(buffer);
    to2.pos = pos;
    return to2;
  }
};

// ../node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n10, le2 = false) {
  if (le2)
    return { h: Number(n10 & U32_MASK64), l: Number(n10 >> _32n & U32_MASK64) };
  return { h: Number(n10 >> _32n & U32_MASK64) | 0, l: Number(n10 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al2 = new Uint32Array(lst.length);
  for (let i10 = 0; i10 < lst.length; i10++) {
    const { h, l: l10 } = fromBig(lst[i10], le2);
    [Ah2[i10], Al2[i10]] = [h, l10];
  }
  return [Ah2, Al2];
}
var toBig = (h, l10) => BigInt(h >>> 0) << _32n | BigInt(l10 >>> 0);
var shrSH = (h, _l2, s10) => h >>> s10;
var shrSL = (h, l10, s10) => h << 32 - s10 | l10 >>> s10;
var rotrSH = (h, l10, s10) => h >>> s10 | l10 << 32 - s10;
var rotrSL = (h, l10, s10) => h << 32 - s10 | l10 >>> s10;
var rotrBH = (h, l10, s10) => h << 64 - s10 | l10 >>> s10 - 32;
var rotrBL = (h, l10, s10) => h >>> s10 - 32 | l10 << 64 - s10;
var rotr32H = (_h2, l10) => l10;
var rotr32L = (h, _l2) => h;
var rotlSH = (h, l10, s10) => h << s10 | l10 >>> 32 - s10;
var rotlSL = (h, l10, s10) => l10 << s10 | h >>> 32 - s10;
var rotlBH = (h, l10, s10) => l10 << s10 - 32 | h >>> 64 - s10;
var rotlBL = (h, l10, s10) => h << s10 - 32 | l10 >>> 64 - s10;
function add(Ah2, Al2, Bh2, Bl2) {
  const l10 = (Al2 >>> 0) + (Bl2 >>> 0);
  return { h: Ah2 + Bh2 + (l10 / 2 ** 32 | 0) | 0, l: l10 | 0 };
}
var add3L = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
var add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
var add4L = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
var add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
var add5L = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
var add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// ../node_modules/@noble/hashes/esm/blake2b.js
var B2B_IV = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a10, b, c, d6, msg, x) {
  const Xl2 = msg[x], Xh2 = msg[x + 1];
  let Al2 = BBUF[2 * a10], Ah2 = BBUF[2 * a10 + 1];
  let Bl2 = BBUF[2 * b], Bh2 = BBUF[2 * b + 1];
  let Cl2 = BBUF[2 * c], Ch2 = BBUF[2 * c + 1];
  let Dl2 = BBUF[2 * d6], Dh2 = BBUF[2 * d6 + 1];
  let ll = u64_default.add3L(Al2, Bl2, Xl2);
  Ah2 = u64_default.add3H(ll, Ah2, Bh2, Xh2);
  Al2 = ll | 0;
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: Dh2 ^ Ah2, Dl: Dl2 ^ Al2 });
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: u64_default.rotr32H(Dh2, Dl2), Dl: u64_default.rotr32L(Dh2, Dl2) });
  ({ h: Ch2, l: Cl2 } = u64_default.add(Ch2, Cl2, Dh2, Dl2));
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: Bh2 ^ Ch2, Bl: Bl2 ^ Cl2 });
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: u64_default.rotrSH(Bh2, Bl2, 24), Bl: u64_default.rotrSL(Bh2, Bl2, 24) });
  BBUF[2 * a10] = Al2, BBUF[2 * a10 + 1] = Ah2;
  BBUF[2 * b] = Bl2, BBUF[2 * b + 1] = Bh2;
  BBUF[2 * c] = Cl2, BBUF[2 * c + 1] = Ch2;
  BBUF[2 * d6] = Dl2, BBUF[2 * d6 + 1] = Dh2;
}
function G2b(a10, b, c, d6, msg, x) {
  const Xl2 = msg[x], Xh2 = msg[x + 1];
  let Al2 = BBUF[2 * a10], Ah2 = BBUF[2 * a10 + 1];
  let Bl2 = BBUF[2 * b], Bh2 = BBUF[2 * b + 1];
  let Cl2 = BBUF[2 * c], Ch2 = BBUF[2 * c + 1];
  let Dl2 = BBUF[2 * d6], Dh2 = BBUF[2 * d6 + 1];
  let ll = u64_default.add3L(Al2, Bl2, Xl2);
  Ah2 = u64_default.add3H(ll, Ah2, Bh2, Xh2);
  Al2 = ll | 0;
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: Dh2 ^ Ah2, Dl: Dl2 ^ Al2 });
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: u64_default.rotrSH(Dh2, Dl2, 16), Dl: u64_default.rotrSL(Dh2, Dl2, 16) });
  ({ h: Ch2, l: Cl2 } = u64_default.add(Ch2, Cl2, Dh2, Dl2));
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: Bh2 ^ Ch2, Bl: Bl2 ^ Cl2 });
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: u64_default.rotrBH(Bh2, Bl2, 63), Bl: u64_default.rotrBL(Bh2, Bl2, 63) });
  BBUF[2 * a10] = Al2, BBUF[2 * a10 + 1] = Ah2;
  BBUF[2 * b] = Bl2, BBUF[2 * b + 1] = Bh2;
  BBUF[2 * c] = Cl2, BBUF[2 * c + 1] = Ch2;
  BBUF[2 * d6] = Dl2, BBUF[2 * d6 + 1] = Dh2;
}
var BLAKE2b = class extends BLAKE {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u32(toBytes(opts.salt));
      this.v4l ^= byteSwapIfBE(salt[0]);
      this.v4h ^= byteSwapIfBE(salt[1]);
      this.v5l ^= byteSwapIfBE(salt[2]);
      this.v5h ^= byteSwapIfBE(salt[3]);
    }
    if (opts.personalization) {
      const pers = u32(toBytes(opts.personalization));
      this.v6l ^= byteSwapIfBE(pers[0]);
      this.v6h ^= byteSwapIfBE(pers[1]);
      this.v7l ^= byteSwapIfBE(pers[2]);
      this.v7h ^= byteSwapIfBE(pers[3]);
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes(opts.key));
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset4, isLast) {
    this.get().forEach((v10, i10) => BBUF[i10] = v10);
    BBUF.set(B2B_IV, 16);
    let { h, l: l10 } = u64_default.fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l10;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s10 = SIGMA;
    for (let i10 = 0; i10 < 12; i10++) {
      G1b(0, 4, 8, 12, msg, offset4 + 2 * s10[j++]);
      G2b(0, 4, 8, 12, msg, offset4 + 2 * s10[j++]);
      G1b(1, 5, 9, 13, msg, offset4 + 2 * s10[j++]);
      G2b(1, 5, 9, 13, msg, offset4 + 2 * s10[j++]);
      G1b(2, 6, 10, 14, msg, offset4 + 2 * s10[j++]);
      G2b(2, 6, 10, 14, msg, offset4 + 2 * s10[j++]);
      G1b(3, 7, 11, 15, msg, offset4 + 2 * s10[j++]);
      G2b(3, 7, 11, 15, msg, offset4 + 2 * s10[j++]);
      G1b(0, 5, 10, 15, msg, offset4 + 2 * s10[j++]);
      G2b(0, 5, 10, 15, msg, offset4 + 2 * s10[j++]);
      G1b(1, 6, 11, 12, msg, offset4 + 2 * s10[j++]);
      G2b(1, 6, 11, 12, msg, offset4 + 2 * s10[j++]);
      G1b(2, 7, 8, 13, msg, offset4 + 2 * s10[j++]);
      G2b(2, 7, 8, 13, msg, offset4 + 2 * s10[j++]);
      G1b(3, 4, 9, 14, msg, offset4 + 2 * s10[j++]);
      G2b(3, 4, 9, 14, msg, offset4 + 2 * s10[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    BBUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// ../node_modules/@mysten/sui/dist/esm/utils/dynamic-fields.js
function deriveDynamicFieldID(parentId, typeTag, key) {
  const address = suiBcs.Address.serialize(parentId).toBytes();
  const tag = suiBcs.TypeTag.serialize(typeTag).toBytes();
  const keyLength = suiBcs.u64().serialize(key.length).toBytes();
  const hash = blake2b.create({
    dkLen: 32
  });
  hash.update(new Uint8Array([240]));
  hash.update(address);
  hash.update(keyLength);
  hash.update(key);
  hash.update(tag);
  return `0x${toHex(hash.digest().slice(0, 32))}`;
}

// ../node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
  const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
  if (typeof typeSignature === "string") {
    switch (typeSignature) {
      case "address":
        return suiBcs.Address;
      case "bool":
        return suiBcs.Bool;
      case "u8":
        return suiBcs.U8;
      case "u16":
        return suiBcs.U16;
      case "u32":
        return suiBcs.U32;
      case "u64":
        return suiBcs.U64;
      case "u128":
        return suiBcs.U128;
      case "u256":
        return suiBcs.U256;
      default:
        throw new Error(`Unknown type signature ${typeSignature}`);
    }
  }
  if ("vector" in typeSignature) {
    if (typeSignature.vector === "u8") {
      return suiBcs.vector(suiBcs.U8).transform({
        input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
        output: (val) => val
      });
    }
    const type2 = getPureBcsSchema(typeSignature.vector);
    return type2 ? suiBcs.vector(type2) : null;
  }
  if ("datatype" in typeSignature) {
    const pkg = normalizeSuiAddress(typeSignature.datatype.package);
    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
        const type2 = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
        return type2 ? suiBcs.vector(type2) : null;
      }
    }
    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizedTypeToMoveTypeSignature(type2) {
  if (typeof type2 === "object" && "Reference" in type2) {
    return {
      ref: "&",
      body: normalizedTypeToMoveTypeSignatureBody(type2.Reference)
    };
  }
  if (typeof type2 === "object" && "MutableReference" in type2) {
    return {
      ref: "&mut",
      body: normalizedTypeToMoveTypeSignatureBody(type2.MutableReference)
    };
  }
  return {
    ref: null,
    body: normalizedTypeToMoveTypeSignatureBody(type2)
  };
}
function normalizedTypeToMoveTypeSignatureBody(type2) {
  if (typeof type2 === "string") {
    switch (type2) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type2}`);
    }
  }
  if ("Vector" in type2) {
    return { vector: normalizedTypeToMoveTypeSignatureBody(type2.Vector) };
  }
  if ("Struct" in type2) {
    return {
      datatype: {
        package: type2.Struct.address,
        module: type2.Struct.module,
        type: type2.Struct.name,
        typeParameters: type2.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
      }
    };
  }
  if ("TypeParameter" in type2) {
    return { typeParameter: type2.TypeParameter };
  }
  throw new Error(`Unexpected type ${JSON.stringify(type2)}`);
}

// ../node_modules/@mysten/utils/dist/esm/chunk.js
function chunk(array2, size4) {
  return Array.from({ length: Math.ceil(array2.length / size4) }, (_, i10) => {
    return array2.slice(i10 * size4, (i10 + 1) * size4);
  });
}

// ../node_modules/@mysten/sui/dist/esm/transactions/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_GAS = 5e10;
async function resolveTransactionData(transactionData, options, next) {
  await normalizeInputs(transactionData, options);
  await resolveObjectReferences(transactionData, options);
  if (!options.onlyTransactionKind) {
    await setGasPrice(transactionData, options);
    await setGasBudget(transactionData, options);
    await setGasPayment(transactionData, options);
  }
  await validate(transactionData);
  return await next();
}
async function setGasPrice(transactionData, options) {
  if (!transactionData.gasConfig.price) {
    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());
  }
}
async function setGasBudget(transactionData, options) {
  if (transactionData.gasConfig.budget) {
    return;
  }
  const dryRunResult = await getClient(options).dryRunTransactionBlock({
    transactionBlock: transactionData.build({
      overrides: {
        gasData: {
          budget: String(MAX_GAS),
          payment: []
        }
      }
    })
  });
  if (dryRunResult.effects.status.status !== "success") {
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
      { cause: dryRunResult }
    );
  }
  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);
  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
  transactionData.gasConfig.budget = String(
    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
  );
}
async function setGasPayment(transactionData, options) {
  if (!transactionData.gasConfig.payment) {
    const coins = await getClient(options).getCoins({
      owner: transactionData.gasConfig.owner || transactionData.sender,
      coinType: SUI_TYPE_ARG
    });
    const paymentCoins = coins.data.filter((coin) => {
      const matchingInput = transactionData.inputs.find((input) => {
        var _a7;
        if ((_a7 = input.Object) == null ? void 0 : _a7.ImmOrOwnedObject) {
          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
        }
        return false;
      });
      return !matchingInput;
    }).map((coin) => ({
      objectId: coin.coinObjectId,
      digest: coin.digest,
      version: coin.version
    }));
    if (!paymentCoins.length) {
      throw new Error("No valid gas coins found for the transaction.");
    }
    transactionData.gasConfig.payment = paymentCoins.map((payment) => parse2(ObjectRef, payment));
  }
}
async function resolveObjectReferences(transactionData, options) {
  const objectsToResolve = transactionData.inputs.filter((input) => {
    var _a7;
    return input.UnresolvedObject && !(input.UnresolvedObject.version || ((_a7 = input.UnresolvedObject) == null ? void 0 : _a7.initialSharedVersion));
  });
  const dedupedIds = [
    ...new Set(
      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))
    )
  ];
  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
  const resolved = (await Promise.all(
    objectChunks.map(
      (chunk2) => getClient(options).multiGetObjects({
        ids: chunk2,
        options: { showOwner: true }
      })
    )
  )).flat();
  const responsesById = new Map(
    dedupedIds.map((id2, index2) => {
      return [id2, resolved[index2]];
    })
  );
  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));
  if (invalidObjects.length) {
    throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
  }
  const objects = resolved.map((object2) => {
    if (object2.error || !object2.data) {
      throw new Error(`Failed to fetch object: ${object2.error}`);
    }
    const owner = object2.data.owner;
    const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : null;
    return {
      objectId: object2.data.objectId,
      digest: object2.data.digest,
      version: object2.data.version,
      initialSharedVersion
    };
  });
  const objectsById = new Map(
    dedupedIds.map((id2, index2) => {
      return [id2, objects[index2]];
    })
  );
  for (const [index2, input] of transactionData.inputs.entries()) {
    if (!input.UnresolvedObject) {
      continue;
    }
    let updated;
    const id2 = normalizeSuiAddress(input.UnresolvedObject.objectId);
    const object2 = objectsById.get(id2);
    if (input.UnresolvedObject.initialSharedVersion ?? (object2 == null ? void 0 : object2.initialSharedVersion)) {
      updated = Inputs.SharedObjectRef({
        objectId: id2,
        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || (object2 == null ? void 0 : object2.initialSharedVersion),
        mutable: isUsedAsMutable(transactionData, index2)
      });
    } else if (isUsedAsReceiving(transactionData, index2)) {
      updated = Inputs.ReceivingRef(
        {
          objectId: id2,
          digest: input.UnresolvedObject.digest ?? (object2 == null ? void 0 : object2.digest),
          version: input.UnresolvedObject.version ?? (object2 == null ? void 0 : object2.version)
        }
      );
    }
    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({
      objectId: id2,
      digest: input.UnresolvedObject.digest ?? (object2 == null ? void 0 : object2.digest),
      version: input.UnresolvedObject.version ?? (object2 == null ? void 0 : object2.version)
    });
  }
}
async function normalizeInputs(transactionData, options) {
  const { inputs, commands } = transactionData;
  const moveCallsToResolve = [];
  const moveFunctionsToResolve = /* @__PURE__ */ new Set();
  commands.forEach((command) => {
    if (command.MoveCall) {
      if (command.MoveCall._argumentTypes) {
        return;
      }
      const inputs2 = command.MoveCall.arguments.map((arg) => {
        if (arg.$kind === "Input") {
          return transactionData.inputs[arg.Input];
        }
        return null;
      });
      const needsResolution = inputs2.some(
        (input) => (input == null ? void 0 : input.UnresolvedPure) || (input == null ? void 0 : input.UnresolvedObject)
      );
      if (needsResolution) {
        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
        moveFunctionsToResolve.add(functionName);
        moveCallsToResolve.push(command.MoveCall);
      }
    }
    switch (command.$kind) {
      case "SplitCoins":
        command.SplitCoins.amounts.forEach((amount) => {
          normalizeRawArgument(amount, suiBcs.U64, transactionData);
        });
        break;
      case "TransferObjects":
        normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
        break;
    }
  });
  const moveFunctionParameters = /* @__PURE__ */ new Map();
  if (moveFunctionsToResolve.size > 0) {
    const client = getClient(options);
    await Promise.all(
      [...moveFunctionsToResolve].map(async (functionName) => {
        const [packageId, moduleId, functionId] = functionName.split("::");
        const def = await client.getNormalizedMoveFunction({
          package: packageId,
          module: moduleId,
          function: functionId
        });
        moveFunctionParameters.set(
          functionName,
          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))
        );
      })
    );
  }
  if (moveCallsToResolve.length) {
    await Promise.all(
      moveCallsToResolve.map(async (moveCall) => {
        const parameters = moveFunctionParameters.get(
          `${moveCall.package}::${moveCall.module}::${moveCall.function}`
        );
        if (!parameters) {
          return;
        }
        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));
        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;
        moveCall._argumentTypes = params;
      })
    );
  }
  commands.forEach((command) => {
    if (!command.MoveCall) {
      return;
    }
    const moveCall = command.MoveCall;
    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
    const params = moveCall._argumentTypes;
    if (!params) {
      return;
    }
    if (params.length !== command.MoveCall.arguments.length) {
      throw new Error(`Incorrect number of arguments for ${fnName}`);
    }
    params.forEach((param, i10) => {
      var _a7, _b3;
      const arg = moveCall.arguments[i10];
      if (arg.$kind !== "Input") return;
      const input = inputs[arg.Input];
      if (!input.UnresolvedPure && !input.UnresolvedObject) {
        return;
      }
      const inputValue = ((_a7 = input.UnresolvedPure) == null ? void 0 : _a7.value) ?? ((_b3 = input.UnresolvedObject) == null ? void 0 : _b3.objectId);
      const schema = getPureBcsSchema(param.body);
      if (schema) {
        arg.type = "pure";
        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
        return;
      }
      if (typeof inputValue !== "string") {
        throw new Error(
          `Expect the argument to be an object id string, got ${JSON.stringify(
            inputValue,
            null,
            2
          )}`
        );
      }
      arg.type = "object";
      const unresolvedObject = input.UnresolvedPure ? {
        $kind: "UnresolvedObject",
        UnresolvedObject: {
          objectId: inputValue
        }
      } : input;
      inputs[arg.Input] = unresolvedObject;
    });
  });
}
function validate(transactionData) {
  transactionData.inputs.forEach((input, index2) => {
    if (input.$kind !== "Object" && input.$kind !== "Pure") {
      throw new Error(
        `Input at index ${index2} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          input
        )}`
      );
    }
  });
}
function normalizeRawArgument(arg, schema, transactionData) {
  if (arg.$kind !== "Input") {
    return;
  }
  const input = transactionData.inputs[arg.Input];
  if (input.$kind !== "UnresolvedPure") {
    return;
  }
  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}
function isUsedAsMutable(transactionData, index2) {
  let usedAsMutable = false;
  transactionData.getInputUses(index2, (arg, tx2) => {
    if (tx2.MoveCall && tx2.MoveCall._argumentTypes) {
      const argIndex = tx2.MoveCall.arguments.indexOf(arg);
      usedAsMutable = tx2.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
    }
    if (tx2.$kind === "MakeMoveVec" || tx2.$kind === "MergeCoins" || tx2.$kind === "SplitCoins") {
      usedAsMutable = true;
    }
  });
  return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index2) {
  let usedAsReceiving = false;
  transactionData.getInputUses(index2, (arg, tx2) => {
    if (tx2.MoveCall && tx2.MoveCall._argumentTypes) {
      const argIndex = tx2.MoveCall.arguments.indexOf(arg);
      usedAsReceiving = isReceivingType(tx2.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
    }
  });
  return usedAsReceiving;
}
function isReceivingType(type2) {
  if (typeof type2.body !== "object" || !("datatype" in type2.body)) {
    return false;
  }
  return type2.body.datatype.package === "0x2" && type2.body.datatype.module === "transfer" && type2.body.datatype.type === "Receiving";
}
function getClient(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}

// ../node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
  function object2(value2) {
    return makeObject(value2);
  }
  object2.system = () => object2("0x5");
  object2.clock = () => object2("0x6");
  object2.random = () => object2("0x8");
  object2.denyList = () => object2("0x403");
  object2.option = ({ type: type2, value: value2 }) => (tx2) => tx2.moveCall({
    typeArguments: [type2],
    target: `0x1::option::${value2 === null ? "none" : "some"}`,
    arguments: value2 === null ? [] : [tx2.object(value2)]
  });
  return object2;
}

// ../node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(typeOrSerializedValue, value2) {
    if (typeof typeOrSerializedValue === "string") {
      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value2));
    }
    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {
      return makePure(typeOrSerializedValue);
    }
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  pure.u8 = (value2) => makePure(suiBcs.U8.serialize(value2));
  pure.u16 = (value2) => makePure(suiBcs.U16.serialize(value2));
  pure.u32 = (value2) => makePure(suiBcs.U32.serialize(value2));
  pure.u64 = (value2) => makePure(suiBcs.U64.serialize(value2));
  pure.u128 = (value2) => makePure(suiBcs.U128.serialize(value2));
  pure.u256 = (value2) => makePure(suiBcs.U256.serialize(value2));
  pure.bool = (value2) => makePure(suiBcs.Bool.serialize(value2));
  pure.string = (value2) => makePure(suiBcs.String.serialize(value2));
  pure.address = (value2) => makePure(suiBcs.Address.serialize(value2));
  pure.id = pure.address;
  pure.vector = (type2, value2) => {
    return makePure(
      suiBcs.vector(pureBcsSchemaFromTypeName(type2)).serialize(value2)
    );
  };
  pure.option = (type2, value2) => {
    return makePure(suiBcs.option(pureBcsSchemaFromTypeName(type2)).serialize(value2));
  };
  return pure;
}

// ../node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e10) => e10.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}

// ../node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class _TransactionDataBuilder {
  constructor(clone) {
    this.version = 2;
    this.sender = (clone == null ? void 0 : clone.sender) ?? null;
    this.expiration = (clone == null ? void 0 : clone.expiration) ?? null;
    this.inputs = (clone == null ? void 0 : clone.inputs) ?? [];
    this.commands = (clone == null ? void 0 : clone.commands) ?? [];
    this.gasData = (clone == null ? void 0 : clone.gasData) ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes) {
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new _TransactionDataBuilder(parse2(TransactionData2, data));
    } else {
      return new _TransactionDataBuilder(parse2(TransactionData2, transactionDataFromV1(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toBase58(hash);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value2) {
    this.gasData = value2;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasData = { ...this.gasData, ...overrides == null ? void 0 : overrides.gasConfig, ...overrides == null ? void 0 : overrides.gasData };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress(this.gasData.owner ?? sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type2, arg) {
    const index2 = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index2, type: type2, $kind: "Input" };
  }
  getInputUses(index2, fn2) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index2) {
        fn2(arg, command);
      }
      return arg;
    });
  }
  mapArguments(fn2) {
    for (const command of this.commands) {
      switch (command.$kind) {
        case "MoveCall":
          command.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn2(arg, command));
          break;
        case "TransferObjects":
          command.TransferObjects.objects = command.TransferObjects.objects.map(
            (arg) => fn2(arg, command)
          );
          command.TransferObjects.address = fn2(command.TransferObjects.address, command);
          break;
        case "SplitCoins":
          command.SplitCoins.coin = fn2(command.SplitCoins.coin, command);
          command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn2(arg, command));
          break;
        case "MergeCoins":
          command.MergeCoins.destination = fn2(command.MergeCoins.destination, command);
          command.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn2(arg, command));
          break;
        case "MakeMoveVec":
          command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
            (arg) => fn2(arg, command)
          );
          break;
        case "Upgrade":
          command.Upgrade.ticket = fn2(command.Upgrade.ticket, command);
          break;
        case "$Intent":
          const inputs = command.$Intent.inputs;
          command.$Intent.inputs = {};
          for (const [key, value2] of Object.entries(inputs)) {
            command.$Intent.inputs[key] = Array.isArray(value2) ? value2.map((arg) => fn2(arg, command)) : fn2(value2, command);
          }
          break;
        case "Publish":
          break;
        default:
          throw new Error(`Unexpected transaction kind: ${command.$kind}`);
      }
    }
  }
  replaceCommand(index2, replacement) {
    if (!Array.isArray(replacement)) {
      this.commands[index2] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index2, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg) => {
        switch (arg.$kind) {
          case "Result":
            if (arg.Result > index2) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] > index2) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return _TransactionDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return parse2(TransactionData2, this);
  }
};

// ../node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if (arg.Object) {
    if (arg.Object.ImmOrOwnedObject) {
      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
    }
    if (arg.Object.Receiving) {
      return normalizeSuiAddress(arg.Object.Receiving.objectId);
    }
    return normalizeSuiAddress(arg.Object.SharedObject.objectId);
  }
  if (arg.UnresolvedObject) {
    return normalizeSuiAddress(arg.UnresolvedObject.objectId);
  }
  return void 0;
}

// ../node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value2) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet6 = (obj, member, value2, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod4 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _serializationPlugins;
var _buildPlugins;
var _intentResolvers;
var _data;
var _Transaction_instances;
var normalizeTransactionArgument_fn;
var resolveArgument_fn;
var prepareBuild_fn;
var runPlugins_fn;
function createTransactionResult(index2, length = Infinity) {
  const baseResult = { $kind: "Result", Result: index2 };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    $kind: "NestedResult",
    NestedResult: [index2, resultIndex]
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i10 = 0;
          while (i10 < length) {
            yield nestedResultFor(i10);
            i10++;
          }
        };
      }
      if (typeof property === "symbol") return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0) return;
      return nestedResultFor(resultIndex);
    }
  });
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
  try {
    const target = globalThis;
    if (!target[TRANSACTION_REGISTRY_KEY]) {
      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
    }
    return target[TRANSACTION_REGISTRY_KEY];
  } catch (e10) {
    return modulePluginRegistry;
  }
}
var _Transaction = class _Transaction2 {
  constructor() {
    __privateAdd6(this, _Transaction_instances);
    __privateAdd6(this, _serializationPlugins);
    __privateAdd6(this, _buildPlugins);
    __privateAdd6(this, _intentResolvers, /* @__PURE__ */ new Map());
    __privateAdd6(this, _data);
    this.object = createObjectMethods(
      (value2) => {
        var _a7, _b3;
        if (typeof value2 === "function") {
          return this.object(value2(this));
        }
        if (typeof value2 === "object" && is(Argument2, value2)) {
          return value2;
        }
        const id2 = getIdFromCallArg(value2);
        const inserted = __privateGet6(this, _data).inputs.find((i10) => id2 === getIdFromCallArg(i10));
        if (((_a7 = inserted == null ? void 0 : inserted.Object) == null ? void 0 : _a7.SharedObject) && typeof value2 === "object" && ((_b3 = value2.Object) == null ? void 0 : _b3.SharedObject)) {
          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value2.Object.SharedObject.mutable;
        }
        return inserted ? { $kind: "Input", Input: __privateGet6(this, _data).inputs.indexOf(inserted), type: "object" } : __privateGet6(this, _data).addInput(
          "object",
          typeof value2 === "string" ? {
            $kind: "UnresolvedObject",
            UnresolvedObject: { objectId: normalizeSuiAddress(value2) }
          } : value2
        );
      }
    );
    const globalPlugins = getGlobalPluginRegistry();
    __privateSet6(this, _data, new TransactionDataBuilder());
    __privateSet6(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
    __privateSet6(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx2 = new _Transaction2();
    __privateSet6(tx2, _data, TransactionDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromBase64(serialized) : serialized
    ));
    return tx2;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(transaction) {
    const newTransaction = new _Transaction2();
    if (isTransaction(transaction)) {
      __privateSet6(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));
    } else if (typeof transaction !== "string" || !transaction.startsWith("{")) {
      __privateSet6(newTransaction, _data, TransactionDataBuilder.fromBytes(
        typeof transaction === "string" ? fromBase64(transaction) : transaction
      ));
    } else {
      __privateSet6(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));
    }
    return newTransaction;
  }
  static registerGlobalSerializationPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().serializationPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalSerializationPlugin(name) {
    getGlobalPluginRegistry().serializationPlugins.delete(name);
  }
  static registerGlobalBuildPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().buildPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalBuildPlugin(name) {
    getGlobalPluginRegistry().buildPlugins.delete(name);
  }
  addSerializationPlugin(step) {
    __privateGet6(this, _serializationPlugins).push(step);
  }
  addBuildPlugin(step) {
    __privateGet6(this, _buildPlugins).push(step);
  }
  addIntentResolver(intent, resolver) {
    if (__privateGet6(this, _intentResolvers).has(intent) && __privateGet6(this, _intentResolvers).get(intent) !== resolver) {
      throw new Error(`Intent resolver for ${intent} already exists`);
    }
    __privateGet6(this, _intentResolvers).set(intent, resolver);
  }
  setSender(sender) {
    __privateGet6(this, _data).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet6(this, _data).sender) {
      __privateGet6(this, _data).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet6(this, _data).expiration = expiration ? parse2(TransactionExpiration2, expiration) : null;
  }
  setGasPrice(price) {
    __privateGet6(this, _data).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet6(this, _data).gasConfig.budget = String(budget);
  }
  setGasBudgetIfNotSet(budget) {
    if (__privateGet6(this, _data).gasData.budget == null) {
      __privateGet6(this, _data).gasConfig.budget = String(budget);
    }
  }
  setGasOwner(owner) {
    __privateGet6(this, _data).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet6(this, _data).gasConfig.payment = payments.map((payment) => parse2(ObjectRef, payment));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return serializeV1TransactionData(__privateGet6(this, _data).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return __privateGet6(this, _data).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value2) => {
        if (isSerializedBcs(value2)) {
          return __privateGet6(this, _data).addInput("pure", {
            $kind: "Pure",
            Pure: {
              bytes: value2.toBase64()
            }
          });
        }
        return __privateGet6(this, _data).addInput(
          "pure",
          is(NormalizedCallArg, value2) ? parse2(NormalizedCallArg, value2) : value2 instanceof Uint8Array ? Inputs.Pure(value2) : { $kind: "UnresolvedPure", UnresolvedPure: { value: value2 } }
        );
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /** Add a transaction to the transaction */
  add(command) {
    if (typeof command === "function") {
      return command(this);
    }
    const index2 = __privateGet6(this, _data).commands.push(command);
    return createTransactionResult(index2 - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    const command = Commands.SplitCoins(
      typeof coin === "string" ? this.object(coin) : __privateMethod4(this, _Transaction_instances, resolveArgument_fn).call(this, coin),
      amounts.map(
        (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod4(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)
      )
    );
    const index2 = __privateGet6(this, _data).commands.push(command);
    return createTransactionResult(index2 - 1, amounts.length);
  }
  mergeCoins(destination, sources) {
    return this.add(
      Commands.MergeCoins(
        this.object(destination),
        sources.map((src) => this.object(src))
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Commands.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return this.add(
      Commands.Upgrade({
        modules,
        dependencies,
        package: packageId,
        ticket: this.object(ticket)
      })
    );
  }
  moveCall({
    arguments: args,
    ...input
  }) {
    return this.add(
      Commands.MoveCall({
        ...input,
        arguments: args == null ? void 0 : args.map((arg) => __privateMethod4(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Commands.TransferObjects(
        objects.map((obj) => this.object(obj)),
        typeof address === "string" ? this.pure.address(address) : __privateMethod4(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type: type2,
    elements
  }) {
    return this.add(
      Commands.MakeMoveVec({
        type: type2,
        elements: elements.map((obj) => this.object(obj))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(serializeV1TransactionData(__privateGet6(this, _data).snapshot()));
  }
  async toJSON(options = {}) {
    await this.prepareForSerialization(options);
    return JSON.stringify(
      parse2(SerializedTransactionDataV2, __privateGet6(this, _data).snapshot()),
      (_key, value2) => typeof value2 === "bigint" ? value2.toString() : value2,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes = await this.build(buildOptions);
    return signer.signTransaction(bytes);
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod4(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet6(this, _data).build({
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await __privateMethod4(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet6(this, _data).getDigest();
  }
  async prepareForSerialization(options) {
    var _a7;
    const intents = /* @__PURE__ */ new Set();
    for (const command of __privateGet6(this, _data).commands) {
      if (command.$Intent) {
        intents.add(command.$Intent.name);
      }
    }
    const steps = [...__privateGet6(this, _serializationPlugins)];
    for (const intent of intents) {
      if ((_a7 = options.supportedIntents) == null ? void 0 : _a7.includes(intent)) {
        continue;
      }
      if (!__privateGet6(this, _intentResolvers).has(intent)) {
        throw new Error(`Missing intent resolver for ${intent}`);
      }
      steps.push(__privateGet6(this, _intentResolvers).get(intent));
    }
    await __privateMethod4(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
  }
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return __privateMethod4(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
  if (typeof arg === "function") {
    return parse2(Argument2, arg(this));
  }
  return parse2(Argument2, arg);
};
prepareBuild_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet6(this, _data).sender) {
    throw new Error("Missing transaction sender");
  }
  await __privateMethod4(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet6(this, _buildPlugins), resolveTransactionData], options);
};
runPlugins_fn = async function(plugins, options) {
  const createNext = (i10) => {
    if (i10 >= plugins.length) {
      return () => {
      };
    }
    const plugin = plugins[i10];
    return async () => {
      const next = createNext(i10 + 1);
      let calledNext = false;
      let nextResolved = false;
      await plugin(__privateGet6(this, _data), options, async () => {
        if (calledNext) {
          throw new Error(`next() was call multiple times in TransactionPlugin ${i10}`);
        }
        calledNext = true;
        await next();
        nextResolved = true;
      });
      if (!calledNext) {
        throw new Error(`next() was not called in TransactionPlugin ${i10}`);
      }
      if (!nextResolved) {
        throw new Error(`next() was not awaited in TransactionPlugin ${i10}`);
      }
    };
  };
  await createNext(0)();
};
var Transaction = _Transaction;

// ../node_modules/@mysten/sui/dist/esm/experimental/core.js
var Experimental_CoreClient = class extends Experimental_BaseClient {
  constructor() {
    super(...arguments);
    this.core = this;
  }
  async getDynamicField(options) {
    const fieldId = deriveDynamicFieldID(
      options.parentId,
      TypeTagSerializer.parseFromStr(options.name.type),
      options.name.bcs
    );
    const {
      objects: [fieldObject]
    } = await this.getObjects({
      objectIds: [fieldId]
    });
    if (fieldObject instanceof Error) {
      throw fieldObject;
    }
    const fieldType = parseStructTag(fieldObject.type);
    return {
      dynamicField: {
        id: fieldObject.id,
        digest: fieldObject.digest,
        version: fieldObject.version,
        type: fieldObject.type,
        name: {
          type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),
          bcs: options.name.bcs
        },
        value: {
          type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),
          bcs: fieldObject.content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    ...input
  }) {
    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
    const abortPromise = new Promise((_, reject) => {
      abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
    });
    abortPromise.catch(() => {
    });
    while (true) {
      abortSignal.throwIfAborted();
      try {
        return await this.getTransaction({
          ...input,
          signal: abortSignal
        });
      } catch (e10) {
        await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
      }
    }
  }
};

// ../node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError = class extends Error {
};
var ObjectError = class _ObjectError extends SuiClientError {
  constructor(code, message) {
    super(message);
    this.code = code;
  }
  static fromResponse(response, objectId) {
    switch (response.code) {
      case "notExists":
        return new _ObjectError(response.code, `Object ${response.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new _ObjectError(
          response.code,
          `Dynamic field not found for object ${response.parent_object_id}`
        );
      case "deleted":
        return new _ObjectError(response.code, `Object ${response.object_id} has been deleted`);
      case "displayError":
        return new _ObjectError(response.code, `Display error: ${response.error}`);
      case "unknown":
      default:
        return new _ObjectError(
          response.code,
          `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`
        );
    }
  }
};

// ../node_modules/@mysten/sui/dist/esm/experimental/transports/jsonRPC.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value2) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet7 = (obj, member, value2, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _jsonRpcClient;
var JSONRpcTransport = class extends Experimental_CoreClient {
  constructor(jsonRpcClient) {
    super({ network: jsonRpcClient.network });
    __privateAdd7(this, _jsonRpcClient);
    __privateSet7(this, _jsonRpcClient, jsonRpcClient);
  }
  async getObjects(options) {
    const batches = batch(options.objectIds, 50);
    const results = [];
    for (const batch2 of batches) {
      const objects = await __privateGet7(this, _jsonRpcClient).multiGetObjects({
        ids: batch2,
        options: {
          showOwner: true,
          showType: true,
          showBcs: true
        }
      });
      for (const [idx, object2] of objects.entries()) {
        if (object2.error) {
          results.push(ObjectError.fromResponse(object2.error, batch2[idx]));
        } else {
          results.push(parseObject(object2.data));
        }
      }
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateGet7(this, _jsonRpcClient).getOwnedObjects({
      owner: options.address,
      limit: options.limit,
      cursor: options.cursor,
      options: {
        showOwner: true,
        showType: true,
        showBcs: true
      }
    });
    return {
      objects: objects.data.map((result) => {
        if (result.error) {
          throw ObjectError.fromResponse(result.error);
        }
        return parseObject(result.data);
      }),
      hasNextPage: objects.hasNextPage,
      cursor: objects.nextCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateGet7(this, _jsonRpcClient).getCoins({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      objects: coins.data.map((coin) => {
        return {
          id: coin.coinObjectId,
          version: coin.version,
          digest: coin.digest,
          balance: coin.balance,
          type: `0x2::coin::Coin<${coin.coinType}>`,
          content: Coin.serialize({
            id: coin.coinObjectId,
            balance: {
              value: coin.balance
            }
          }).toBytes(),
          owner: {
            $kind: "ObjectOwner",
            ObjectOwner: options.address
          }
        };
      }),
      hasNextPage: coins.hasNextPage,
      cursor: coins.nextCursor ?? null
    };
  }
  async getBalance(options) {
    const balance = await __privateGet7(this, _jsonRpcClient).getBalance({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      balance: {
        coinType: balance.coinType,
        balance: balance.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateGet7(this, _jsonRpcClient).getAllBalances({
      owner: options.address
    });
    return {
      balances: balances.map((balance) => ({
        coinType: balance.coinType,
        balance: balance.totalBalance
      })),
      hasNextPage: false,
      cursor: null
    };
  }
  async getTransaction(options) {
    const transaction = await __privateGet7(this, _jsonRpcClient).getTransactionBlock({
      digest: options.digest,
      options: {
        showRawInput: true,
        showObjectChanges: true,
        showRawEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async executeTransaction(options) {
    const transaction = await __privateGet7(this, _jsonRpcClient).executeTransactionBlock({
      transactionBlock: options.transaction,
      signature: options.signatures,
      options: {
        showRawEffects: true,
        showEvents: true,
        showObjectChanges: true,
        showRawInput: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async dryRunTransaction(options) {
    const tx2 = Transaction.from(options.transaction);
    const result = await __privateGet7(this, _jsonRpcClient).dryRunTransactionBlock({
      transactionBlock: options.transaction
    });
    return {
      transaction: {
        digest: await tx2.getDigest(),
        effects: parseTransactionEffectsJson({
          effects: result.effects,
          objectChanges: result.objectChanges
        }),
        signatures: [],
        bcs: options.transaction
      }
    };
  }
  async getReferenceGasPrice() {
    const referenceGasPrice = await __privateGet7(this, _jsonRpcClient).getReferenceGasPrice();
    return {
      referenceGasPrice: String(referenceGasPrice)
    };
  }
  async getDynamicFields(options) {
    const dynamicFields = await __privateGet7(this, _jsonRpcClient).getDynamicFields({
      parentId: options.parentId,
      limit: options.limit,
      cursor: options.cursor
    });
    return {
      dynamicFields: dynamicFields.data.map((dynamicField) => ({
        id: dynamicField.objectId,
        version: dynamicField.version,
        digest: dynamicField.digest,
        type: dynamicField.objectType,
        name: {
          type: dynamicField.name.type,
          bcs: fromBase64(dynamicField.bcsName)
        }
      })),
      hasNextPage: dynamicFields.hasNextPage,
      cursor: dynamicFields.nextCursor
    };
  }
};
_jsonRpcClient = /* @__PURE__ */ new WeakMap();
function parseObject(object2) {
  var _a7;
  return {
    id: object2.objectId,
    version: object2.version,
    digest: object2.digest,
    type: object2.type,
    content: ((_a7 = object2.bcs) == null ? void 0 : _a7.dataType) === "moveObject" ? fromBase64(object2.bcs.bcsBytes) : new Uint8Array(),
    owner: parseOwner(object2.owner)
  };
}
function parseOwner(owner) {
  if (owner === "Immutable") {
    return {
      $kind: "Immutable",
      Immutable: true
    };
  }
  if ("ConsensusV2" in owner) {
    return {
      $kind: "ConsensusV2",
      ConsensusV2: {
        authenticator: {
          $kind: "SingleOwner",
          SingleOwner: owner.ConsensusV2.authenticator.SingleOwner
        },
        startVersion: owner.ConsensusV2.start_version
      }
    };
  }
  if ("AddressOwner" in owner) {
    return {
      $kind: "AddressOwner",
      AddressOwner: owner.AddressOwner
    };
  }
  if ("ObjectOwner" in owner) {
    return {
      $kind: "ObjectOwner",
      ObjectOwner: owner.ObjectOwner
    };
  }
  if ("Shared" in owner) {
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: owner.Shared.initial_shared_version
      }
    };
  }
  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseTransaction(transaction) {
  const parsedTx = suiBcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction))[0];
  return {
    digest: transaction.digest,
    effects: parseTransactionEffects({
      effects: new Uint8Array(transaction.rawEffects),
      objectChanges: transaction.objectChanges ?? null
    }),
    bcs: suiBcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes(),
    signatures: parsedTx.txSignatures
  };
}
function parseTransactionEffects({
  effects,
  epoch,
  objectChanges
}) {
  const parsed = suiBcs.TransactionEffects.parse(effects);
  const objectTypes = {};
  objectChanges == null ? void 0 : objectChanges.forEach((change) => {
    if (change.type !== "published") {
      objectTypes[change.objectId] = change.objectType;
    }
  });
  switch (parsed.$kind) {
    case "V1":
      return parseTransactionEffectsV1({ bytes: effects, effects: parsed.V1, epoch, objectTypes });
    case "V2":
      return parseTransactionEffectsV2({ bytes: effects, effects: parsed.V2, epoch, objectTypes });
    default:
      throw new Error(
        `Unknown transaction effects version: ${parsed.$kind}`
      );
  }
}
function parseTransactionEffectsV1(_) {
  throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV2({
  bytes,
  effects,
  epoch,
  objectTypes
}) {
  const changedObjects = effects.changedObjects.map(
    ([id2, change]) => {
      var _a7, _b3, _c2, _d2, _e, _f2;
      return {
        id: id2,
        inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: ((_a7 = change.inputState.Exist) == null ? void 0 : _a7[0][0]) ?? null,
        inputDigest: ((_b3 = change.inputState.Exist) == null ? void 0 : _b3[0][1]) ?? null,
        inputOwner: ((_c2 = change.inputState.Exist) == null ? void 0 : _c2[1]) ?? null,
        outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
        outputVersion: change.outputState.$kind === "PackageWrite" ? (_d2 = change.outputState.PackageWrite) == null ? void 0 : _d2[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
        outputDigest: change.outputState.$kind === "PackageWrite" ? (_e = change.outputState.PackageWrite) == null ? void 0 : _e[1] : ((_f2 = change.outputState.ObjectWrite) == null ? void 0 : _f2[0]) ?? null,
        outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
        idOperation: change.idOperation.$kind,
        objectType: objectTypes[id2] ?? null
      };
    }
  );
  return {
    bcs: bytes,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.$kind === "Success" ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: add command
      error: effects.status.Failed.error.$kind
    },
    epoch: epoch ?? null,
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
    eventsDigest: effects.eventsDigest,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion,
    changedObjects,
    unchangedSharedObjects: effects.unchangedSharedObjects.map(
      ([objectId, object2]) => {
        return {
          kind: object2.$kind,
          objectId,
          version: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[0] : object2[object2.$kind],
          digest: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[1] : null,
          objectType: objectTypes[objectId] ?? null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxDataDigest
  };
}
function parseTransactionEffectsJson({
  bytes,
  effects,
  epoch,
  objectChanges
}) {
  var _a7;
  const changedObjects = [];
  const unchangedSharedObjects = [];
  objectChanges == null ? void 0 : objectChanges.forEach((change) => {
    var _a8, _b3, _c2, _d2;
    switch (change.type) {
      case "published":
        changedObjects.push({
          id: change.packageId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "PackageWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: null,
          idOperation: "Created",
          objectType: null
        });
        break;
      case "transferred":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: change.digest,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: change.sender
          },
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.recipient),
          idOperation: "None",
          objectType: change.objectType
        });
        break;
      case "mutated":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.previousVersion,
          inputDigest: null,
          inputOwner: parseOwner(change.owner),
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.owner),
          idOperation: "None",
          objectType: change.objectType
        });
        break;
      case "deleted":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: ((_b3 = (_a8 = effects.deleted) == null ? void 0 : _a8.find((d6) => d6.objectId === change.objectId)) == null ? void 0 : _b3.digest) ?? null,
          inputOwner: null,
          outputState: "DoesNotExist",
          outputVersion: null,
          outputDigest: null,
          outputOwner: null,
          idOperation: "Deleted",
          objectType: change.objectType
        });
        break;
      case "wrapped":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: null,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: change.sender
          },
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: ((_d2 = (_c2 = effects.wrapped) == null ? void 0 : _c2.find((w10) => w10.objectId === change.objectId)) == null ? void 0 : _d2.digest) ?? null,
          outputOwner: {
            $kind: "ObjectOwner",
            ObjectOwner: change.sender
          },
          idOperation: "None",
          objectType: change.objectType
        });
        break;
      case "created":
        changedObjects.push({
          id: change.objectId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.owner),
          idOperation: "Created",
          objectType: change.objectType
        });
        break;
    }
  });
  return {
    bcs: bytes ?? null,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.status === "success" ? { success: true, error: null } : { success: false, error: effects.status.error },
    epoch: epoch ?? null,
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: {
      id: (_a7 = effects.gasObject) == null ? void 0 : _a7.reference.objectId,
      inputState: "Exists",
      inputVersion: null,
      inputDigest: null,
      inputOwner: null,
      outputState: "ObjectWrite",
      outputVersion: effects.gasObject.reference.version,
      outputDigest: effects.gasObject.reference.digest,
      outputOwner: parseOwner(effects.gasObject.owner),
      idOperation: "None",
      objectType: normalizeStructTag("0x2::coin::Coin<0x2::sui::SUI>")
    },
    eventsDigest: effects.eventsDigest ?? null,
    dependencies: effects.dependencies ?? [],
    lamportVersion: effects.gasObject.reference.version,
    changedObjects,
    unchangedSharedObjects,
    auxiliaryDataDigest: null
  };
}
var Balance = suiBcs.struct("Balance", {
  value: suiBcs.u64()
});
var Coin = suiBcs.struct("Coin", {
  id: suiBcs.Address,
  balance: Balance
});

// ../node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js
var _caches;
var _cache2;
var _onEffects;
_caches = /* @__PURE__ */ new WeakMap();
_cache2 = /* @__PURE__ */ new WeakMap();
_onEffects = /* @__PURE__ */ new WeakMap();

// ../node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js
var _client;
var _lastDigest;
_client = /* @__PURE__ */ new WeakMap();
_lastDigest = /* @__PURE__ */ new WeakMap();

// ../node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js
var _queue;
var _queue2;
_queue = /* @__PURE__ */ new WeakMap();
_queue2 = /* @__PURE__ */ new WeakMap();

// ../node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js
var _queue3;
var _signer;
var _cache3;
var _defaultGasBudget;
var _cacheGasCoin;
var _buildTransaction;
_queue3 = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
_defaultGasBudget = /* @__PURE__ */ new WeakMap();
_cacheGasCoin = /* @__PURE__ */ new WeakMap();
_buildTransaction = /* @__PURE__ */ new WeakMap();
function getGasCoinFromEffects(effects) {
  if (!effects.V2) {
    throw new Error("Unexpected effects version");
  }
  const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];
  if (!gasObjectChange) {
    throw new Error("Gas object not found in effects");
  }
  const [objectId, { outputState }] = gasObjectChange;
  if (!outputState.ObjectWrite) {
    throw new Error("Unexpected gas object state");
  }
  const [digest, owner] = outputState.ObjectWrite;
  return {
    ref: {
      objectId,
      digest,
      version: effects.V2.lamportVersion
    },
    owner: owner.AddressOwner || owner.ObjectOwner
  };
}

// ../node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet8 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet8 = (obj, member, value2, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod5 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var __privateWrapper3 = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet8(obj, member, value2, setter);
  },
  get _() {
    return __privateGet8(obj, member, getter);
  }
});
var _signer2;
var _client2;
var _coinBatchSize;
var _initialCoinBalance;
var _minimumCoinBalance;
var _epochBoundaryWindow;
var _defaultGasBudget2;
var _maxPoolSize;
var _sourceCoins;
var _coinPool;
var _cache4;
var _objectIdQueues;
var _buildQueue;
var _executeQueue;
var _lastDigest2;
var _cacheLock;
var _pendingTransactions;
var _gasPrice;
var _ParallelTransactionExecutor_instances;
var getUsedObjects_fn;
var execute_fn;
var updateCache_fn;
var waitForLastDigest_fn;
var getGasCoin_fn;
var getGasPrice_fn;
var refillCoinPool_fn;
_signer2 = /* @__PURE__ */ new WeakMap();
_client2 = /* @__PURE__ */ new WeakMap();
_coinBatchSize = /* @__PURE__ */ new WeakMap();
_initialCoinBalance = /* @__PURE__ */ new WeakMap();
_minimumCoinBalance = /* @__PURE__ */ new WeakMap();
_epochBoundaryWindow = /* @__PURE__ */ new WeakMap();
_defaultGasBudget2 = /* @__PURE__ */ new WeakMap();
_maxPoolSize = /* @__PURE__ */ new WeakMap();
_sourceCoins = /* @__PURE__ */ new WeakMap();
_coinPool = /* @__PURE__ */ new WeakMap();
_cache4 = /* @__PURE__ */ new WeakMap();
_objectIdQueues = /* @__PURE__ */ new WeakMap();
_buildQueue = /* @__PURE__ */ new WeakMap();
_executeQueue = /* @__PURE__ */ new WeakMap();
_lastDigest2 = /* @__PURE__ */ new WeakMap();
_cacheLock = /* @__PURE__ */ new WeakMap();
_pendingTransactions = /* @__PURE__ */ new WeakMap();
_gasPrice = /* @__PURE__ */ new WeakMap();
_ParallelTransactionExecutor_instances = /* @__PURE__ */ new WeakSet();
getUsedObjects_fn = async function(transaction) {
  const usedObjects = /* @__PURE__ */ new Set();
  let serialized = false;
  transaction.addSerializationPlugin(async (blockData, _options2, next) => {
    await next();
    if (serialized) {
      return;
    }
    serialized = true;
    blockData.inputs.forEach((input) => {
      var _a7, _b3, _c2, _d2, _e;
      if ((_b3 = (_a7 = input.Object) == null ? void 0 : _a7.ImmOrOwnedObject) == null ? void 0 : _b3.objectId) {
        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
      } else if ((_d2 = (_c2 = input.Object) == null ? void 0 : _c2.Receiving) == null ? void 0 : _d2.objectId) {
        usedObjects.add(input.Object.Receiving.objectId);
      } else if (((_e = input.UnresolvedObject) == null ? void 0 : _e.objectId) && !input.UnresolvedObject.initialSharedVersion) {
        usedObjects.add(input.UnresolvedObject.objectId);
      }
    });
  });
  await transaction.prepareForSerialization({ client: __privateGet8(this, _client2) });
  return usedObjects;
};
execute_fn = async function(transaction, usedObjects, options, additionalSignatures = []) {
  var _a7;
  let gasCoin;
  try {
    transaction.setSenderIfNotSet(__privateGet8(this, _signer2).toSuiAddress());
    await __privateGet8(this, _buildQueue).runTask(async () => {
      const data = transaction.getData();
      if (!data.gasData.price) {
        transaction.setGasPrice(await __privateMethod5(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));
      }
      transaction.setGasBudgetIfNotSet(__privateGet8(this, _defaultGasBudget2));
      await __privateMethod5(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);
      gasCoin = await __privateMethod5(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);
      __privateWrapper3(this, _pendingTransactions)._++;
      transaction.setGasPayment([
        {
          objectId: gasCoin.id,
          version: gasCoin.version,
          digest: gasCoin.digest
        }
      ]);
      await __privateGet8(this, _cache4).buildTransaction({ transaction, onlyTransactionKind: true });
    });
    const bytes = await transaction.build({ client: __privateGet8(this, _client2) });
    const { signature } = await __privateGet8(this, _signer2).signTransaction(bytes);
    const results = await __privateGet8(this, _cache4).executeTransaction({
      transaction: bytes,
      signature: [signature, ...additionalSignatures],
      options: {
        ...options,
        showEffects: true
      }
    });
    const effectsBytes = Uint8Array.from(results.rawEffects);
    const effects = suiBcs.TransactionEffects.parse(effectsBytes);
    const gasResult = getGasCoinFromEffects(effects);
    const gasUsed = (_a7 = effects.V2) == null ? void 0 : _a7.gasUsed;
    if (gasCoin && gasUsed && gasResult.owner === __privateGet8(this, _signer2).toSuiAddress()) {
      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
      let usesGasCoin = false;
      new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {
        if (arg.$kind === "GasCoin") {
          usesGasCoin = true;
        }
        return arg;
      });
      if (!usesGasCoin && gasCoin.balance >= __privateGet8(this, _minimumCoinBalance)) {
        __privateGet8(this, _coinPool).push({
          id: gasResult.ref.objectId,
          version: gasResult.ref.version,
          digest: gasResult.ref.digest,
          balance: gasCoin.balance - totalUsed
        });
      } else {
        if (!__privateGet8(this, _sourceCoins)) {
          __privateSet8(this, _sourceCoins, /* @__PURE__ */ new Map());
        }
        __privateGet8(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
      }
    }
    __privateSet8(this, _lastDigest2, results.digest);
    return {
      digest: results.digest,
      effects: toBase64(effectsBytes),
      data: results
    };
  } catch (error2) {
    if (gasCoin) {
      if (!__privateGet8(this, _sourceCoins)) {
        __privateSet8(this, _sourceCoins, /* @__PURE__ */ new Map());
      }
      __privateGet8(this, _sourceCoins).set(gasCoin.id, null);
    }
    await __privateMethod5(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {
      await Promise.all([
        __privateGet8(this, _cache4).cache.deleteObjects([...usedObjects]),
        __privateMethod5(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)
      ]);
    });
    throw error2;
  } finally {
    usedObjects.forEach((objectId) => {
      const queue = __privateGet8(this, _objectIdQueues).get(objectId);
      if (queue && queue.length > 0) {
        queue.shift()();
      } else if (queue) {
        __privateGet8(this, _objectIdQueues).delete(objectId);
      }
    });
    __privateWrapper3(this, _pendingTransactions)._--;
  }
};
updateCache_fn = async function(fn2) {
  if (__privateGet8(this, _cacheLock)) {
    await __privateGet8(this, _cacheLock);
  }
  __privateSet8(this, _cacheLock, (fn2 == null ? void 0 : fn2().then(
    () => {
      __privateSet8(this, _cacheLock, null);
    },
    () => {
    }
  )) ?? null);
};
waitForLastDigest_fn = async function() {
  const digest = __privateGet8(this, _lastDigest2);
  if (digest) {
    __privateSet8(this, _lastDigest2, null);
    await __privateGet8(this, _client2).waitForTransaction({ digest });
  }
};
getGasCoin_fn = async function() {
  if (__privateGet8(this, _coinPool).length === 0 && __privateGet8(this, _pendingTransactions) <= __privateGet8(this, _maxPoolSize)) {
    await __privateMethod5(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);
  }
  if (__privateGet8(this, _coinPool).length === 0) {
    throw new Error("No coins available");
  }
  const coin = __privateGet8(this, _coinPool).shift();
  return coin;
};
getGasPrice_fn = async function() {
  const remaining = __privateGet8(this, _gasPrice) ? __privateGet8(this, _gasPrice).expiration - __privateGet8(this, _epochBoundaryWindow) - Date.now() : 0;
  if (remaining > 0) {
    return __privateGet8(this, _gasPrice).price;
  }
  if (__privateGet8(this, _gasPrice)) {
    const timeToNextEpoch = Math.max(
      __privateGet8(this, _gasPrice).expiration + __privateGet8(this, _epochBoundaryWindow) - Date.now(),
      1e3
    );
    await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));
  }
  const state = await __privateGet8(this, _client2).getLatestSuiSystemState();
  __privateSet8(this, _gasPrice, {
    price: BigInt(state.referenceGasPrice),
    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)
  });
  return __privateMethod5(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);
};
refillCoinPool_fn = async function() {
  var _a7;
  const batchSize = Math.min(
    __privateGet8(this, _coinBatchSize),
    __privateGet8(this, _maxPoolSize) - (__privateGet8(this, _coinPool).length + __privateGet8(this, _pendingTransactions)) + 1
  );
  if (batchSize === 0) {
    return;
  }
  const txb = new Transaction();
  const address = __privateGet8(this, _signer2).toSuiAddress();
  txb.setSender(address);
  if (__privateGet8(this, _sourceCoins)) {
    const refs = [];
    const ids = [];
    for (const [id2, ref] of __privateGet8(this, _sourceCoins)) {
      if (ref) {
        refs.push(ref);
      } else {
        ids.push(id2);
      }
    }
    if (ids.length > 0) {
      const coins = await __privateGet8(this, _client2).multiGetObjects({
        ids
      });
      refs.push(
        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
          objectId: data.objectId,
          version: data.version,
          digest: data.digest
        }))
      );
    }
    txb.setGasPayment(refs);
    __privateSet8(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const amounts = new Array(batchSize).fill(__privateGet8(this, _initialCoinBalance));
  const results = txb.splitCoins(txb.gas, amounts);
  const coinResults = [];
  for (let i10 = 0; i10 < amounts.length; i10++) {
    coinResults.push(results[i10]);
  }
  txb.transferObjects(coinResults, address);
  await this.waitForLastTransaction();
  const result = await __privateGet8(this, _client2).signAndExecuteTransaction({
    transaction: txb,
    signer: __privateGet8(this, _signer2),
    options: {
      showRawEffects: true
    }
  });
  const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
  (_a7 = effects.V2) == null ? void 0 : _a7.changedObjects.forEach(([id2, { outputState }], i10) => {
    var _a8;
    if (i10 === ((_a8 = effects.V2) == null ? void 0 : _a8.gasObjectIndex) || !outputState.ObjectWrite) {
      return;
    }
    __privateGet8(this, _coinPool).push({
      id: id2,
      version: effects.V2.lamportVersion,
      digest: outputState.ObjectWrite[0],
      balance: BigInt(__privateGet8(this, _initialCoinBalance))
    });
  });
  if (!__privateGet8(this, _sourceCoins)) {
    __privateSet8(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const gasObject = getGasCoinFromEffects(effects).ref;
  __privateGet8(this, _sourceCoins).set(gasObject.objectId, gasObject);
  await __privateGet8(this, _client2).waitForTransaction({ digest: result.digest });
};

// ../node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
var CoinWithBalanceData = object({
  type: string(),
  balance: bigint()
});

// ../node_modules/@mysten/sui/dist/esm/transactions/Arguments.js
var Arguments = {
  pure: createPure((value2) => (tx2) => tx2.pure(value2)),
  object: createObjectMethods((value2) => (tx2) => tx2.object(value2)),
  sharedObjectRef: (...args) => (tx2) => tx2.sharedObjectRef(...args),
  objectRef: (...args) => (tx2) => tx2.objectRef(...args),
  receivingRef: (...args) => (tx2) => tx2.receivingRef(...args)
};

// ../node_modules/@mysten/sui/dist/esm/client/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiClient = class extends Experimental_BaseClient {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    super({ network: options.network ?? "unknown" });
    this.core = new JSONRpcTransport(this);
    this.jsonRpc = this;
    this.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });
  }
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  async getRpcApiVersion({ signal } = {}) {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: [],
      signal
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [input.owner, input.coinType, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [input.owner, input.coinType],
      signal: input.signal
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllBalances",
      params: [input.owner],
      signal: input.signal
    });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [input.coinType],
      signal: input.signal
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [input.coinType],
      signal: input.signal
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params, { signal } = {}) {
    return await this.transport.request({ method, params, signal });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [input.package, input.module, input.function],
      signal: input.signal
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [input.package],
      signal: input.signal
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [input.package, input.module],
      signal: input.signal
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [input.package, input.module, input.function],
      signal: input.signal
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [input.package, input.module, input.struct],
      signal: input.signal
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ],
      signal: input.signal
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options],
      signal: input.signal
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options],
      signal: input.signal
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id2) => {
      if (!id2 || !isValidSuiObjectId(normalizeSuiObjectId(id2))) {
        throw new Error(`Invalid Sui Object id ${id2}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options],
      signal: input.signal
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      signal: input.signal
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options],
      signal: input.signal
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d6) => {
      if (!isValidTransactionDigest(d6)) {
        throw new Error(`Invalid Transaction digest ${d6}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options],
      signal: input.signal
    });
  }
  async executeTransactionBlock({
    transactionBlock,
    signature,
    options,
    requestType,
    signal
  }) {
    const result = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof transactionBlock === "string" ? transactionBlock : toBase64(transactionBlock),
        Array.isArray(signature) ? signature : [signature],
        options
      ],
      signal
    });
    if (requestType === "WaitForLocalExecution") {
      try {
        await this.waitForTransaction({
          digest: result.digest
        });
      } catch (_) {
      }
    }
    return result;
  }
  async signAndExecuteTransaction({
    transaction,
    signer,
    ...input
  }) {
    let transactionBytes;
    if (transaction instanceof Uint8Array) {
      transactionBytes = transaction;
    } else {
      transaction.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transaction.build({ client: this });
    }
    const { signature, bytes } = await signer.signTransaction(transactionBytes);
    return this.executeTransactionBlock({
      transactionBlock: bytes,
      signature,
      ...input
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks({ signal } = {}) {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: [],
      signal
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice({ signal } = {}) {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: [],
      signal
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getStakes",
      params: [input.owner],
      signal: input.signal
    });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id2) => {
      if (!id2 || !isValidSuiObjectId(normalizeSuiObjectId(id2))) {
        throw new Error(`Invalid Sui Stake id ${id2}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds],
      signal: input.signal
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState({
    signal
  } = {}) {
    return await this.transport.request({
      method: "suix_getLatestSuiSystemState",
      params: [],
      signal
    });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      signal: input.signal
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage,
      signal: input.signal
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage,
      signal: input.signal
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    var _a7, _b3;
    let devInspectTxBytes;
    if (isTransaction(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toBase64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toBase64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    (_a7 = input.signal) == null ? void 0 : _a7.throwIfAborted();
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, (_b3 = input.gasPrice) == null ? void 0 : _b3.toString(), input.epoch],
      signal: input.signal
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toBase64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name],
      signal: input.signal
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber({
    signal
  } = {}) {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: [],
      signal
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({
      method: "sui_getCheckpoint",
      params: [input.id],
      signal: input.signal
    });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input == null ? void 0 : input.limit, input.descendingOrder],
      signal: input.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input == null ? void 0 : input.epoch],
      signal: input == null ? void 0 : input.signal
    });
  }
  async getNetworkMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getNetworkMetrics",
      params: [],
      signal
    });
  }
  async getAddressMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getLatestAddressMetrics",
      params: [],
      signal
    });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder],
      signal: input == null ? void 0 : input.signal
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input == null ? void 0 : input.descendingOrder],
      signal: input == null ? void 0 : input.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder],
      signal: input == null ? void 0 : input.signal
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getMoveCallMetrics",
      params: [],
      signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getCurrentEpoch",
      params: [],
      signal
    });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getValidatorsApy",
      params: [],
      signal
    });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier({ signal } = {}) {
    const checkpoint = await this.getCheckpoint({ id: "0", signal });
    const bytes = fromBase58(checkpoint.digest);
    return toHex(bytes.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name],
      signal: input.signal
    });
  }
  async resolveNameServiceNames({
    format = "dot",
    ...input
  }) {
    const { nextCursor, hasNextPage: hasNextPage2, data } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit],
      signal: input.signal
    });
    return {
      hasNextPage: hasNextPage2,
      nextCursor,
      data: data.map((name) => normalizeSuiNSName(name, format))
    };
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input == null ? void 0 : input.version],
      signal: input == null ? void 0 : input.signal
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    pollInterval = 2 * 1e3,
    ...input
  }) {
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal == null ? void 0 : signal.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch (e10) {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
  experimental_asClientExtension() {
    return {
      name: "jsonRPC",
      register: () => {
        return this;
      }
    };
  }
};

// ../node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value2, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value2 >> _32n2 & _u32_max);
  const wl2 = Number(value2 & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l10 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh2, isLE2);
  view.setUint32(byteOffset + l10, wl2, isLE2);
}
function Chi(a10, b, c) {
  return a10 & b ^ ~a10 & c;
}
function Maj(a10, b, c) {
  return a10 & b ^ a10 & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i10 = pos; i10 < blockLen; i10++)
      buffer[i10] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i10 = 0; i10 < outLen; i10++)
      oview.setUint32(4 * i10, state[i10], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to2.length = length;
    to2.pos = pos;
    to2.finished = finished;
    to2.destroyed = destroyed;
    if (length % blockLen)
      to2.buffer.set(buffer);
    return to2;
  }
};

// ../node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H: H10 } = this;
    return [A, B, C, D, E, F, G, H10];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H10) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H10 | 0;
  }
  process(view, offset4) {
    for (let i10 = 0; i10 < 16; i10++, offset4 += 4)
      SHA256_W[i10] = view.getUint32(offset4, false);
    for (let i10 = 16; i10 < 64; i10++) {
      const W15 = SHA256_W[i10 - 15];
      const W22 = SHA256_W[i10 - 2];
      const s02 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s12 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i10] = s12 + SHA256_W[i10 - 7] + s02 + SHA256_W[i10 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H: H10 } = this;
    for (let i10 = 0; i10 < 64; i10++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T12 = H10 + sigma1 + Chi(E, F, G) + SHA256_K[i10] + SHA256_W[i10] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H10 = G;
      G = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H10 = H10 + this.H | 0;
    this.set(A, B, C, D, E, F, G, H10);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// ../node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i10 = 0; i10 < pad.length; i10++)
      pad[i10] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i10 = 0; i10 < pad.length; i10++)
      pad[i10] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// ../node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes2,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  inRange: () => inRange,
  isBytes: () => isBytes3,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes3(a10) {
  return a10 instanceof Uint8Array || ArrayBuffer.isView(a10) && a10.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
function abool(title3, value2) {
  if (typeof value2 !== "boolean")
    throw new Error(title3 + " boolean expected, got " + value2);
}
var hexes2 = Array.from({ length: 256 }, (_, i10) => i10.toString(16).padStart(2, "0"));
function bytesToHex2(bytes) {
  abytes2(bytes);
  let hex2 = "";
  for (let i10 = 0; i10 < bytes.length; i10++) {
    hex2 += hexes2[bytes[i10]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n : BigInt("0x" + hex2);
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl2);
  const array2 = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n12 = asciiToBase162(hex2.charCodeAt(hi2));
    const n22 = asciiToBase162(hex2.charCodeAt(hi2 + 1));
    if (n12 === void 0 || n22 === void 0) {
      const char = hex2[hi2] + hex2[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array2[ai2] = n12 * 16 + n22;
  }
  return array2;
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex2(bytes));
}
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n10, len) {
  return hexToBytes2(n10.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n10, len) {
  return numberToBytesBE(n10, len).reverse();
}
function numberToVarBytesBE(n10) {
  return hexToBytes2(numberToHexUnpadded(n10));
}
function ensureBytes(title3, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes2(hex2);
    } catch (e10) {
      throw new Error(title3 + " must be hex string or Uint8Array, cause: " + e10);
    }
  } else if (isBytes3(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title3 + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title3 + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i10 = 0; i10 < arrays.length; i10++) {
    const a10 = arrays[i10];
    abytes2(a10);
    sum += a10.length;
  }
  const res = new Uint8Array(sum);
  for (let i10 = 0, pad = 0; i10 < arrays.length; i10++) {
    const a10 = arrays[i10];
    res.set(a10, pad);
    pad += a10.length;
  }
  return res;
}
function equalBytes(a10, b) {
  if (a10.length !== b.length)
    return false;
  let diff = 0;
  for (let i10 = 0; i10 < a10.length; i10++)
    diff |= a10[i10] ^ b[i10];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n10) => typeof n10 === "bigint" && _0n <= n10;
function inRange(n10, min2, max2) {
  return isPosBig(n10) && isPosBig(min2) && isPosBig(max2) && min2 <= n10 && n10 < max2;
}
function aInRange(title3, n10, min2, max2) {
  if (!inRange(n10, min2, max2))
    throw new Error("expected valid " + title3 + ": " + min2 + " <= n < " + max2 + ", got " + n10);
}
function bitLen(n10) {
  let len;
  for (len = 0; n10 > _0n; n10 >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n10, pos) {
  return n10 >> BigInt(pos) & _1n;
}
function bitSet(n10, pos, value2) {
  return n10 | (value2 ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n10) => (_2n << BigInt(n10 - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v10 = u8n(hashLen);
  let k = u8n(hashLen);
  let i10 = 0;
  const reset = () => {
    v10.fill(1);
    k.fill(0);
    i10 = 0;
  };
  const h = (...b) => hmacFn(k, v10, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v10 = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v10 = h();
  };
  const gen = () => {
    if (i10++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v10 = h();
      const sl2 = v10.slice();
      out.push(sl2);
      len += v10.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object2;
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn2) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// ../node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a10, b) {
  const result = a10 % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n2)
    throw new Error("invalid modulus");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a10 = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u10 = _1n2, v10 = _0n2;
  while (a10 !== _0n2) {
    const q = b / a10;
    const r10 = b % a10;
    const m = x - u10 * q;
    const n10 = y - v10 * q;
    b = a10, a10 = r10, x = u10, y = v10, u10 = m, v10 = n10;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++) {
    if (Z > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp3, n10) {
      const root = Fp3.pow(n10, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n10))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp3, n10) {
    if (Fp3.pow(n10, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r10 = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n10, Q1div2);
    let b = Fp3.pow(n10, Q);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO))
        return Fp3.ZERO;
      let m = 1;
      for (let t23 = Fp3.sqr(b); m < r10; m++) {
        if (Fp3.eql(t23, Fp3.ONE))
          break;
        t23 = Fp3.sqr(t23);
      }
      const ge2 = Fp3.pow(g, _1n2 << BigInt(r10 - m - 1));
      g = Fp3.sqr(ge2);
      x = Fp3.mul(x, ge2);
      b = Fp3.mul(b, g);
      r10 = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp3, n10) {
      const root = Fp3.pow(n10, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n10))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c12 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp3, n10) {
      const n22 = Fp3.mul(n10, _2n2);
      const v10 = Fp3.pow(n22, c12);
      const nv2 = Fp3.mul(n10, v10);
      const i10 = Fp3.mul(Fp3.mul(nv2, _2n2), v10);
      const root = Fp3.mul(nv2, Fp3.sub(i10, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n10))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d6 = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d6);
    d6 = f.sqr(d6);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i10) => {
    if (f.is0(num))
      return acc;
    tmp[i10] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i10) => {
    if (f.is0(num))
      return acc;
    tmp[i10] = f.mul(acc, tmp[i10]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n10, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n10.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n10) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n10);
    }),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a10, b, c) => c ? b : a10,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f);
}
function FpSqrtEven(Fp3, elm) {
  if (!Fp3.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp3.sqrt(elm);
  return Fp3.isOdd(root) ? Fp3.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// ../node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, bits) {
  validateW(W, bits);
  const windows = Math.ceil(bits / W) + 1;
  const windowSize = 2 ** (W - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i10) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i10);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s10, i10) => {
    if (!field.isValid(s10))
      throw new Error("invalid scalar at index " + i10);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n10, p = c.ZERO) {
      let d6 = elm;
      while (n10 > _0n3) {
        if (n10 & _1n3)
          p = p.add(d6);
        d6 = d6.double();
        n10 >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i10 = 1; i10 < windowSize; i10++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n10) {
      const { windows, windowSize } = calcWOpts(W, bits);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset4 = window2 * windowSize;
        let wbits = Number(n10 & mask);
        n10 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n10 += _1n3;
        }
        const offset1 = offset4;
        const offset22 = offset4 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n10, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset4 = window2 * windowSize;
        if (n10 === _0n3)
          break;
        let wbits = Number(n10 & mask);
        n10 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n10 += _1n3;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset4 + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W, P, transform2) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform2(comp));
      }
      return comp;
    },
    wNAFCached(P, n10, transform2) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform2), n10);
    },
    wNAFCachedUnsafe(P, n10, transform2, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n10, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform2), n10, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i10 = lastBits; i10 >= 0; i10 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i10) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i10 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// ../node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a10 } = opts;
  if (endo) {
    if (!Fp3.eql(a10, Fp3.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t10 = numberToHexUnpadded(tag);
      return t10 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length = length << 8 | b;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v10 = data.subarray(pos, pos + length);
      if (v10.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v: v10, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E } = DER;
      if (num < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded(num);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return b2n(data);
    }
  },
  toSig(hex2) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    abytes2(data);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs2 = tlv.encode(2, int.encode(sig.r));
    const ss2 = tlv.encode(2, int.encode(sig.s));
    const seq = rs2 + ss2;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const Fn2 = Field(CURVE.n, CURVE.nBitLength);
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a10 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a10.x), Fp3.toBytes(a10.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a: a10, b } = CURVE;
    const x22 = Fp3.sqr(x);
    const x32 = Fp3.mul(x22, x);
    return Fp3.add(Fp3.add(x32, Fp3.mul(x, a10)), b);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n4, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error2) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod(num, N);
    aInRange("private key", num, _1n4, N);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp3.eql(z, Fp3.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z);
    const ax2 = Fp3.mul(x, iz);
    const ay2 = Fp3.mul(y, iz);
    const zz = Fp3.mul(z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax2, y: ay2 };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp3.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left = Fp3.sqr(y);
    const right = weierstrassEquation(x);
    if (!Fp3.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point {
    constructor(px2, py2, pz) {
      this.px = px2;
      this.py = py2;
      this.pz = pz;
      if (px2 == null || !Fp3.isValid(px2))
        throw new Error("x required");
      if (py2 == null || !Fp3.isValid(py2))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i10) => Fp3.eql(i10, Fp3.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i10) => p.toAffine(toInv[i10])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn2, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X12, py: Y12, pz: Z12 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U12 = Fp3.eql(Fp3.mul(X12, Z22), Fp3.mul(X22, Z12));
      const U22 = Fp3.eql(Fp3.mul(Y12, Z22), Fp3.mul(Y22, Z12));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a10, b } = CURVE;
      const b32 = Fp3.mul(b, _3n2);
      const { px: X12, py: Y12, pz: Z12 } = this;
      let X32 = Fp3.ZERO, Y32 = Fp3.ZERO, Z32 = Fp3.ZERO;
      let t02 = Fp3.mul(X12, X12);
      let t12 = Fp3.mul(Y12, Y12);
      let t23 = Fp3.mul(Z12, Z12);
      let t32 = Fp3.mul(X12, Y12);
      t32 = Fp3.add(t32, t32);
      Z32 = Fp3.mul(X12, Z12);
      Z32 = Fp3.add(Z32, Z32);
      X32 = Fp3.mul(a10, Z32);
      Y32 = Fp3.mul(b32, t23);
      Y32 = Fp3.add(X32, Y32);
      X32 = Fp3.sub(t12, Y32);
      Y32 = Fp3.add(t12, Y32);
      Y32 = Fp3.mul(X32, Y32);
      X32 = Fp3.mul(t32, X32);
      Z32 = Fp3.mul(b32, Z32);
      t23 = Fp3.mul(a10, t23);
      t32 = Fp3.sub(t02, t23);
      t32 = Fp3.mul(a10, t32);
      t32 = Fp3.add(t32, Z32);
      Z32 = Fp3.add(t02, t02);
      t02 = Fp3.add(Z32, t02);
      t02 = Fp3.add(t02, t23);
      t02 = Fp3.mul(t02, t32);
      Y32 = Fp3.add(Y32, t02);
      t23 = Fp3.mul(Y12, Z12);
      t23 = Fp3.add(t23, t23);
      t02 = Fp3.mul(t23, t32);
      X32 = Fp3.sub(X32, t02);
      Z32 = Fp3.mul(t23, t12);
      Z32 = Fp3.add(Z32, Z32);
      Z32 = Fp3.add(Z32, Z32);
      return new Point(X32, Y32, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X12, py: Y12, pz: Z12 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp3.ZERO, Y32 = Fp3.ZERO, Z32 = Fp3.ZERO;
      const a10 = CURVE.a;
      const b32 = Fp3.mul(CURVE.b, _3n2);
      let t02 = Fp3.mul(X12, X22);
      let t12 = Fp3.mul(Y12, Y22);
      let t23 = Fp3.mul(Z12, Z22);
      let t32 = Fp3.add(X12, Y12);
      let t42 = Fp3.add(X22, Y22);
      t32 = Fp3.mul(t32, t42);
      t42 = Fp3.add(t02, t12);
      t32 = Fp3.sub(t32, t42);
      t42 = Fp3.add(X12, Z12);
      let t52 = Fp3.add(X22, Z22);
      t42 = Fp3.mul(t42, t52);
      t52 = Fp3.add(t02, t23);
      t42 = Fp3.sub(t42, t52);
      t52 = Fp3.add(Y12, Z12);
      X32 = Fp3.add(Y22, Z22);
      t52 = Fp3.mul(t52, X32);
      X32 = Fp3.add(t12, t23);
      t52 = Fp3.sub(t52, X32);
      Z32 = Fp3.mul(a10, t42);
      X32 = Fp3.mul(b32, t23);
      Z32 = Fp3.add(X32, Z32);
      X32 = Fp3.sub(t12, Z32);
      Z32 = Fp3.add(t12, Z32);
      Y32 = Fp3.mul(X32, Z32);
      t12 = Fp3.add(t02, t02);
      t12 = Fp3.add(t12, t02);
      t23 = Fp3.mul(a10, t23);
      t42 = Fp3.mul(b32, t42);
      t12 = Fp3.add(t12, t23);
      t23 = Fp3.sub(t02, t23);
      t23 = Fp3.mul(a10, t23);
      t42 = Fp3.add(t42, t23);
      t02 = Fp3.mul(t12, t42);
      Y32 = Fp3.add(Y32, t02);
      t02 = Fp3.mul(t52, t42);
      X32 = Fp3.mul(t32, X32);
      X32 = Fp3.sub(X32, t02);
      t02 = Fp3.mul(t32, t12);
      Z32 = Fp3.mul(t52, Z32);
      Z32 = Fp3.add(Z32, t02);
      return new Point(X32, Y32, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n10) {
      return wnaf.wNAFCached(this, n10, Point.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n4, N);
      const I = Point.ZERO;
      if (sc === _0n4)
        return I;
      if (this.is0() || sc === _1n4)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
      let { k1neg, k1: k12, k2neg, k2: k22 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d6 = this;
      while (k12 > _0n4 || k22 > _0n4) {
        if (k12 & _1n4)
          k1p = k1p.add(d6);
        if (k22 & _1n4)
          k2p = k2p.add(d6);
        d6 = d6.double();
        k12 >>= _1n4;
        k22 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n4, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1: k12, k2neg, k2: k22 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k12);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a10, b) {
      const G = Point.BASE;
      const mul = (P, a11) => a11 === _0n4 || a11 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a11) : P.multiply(a11);
      const sum = mul(this, a10).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point.ZERO = new Point(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function modN(a10) {
    return mod(a10, CURVE_ORDER);
  }
  function invN(a10) {
    return invert(a10, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a10 = point.toAffine();
      const x = Fp3.toBytes(a10.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a10.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n4, Fp3.ORDER))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x);
        let y;
        try {
          y = Fp3.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp3.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      } else {
        const cl2 = compressedLen;
        const ul2 = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl2 + ", or uncompressed " + ul2 + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n4;
    return number2 > HALF;
  }
  function normalizeS(s10) {
    return isBiggerThanHalfOrder(s10) ? modN(-s10) : s10;
  }
  const slcNum = (b, from, to2) => bytesToNumberBE(b.slice(from, to2));
  class Signature {
    constructor(r10, s10, recovery) {
      this.r = r10;
      this.s = s10;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l10 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l10 * 2);
      return new Signature(slcNum(hex2, 0, l10), slcNum(hex2, l10, 2 * l10));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r10, s: s10 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r10, s10);
    }
    assertValidity() {
      aInRange("r", this.r, _1n4, CURVE_ORDER);
      aInRange("s", this.s, _1n4, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r10, s: s10, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r10 + CURVE.n : r10;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R10 = Point.fromHex(prefix + numToNByteStr(radj));
      const ir2 = invN(radj);
      const u12 = modN(-h * ir2);
      const u22 = modN(s10 * ir2);
      const Q = Point.BASE.multiplyAndAddUnsafe(R10, u12, u22);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n4, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d6 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d6), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e10 = ent === true ? randomBytes2(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e10));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik2 = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r10 = modN(q.x);
      if (r10 === _0n4)
        return;
      const s10 = modN(ik2 * modN(m + r10 * d6));
      if (s10 === _0n4)
        return;
      let recovery = (q.x === r10 ? 0 : 2) | Number(q.y & _1n4);
      let normS = s10;
      if (lowS && isBiggerThanHalfOrder(s10)) {
        normS = normalizeS(s10);
        recovery ^= 1;
      }
      return new Signature(r10, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a7;
    const sg2 = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg2 === "string" || isBytes3(sg2);
    const isObj = !isHex2 && !format && typeof sg2 === "object" && sg2 !== null && typeof sg2.r === "bigint" && typeof sg2.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj)
        _sig = new Signature(sg2.r, sg2.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg2);
      }
      P = Point.fromHex(publicKey);
    } catch (error2) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r10, s: s10 } = _sig;
    const h = bits2int_modN(msgHash);
    const is3 = invN(s10);
    const u12 = modN(h * is3);
    const u22 = modN(r10 * is3);
    const R10 = (_a7 = Point.BASE.multiplyAndAddUnsafe(P, u12, u22)) == null ? void 0 : _a7.toAffine();
    if (!R10)
      return false;
    const v10 = modN(R10.x);
    return v10 === r10;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp3, Z) {
  const q = Fp3.ORDER;
  let l10 = _0n4;
  for (let o10 = q - _1n4; o10 % _2n3 === _0n4; o10 /= _2n3)
    l10 += _1n4;
  const c12 = l10;
  const _2n_pow_c1_1 = _2n3 << c12 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c22 = (q - _1n4) / _2n_pow_c1;
  const c32 = (c22 - _1n4) / _2n3;
  const c42 = _2n_pow_c1 - _1n4;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp3.pow(Z, c22);
  const c72 = Fp3.pow(Z, (c22 + _1n4) / _2n3);
  let sqrtRatio = (u10, v10) => {
    let tv1 = c62;
    let tv2 = Fp3.pow(v10, c42);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v10);
    let tv5 = Fp3.mul(u10, tv3);
    tv5 = Fp3.pow(tv5, c32);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v10);
    tv3 = Fp3.mul(tv5, u10);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c52);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c72);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i10 = c12; i10 > _1n4; i10--) {
      let tv52 = i10 - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e12 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e12);
      tv4 = Fp3.cmov(tvv5, tv4, e12);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n2 === _3n2) {
    const c13 = (Fp3.ORDER - _3n2) / _4n2;
    const c23 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = (u10, v10) => {
      let tv1 = Fp3.sqr(v10);
      const tv2 = Fp3.mul(u10, v10);
      tv1 = Fp3.mul(tv1, tv2);
      let y12 = Fp3.pow(tv1, c13);
      y12 = Fp3.mul(y12, tv2);
      const y22 = Fp3.mul(y12, c23);
      const tv3 = Fp3.mul(Fp3.sqr(y12), v10);
      const isQR = Fp3.eql(tv3, u10);
      let y = Fp3.cmov(y22, y12, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, opts.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u10) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u10);
    tv1 = Fp3.mul(tv1, opts.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts.B);
    tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts.B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value: value2 } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u10);
    y = Fp3.mul(y, value2);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value2, isValid);
    const e12 = Fp3.isOdd(u10) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e12);
    x = Fp3.div(x, tv4);
    return { x, y };
  };
}

// ../node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash) {
  return {
    hash,
    hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
  return { ...create(defHash), create };
}

// ../node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value2, length) {
  anum(value2);
  anum(length);
  if (value2 < 0 || value2 >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value2);
  const res = Array.from({ length }).fill(0);
  for (let i10 = length - 1; i10 >= 0; i10--) {
    res[i10] = value2 & 255;
    value2 >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a10, b) {
  const arr = new Uint8Array(a10.length);
  for (let i10 = 0; i10 < a10.length; i10++) {
    arr[i10] = a10[i10] ^ b[i10];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H10) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H10(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H10;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H10(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H10(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i10 = 1; i10 <= ell; i10++) {
    const args = [strxor(b_0, b[i10 - 1]), i2osp(i10 + 1, 1), DST_prime];
    b[i10] = H10(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H10) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H10.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H10.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count3, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash, expand, DST: _DST } = options;
  abytes2(msg);
  anum(count3);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count3 * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u10 = new Array(count3);
  for (let i10 = 0; i10 < count3; i10++) {
    const e10 = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i10 * m);
      const tv2 = prb.subarray(elm_offset, elm_offset + L);
      e10[j] = mod(os2ip(tv2), p);
    }
    u10[i10] = e10;
  }
  return u10;
}
function createHasher(Point, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u10 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u02 = Point.fromAffine(mapToCurve(u10[0]));
      const u12 = Point.fromAffine(mapToCurve(u10[1]));
      const P = u02.add(u12).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u10 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point.fromAffine(mapToCurve(u10[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i10 of scalars)
        if (typeof i10 !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// ../node_modules/@noble/curves/esm/p256.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp256.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  // Equation params: a, b
  b: CURVE_B,
  Fp: Fp256,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var mapSWU = (() => mapToCurveSimpleSWU(Fp256, {
  A: CURVE_A,
  B: CURVE_B,
  Z: Fp256.create(BigInt("-10"))
}))();
var htf = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// ../node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
  return suiBcs.IntentMessage(suiBcs.fixedArray(message.length, suiBcs.u8())).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// ../node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};

// ../node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a10, b) {
  if (a10 === b) return true;
  if (a10.length !== b.length) {
    return false;
  }
  for (let i10 = 0; i10 < a10.length; i10++) {
    if (a10[i10] !== b[i10]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toBase64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.vector(suiBcs.u8()).serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return this.toSuiAddress() === address;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
    );
  }
};
function parseSerializedKeypairSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size4 = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size4);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// ../node_modules/@mysten/sui/dist/esm/keypairs/passkey/publickey.js
var PASSKEY_PUBLIC_KEY_SIZE = 33;
var PASSKEY_SIGNATURE_SIZE = 64;
var SECP256R1_SPKI_HEADER = new Uint8Array([
  48,
  89,
  // SEQUENCE, length 89
  48,
  19,
  // SEQUENCE, length 19
  6,
  7,
  // OID, length 7
  42,
  134,
  72,
  206,
  61,
  2,
  1,
  // OID: 1.2.840.10045.2.1 (ecPublicKey)
  6,
  8,
  // OID, length 8
  42,
  134,
  72,
  206,
  61,
  3,
  1,
  7,
  // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)
  3,
  66,
  // BIT STRING, length 66
  0
  // no unused bits
]);
var PasskeyPublicKey = class extends PublicKey2 {
  /**
   * Create a new PasskeyPublicKey object
   * @param value passkey public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two passkey public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Passkey"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    const parsed = parseSerializedPasskeySignature(signature);
    const clientDataJSON = JSON.parse(parsed.clientDataJson);
    if (clientDataJSON.type !== "webauthn.get") {
      return false;
    }
    const parsedChallenge = fromBase64(
      clientDataJSON.challenge.replace(/-/g, "+").replace(/_/g, "/")
    );
    if (!bytesEqual(message, parsedChallenge)) {
      return false;
    }
    const pk2 = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);
    if (!bytesEqual(this.toRawBytes(), pk2)) {
      return false;
    }
    const payload = new Uint8Array([...parsed.authenticatorData, ...sha256(parsed.clientDataJson)]);
    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);
    return secp256r1.verify(sig, sha256(payload), pk2);
  }
};
PasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;
function parseSerializedPasskeySignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {
    throw new Error("Invalid signature scheme");
  }
  const dec = PasskeyAuthenticator.parse(bytes.slice(1));
  return {
    signatureScheme: "Passkey",
    serializedSignature: toBase64(bytes),
    signature: bytes,
    authenticatorData: dec.authenticatorData,
    clientDataJson: dec.clientDataJson,
    userSignature: new Uint8Array(dec.userSignature),
    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))
  };
}

// ../node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 10,
  patch: 0,
  preReleaseTag: null
});

// ../node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// ../node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// ../node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// ../node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// ../node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i10 = 0; i10 < locationLine.length; i10 += 80) {
      subLines.push(locationLine.slice(i10, i10 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// ../node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array2) {
  return array2 === void 0 || array2.length === 0 ? void 0 : array2;
}

// ../node_modules/graphql/language/ast.mjs
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode2(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// ../node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// ../node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// ../node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// ../node_modules/graphql/language/blockString.mjs
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// ../node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// ../node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries = Object.entries(object2);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries.map(
    ([key, value2]) => key + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len;
  const items = [];
  for (let i10 = 0; i10 < len; ++i10) {
    items.push(formatValue(array2[i10], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    const name = object2.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// ../node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// ../node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// ../node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// ../node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// ../node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// ../node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn2(map[key], key);
  }
  return result;
}

// ../node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// ../node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a10, b) => {
    const distanceDiff = optionsByDistance[a10] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a10, b);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a10 = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a10.length < b.length) {
      const tmp = a10;
      a10 = b;
      b = tmp;
    }
    const aLength = a10.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i10 = 1; i10 <= aLength; i10++) {
      const upRow = rows[(i10 - 1) % 3];
      const currentRow = rows[i10 % 3];
      let smallestCell = currentRow[0] = i10;
      for (let j = 1; j <= bLength; j++) {
        const cost = a10[i10 - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i10 > 1 && j > 1 && a10[i10 - 1] === b[j - 2] && a10[i10 - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i10 - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array2 = new Array(strLength);
  for (let i10 = 0; i10 < strLength; ++i10) {
    array2[i10] = str.charCodeAt(i10);
  }
  return array2;
}

// ../node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map[key] = value2;
  }
  return map;
}

// ../node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// ../node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index2 = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys[index2];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode2(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode2(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// ../node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2(
        [
          node.operation,
          join2([node.name, varDefs]),
          join2(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join2(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name, value: value2 }) => name + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives: directives2 }) => "..." + name + wrap(" ", join2(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet: selectionSet2 }) => join2(
      [
        "...",
        wrap("on ", typeCondition),
        join2(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join2(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values }) => "[" + join2(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value: value2 }) => name + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join2(["schema", join2(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives: directives2 }) => wrap("", description, "\n") + join2(["scalar", name, join2(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join2(
      [
        "type",
        name,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type: type2, directives: directives2 }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type2 + wrap(" ", join2(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join2(
      [name + ": " + type2, wrap("= ", defaultValue), join2(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join2(
      [
        "interface",
        name,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives: directives2, types }) => wrap("", description, "\n") + join2(
      ["union", name, join2(directives2, " "), wrap("= ", join2(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives: directives2, values }) => wrap("", description, "\n") + join2(["enum", name, join2(directives2, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives: directives2 }) => wrap("", description, "\n") + join2([name, join2(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives: directives2, fields }) => wrap("", description, "\n") + join2(["input", name, join2(directives2, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join2(
      ["extend schema", join2(directives2, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives: directives2 }) => join2(["extend scalar", name, join2(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives: directives2, fields }) => join2(
      [
        "extend type",
        name,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives: directives2, fields }) => join2(
      [
        "extend interface",
        name,
        wrap("implements ", join2(interfaces, " & ")),
        join2(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives: directives2, types }) => join2(
      [
        "extend union",
        name,
        join2(directives2, " "),
        wrap("= ", join2(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives: directives2, values }) => join2(["extend enum", name, join2(directives2, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives: directives2, fields }) => join2(["extend input", name, join2(directives2, " "), block(fields)], " ")
  }
};
function join2(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap("{\n", indent(join2(array2, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// ../node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// ../node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i10 = 1; i10 < name.length; ++i10) {
    if (!isNameContinue(name.charCodeAt(i10))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// ../node_modules/graphql/type/definition.mjs
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value2) => value2.name);
    }
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// ../node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// ../node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// ../node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// ../node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// ../node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item of value2) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value2[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// ../node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values = type2.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values = Object.values(type2.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type2) => {
        if (isInputObjectType(type2)) {
          return type2.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// ../node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// ../node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// ../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// ../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// ../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// ../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path3, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    // Not reachable, all possible types have been considered.
    /* c8 ignore next */
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// ../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _12, parent, _22, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// ../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// ../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s10) => '"' + s10.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// ../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// ../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// ../node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// ../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFieldsAndFragmentPairs = new OrderedPairSet();
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i10 = 0; i10 < fragmentNames.length; i10++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i10]
      );
      for (let j = i10 + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fragmentNames[i10],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  if (comparedFieldsAndFragmentPairs.has(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFieldsAndFragmentPairs.add(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  );
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i10 = 0; i10 < fields.length; i10++) {
        for (let j = i10 + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i10],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value: value2 }) => [name.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print(sortValueNode(value2));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var OrderedPairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a10, b, weaklyPresent) {
    var _this$_data$get;
    const result = (_this$_data$get = this._data.get(a10)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
    if (result === void 0) {
      return false;
    }
    return weaklyPresent ? true : weaklyPresent === result;
  }
  add(a10, b, weaklyPresent) {
    const map = this._data.get(a10);
    if (map === void 0) {
      this._data.set(a10, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
    } else {
      map.set(b, weaklyPresent);
    }
  }
};
var PairSet = class {
  constructor() {
    this._orderedPairSet = new OrderedPairSet();
  }
  has(a10, b, weaklyPresent) {
    return a10 < b ? this._orderedPairSet.has(a10, b, weaklyPresent) : this._orderedPairSet.has(b, a10, weaklyPresent);
  }
  add(a10, b, weaklyPresent) {
    if (a10 < b) {
      this._orderedPairSet.add(a10, b, weaklyPresent);
    } else {
      this._orderedPairSet.add(b, a10, weaklyPresent);
    }
  }
};

// ../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}

// ../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    // Not reachable. All possible types have been considered
    /* c8 ignore next */
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// ../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// ../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type2 = context.getType();
      const selectionSet2 = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet2) {
            const fieldName = node.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        } else if (selectionSet2.selections.length === 0) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// ../node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type2.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// ../node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// ../node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// ../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// ../node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// ../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// ../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// ../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// ../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// ../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}

// ../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// ../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// ../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// ../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// ../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type2.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type2,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error2) {
    const typeStr = inspect(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error2.message,
          {
            nodes: node,
            originalError: error2
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type2, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type2.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value2 = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value2 || value2.kind === Kind.NULL;
  const isVariable = (value2 === null || value2 === void 0 ? void 0 : value2.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type2.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value2.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}

// ../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// ../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type: type2, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// ../node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// ../node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn2) {
  let cache0;
  return function memoized2(a12, a23, a32) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a12);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a12, cache1);
    }
    let cache2 = cache1.get(a23);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a23, cache2);
    }
    let fnResult = cache2.get(a32);
    if (fnResult === void 0) {
      fnResult = fn2(a12, a23, a32);
      cache2.set(a32, fnResult);
    }
    return fnResult;
  };
}

// ../node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// ../node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);

// ../node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// ../node_modules/@mysten/sui/dist/esm/graphql/client.js
var _url;
var _queries;
var _headers;
var _fetch;
_url = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// ../node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e10, r10, n10, i10, t10, a10, l10) {
    super(e10);
    this.name = "GraphQLError";
    this.message = e10;
    if (t10) {
      this.path = t10;
    }
    if (r10) {
      this.nodes = Array.isArray(r10) ? r10 : [r10];
    }
    if (n10) {
      this.source = n10;
    }
    if (i10) {
      this.positions = i10;
    }
    if (a10) {
      this.originalError = a10;
    }
    var o10 = l10;
    if (!o10 && a10) {
      var u10 = a10.extensions;
      if (u10 && "object" == typeof u10) {
        o10 = u10;
      }
    }
    this.extensions = o10 || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var n;
var i;
function error(e10) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${i} in ${e10}`);
}
function advance(e10) {
  e10.lastIndex = i;
  if (e10.test(n)) {
    return n.slice(i, i = e10.lastIndex);
  }
}
var t = / +(?=[^\s])/y;
function blockString(e10) {
  var r10 = e10.split("\n");
  var n10 = "";
  var i10 = 0;
  var a10 = 0;
  var l10 = r10.length - 1;
  for (var o10 = 0; o10 < r10.length; o10++) {
    t.lastIndex = 0;
    if (t.test(r10[o10])) {
      if (o10 && (!i10 || t.lastIndex < i10)) {
        i10 = t.lastIndex;
      }
      a10 = a10 || o10;
      l10 = o10;
    }
  }
  for (var u10 = a10; u10 <= l10; u10++) {
    if (u10 !== a10) {
      n10 += "\n";
    }
    n10 += r10[u10].slice(i10).replace(/\\"""/g, '"""');
  }
  return n10;
}
function ignored() {
  for (var e10 = 0 | n.charCodeAt(i++); 9 === e10 || 10 === e10 || 13 === e10 || 32 === e10 || 35 === e10 || 44 === e10 || 65279 === e10; e10 = 0 | n.charCodeAt(i++)) {
    if (35 === e10) {
      while (10 !== (e10 = n.charCodeAt(i++)) && 13 !== e10) {
      }
    }
  }
  i--;
}
var a = /[_A-Za-z]\w*/y;
var l = new RegExp("(?:(null|true|false)|\\$(" + a.source + ')|(-?\\d+)((?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)?|("""(?:"""|(?:[\\s\\S]*?[^\\\\])"""))|("(?:"|[^\\r\\n]*?[^\\\\]"))|(' + a.source + "))", "y");
var o = function(e10) {
  e10[e10.Const = 1] = "Const";
  e10[e10.Var = 2] = "Var";
  e10[e10.Int = 3] = "Int";
  e10[e10.Float = 4] = "Float";
  e10[e10.BlockString = 5] = "BlockString";
  e10[e10.String = 6] = "String";
  e10[e10.Enum = 7] = "Enum";
  return e10;
}(o || {});
var u = /\\/;
function value(e10) {
  var r10;
  var t10;
  l.lastIndex = i;
  if (91 === n.charCodeAt(i)) {
    i++;
    ignored();
    var d6 = [];
    while (93 !== n.charCodeAt(i)) {
      d6.push(value(e10));
    }
    i++;
    ignored();
    return {
      kind: "ListValue",
      values: d6
    };
  } else if (123 === n.charCodeAt(i)) {
    i++;
    ignored();
    var s10 = [];
    while (125 !== n.charCodeAt(i)) {
      if (null == (r10 = advance(a))) {
        throw error("ObjectField");
      }
      ignored();
      if (58 !== n.charCodeAt(i++)) {
        throw error("ObjectField");
      }
      ignored();
      s10.push({
        kind: "ObjectField",
        name: {
          kind: "Name",
          value: r10
        },
        value: value(e10)
      });
    }
    i++;
    ignored();
    return {
      kind: "ObjectValue",
      fields: s10
    };
  } else if (null != (t10 = l.exec(n))) {
    i = l.lastIndex;
    ignored();
    if (null != (r10 = t10[o.Const])) {
      return "null" === r10 ? {
        kind: "NullValue"
      } : {
        kind: "BooleanValue",
        value: "true" === r10
      };
    } else if (null != (r10 = t10[o.Var])) {
      if (e10) {
        throw error("Variable");
      } else {
        return {
          kind: "Variable",
          name: {
            kind: "Name",
            value: r10
          }
        };
      }
    } else if (null != (r10 = t10[o.Int])) {
      var v10;
      if (null != (v10 = t10[o.Float])) {
        return {
          kind: "FloatValue",
          value: r10 + v10
        };
      } else {
        return {
          kind: "IntValue",
          value: r10
        };
      }
    } else if (null != (r10 = t10[o.BlockString])) {
      return {
        kind: "StringValue",
        value: blockString(r10.slice(3, -3)),
        block: true
      };
    } else if (null != (r10 = t10[o.String])) {
      return {
        kind: "StringValue",
        value: u.test(r10) ? JSON.parse(r10) : r10.slice(1, -1),
        block: false
      };
    } else if (null != (r10 = t10[o.Enum])) {
      return {
        kind: "EnumValue",
        value: r10
      };
    }
  }
  throw error("Value");
}
function arguments_(e10) {
  if (40 === n.charCodeAt(i)) {
    var r10 = [];
    i++;
    ignored();
    var t10;
    do {
      if (null == (t10 = advance(a))) {
        throw error("Argument");
      }
      ignored();
      if (58 !== n.charCodeAt(i++)) {
        throw error("Argument");
      }
      ignored();
      r10.push({
        kind: "Argument",
        name: {
          kind: "Name",
          value: t10
        },
        value: value(e10)
      });
    } while (41 !== n.charCodeAt(i));
    i++;
    ignored();
    return r10;
  }
}
function directives(e10) {
  if (64 === n.charCodeAt(i)) {
    var r10 = [];
    var t10;
    do {
      i++;
      if (null == (t10 = advance(a))) {
        throw error("Directive");
      }
      ignored();
      r10.push({
        kind: "Directive",
        name: {
          kind: "Name",
          value: t10
        },
        arguments: arguments_(e10)
      });
    } while (64 === n.charCodeAt(i));
    return r10;
  }
}
function type() {
  var e10;
  var r10 = 0;
  while (91 === n.charCodeAt(i)) {
    r10++;
    i++;
    ignored();
  }
  if (null == (e10 = advance(a))) {
    throw error("NamedType");
  }
  ignored();
  var t10 = {
    kind: "NamedType",
    name: {
      kind: "Name",
      value: e10
    }
  };
  do {
    if (33 === n.charCodeAt(i)) {
      i++;
      ignored();
      t10 = {
        kind: "NonNullType",
        type: t10
      };
    }
    if (r10) {
      if (93 !== n.charCodeAt(i++)) {
        throw error("NamedType");
      }
      ignored();
      t10 = {
        kind: "ListType",
        type: t10
      };
    }
  } while (r10--);
  return t10;
}
var d = new RegExp("(?:(\\.{3})|(" + a.source + "))", "y");
var s = function(e10) {
  e10[e10.Spread = 1] = "Spread";
  e10[e10.Name = 2] = "Name";
  return e10;
}(s || {});
function selectionSet() {
  var e10 = [];
  var r10;
  var t10;
  do {
    d.lastIndex = i;
    if (null != (t10 = d.exec(n))) {
      i = d.lastIndex;
      if (null != t10[s.Spread]) {
        ignored();
        var l10 = advance(a);
        if (null != l10 && "on" !== l10) {
          ignored();
          e10.push({
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: l10
            },
            directives: directives(false)
          });
        } else {
          ignored();
          if ("on" === l10) {
            if (null == (l10 = advance(a))) {
              throw error("NamedType");
            }
            ignored();
          }
          var o10 = directives(false);
          if (123 !== n.charCodeAt(i++)) {
            throw error("InlineFragment");
          }
          ignored();
          e10.push({
            kind: "InlineFragment",
            typeCondition: l10 ? {
              kind: "NamedType",
              name: {
                kind: "Name",
                value: l10
              }
            } : void 0,
            directives: o10,
            selectionSet: selectionSet()
          });
        }
      } else if (null != (r10 = t10[s.Name])) {
        var u10 = void 0;
        ignored();
        if (58 === n.charCodeAt(i)) {
          i++;
          ignored();
          u10 = r10;
          if (null == (r10 = advance(a))) {
            throw error("Field");
          }
          ignored();
        }
        var v10 = arguments_(false);
        ignored();
        var c = directives(false);
        var f = void 0;
        if (123 === n.charCodeAt(i)) {
          i++;
          ignored();
          f = selectionSet();
        }
        e10.push({
          kind: "Field",
          alias: u10 ? {
            kind: "Name",
            value: u10
          } : void 0,
          name: {
            kind: "Name",
            value: r10
          },
          arguments: v10,
          directives: c,
          selectionSet: f
        });
      }
    } else {
      throw error("SelectionSet");
    }
  } while (125 !== n.charCodeAt(i));
  i++;
  ignored();
  return {
    kind: "SelectionSet",
    selections: e10
  };
}
function fragmentDefinition() {
  var e10;
  var r10;
  if (null == (e10 = advance(a))) {
    throw error("FragmentDefinition");
  }
  ignored();
  if ("on" !== advance(a)) {
    throw error("FragmentDefinition");
  }
  ignored();
  if (null == (r10 = advance(a))) {
    throw error("FragmentDefinition");
  }
  ignored();
  var t10 = directives(false);
  if (123 !== n.charCodeAt(i++)) {
    throw error("FragmentDefinition");
  }
  ignored();
  return {
    kind: "FragmentDefinition",
    name: {
      kind: "Name",
      value: e10
    },
    typeCondition: {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: r10
      }
    },
    directives: t10,
    selectionSet: selectionSet()
  };
}
var v = /(?:query|mutation|subscription|fragment)/y;
function operationDefinition(e10) {
  var r10;
  var t10;
  var l10;
  if (e10) {
    ignored();
    r10 = advance(a);
    t10 = function variableDefinitions() {
      ignored();
      if (40 === n.charCodeAt(i)) {
        var e11 = [];
        i++;
        ignored();
        var r11;
        do {
          if (36 !== n.charCodeAt(i++)) {
            throw error("Variable");
          }
          if (null == (r11 = advance(a))) {
            throw error("Variable");
          }
          ignored();
          if (58 !== n.charCodeAt(i++)) {
            throw error("VariableDefinition");
          }
          ignored();
          var t11 = type();
          var l11 = void 0;
          if (61 === n.charCodeAt(i)) {
            i++;
            ignored();
            l11 = value(true);
          }
          ignored();
          e11.push({
            kind: "VariableDefinition",
            variable: {
              kind: "Variable",
              name: {
                kind: "Name",
                value: r11
              }
            },
            type: t11,
            defaultValue: l11,
            directives: directives(true)
          });
        } while (41 !== n.charCodeAt(i));
        i++;
        ignored();
        return e11;
      }
    }();
    l10 = directives(false);
  }
  if (123 === n.charCodeAt(i)) {
    i++;
    ignored();
    return {
      kind: "OperationDefinition",
      operation: e10 || "query",
      name: r10 ? {
        kind: "Name",
        value: r10
      } : void 0,
      variableDefinitions: t10,
      directives: l10,
      selectionSet: selectionSet()
    };
  }
}
function parse4(e10, r10) {
  i = 0;
  return function document2(e11, r11) {
    var n10;
    var t10;
    ignored();
    var a10 = [];
    do {
      if ("fragment" === (n10 = advance(v))) {
        ignored();
        a10.push(fragmentDefinition());
      } else if (null != (t10 = operationDefinition(n10))) {
        a10.push(t10);
      } else {
        throw error("Document");
      }
    } while (i < e11.length);
    if (!r11) {
      var l10;
      return {
        kind: "Document",
        definitions: a10,
        set loc(e12) {
          l10 = e12;
        },
        get loc() {
          if (!l10) {
            l10 = {
              start: 0,
              end: e11.length,
              startToken: void 0,
              endToken: void 0,
              source: {
                body: e11,
                name: "graphql.web",
                locationOffset: {
                  line: 1,
                  column: 1
                }
              }
            };
          }
          return l10;
        }
      };
    }
    return {
      kind: "Document",
      definitions: a10
    };
  }(n = "string" == typeof e10.body ? e10.body : e10, r10 && r10.noLocation);
}

// ../node_modules/gql.tada/dist/gql-tada.mjs
var a2 = 0;
var e2 = /* @__PURE__ */ new Set();
function initGraphQLTada() {
  function graphql3(t10, i10) {
    var o10 = parse4(t10).definitions;
    var s10 = /* @__PURE__ */ new Set();
    for (var f of i10 || []) {
      for (var u10 of f.definitions) {
        if (u10.kind === e.FRAGMENT_DEFINITION && !s10.has(u10)) {
          o10.push(u10);
          s10.add(u10);
        }
      }
    }
    var d6;
    if ((d6 = o10[0].kind === e.FRAGMENT_DEFINITION) && o10[0].directives) {
      o10[0].directives = o10[0].directives.filter((r10) => "_unmask" !== r10.name.value);
    }
    var c;
    return {
      kind: e.DOCUMENT,
      definitions: o10,
      get loc() {
        if (!c && d6) {
          var r10 = t10 + function concatLocSources(r11) {
            try {
              a2++;
              var n10 = "";
              for (var t11 of r11) {
                if (!e2.has(t11)) {
                  e2.add(t11);
                  var { loc: i11 } = t11;
                  if (i11) {
                    n10 += i11.source.body;
                  }
                }
              }
              return n10;
            } finally {
              if (0 == --a2) {
                e2.clear();
              }
            }
          }(i10 || []);
          return {
            start: 0,
            end: r10.length,
            source: {
              body: r10,
              name: "GraphQLTada",
              locationOffset: {
                line: 1,
                column: 1
              }
            }
          };
        }
        return c;
      },
      set loc(r10) {
        c = r10;
      }
    };
  }
  graphql3.scalar = function scalar(r10, n10) {
    return n10;
  };
  graphql3.persisted = function persisted(n10, a10) {
    return {
      kind: e.DOCUMENT,
      definitions: a10 ? a10.definitions : [],
      documentId: n10
    };
  };
  return graphql3;
}
var t2 = initGraphQLTada();

// ../node_modules/@mysten/sui/dist/esm/graphql/schemas/latest/index.js
var graphql2 = initGraphQLTada();

// ../node_modules/@mysten/sui/dist/esm/zklogin/jwt-decode.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";

// ../node_modules/@mysten/sui/dist/esm/zklogin/poseidon.js
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);

// ../node_modules/@mysten/sui/dist/esm/zklogin/utils.js
function findFirstNonZeroIndex(bytes) {
  for (let i10 = 0; i10 < bytes.length; i10++) {
    if (bytes[i10] !== 0) {
      return i10;
    }
  }
  return -1;
}
function toPaddedBigEndianBytes(num, width) {
  const hex2 = num.toString(16);
  return hexToBytes(hex2.padStart(width * 2, "0").slice(-width * 2));
}
function toBigEndianBytes(num, width) {
  const bytes = toPaddedBigEndianBytes(num, width);
  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);
  if (firstNonZeroIndex === -1) {
    return new Uint8Array([0]);
  }
  return bytes.slice(firstNonZeroIndex);
}

// ../node_modules/@mysten/sui/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.vector(bcs.u8())
});

// ../node_modules/@mysten/sui/dist/esm/zklogin/publickey.js
var __typeError8 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError8("Cannot " + msg);
var __privateGet9 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var _data2;
var _client3;
var _legacyAddress;
var _ZkLoginPublicIdentifier_instances;
var toLegacyAddress_fn;
_data2 = /* @__PURE__ */ new WeakMap();
_client3 = /* @__PURE__ */ new WeakMap();
_legacyAddress = /* @__PURE__ */ new WeakMap();
_ZkLoginPublicIdentifier_instances = /* @__PURE__ */ new WeakSet();
toLegacyAddress_fn = function() {
  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet9(this, _data2), true);
  const addressBytes = new Uint8Array(legacyBytes.length + 1);
  addressBytes[0] = this.flag();
  addressBytes.set(legacyBytes, 1);
  return normalizeSuiAddress(
    bytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
  );
};
var VerifyZkLoginSignatureQuery = graphql2(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`);
function normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {
  const issByteLength = bytes[0] + 1;
  const addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);
  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const data = new Uint8Array(issByteLength + seedBytes.length);
  data.set(bytes.slice(0, issByteLength), 0);
  data.set(seedBytes, issByteLength);
  return data;
}

// ../node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase64(serializedSignature);
}

// ../node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber2(c);
  anumber2(dkLen);
  anumber2(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u10) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u10.fill(0);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u10 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u10);
    Ti2.set(u10.subarray(0, Ti2.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u10).digestInto(u10);
      for (let i10 = 0; i10 < Ti2.length; i10++)
        Ti2[i10] ^= u10[i10];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u10);
}

// ../node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n10) => BigInt(n10))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
    return [Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2];
  }
  // prettier-ignore
  set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2) {
    this.Ah = Ah2 | 0;
    this.Al = Al2 | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl2 | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl2 | 0;
    this.Eh = Eh2 | 0;
    this.El = El2 | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl2 | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl2 | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl2 | 0;
  }
  process(view, offset4) {
    for (let i10 = 0; i10 < 16; i10++, offset4 += 4) {
      SHA512_W_H[i10] = view.getUint32(offset4);
      SHA512_W_L[i10] = view.getUint32(offset4 += 4);
    }
    for (let i10 = 16; i10 < 80; i10++) {
      const W15h = SHA512_W_H[i10 - 15] | 0;
      const W15l = SHA512_W_L[i10 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i10 - 2] | 0;
      const W2l = SHA512_W_L[i10 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i10 - 7], SHA512_W_L[i10 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i10 - 7], SHA512_W_H[i10 - 16]);
      SHA512_W_H[i10] = SUMh | 0;
      SHA512_W_L[i10] = SUMl | 0;
    }
    let { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
    for (let i10 = 0; i10 < 80; i10++) {
      const sigma1h = u64_default.rotrSH(Eh2, El2, 14) ^ u64_default.rotrSH(Eh2, El2, 18) ^ u64_default.rotrBH(Eh2, El2, 41);
      const sigma1l = u64_default.rotrSL(Eh2, El2, 14) ^ u64_default.rotrSL(Eh2, El2, 18) ^ u64_default.rotrBL(Eh2, El2, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
      const T1ll = u64_default.add5L(Hl2, sigma1l, CHIl, SHA512_Kl[i10], SHA512_W_L[i10]);
      const T1h = u64_default.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i10], SHA512_W_H[i10]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah2, Al2, 28) ^ u64_default.rotrBH(Ah2, Al2, 34) ^ u64_default.rotrBH(Ah2, Al2, 39);
      const sigma0l = u64_default.rotrSL(Ah2, Al2, 28) ^ u64_default.rotrBL(Ah2, Al2, 34) ^ u64_default.rotrBL(Ah2, Al2, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
      Hh2 = Gh2 | 0;
      Hl2 = Gl2 | 0;
      Gh2 = Fh2 | 0;
      Gl2 = Fl2 | 0;
      Fh2 = Eh2 | 0;
      Fl2 = El2 | 0;
      ({ h: Eh2, l: El2 } = u64_default.add(Dh2 | 0, Dl2 | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl2 = Cl2 | 0;
      Ch2 = Bh2 | 0;
      Cl2 = Bl2 | 0;
      Bh2 = Ah2 | 0;
      Bl2 = Al2 | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah2 = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al2 = All | 0;
    }
    ({ h: Ah2, l: Al2 } = u64_default.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al2 | 0));
    ({ h: Bh2, l: Bl2 } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl2 | 0));
    ({ h: Ch2, l: Cl2 } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl2 | 0));
    ({ h: Dh2, l: Dl2 } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl2 | 0));
    ({ h: Eh2, l: El2 } = u64_default.add(this.Eh | 0, this.El | 0, Eh2 | 0, El2 | 0));
    ({ h: Fh2, l: Fl2 } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl2 | 0));
    ({ h: Gh2, l: Gl2 } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl2 | 0));
    ({ h: Hh2, l: Hl2 } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl2 | 0));
    this.set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// ../node_modules/@scure/bip39/esm/index.js
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

// ../node_modules/@mysten/sui/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHex(mnemonicToSeed(mnemonics));
}

// ../node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE = 32;
var SUI_PRIVATE_KEY_PREFIX = "suiprivkey";
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes) {
    return this.signWithIntent(bytes, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    const { signature } = await this.signWithIntent(
      bcs.vector(bcs.u8()).serialize(bytes).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase64(bytes),
      signature
    };
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};
var Keypair = class extends Signer {
};
function decodeSuiPrivateKey(value2) {
  const { prefix, words } = bech32.decode(value2);
  if (prefix !== SUI_PRIVATE_KEY_PREFIX) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
  return {
    schema: signatureScheme,
    secretKey
  };
}
function encodeSuiPrivateKey(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));
}

// ../node_modules/@noble/curves/esm/abstract/edwards.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts2(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n4 << BigInt(nByteLength * 8) - _1n5;
  const modP = Fp3.create;
  const Fn2 = Field(CURVE.n, CURVE.nBitLength);
  const uvRatio2 = CURVE.uvRatio || ((u10, v10) => {
    try {
      return { isValid: true, value: Fp3.sqrt(u10 * Fp3.inv(v10)) };
    } catch (e10) {
      return { isValid: false, value: _0n5 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title3, n10) {
    aInRange("coordinate " + title3, n10, _0n5, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp3.inv(z);
    const ax2 = modP(x * iz);
    const ay2 = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n5, y: _1n5 };
    if (zz !== _1n5)
      throw new Error("invZ was invalid");
    return { x: ax2, y: ay2 };
  });
  const assertValidMemo = memoized((p) => {
    const { a: a10, d: d6 } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X22 = modP(X * X);
    const Y22 = modP(Y * Y);
    const Z22 = modP(Z * Z);
    const Z42 = modP(Z22 * Z22);
    const aX2 = modP(X22 * a10);
    const left = modP(Z22 * modP(aX2 + Y22));
    const right = modP(Z42 + modP(d6 * modP(X22 * Y22)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT2 = modP(Z * T);
    if (XY !== ZT2)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex2, ey2, ez, et) {
      this.ex = ex2;
      this.ey = ey2;
      this.ez = ez;
      this.et = et;
      aCoordinate("x", ex2);
      aCoordinate("y", ey2);
      aCoordinate("z", ez);
      aCoordinate("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      aCoordinate("x", x);
      aCoordinate("y", y);
      return new Point(x, y, _1n5, modP(x * y));
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.ez));
      return points.map((p, i10) => p.toAffine(toInv[i10])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn2, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X12, ey: Y12, ez: Z12 } = this;
      const { ex: X22, ey: Y22, ez: Z22 } = other;
      const X1Z2 = modP(X12 * Z22);
      const X2Z1 = modP(X22 * Z12);
      const Y1Z2 = modP(Y12 * Z22);
      const Y2Z1 = modP(Y22 * Z12);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a10 } = CURVE;
      const { ex: X12, ey: Y12, ez: Z12 } = this;
      const A = modP(X12 * X12);
      const B = modP(Y12 * Y12);
      const C = modP(_2n4 * modP(Z12 * Z12));
      const D = modP(a10 * A);
      const x1y1 = X12 + Y12;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G10 = D + B;
      const F = G10 - C;
      const H10 = D - B;
      const X32 = modP(E * F);
      const Y32 = modP(G10 * H10);
      const T32 = modP(E * H10);
      const Z32 = modP(F * G10);
      return new Point(X32, Y32, Z32, T32);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a: a10, d: d6 } = CURVE;
      const { ex: X12, ey: Y12, ez: Z12, et: T12 } = this;
      const { ex: X22, ey: Y22, ez: Z22, et: T22 } = other;
      if (a10 === BigInt(-1)) {
        const A6 = modP((Y12 - X12) * (Y22 + X22));
        const B10 = modP((Y12 + X12) * (Y22 - X22));
        const F10 = modP(B10 - A6);
        if (F10 === _0n5)
          return this.double();
        const C6 = modP(Z12 * _2n4 * T22);
        const D10 = modP(T12 * _2n4 * Z22);
        const E6 = D10 + C6;
        const G11 = B10 + A6;
        const H11 = D10 - C6;
        const X33 = modP(E6 * F10);
        const Y33 = modP(G11 * H11);
        const T33 = modP(E6 * H11);
        const Z33 = modP(F10 * G11);
        return new Point(X33, Y33, Z33, T33);
      }
      const A = modP(X12 * X22);
      const B = modP(Y12 * Y22);
      const C = modP(T12 * d6 * T22);
      const D = modP(Z12 * Z22);
      const E = modP((X12 + Y12) * (X22 + Y22) - A - B);
      const F = D - C;
      const G10 = D + C;
      const H10 = modP(B - a10 * A);
      const X32 = modP(E * F);
      const Y32 = modP(G10 * H10);
      const T32 = modP(E * H10);
      const Z32 = modP(F * G10);
      return new Point(X32, Y32, Z32, T32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n10) {
      return wnaf.wNAFCached(this, n10, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n10 = scalar;
      aInRange("scalar", n10, _1n5, CURVE_ORDER);
      const { p, f } = this.wNAF(n10);
      return Point.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n10 = scalar;
      aInRange("scalar", n10, _0n5, CURVE_ORDER);
      if (n10 === _0n5)
        return I;
      if (this.is0() || n10 === _1n5)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n10, Point.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n5)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d: d6, a: a10 } = CURVE;
      const len = Fp3.BYTES;
      hex2 = ensureBytes("pointHex", hex2, len);
      abool("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max2 = zip215 ? MASK : Fp3.ORDER;
      aInRange("pointHex.y", y, _0n5, max2);
      const y22 = modP(y * y);
      const u10 = modP(y22 - _1n5);
      const v10 = modP(d6 * y22 - a10);
      let { isValid, value: x } = uvRatio2(u10, v10);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n5) === _1n5;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n5 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x, y } = this.toAffine();
      const bytes = numberToBytesLE(y, Fp3.BYTES);
      bytes[bytes.length - 1] |= x & _1n5 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex2(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n5, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n5, _1n5, _1n5, _0n5);
  const { BASE: G, ZERO: I } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a10) {
    return mod(a10, CURVE_ORDER);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getExtendedPublicKey(key) {
    const len = Fp3.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r10 = hashDomainToScalar(options.context, prefix, msg);
    const R10 = G.multiply(r10).toRawBytes();
    const k = hashDomainToScalar(options.context, R10, pointBytes, msg);
    const s10 = modN(r10 + k * scalar);
    aInRange("signature.s", s10, _0n5, CURVE_ORDER);
    const res = concatBytes2(R10, numberToBytesLE(s10, Fp3.BYTES));
    return ensureBytes("result", res, Fp3.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s10 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R10, SB2;
    try {
      A = Point.fromHex(publicKey, zip215);
      R10 = Point.fromHex(sig.slice(0, len), zip215);
      SB2 = G.multiplyUnsafe(s10);
    } catch (error2) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R10.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R10.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB2).clearCofactor().equals(Point.ZERO);
  }
  G._setWindowSize(8);
  const utils2 = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign,
    verify,
    ExtendedPoint: Point,
    utils: utils2
  };
}

// ../node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
function validateOpts3(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts3(curveDef);
  const { P } = CURVE;
  const modP = (n10) => mod(n10, P);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
  const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return [x_2, x_3];
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u10, scalar) {
    aInRange("u", u10, _0n6, P);
    aInRange("scalar", scalar, _0n6, P);
    const k = scalar;
    const x_1 = u10;
    let x_2 = _1n6;
    let z_2 = _0n6;
    let x_3 = u10;
    let z_3 = _1n6;
    let swap = _0n6;
    let sw2;
    for (let t10 = BigInt(montgomeryBits - 1); t10 >= _0n6; t10--) {
      const k_t = k >> t10 & _1n6;
      swap ^= k_t;
      sw2 = cswap(swap, x_2, x_3);
      x_2 = sw2[0];
      x_3 = sw2[1];
      sw2 = cswap(swap, z_2, z_3);
      z_2 = sw2[0];
      z_3 = sw2[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA2 = modP(A * A);
      const B = x_2 - z_2;
      const BB2 = modP(B * B);
      const E = AA2 - BB2;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA2 = modP(D * A);
      const CB2 = modP(C * B);
      const dacb = DA2 + CB2;
      const da_cb = DA2 - CB2;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA2 * BB2);
      z_2 = modP(E * (AA2 + modP(a24 * E)));
    }
    sw2 = cswap(swap, x_2, x_3);
    x_2 = sw2[0];
    x_3 = sw2[1];
    sw2 = cswap(swap, z_2, z_3);
    z_2 = sw2[0];
    z_3 = sw2[1];
    const z22 = powPminus2(z_2);
    return modP(x_2 * z22);
  }
  function encodeUCoordinate(u10) {
    return numberToBytesLE(modP(u10), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u10 = ensureBytes("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === 32)
      u10[31] &= 127;
    return bytesToNumberLE(u10);
  }
  function decodeScalar(n10) {
    const bytes = ensureBytes("scalar", n10);
    const len = bytes.length;
    if (len !== montgomeryBytes && len !== fieldLen) {
      let valid = "" + montgomeryBytes + " or " + fieldLen;
      throw new Error("invalid scalar, expected " + valid + " bytes, got " + len);
    }
    return bytesToNumberLE(adjustScalarBytes2(bytes));
  }
  function scalarMult(scalar, u10) {
    const pointU = decodeUCoordinate(u10);
    const _scalar = decodeScalar(scalar);
    const pu2 = montgomeryLadder(pointU, _scalar);
    if (pu2 === _0n6)
      throw new Error("invalid private or public key received");
    return encodeUCoordinate(pu2);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// ../node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = BigInt(2);
var _3n3 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x22 = x * x % P;
  const b22 = x22 * x % P;
  const b42 = pow2(b22, _2n5, P) * b22 % P;
  const b52 = pow2(b42, _1n7, P) * x % P;
  const b10 = pow2(b52, _5n2, P) * b52 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n5, P) * x % P;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function uvRatio(u10, v10) {
  const P = ED25519_P;
  const v32 = mod(v10 * v10 * v10, P);
  const v72 = mod(v32 * v32 * v10, P);
  const pow3 = ed25519_pow_2_252_3(u10 * v72).pow_p_5_8;
  let x = mod(u10 * v32 * pow3, P);
  const vx2 = mod(v10 * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u10;
  const useRoot2 = vx2 === mod(-u10, P);
  const noRoot = vx2 === mod(-u10 * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n3,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_3(x);
    return mod(pow2(pow_p_5_8, _3n3, P) * b22, P);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (() => (Fp.ORDER + _3n3) / _8n3)();
var ELL2_C2 = (() => Fp.pow(_2n5, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function map_to_curve_elligator2_curve25519(u10) {
  const ELL2_C4 = (Fp.ORDER - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u10);
  tv1 = Fp.mul(tv1, _2n5);
  let xd2 = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd2);
  let gxd = Fp.mul(tv2, xd2);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e12 = Fp.eql(tv2, gx1);
  let y13 = Fp.cmov(y12, y11, e12);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u10);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e23 = Fp.eql(tv2, gx2);
  let y23 = Fp.cmov(y22, y21, e23);
  tv2 = Fp.sqr(y13);
  tv2 = Fp.mul(tv2, gxd);
  let e32 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e32);
  let y = Fp.cmov(y23, y13, e32);
  let e42 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e32 !== e42);
  return { xMn: xn, xMd: xd2, yMn: y, yMd: _1n7 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u10) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u10);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd2 = Fp.mul(xMd, yMn);
  let yn2 = Fp.sub(xMn, xMd);
  let yd2 = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd2, yd2);
  let e10 = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e10);
  xd2 = Fp.cmov(xd2, Fp.ONE, e10);
  yn2 = Fp.cmov(yn2, Fp.ONE, e10);
  yd2 = Fp.cmov(yd2, Fp.ONE, e10);
  const inv = Fp.invertBatch([xd2, yd2]);
  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn2, inv[1]) };
}
var htf2 = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve2 = (() => htf2.hashToCurve)();
var encodeToCurve2 = (() => htf2.encodeToCurve)();
function assertRstPoint(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n7, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r02) {
  const { d: d6 } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod2 = ed25519.CURVE.Fp.create;
  const r10 = mod2(SQRT_M1 * r02 * r02);
  const Ns2 = mod2((r10 + _1n7) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod2((c - d6 * r10) * mod2(r10 + d6));
  let { isValid: Ns_D_is_sq, value: s10 } = uvRatio(Ns2, D);
  let s_2 = mod2(s10 * r02);
  if (!isNegativeLE(s_2, P))
    s_2 = mod2(-s_2);
  if (!Ns_D_is_sq)
    s10 = s_2;
  if (!Ns_D_is_sq)
    c = r10;
  const Nt = mod2(c * (r10 - _1n7) * D_MINUS_ONE_SQ - D);
  const s22 = s10 * s10;
  const W02 = mod2((s10 + s10) * D);
  const W12 = mod2(Nt * SQRT_AD_MINUS_ONE);
  const W22 = mod2(_1n7 - s22);
  const W32 = mod2(_1n7 + s22);
  return new ed25519.ExtendedPoint(mod2(W02 * W32), mod2(W22 * W12), mod2(W12 * W32), mod2(W02 * W22));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep2) {
    this.ep = ep2;
  }
  static fromAffine(ap2) {
    return new _RistPoint(ed25519.ExtendedPoint.fromAffine(ap2));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex2) {
    hex2 = ensureBytes("ristrettoHash", hex2, 64);
    const r12 = bytes255ToNumberLE(hex2.slice(0, 32));
    const R12 = calcElligatorRistrettoMap(r12);
    const r22 = bytes255ToNumberLE(hex2.slice(32, 64));
    const R22 = calcElligatorRistrettoMap(r22);
    return new _RistPoint(R12.add(R22));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex2) {
    hex2 = ensureBytes("ristrettoHex", hex2, 32);
    const { a: a10, d: d6 } = ed25519.CURVE;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s10 = bytes255ToNumberLE(hex2);
    if (!equalBytes(numberToBytesLE(s10, 32), hex2) || isNegativeLE(s10, P))
      throw new Error(emsg);
    const s22 = mod2(s10 * s10);
    const u12 = mod2(_1n7 + a10 * s22);
    const u22 = mod2(_1n7 - a10 * s22);
    const u1_2 = mod2(u12 * u12);
    const u2_2 = mod2(u22 * u22);
    const v10 = mod2(a10 * d6 * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod2(v10 * u2_2));
    const Dx2 = mod2(I * u22);
    const Dy2 = mod2(I * Dx2 * v10);
    let x = mod2((s10 + s10) * Dx2);
    if (isNegativeLE(x, P))
      x = mod2(-x);
    const y = mod2(u12 * Dy2);
    const t10 = mod2(x * y);
    if (!isValid || isNegativeLE(t10, P) || y === _0n7)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.ExtendedPoint(x, y, _1n7, t10));
  }
  static msm(points, scalars) {
    const Fn2 = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);
    return pippenger(_RistPoint, Fn2, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x, ey: y, ez: z, et: t10 } = this.ep;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const u12 = mod2(mod2(z + y) * mod2(z - y));
    const u22 = mod2(x * y);
    const u2sq = mod2(u22 * u22);
    const { value: invsqrt } = invertSqrt(mod2(u12 * u2sq));
    const D12 = mod2(invsqrt * u12);
    const D22 = mod2(invsqrt * u22);
    const zInv = mod2(D12 * D22 * t10);
    let D;
    if (isNegativeLE(t10 * zInv, P)) {
      let _x2 = mod2(y * SQRT_M1);
      let _y2 = mod2(x * SQRT_M1);
      x = _x2;
      y = _y2;
      D = mod2(D12 * INVSQRT_A_MINUS_D);
    } else {
      D = D22;
    }
    if (isNegativeLE(x * zInv, P))
      y = mod2(-y);
    let s10 = mod2((z - y) * D);
    if (isNegativeLE(s10, P))
      s10 = mod2(-s10);
    return numberToBytesLE(s10, 32);
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    assertRstPoint(other);
    const { ex: X12, ey: Y12 } = this.ep;
    const { ex: X22, ey: Y22 } = other.ep;
    const mod2 = ed25519.CURVE.Fp.create;
    const one = mod2(X12 * Y22) === mod2(Y12 * X22);
    const two = mod2(Y12 * Y22) === mod2(X12 * X22);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// ../node_modules/@mysten/sui/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h = hmac.create(sha512, ED25519_CURVE);
  const I = h.update(fromHex(seed)).digest();
  const IL2 = I.slice(0, 32);
  const IR2 = I.slice(32);
  return {
    key: IL2,
    chainCode: IR2
  };
};
var CKDPriv = ({ key, chainCode }, index2) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv2 = new DataView(indexBuffer);
  cv2.setUint32(0, index2);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);
  const I = hmac.create(sha512, chainCode).update(data).digest();
  const IL2 = I.slice(0, 32);
  const IR2 = I.slice(32);
  return {
    key: IL2,
    chainCode: IR2
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath = (path, seed, offset4 = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el2) => parseInt(el2, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset4), {
    key,
    chainCode
  });
};

// ../node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value2) {
    super();
    if (typeof value2 === "string") {
      this.data = fromBase64(value2);
    } else if (value2 instanceof Uint8Array) {
      this.data = value2;
    } else {
      this.data = Uint8Array.from(value2);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return ed25519.verify(bytes, message, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// ../node_modules/@mysten/sui/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class _Ed25519Keypair extends Keypair {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = {
        publicKey: keypair.publicKey,
        secretKey: keypair.secretKey.slice(0, 32)
      };
    } else {
      const privateKey = ed25519.utils.randomPrivateKey();
      this.keypair = {
        publicKey: ed25519.getPublicKey(privateKey),
        secretKey: privateKey
      };
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    const secretKey = ed25519.utils.randomPrivateKey();
    return new _Ed25519Keypair({
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    });
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key as a byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey(secretKey);
      if (decoded.schema !== "ED25519") {
        throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = {
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    };
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = ed25519.sign(signData, secretKey);
      if (!ed25519.verify(signature, signData, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new _Ed25519Keypair(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Ed25519 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey(
      this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),
      this.getKeyScheme()
    );
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  async sign(data) {
    return ed25519.sign(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return _Ed25519Keypair.fromSecretKey(key);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(seedHex, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, seedHex);
    return _Ed25519Keypair.fromSecretKey(key);
  }
};

// ../node_modules/@mysten/zksend/dist/esm/links/zk-bag.js
var _package;
var _module;
_package = /* @__PURE__ */ new WeakMap();
_module = /* @__PURE__ */ new WeakMap();

// ../node_modules/@mysten/zksend/dist/esm/links/builder.js
var __typeError9 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck9 = (obj, member, msg) => member.has(obj) || __typeError9("Cannot " + msg);
var __privateGet10 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateMethod6 = (obj, member, method) => (__accessCheck9(obj, member, "access private method"), method);
var _host;
var _path;
var _client4;
var _redirect;
var _coinsByType;
var _contract;
var _ZkSendLinkBuilder_instances;
var objectsToTransfer_fn;
var createSendTransactionWithoutContract_fn;
var estimateClaimGasFee_fn;
var getCoinsByType_fn;
var SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);
_host = /* @__PURE__ */ new WeakMap();
_path = /* @__PURE__ */ new WeakMap();
_client4 = /* @__PURE__ */ new WeakMap();
_redirect = /* @__PURE__ */ new WeakMap();
_coinsByType = /* @__PURE__ */ new WeakMap();
_contract = /* @__PURE__ */ new WeakMap();
_ZkSendLinkBuilder_instances = /* @__PURE__ */ new WeakSet();
objectsToTransfer_fn = async function(tx2) {
  const objectIDs = [...this.objectIds];
  const refsWithType = this.objectRefs.concat(
    (objectIDs.length > 0 ? await __privateGet10(this, _client4).multiGetObjects({
      ids: objectIDs,
      options: {
        showType: true
      }
    }) : []).map((res, i10) => {
      var _a7;
      if (!res.data || res.error) {
        throw new Error(`Failed to load object ${objectIDs[i10]} (${(_a7 = res.error) == null ? void 0 : _a7.code})`);
      }
      return {
        ref: tx2.objectRef({
          version: res.data.version,
          digest: res.data.digest,
          objectId: res.data.objectId
        }),
        type: res.data.type
      };
    })
  );
  for (const [coinType, amount] of this.balances) {
    if (coinType === SUI_COIN_TYPE) {
      const [sui] = tx2.splitCoins(tx2.gas, [amount]);
      refsWithType.push({
        ref: sui,
        type: `0x2::coin::Coin<${coinType}>`
      });
    } else {
      const coins = (await __privateMethod6(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType)).map((coin) => coin.coinObjectId);
      if (coins.length > 1) {
        tx2.mergeCoins(coins[0], coins.slice(1));
      }
      const [split2] = tx2.splitCoins(coins[0], [amount]);
      refsWithType.push({
        ref: split2,
        type: `0x2::coin::Coin<${coinType}>`
      });
    }
  }
  return refsWithType;
};
createSendTransactionWithoutContract_fn = async function({
  transaction: tx2 = new Transaction(),
  calculateGas
} = {}) {
  const gasEstimateFromDryRun = await __privateMethod6(this, _ZkSendLinkBuilder_instances, estimateClaimGasFee_fn).call(this);
  const baseGasAmount = calculateGas ? await calculateGas({
    balances: this.balances,
    objects: [...this.objectIds],
    gasEstimateFromDryRun
  }) : gasEstimateFromDryRun * 2n;
  const gasWithBuffer = baseGasAmount + 1013n;
  const roundedGasAmount = gasWithBuffer - gasWithBuffer % 1000n - 13n;
  const address = this.keypair.toSuiAddress();
  const objectsToTransfer = (await __privateMethod6(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, tx2)).map((obj) => obj.ref);
  const [gas] = tx2.splitCoins(tx2.gas, [roundedGasAmount]);
  objectsToTransfer.push(gas);
  tx2.setSenderIfNotSet(this.sender);
  tx2.transferObjects(objectsToTransfer, address);
  return tx2;
};
estimateClaimGasFee_fn = async function() {
  const tx2 = new Transaction();
  tx2.setSender(this.sender);
  tx2.setGasPayment([]);
  tx2.transferObjects([tx2.gas], this.keypair.toSuiAddress());
  const idsToTransfer = [...this.objectIds];
  for (const [coinType] of this.balances) {
    const coins = await __privateMethod6(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType);
    if (!coins.length) {
      throw new Error(`Sending account does not contain any coins of type ${coinType}`);
    }
    idsToTransfer.push(coins[0].coinObjectId);
  }
  if (idsToTransfer.length > 0) {
    tx2.transferObjects(
      idsToTransfer.map((id2) => tx2.object(id2)),
      this.keypair.toSuiAddress()
    );
  }
  const result = await __privateGet10(this, _client4).dryRunTransactionBlock({
    transactionBlock: await tx2.build({ client: __privateGet10(this, _client4) })
  });
  return BigInt(result.effects.gasUsed.computationCost) + BigInt(result.effects.gasUsed.storageCost) - BigInt(result.effects.gasUsed.storageRebate);
};
getCoinsByType_fn = async function(coinType) {
  if (__privateGet10(this, _coinsByType).has(coinType)) {
    return __privateGet10(this, _coinsByType).get(coinType);
  }
  const coins = await __privateGet10(this, _client4).getCoins({
    coinType,
    owner: this.sender
  });
  __privateGet10(this, _coinsByType).set(coinType, coins.data);
  return coins.data;
};

// ../node_modules/@mysten/zksend/dist/esm/links/utils.js
function getAssetsFromTransaction({
  transaction,
  address,
  isSent
}) {
  var _a7, _b3;
  const normalizedAddress = normalizeSuiAddress(address);
  const balances = [];
  const nfts = [];
  const coins = [];
  (_a7 = transaction.balanceChanges) == null ? void 0 : _a7.forEach((change) => {
    const validAmountChange = isSent ? BigInt(change.amount) < 0n : BigInt(change.amount) > 0n;
    if (validAmountChange && isOwner(change.owner, normalizedAddress)) {
      balances.push({
        coinType: normalizeStructTag(change.coinType),
        amount: BigInt(change.amount)
      });
    }
  });
  (_b3 = transaction.objectChanges) == null ? void 0 : _b3.forEach((change) => {
    if (!isObjectOwner(change, normalizedAddress, isSent)) {
      return;
    }
    if ("objectType" in change) {
      const type2 = parseStructTag(change.objectType);
      if (type2.address === normalizeSuiAddress("0x2") && type2.module === "coin" && type2.name === "Coin") {
        if (change.type === "created" || change.type === "transferred" || change.type === "mutated") {
          coins.push({
            ...change,
            type: change.objectType
          });
        }
        return;
      }
    }
    if (isObjectOwner(change, normalizedAddress, isSent) && (change.type === "created" || change.type === "transferred" || change.type === "mutated")) {
      nfts.push({
        objectId: change.objectId,
        type: change.objectType,
        version: change.version,
        digest: change.digest
      });
    }
  });
  return {
    balances,
    nfts,
    coins
  };
}
function getObjectOwnerFromObjectChange(objectChange, isSent) {
  if (isSent) {
    return "owner" in objectChange ? objectChange.owner : null;
  }
  return "recipient" in objectChange ? objectChange.recipient : null;
}
function isObjectOwner(objectChange, address, isSent) {
  const owner = getObjectOwnerFromObjectChange(objectChange, isSent);
  if (isSent) {
    return owner && typeof owner === "object" && "AddressOwner" in owner;
  }
  return ownedAfterChange(objectChange, address);
}
function ownedAfterChange(objectChange, address) {
  if (objectChange.type === "transferred" && isOwner(objectChange.recipient, address)) {
    return true;
  }
  if ((objectChange.type === "created" || objectChange.type === "mutated") && isOwner(objectChange.owner, address)) {
    return true;
  }
  return false;
}
function isOwner(owner, address) {
  return owner && typeof owner === "object" && "AddressOwner" in owner && normalizeSuiAddress(owner.AddressOwner) === address;
}

// ../node_modules/@mysten/zksend/dist/esm/links/claim.js
var __typeError10 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck10 = (obj, member, msg) => member.has(obj) || __typeError10("Cannot " + msg);
var __privateGet11 = (obj, member, getter) => (__accessCheck10(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet9 = (obj, member, value2, setter) => (__accessCheck10(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod7 = (obj, member, method) => (__accessCheck10(obj, member, "access private method"), method);
var _client5;
var _contract2;
var _network;
var _host2;
var _path2;
var _claimApi;
var _gasCoin;
var _hasSui;
var _ownedObjects;
var _ZkSendLink_instances;
var loadBagObject_fn;
var loadBag_fn;
var loadClaimedAssets_fn;
var createSponsoredTransaction_fn;
var executeSponsoredTransaction_fn;
var fetch_fn;
var listNonContractClaimableAssets_fn;
var createNonContractClaimTransaction_fn;
var loadOwnedObjects_fn;
var SUI_COIN_TYPE2 = normalizeStructTag(SUI_TYPE_ARG);
var SUI_COIN_OBJECT_TYPE = normalizeStructTag("0x2::coin::Coin<0x2::sui::SUI>");
_client5 = /* @__PURE__ */ new WeakMap();
_contract2 = /* @__PURE__ */ new WeakMap();
_network = /* @__PURE__ */ new WeakMap();
_host2 = /* @__PURE__ */ new WeakMap();
_path2 = /* @__PURE__ */ new WeakMap();
_claimApi = /* @__PURE__ */ new WeakMap();
_gasCoin = /* @__PURE__ */ new WeakMap();
_hasSui = /* @__PURE__ */ new WeakMap();
_ownedObjects = /* @__PURE__ */ new WeakMap();
_ZkSendLink_instances = /* @__PURE__ */ new WeakSet();
loadBagObject_fn = async function() {
  if (!__privateGet11(this, _contract2)) {
    throw new Error("Cannot load bag object for non-contract based links");
  }
  const bagField = await __privateGet11(this, _client5).getDynamicFieldObject({
    parentId: __privateGet11(this, _contract2).ids.bagStoreTableId,
    name: {
      type: "address",
      value: this.address
    }
  });
  this.bagObject = bagField.data;
  if (this.bagObject) {
    this.claimed = false;
  }
};
loadBag_fn = async function({
  transaction,
  loadAssets = true,
  loadClaimedAssets = loadAssets
} = {}) {
  var _a7, _b3, _c2, _d2, _e, _f2, _g2, _h2, _i2, _j2, _k2, _l2;
  if (!__privateGet11(this, _contract2)) {
    return;
  }
  if (!this.bagObject || !this.claimed) {
    await __privateMethod7(this, _ZkSendLink_instances, loadBagObject_fn).call(this);
  }
  if (!loadAssets) {
    return;
  }
  if (!this.bagObject) {
    if (loadClaimedAssets) {
      await __privateMethod7(this, _ZkSendLink_instances, loadClaimedAssets_fn).call(this);
    }
    return;
  }
  const bagId = (_b3 = (_a7 = this.bagObject.content.fields.value.fields) == null ? void 0 : _a7.id) == null ? void 0 : _b3.id;
  if (bagId && (transaction == null ? void 0 : transaction.balanceChanges) && transaction.objectChanges) {
    this.assets = getAssetsFromTransaction({
      transaction,
      address: bagId,
      isSent: false
    });
    return;
  }
  const itemIds = (_g2 = (_f2 = (_e = (_d2 = (_c2 = this.bagObject) == null ? void 0 : _c2.content) == null ? void 0 : _d2.fields) == null ? void 0 : _e.value) == null ? void 0 : _f2.fields) == null ? void 0 : _g2.item_ids.fields.contents;
  this.creatorAddress = (_l2 = (_k2 = (_j2 = (_i2 = (_h2 = this.bagObject) == null ? void 0 : _h2.content) == null ? void 0 : _i2.fields) == null ? void 0 : _j2.value) == null ? void 0 : _k2.fields) == null ? void 0 : _l2.owner;
  if (!itemIds) {
    throw new Error("Invalid bag field");
  }
  const objectsResponse = await __privateGet11(this, _client5).multiGetObjects({
    ids: itemIds,
    options: {
      showType: true,
      showContent: true
    }
  });
  this.assets = {
    balances: [],
    nfts: [],
    coins: []
  };
  const balances = /* @__PURE__ */ new Map();
  objectsResponse.forEach((object2, i10) => {
    var _a8;
    if (!object2.data || !object2.data.type) {
      throw new Error(`Failed to load claimable object ${itemIds[i10]}`);
    }
    const type2 = parseStructTag(normalizeStructTag(object2.data.type));
    if (type2.address === normalizeSuiAddress("0x2") && type2.module === "coin" && type2.name === "Coin") {
      this.assets.coins.push({
        objectId: object2.data.objectId,
        type: object2.data.type,
        version: object2.data.version,
        digest: object2.data.digest
      });
      if (((_a8 = object2.data.content) == null ? void 0 : _a8.dataType) === "moveObject") {
        const amount = BigInt(object2.data.content.fields.balance);
        const coinType = normalizeStructTag(
          parseStructTag(object2.data.content.type).typeParams[0]
        );
        if (!balances.has(coinType)) {
          balances.set(coinType, { coinType, amount });
        } else {
          balances.get(coinType).amount += amount;
        }
      }
    } else {
      this.assets.nfts.push({
        objectId: object2.data.objectId,
        type: object2.data.type,
        version: object2.data.version,
        digest: object2.data.digest
      });
    }
  });
  this.assets.balances = [...balances.values()];
};
loadClaimedAssets_fn = async function() {
  var _a7;
  const result = await __privateGet11(this, _client5).queryTransactionBlocks({
    limit: 1,
    filter: {
      FromAddress: this.address
    },
    options: {
      showObjectChanges: true,
      showBalanceChanges: true,
      showInput: true
    }
  });
  if (!(result == null ? void 0 : result.data[0])) {
    return;
  }
  const [tx2] = result.data;
  if (((_a7 = tx2.transaction) == null ? void 0 : _a7.data.transaction.kind) !== "ProgrammableTransaction") {
    return;
  }
  const transfer = tx2.transaction.data.transaction.transactions.findLast(
    (tx22) => "TransferObjects" in tx22
  );
  if (!transfer) {
    return;
  }
  const receiverArg = transfer.TransferObjects[1];
  if (!(typeof receiverArg === "object" && "Input" in receiverArg)) {
    return;
  }
  const input = tx2.transaction.data.transaction.inputs[receiverArg.Input];
  if (input.type !== "pure") {
    return;
  }
  const receiver = typeof input.value === "string" ? input.value : suiBcs.Address.parse(new Uint8Array(input.value.Pure));
  this.claimed = true;
  this.claimedBy = receiver;
  this.assets = getAssetsFromTransaction({
    transaction: tx2,
    address: receiver,
    isSent: false
  });
};
createSponsoredTransaction_fn = async function(tx2, claimer, sender) {
  return __privateMethod7(this, _ZkSendLink_instances, fetch_fn).call(this, "transaction-blocks/sponsor", {
    method: "POST",
    body: JSON.stringify({
      network: __privateGet11(this, _network),
      sender,
      claimer,
      transactionBlockKindBytes: toBase64(
        await tx2.build({
          onlyTransactionKind: true,
          client: __privateGet11(this, _client5)
        })
      )
    })
  });
};
executeSponsoredTransaction_fn = async function(input, signature) {
  return __privateMethod7(this, _ZkSendLink_instances, fetch_fn).call(this, `transaction-blocks/sponsor/${input.digest}`, {
    method: "POST",
    body: JSON.stringify({
      signature
    })
  });
};
fetch_fn = async function(path, init) {
  const res = await fetch(`${__privateGet11(this, _claimApi)}/v1/${path}`, {
    ...init,
    headers: {
      ...init.headers,
      "Content-Type": "application/json"
    }
  });
  if (!res.ok) {
    console.error(path, await res.text());
    throw new Error(`Request to claim API failed with status code ${res.status}`);
  }
  const { data } = await res.json();
  return data;
};
listNonContractClaimableAssets_fn = async function() {
  const balances = [];
  const nfts = [];
  const coins = [];
  if (__privateGet11(this, _ownedObjects).length === 0 && !__privateGet11(this, _hasSui)) {
    return {
      balances,
      nfts,
      coins
    };
  }
  const address = new Ed25519Keypair().toSuiAddress();
  const normalizedAddress = normalizeSuiAddress(address);
  const tx2 = this.createClaimTransaction(normalizedAddress);
  if (__privateGet11(this, _gasCoin) || !__privateGet11(this, _hasSui)) {
    tx2.setGasPayment([]);
  }
  const dryRun = await __privateGet11(this, _client5).dryRunTransactionBlock({
    transactionBlock: await tx2.build({ client: __privateGet11(this, _client5) })
  });
  dryRun.balanceChanges.forEach((balanceChange) => {
    if (BigInt(balanceChange.amount) > 0n && isOwner(balanceChange.owner, normalizedAddress)) {
      balances.push({
        coinType: normalizeStructTag(balanceChange.coinType),
        amount: BigInt(balanceChange.amount)
      });
    }
  });
  dryRun.objectChanges.forEach((objectChange) => {
    if ("objectType" in objectChange) {
      const type2 = parseStructTag(objectChange.objectType);
      if (type2.address === normalizeSuiAddress("0x2") && type2.module === "coin" && type2.name === "Coin") {
        if (ownedAfterChange(objectChange, normalizedAddress)) {
          coins.push(objectChange);
        }
        return;
      }
    }
    if (ownedAfterChange(objectChange, normalizedAddress)) {
      nfts.push(objectChange);
    }
  });
  return {
    balances,
    nfts,
    coins
  };
};
createNonContractClaimTransaction_fn = function(address) {
  if (!this.keypair) {
    throw new Error("Cannot claim assets without the links keypair");
  }
  const tx2 = new Transaction();
  tx2.setSender(this.keypair.toSuiAddress());
  const objectsToTransfer = __privateGet11(this, _ownedObjects).filter((object2) => {
    if (__privateGet11(this, _gasCoin)) {
      if (object2.objectId === __privateGet11(this, _gasCoin).coinObjectId) {
        return false;
      }
    } else if (object2.type === SUI_COIN_OBJECT_TYPE) {
      return false;
    }
    return true;
  }).map((object2) => tx2.object(object2.objectId));
  if (__privateGet11(this, _gasCoin) && this.creatorAddress) {
    tx2.transferObjects([tx2.gas], this.creatorAddress);
  } else {
    objectsToTransfer.push(tx2.gas);
  }
  if (objectsToTransfer.length > 0) {
    tx2.transferObjects(objectsToTransfer, address);
  }
  return tx2;
};
loadOwnedObjects_fn = async function({
  loadClaimedAssets = true
} = {}) {
  var _a7, _b3;
  this.assets = {
    nfts: [],
    balances: [],
    coins: []
  };
  let nextCursor;
  do {
    const ownedObjects = await __privateGet11(this, _client5).getOwnedObjects({
      cursor: nextCursor,
      owner: this.address,
      options: {
        showType: true,
        showContent: true
      }
    });
    nextCursor = ownedObjects.hasNextPage ? ownedObjects.nextCursor : null;
    for (const object2 of ownedObjects.data) {
      if (object2.data) {
        __privateGet11(this, _ownedObjects).push({
          objectId: normalizeSuiObjectId(object2.data.objectId),
          version: object2.data.version,
          digest: object2.data.digest,
          type: normalizeStructTag(object2.data.type)
        });
      }
    }
  } while (nextCursor);
  const coins = await __privateGet11(this, _client5).getCoins({
    coinType: SUI_COIN_TYPE2,
    owner: this.address
  });
  __privateSet9(this, _hasSui, coins.data.length > 0);
  __privateSet9(this, _gasCoin, coins.data.find((coin) => BigInt(coin.balance) % 1000n === 987n));
  const result = await __privateGet11(this, _client5).queryTransactionBlocks({
    limit: 1,
    order: "ascending",
    filter: {
      ToAddress: this.address
    },
    options: {
      showInput: true,
      showBalanceChanges: true,
      showObjectChanges: true
    }
  });
  this.creatorAddress = (_b3 = (_a7 = result.data[0]) == null ? void 0 : _a7.transaction) == null ? void 0 : _b3.data.sender;
  if (__privateGet11(this, _hasSui) || __privateGet11(this, _ownedObjects).length > 0) {
    this.claimed = false;
    this.assets = await __privateMethod7(this, _ZkSendLink_instances, listNonContractClaimableAssets_fn).call(this);
  } else if (result.data[0] && loadClaimedAssets) {
    this.claimed = true;
    await __privateMethod7(this, _ZkSendLink_instances, loadClaimedAssets_fn).call(this);
  }
};

// ../node_modules/@mysten/zksend/dist/esm/links/list-created-links.js
var ListCreatedLinksQuery = graphql2(`
	query listCreatedLinks($address: SuiAddress!, $function: String!, $cursor: String) {
		transactionBlocks(
			last: 10
			before: $cursor
			filter: { sentAddress: $address, function: $function }
		) {
			pageInfo {
				startCursor
				hasPreviousPage
			}
			nodes {
				effects {
					timestamp
				}
				digest
				bcs
			}
		}
	}
`);

// ../node_modules/@wallet-standard/app/lib/esm/wallets.js
var _AppReadyEvent_detail;
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// ../node_modules/@wallet-standard/errors/lib/esm/codes.js
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND = 3834e3;
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND = 3834001;
var WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED = 4001e3;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED = 616e4;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED = 6160001;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED = 6160002;

// ../node_modules/@wallet-standard/errors/lib/esm/messages.js
var WalletStandardErrorMessages = {
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED]: "The wallet account $address does not support the chain `$chain`",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED]: "The wallet account $address does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED]: "The wallet '$walletName' does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND]: "No account with address $address could be found in the '$walletName' wallet",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND]: "No underlying Wallet Standard wallet could be found for this handle. This can happen if the wallet associated with the handle has been unregistered.",
  [WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED]: "The user rejected the request"
};

// ../node_modules/@wallet-standard/errors/lib/esm/message-formatter.js
var StateType;
(function(StateType2) {
  StateType2[StateType2["EscapeSequence"] = 0] = "EscapeSequence";
  StateType2[StateType2["Text"] = 1] = "Text";
  StateType2[StateType2["Variable"] = 2] = "Variable";
})(StateType || (StateType = {}));

// ../node_modules/@wallet-standard/wallet/lib/esm/register.js
var _RegisterWalletEvent_detail;
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();

// ../node_modules/@wallet-standard/wallet/lib/esm/util.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _ReadonlyWalletAccount_address;
var _ReadonlyWalletAccount_publicKey;
var _ReadonlyWalletAccount_chains;
var _ReadonlyWalletAccount_features;
var _ReadonlyWalletAccount_label;
var _ReadonlyWalletAccount_icon;
var ReadonlyWalletAccount = class _ReadonlyWalletAccount {
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.address | WalletAccount::address} */
  get address() {
    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.publicKey | WalletAccount::publicKey} */
  get publicKey() {
    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.chains | WalletAccount::chains} */
  get chains() {
    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.features | WalletAccount::features} */
  get features() {
    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.label | WalletAccount::label} */
  get label() {
    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.icon | WalletAccount::icon} */
  get icon() {
    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, "f");
  }
  /**
   * Create and freeze a read-only account.
   *
   * @param account Account to copy properties from.
   */
  constructor(account) {
    _ReadonlyWalletAccount_address.set(this, void 0);
    _ReadonlyWalletAccount_publicKey.set(this, void 0);
    _ReadonlyWalletAccount_chains.set(this, void 0);
    _ReadonlyWalletAccount_features.set(this, void 0);
    _ReadonlyWalletAccount_label.set(this, void 0);
    _ReadonlyWalletAccount_icon.set(this, void 0);
    if (new.target === _ReadonlyWalletAccount) {
      Object.freeze(this);
    }
    __classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, "f");
    __classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), "f");
    __classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), "f");
    __classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), "f");
    __classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, "f");
    __classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, "f");
  }
};
_ReadonlyWalletAccount_address = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_publicKey = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_chains = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_features = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_label = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_icon = /* @__PURE__ */ new WeakMap();

// ../node_modules/@mysten/zksend/dist/esm/wallet/channel/events.js
var StashedRequestData = variant("type", [
  object({
    type: literal("connect")
  }),
  object({
    type: literal("sign-transaction-block"),
    data: string("`data` is required"),
    address: string("`address` is required")
  }),
  object({
    type: literal("sign-personal-message"),
    bytes: string("`bytes` is required"),
    address: string("`address` is required")
  })
]);
var StashedRequest = object({
  id: pipe(string("`id` is required"), uuid()),
  origin: pipe(string(), url("`origin` must be a valid URL")),
  name: optional(string()),
  payload: StashedRequestData
});
var StashedResponseData = variant("type", [
  object({
    type: literal("connect"),
    address: string()
  }),
  object({
    type: literal("sign-transaction-block"),
    bytes: string(),
    signature: string()
  }),
  object({
    type: literal("sign-personal-message"),
    bytes: string(),
    signature: string()
  })
]);
var StashedResponsePayload = variant("type", [
  object({
    type: literal("reject")
  }),
  object({
    type: literal("resolve"),
    data: StashedResponseData
  })
]);
var StashedResponse = object({
  id: pipe(string(), uuid()),
  source: literal("zksend-channel"),
  payload: StashedResponsePayload
});

// ../node_modules/@mysten/zksend/dist/esm/wallet/channel/index.js
var __typeError11 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck11 = (obj, member, msg) => member.has(obj) || __typeError11("Cannot " + msg);
var __privateGet12 = (obj, member, getter) => (__accessCheck11(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet10 = (obj, member, value2, setter) => (__accessCheck11(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _popup;
var _id;
var _origin;
var _name;
var _network2;
var _promise;
var _resolve;
var _reject;
var _interval;
var _listener;
var _StashedPopup_instances;
var cleanup_fn;
var _request;
_popup = /* @__PURE__ */ new WeakMap();
_id = /* @__PURE__ */ new WeakMap();
_origin = /* @__PURE__ */ new WeakMap();
_name = /* @__PURE__ */ new WeakMap();
_network2 = /* @__PURE__ */ new WeakMap();
_promise = /* @__PURE__ */ new WeakMap();
_resolve = /* @__PURE__ */ new WeakMap();
_reject = /* @__PURE__ */ new WeakMap();
_interval = /* @__PURE__ */ new WeakMap();
_listener = /* @__PURE__ */ new WeakMap();
_StashedPopup_instances = /* @__PURE__ */ new WeakSet();
cleanup_fn = function() {
  if (__privateGet12(this, _interval)) {
    clearInterval(__privateGet12(this, _interval));
    __privateSet10(this, _interval, null);
  }
  window.removeEventListener("message", __privateGet12(this, _listener));
};
_request = /* @__PURE__ */ new WeakMap();

// ../node_modules/@mysten/zksend/dist/esm/wallet/index.js
var __typeError12 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck12 = (obj, member, msg) => member.has(obj) || __typeError12("Cannot " + msg);
var __privateGet13 = (obj, member, getter) => (__accessCheck12(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet11 = (obj, member, value2, setter) => (__accessCheck12(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var _events;
var _accounts;
var _origin2;
var _name2;
var _network3;
var _signTransactionBlock;
var _signTransaction;
var _signPersonalMessage;
var _on;
var _StashedWallet_instances;
var setAccount_fn;
var _connect;
var _disconnect;
var STASHED_RECENT_ADDRESS_KEY = "stashed:recentAddress";
_events = /* @__PURE__ */ new WeakMap();
_accounts = /* @__PURE__ */ new WeakMap();
_origin2 = /* @__PURE__ */ new WeakMap();
_name2 = /* @__PURE__ */ new WeakMap();
_network3 = /* @__PURE__ */ new WeakMap();
_signTransactionBlock = /* @__PURE__ */ new WeakMap();
_signTransaction = /* @__PURE__ */ new WeakMap();
_signPersonalMessage = /* @__PURE__ */ new WeakMap();
_on = /* @__PURE__ */ new WeakMap();
_StashedWallet_instances = /* @__PURE__ */ new WeakSet();
setAccount_fn = function(address) {
  if (address) {
    __privateSet11(this, _accounts, [
      new ReadonlyWalletAccount({
        address,
        chains: this.chains,
        features: ["sui:signTransaction", "sui:signTransactionBlock", "sui:signPersonalMessage"],
        // NOTE: Stashed doesn't support getting public keys, and zkLogin accounts don't have meaningful public keys anyway
        publicKey: new Uint8Array()
      })
    ]);
    localStorage.setItem(STASHED_RECENT_ADDRESS_KEY, address);
  } else {
    __privateSet11(this, _accounts, []);
  }
  __privateGet13(this, _events).emit("change", { accounts: this.accounts });
};
_connect = /* @__PURE__ */ new WeakMap();
_disconnect = /* @__PURE__ */ new WeakMap();

// ../node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// ../node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function shallowEqualObjects(a10, b) {
  if (!b || Object.keys(a10).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a10) {
    if (a10[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainObject(o10) {
  if (!hasObjectPrototype(o10)) {
    return false;
  }
  const ctor = o10.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o10) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o10) {
  return Object.prototype.toString.call(o10) === "[object Object]";
}
var skipToken = Symbol();

// ../node_modules/@tanstack/query-core/build/modern/focusManager.js
var _focused, _cleanup, _setup, _a;
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a7;
    if (!this.hasListeners()) {
      (_a7 = __privateGet(this, _cleanup)) == null ? void 0 : _a7.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a7;
    __privateSet(this, _setup, setup);
    (_a7 = __privateGet(this, _cleanup)) == null ? void 0 : _a7.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a7;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a7 = globalThis.document) == null ? void 0 : _a7.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();

// ../node_modules/@tanstack/query-core/build/modern/onlineManager.js
var _online, _cleanup2, _setup2, _a2;
var OnlineManager = (_a2 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a7;
    if (!this.hasListeners()) {
      (_a7 = __privateGet(this, _cleanup2)) == null ? void 0 : _a7.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a7;
    __privateSet(this, _setup2, setup);
    (_a7 = __privateGet(this, _cleanup2)) == null ? void 0 : _a7.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _a2);
var onlineManager = new OnlineManager();

// ../node_modules/@tanstack/query-core/build/modern/notifyManager.js
var defaultScheduler = (cb2) => setTimeout(cb2, 0);
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn2) => {
      notifyFn = fn2;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn2) => {
      batchNotifyFn = fn2;
    },
    setScheduler: (fn2) => {
      scheduleFn = fn2;
    }
  };
}
var notifyManager = createNotifyManager();

// ../node_modules/@tanstack/query-core/build/modern/mutation.js
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// ../node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var _client6, _currentResult, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn, _a3;
var MutationObserver2 = (_a3 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client6);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client6, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a7;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client6).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client6).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a7;
    if (!this.hasListeners()) {
      (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  reset() {
    var _a7;
    (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn).call(this);
  }
  mutate(variables, options) {
    var _a7;
    __privateSet(this, _mutateOptions, options);
    (_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client6).getMutationCache().build(__privateGet(this, _client6), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client6 = new WeakMap(), _currentResult = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a7;
  const state = ((_a7 = __privateGet(this, _currentMutation)) == null ? void 0 : _a7.state) ?? getDefaultState();
  __privateSet(this, _currentResult, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn = function(action) {
  notifyManager.batch(() => {
    var _a7, _b3, _c2, _d2, _e, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult).variables;
      const context = __privateGet(this, _currentResult).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b3 = (_a7 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b3.call(_a7, action.data, variables, context);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e, action.error, variables, context);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult));
    });
  });
}, _a3);

// ../node_modules/@tanstack/query-core/build/modern/types.js
var dataTagSymbol = Symbol("dataTagSymbol");
var dataTagErrorSymbol = Symbol("dataTagErrorSymbol");
var unsetMarker = Symbol("unsetMarker");

// ../node_modules/@tanstack/react-query/build/modern/useQueries.js
var React32 = __toESM(require_react(), 1);

// ../node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React28 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React28.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = React28.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};

// ../node_modules/@tanstack/react-query/build/modern/isRestoring.js
var React29 = __toESM(require_react(), 1);
var IsRestoringContext = React29.createContext(false);
var IsRestoringProvider = IsRestoringContext.Provider;

// ../node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React30 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React30.createContext(createValue());

// ../node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React31 = __toESM(require_react(), 1);

// ../node_modules/@tanstack/react-query/build/modern/utils.js
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop2() {
}

// ../node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React33 = __toESM(require_react(), 1);

// ../node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js
var React34 = __toESM(require_react(), 1);

// ../node_modules/@tanstack/react-query/build/modern/useIsFetching.js
var React35 = __toESM(require_react(), 1);

// ../node_modules/@tanstack/react-query/build/modern/useMutationState.js
var React36 = __toESM(require_react(), 1);

// ../node_modules/@tanstack/react-query/build/modern/useMutation.js
var React37 = __toESM(require_react(), 1);
function useMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const [observer] = React37.useState(
    () => new MutationObserver2(
      client,
      options
    )
  );
  React37.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React37.useSyncExternalStore(
    React37.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React37.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop2);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_react9 = __toESM(require_react());

// ../node_modules/zustand/esm/index.mjs
var import_react4 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var { useDebugValue } = import_react4.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_react10 = __toESM(require_react());

// ../node_modules/@mysten/dapp-kit/node_modules/@mysten/wallet-standard/dist/esm/wallet.js
async function signTransaction2(wallet, input) {
  if (wallet.features["sui:signTransaction"]) {
    return wallet.features["sui:signTransaction"].signTransaction(input);
  }
  if (!wallet.features["sui:signTransactionBlock"]) {
    throw new Error(
      `Provided wallet (${wallet.name}) does not support the signTransaction feature.`
    );
  }
  const { signTransactionBlock } = wallet.features["sui:signTransactionBlock"];
  const transaction = Transaction.from(await input.transaction.toJSON());
  const { transactionBlockBytes, signature } = await signTransactionBlock({
    transactionBlock: transaction,
    account: input.account,
    chain: input.chain
  });
  return { bytes: transactionBlockBytes, signature };
}

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var import_react11 = __toESM(require_react());
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());

// ../node_modules/@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js
function toPrimitive(t10, r10) {
  if ("object" != typeof t10 || !t10) return t10;
  var e10 = t10[Symbol.toPrimitive];
  if (void 0 !== e10) {
    var i10 = e10.call(t10, r10 || "default");
    if ("object" != typeof i10) return i10;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r10 ? String : Number)(t10);
}
function toPropertyKey(t10) {
  var i10 = toPrimitive(t10, "string");
  return "symbol" == typeof i10 ? i10 : String(i10);
}
function _defineProperty(obj, key, value2) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function ownKeys(e10, r10) {
  var t10 = Object.keys(e10);
  if (Object.getOwnPropertySymbols) {
    var o10 = Object.getOwnPropertySymbols(e10);
    r10 && (o10 = o10.filter(function(r11) {
      return Object.getOwnPropertyDescriptor(e10, r11).enumerable;
    })), t10.push.apply(t10, o10);
  }
  return t10;
}
function _objectSpread2(e10) {
  for (var r10 = 1; r10 < arguments.length; r10++) {
    var t10 = null != arguments[r10] ? arguments[r10] : {};
    r10 % 2 ? ownKeys(Object(t10), true).forEach(function(r11) {
      _defineProperty(e10, r11, t10[r11]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(t10)) : ownKeys(Object(t10)).forEach(function(r11) {
      Object.defineProperty(e10, r11, Object.getOwnPropertyDescriptor(t10, r11));
    });
  }
  return e10;
}
function mapValues(input, fn2) {
  var result = {};
  for (var _key in input) {
    result[_key] = fn2(input[_key], _key);
  }
  return result;
}
var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
  for (var key of Object.keys(compoundCheck)) {
    var _selections$key;
    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {
      return false;
    }
  }
  return true;
};
var createRuntimeFn = (config) => {
  var runtimeFn = (options) => {
    var className = config.defaultClassName;
    var selections = _objectSpread2(_objectSpread2({}, config.defaultVariants), options);
    for (var variantName in selections) {
      var _selections$variantNa;
      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];
      if (variantSelection != null) {
        var selection = variantSelection;
        if (typeof selection === "boolean") {
          selection = selection === true ? "true" : "false";
        }
        var selectionClassName = (
          // @ts-expect-error
          config.variantClassNames[variantName][selection]
        );
        if (selectionClassName) {
          className += " " + selectionClassName;
        }
      }
    }
    for (var [compoundCheck, compoundClassName] of config.compoundVariants) {
      if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) {
        className += " " + compoundClassName;
      }
    }
    return className;
  };
  runtimeFn.variants = () => Object.keys(config.variantClassNames);
  runtimeFn.classNames = {
    get base() {
      return config.defaultClassName.split(" ")[0];
    },
    get variants() {
      return mapValues(config.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
    }
  };
  return runtimeFn;
};

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var import_react13 = __toESM(require_react());
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var import_react14 = __toESM(require_react());
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var import_react15 = __toESM(require_react());
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var import_jsx_runtime32 = __toESM(require_jsx_runtime());

// ../node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var React46 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-menu/dist/index.mjs
var React45 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope3] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react5.default.useRef(null);
    const itemMap = import_react5.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime10.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react5.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime10.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react5.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react5.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react5.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return (0, import_jsx_runtime10.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection3(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react5.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a10, b) => orderedNodes.indexOf(a10.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection3,
    createCollectionScope3
  ];
}

// ../node_modules/@radix-ui/react-direction/dist/index.mjs
var React39 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React39.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React39.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// ../node_modules/@radix-ui/react-popper/dist/index.mjs
var React43 = __toESM(require_react(), 1);

// ../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v10) => ({
  x: v10,
  y: v10
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value2, end) {
  return max(start, min(value2, end));
}
function evaluate(value2, param) {
  return typeof value2 === "function" ? value2(param) : value2;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr2;
      return isStart ? lr2 : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// ../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i10 = 0; i10 < validMiddleware.length; i10++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i10];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i10 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding: padding2 = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding2);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d6) => d6.overflows[0] <= 0).sort((a10, b) => a10.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d6) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d6.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d6) => [d6.placement, d6.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a10, b) => a10[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x6,
              y: y10
            } = _ref;
            return {
              x: x6,
              y: y10
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode3(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode3(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode3(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
}
function isElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
}
function isHTMLElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
}
function isShadowRoot(value2) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e10) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value2) => css[value2] ? css[value2] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value2) => (css.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css.contain || "").includes(value2));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a10, b) {
  return a10.x === b.x && a10.y === b.y && a10.width === b.width && a10.height === b.height;
}
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e10) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React40 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react7.useLayoutEffect : import_react7.useEffect;
function deepEqual(a10, b) {
  if (a10 === b) {
    return true;
  }
  if (typeof a10 !== typeof b) {
    return false;
  }
  if (typeof a10 === "function" && a10.toString() === b.toString()) {
    return true;
  }
  let length;
  let i10;
  let keys;
  if (a10 && b && typeof a10 === "object") {
    if (Array.isArray(a10)) {
      length = a10.length;
      if (length !== b.length) return false;
      for (i10 = length; i10-- !== 0; ) {
        if (!deepEqual(a10[i10], b[i10])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a10);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i10 = length; i10-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i10])) {
        return false;
      }
    }
    for (i10 = length; i10-- !== 0; ) {
      const key = keys[i10];
      if (key === "_owner" && a10.$$typeof) {
        continue;
      }
      if (!deepEqual(a10[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a10 !== a10 && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value2) {
  const dpr = getDPR(element);
  return Math.round(value2 * dpr) / dpr;
}
function useLatestRef(value2) {
  const ref = React40.useRef(value2);
  index(() => {
    ref.current = value2;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React40.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React40.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React40.useState(null);
  const [_floating, _setFloating] = React40.useState(null);
  const setReference = React40.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React40.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React40.useRef(null);
  const floatingRef = React40.useRef(null);
  const dataRef = React40.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React40.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM3.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React40.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React40.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React40.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React40.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React40.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value2) {
    return {}.hasOwnProperty.call(value2, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding: padding2
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding: padding2
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding: padding2
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../node_modules/@radix-ui/react-arrow/dist/index.mjs
var React41 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React41.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime13.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime13.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root2 = Arrow;

// ../node_modules/@radix-ui/react-use-size/dist/index.mjs
var React42 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React42.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// ../node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React43.useState(null);
  return (0, import_jsx_runtime14.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React43.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React43.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : (0, import_jsx_runtime14.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME2 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME2);
var PopperContent = React43.forwardRef(
  (props, forwardedRef) => {
    var _a7, _b3, _c2, _d2, _e, _f2;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME2, __scopePopper);
    const [content4, setContent] = React43.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React43.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a7 = middlewareData.arrow) == null ? void 0 : _a7.x;
    const arrowY = (_b3 = middlewareData.arrow) == null ? void 0 : _b3.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React43.useState();
    useLayoutEffect2(() => {
      if (content4) setContentZIndex(window.getComputedStyle(content4).zIndex);
    }, [content4]);
    return (0, import_jsx_runtime14.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime14.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime14.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME2;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React43.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime14.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime14.jsx)(
          Root2,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value2) {
  return value2 !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a7, _b3, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a7 = middlewareData.arrow) == null ? void 0 : _a7.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b3 = middlewareData.arrow) == null ? void 0 : _b3.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper;
var Anchor = PopperAnchor;
var Content2 = PopperContent;
var Arrow2 = PopperArrow;

// ../node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React44 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React44.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime15.jsx)(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime15.jsx)(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime15.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React44.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React44.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React44.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React44.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React44.useState(0);
  React44.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime15.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React44.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React44.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React44.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React44.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime15.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React44.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id2 = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id2;
    const getItems = useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    React44.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime15.jsx)(
      Collection.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: (0, import_jsx_runtime15.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array2, startIndex) {
  return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
}
var Root3 = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// ../node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope(__scopeMenu);
  const [content4, setContent] = React45.useState(null);
  const isUsingKeyboardRef = React45.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React45.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return (0, import_jsx_runtime16.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime16.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content: content4,
      onContentChange: setContent,
      children: (0, import_jsx_runtime16.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React45.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME2 = "MenuAnchor";
var MenuAnchor = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime16.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME2;
var PORTAL_NAME3 = "MenuPortal";
var [PortalProvider2, usePortalContext2] = createMenuContext(PORTAL_NAME3, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container: container8 } = props;
  const context = useMenuContext(PORTAL_NAME3, __scopeMenu);
  return (0, import_jsx_runtime16.jsx)(PortalProvider2, { scope: __scopeMenu, forceMount, children: (0, import_jsx_runtime16.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime16.jsx)(Portal, { asChild: true, container: container8, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME3;
var CONTENT_NAME3 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME3);
var MenuContent = React45.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME3, props.__scopeMenu);
    return (0, import_jsx_runtime16.jsx)(Collection2.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime16.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime16.jsx)(Collection2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? (0, import_jsx_runtime16.jsx)(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime16.jsx)(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React45.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
    const ref = React45.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React45.useEffect(() => {
      const content4 = ref.current;
      if (content4) return hideOthers(content4);
    }, []);
    return (0, import_jsx_runtime16.jsx)(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React45.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
  return (0, import_jsx_runtime16.jsx)(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot3 = createSlot("MenuContent.ScrollLock");
var MenuContentImpl = React45.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME3, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME3, __scopeMenu);
    const popperScope = usePopperScope(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React45.useState(null);
    const contentRef = React45.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React45.useRef(0);
    const searchRef = React45.useRef("");
    const pointerGraceTimerRef = React45.useRef(0);
    const pointerGraceIntentRef = React45.useRef(null);
    const pointerDirRef = React45.useRef("right");
    const lastPointerXRef = React45.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React45.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot3, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a7, _b3;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a7 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a7.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b3 = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b3.ref.current;
      (function updateSearch(value2) {
        searchRef.current = value2;
        window.clearTimeout(timerRef.current);
        if (value2 !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React45.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React45.useCallback((event) => {
      var _a7, _b3;
      const isMovingTowards = pointerDirRef.current === ((_a7 = pointerGraceIntentRef.current) == null ? void 0 : _a7.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b3 = pointerGraceIntentRef.current) == null ? void 0 : _b3.area);
    }, []);
    return (0, import_jsx_runtime16.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React45.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React45.useCallback(
          (event) => {
            var _a7;
            if (isPointerMovingToSubmenu(event)) return;
            (_a7 = contentRef.current) == null ? void 0 : _a7.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React45.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React45.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: (0, import_jsx_runtime16.jsx)(ScrollLockWrapper, { ...scrollLockWrapperProps, children: (0, import_jsx_runtime16.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a7;
              event.preventDefault();
              (_a7 = contentRef.current) == null ? void 0 : _a7.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime16.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: (0, import_jsx_runtime16.jsx)(
                  Root3,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: (0, import_jsx_runtime16.jsx)(
                      Content2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content4 = contentRef.current;
                          if (event.target !== content4) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst3(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME3;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return (0, import_jsx_runtime16.jsx)(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return (0, import_jsx_runtime16.jsx)(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React45.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React45.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME2, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME2, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React45.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return (0, import_jsx_runtime16.jsx)(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a7;
          (_a7 = props.onPointerDown) == null ? void 0 : _a7.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a7;
          if (!isPointerDownRef.current) (_a7 = event.currentTarget) == null ? void 0 : _a7.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME2;
var MenuItemImpl = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME2, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref = React45.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React45.useState(false);
    const [textContent, setTextContent] = React45.useState("");
    React45.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return (0, import_jsx_runtime16.jsx)(
      Collection2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: (0, import_jsx_runtime16.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: (0, import_jsx_runtime16.jsx)(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React45.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return (0, import_jsx_runtime16.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime16.jsx)(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React45.forwardRef(
  (props, forwardedRef) => {
    const { value: value2, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef(onValueChange);
    return (0, import_jsx_runtime16.jsx)(RadioGroupProvider, { scope: props.__scopeMenu, value: value2, onValueChange: handleValueChange, children: (0, import_jsx_runtime16.jsx)(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React45.forwardRef(
  (props, forwardedRef) => {
    const { value: value2, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
    const checked = value2 === context.value;
    return (0, import_jsx_runtime16.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime16.jsx)(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a7;
            return (_a7 = context.onValueChange) == null ? void 0 : _a7.call(context, value2);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return (0, import_jsx_runtime16.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: (0, import_jsx_runtime16.jsx)(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return (0, import_jsx_runtime16.jsx)(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME2 = "MenuArrow";
var MenuArrow = React45.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime16.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME2;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope(__scopeMenu);
  const [trigger, setTrigger] = React45.useState(null);
  const [content4, setContent] = React45.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React45.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return (0, import_jsx_runtime16.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime16.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content: content4,
      onContentChange: setContent,
      children: (0, import_jsx_runtime16.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React45.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const openTimerRef = React45.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React45.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React45.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React45.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return (0, import_jsx_runtime16.jsx)(MenuAnchor, { asChild: true, ...scope, children: (0, import_jsx_runtime16.jsx)(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a7;
          (_a7 = props.onClick) == null ? void 0 : _a7.call(props, event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a7, _b3;
            clearOpenTimer();
            const contentRect = (_a7 = context.content) == null ? void 0 : _a7.getBoundingClientRect();
            if (contentRect) {
              const side = (_b3 = context.content) == null ? void 0 : _b3.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a7;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a7 = context.content) == null ? void 0 : _a7.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React45.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME3, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME3, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
    const ref = React45.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return (0, import_jsx_runtime16.jsx)(Collection2.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime16.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime16.jsx)(Collection2.Slot, { scope: props.__scopeMenu, children: (0, import_jsx_runtime16.jsx)(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a7;
          if (rootContext.isUsingKeyboardRef.current) (_a7 = ref.current) == null ? void 0 : _a7.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a7;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a7 = subContext.trigger) == null ? void 0 : _a7.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array2, startIndex) {
  return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v10) => v10 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value2) => value2.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i10 = 0, j = polygon.length - 1; i10 < polygon.length; j = i10++) {
    const ii2 = polygon[i10];
    const jj2 = polygon[j];
    const xi2 = ii2.x;
    const yi2 = ii2.y;
    const xj2 = jj2.x;
    const yj2 = jj2.y;
    const intersect = yi2 > y !== yj2 > y && x < (xj2 - xi2) * (y - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal3 = MenuPortal;
var Content22 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow22 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// ../node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React46.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return (0, import_jsx_runtime17.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React46.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: (0, import_jsx_runtime17.jsx)(Root32, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME2 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME2, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime17.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime17.jsx)(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME4 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(Portal3, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME4 = "DropdownMenuContent";
var DropdownMenuContent = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React46.useRef(false);
    return (0, import_jsx_runtime17.jsx)(
      Content22,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a7;
          if (!hasInteractedOutsideRef.current) (_a7 = context.triggerRef.current) == null ? void 0 : _a7.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME4;
var GROUP_NAME3 = "DropdownMenuGroup";
var DropdownMenuGroup = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime17.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "DropdownMenuLabel";
var DropdownMenuLabel = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime17.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME3 = "DropdownMenuItem";
var DropdownMenuItem = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime17.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME3;
var CHECKBOX_ITEM_NAME2 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME2 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME3 = "DropdownMenuArrow";
var DropdownMenuArrow = React46.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime17.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME3;
var SUB_TRIGGER_NAME2 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React46.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime17.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME2;

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_react16 = __toESM(require_react());
var import_react17 = __toESM(require_react());
var import_react18 = __toESM(require_react());
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var import_react19 = __toESM(require_react());
var import_react20 = __toESM(require_react());
var import_react21 = __toESM(require_react());
var import_react22 = __toESM(require_react());
var import_react23 = __toESM(require_react());
var import_react24 = __toESM(require_react());

// ../node_modules/@vanilla-extract/private/dist/vanilla-extract-private.esm.js
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function walkObject(obj, fn2) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone = {};
  for (var key in obj) {
    var _value = obj[key];
    var currentPath = [...path, key];
    if (typeof _value === "string" || typeof _value === "number" || _value == null) {
      clone[key] = fn2(_value, currentPath);
    } else if (typeof _value === "object" && !Array.isArray(_value)) {
      clone[key] = walkObject(_value, fn2, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
    }
  }
  return clone;
}

// ../node_modules/@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.browser.esm.js
var stylesheets = {};
var injectStyles2 = (_ref) => {
  var {
    fileScope,
    css
  } = _ref;
  var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join("/") : fileScope.filePath;
  var stylesheet = stylesheets[fileScopeId];
  if (!stylesheet) {
    var styleEl = document.createElement("style");
    if (fileScope.packageName) {
      styleEl.setAttribute("data-package", fileScope.packageName);
    }
    styleEl.setAttribute("data-file", fileScope.filePath);
    styleEl.setAttribute("type", "text/css");
    stylesheet = stylesheets[fileScopeId] = styleEl;
    document.head.appendChild(styleEl);
  }
  stylesheet.innerHTML = css;
};

// ../node_modules/@vanilla-extract/css/dist/transformCss-830a230d.browser.esm.js
var import_cssesc = __toESM(require_cssesc());

// ../node_modules/modern-ahocorasick/dist/index.js
var AhoCorasick = class {
  constructor(keywords) {
    const { failure, gotoFn, output } = this._buildTables(keywords);
    this.gotoFn = gotoFn;
    this.output = output;
    this.failure = failure;
  }
  _buildTables(keywords) {
    const gotoFn = {
      0: {}
    };
    const output = {};
    let state = 0;
    for (const word of keywords) {
      let curr = 0;
      for (const l10 of word) {
        if (gotoFn[curr] && l10 in gotoFn[curr]) {
          curr = gotoFn[curr][l10];
        } else {
          state++;
          gotoFn[curr][l10] = state;
          gotoFn[state] = {};
          curr = state;
          output[state] = [];
        }
      }
      output[curr].push(word);
    }
    const failure = {};
    const xs2 = [];
    for (const l10 in gotoFn[0]) {
      const state2 = gotoFn[0][l10];
      failure[state2] = 0;
      xs2.push(state2);
    }
    while (xs2.length > 0) {
      const r10 = xs2.shift();
      if (r10 !== void 0) {
        for (const l10 in gotoFn[r10]) {
          const s10 = gotoFn[r10][l10];
          xs2.push(s10);
          let state2 = failure[r10];
          while (state2 > 0 && !(l10 in gotoFn[state2])) {
            state2 = failure[state2];
          }
          if (l10 in gotoFn[state2]) {
            const fs2 = gotoFn[state2][l10];
            failure[s10] = fs2;
            output[s10] = [...output[s10], ...output[fs2]];
          } else {
            failure[s10] = 0;
          }
        }
      }
    }
    return {
      gotoFn,
      output,
      failure
    };
  }
  search(str) {
    let state = 0;
    const results = [];
    for (let i10 = 0; i10 < str.length; i10++) {
      const l10 = str[i10];
      while (state > 0 && !(l10 in this.gotoFn[state])) {
        state = this.failure[state];
      }
      if (!(l10 in this.gotoFn[state])) {
        continue;
      }
      state = this.gotoFn[state][l10];
      if (this.output[state].length > 0) {
        const foundStrs = this.output[state];
        results.push([i10, foundStrs]);
      }
    }
    return results;
  }
  match(str) {
    let state = 0;
    for (let i10 = 0; i10 < str.length; i10++) {
      const l10 = str[i10];
      while (state > 0 && !(l10 in this.gotoFn[state])) {
        state = this.failure[state];
      }
      if (!(l10 in this.gotoFn[state])) {
        continue;
      }
      state = this.gotoFn[state][l10];
      if (this.output[state].length > 0) {
        return true;
      }
    }
    return false;
  }
};

// ../node_modules/@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.browser.esm.js
var mockAdapter = {
  appendCss: () => {
  },
  registerClassName: () => {
  },
  onEndFileScope: () => {
  },
  registerComposition: () => {
  },
  markCompositionUsed: () => {
  },
  getIdentOption: () => false ? "short" : "debug"
};
var adapterStack = [mockAdapter];
var currentAdapter = () => {
  if (adapterStack.length < 1) {
    throw new Error("No adapter configured");
  }
  return adapterStack[adapterStack.length - 1];
};
var hasConfiguredAdapter = false;
var setAdapterIfNotSet = (newAdapter) => {
  if (!hasConfiguredAdapter) {
    setAdapter(newAdapter);
  }
};
var setAdapter = (newAdapter) => {
  if (!newAdapter) {
    throw new Error('No adapter provided when calling "setAdapter"');
  }
  hasConfiguredAdapter = true;
  adapterStack.push(newAdapter);
};
var markCompositionUsed = function markCompositionUsed2() {
  return currentAdapter().markCompositionUsed(...arguments);
};

// ../node_modules/@vanilla-extract/css/dist/taggedTemplateLiteral-8e47dbd7.browser.esm.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

// ../node_modules/css-what/lib/es/types.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

// ../node_modules/css-what/lib/es/parse.js
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
var unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse5(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset4) {
    const match = selector.slice(selectorIndex + offset4).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset4 + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset4) {
    selectorIndex += offset4;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type2) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type2;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type: type2 });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case 62: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === 124) {
          name = getName(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name = getName(2);
        } else {
          name = getName(0);
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
            namespace = name;
            name = getName(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== 61) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === 61) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value2 = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
              sectionEnd += 1;
            }
            if (selector.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value2 = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
              selectorIndex += 1;
            }
            value2 = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
          if (forceIgnore === 115) {
            ignoreCase = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105) {
            ignoreCase = true;
            stripWhitespace(1);
          }
        }
        if (selector.charCodeAt(selectorIndex) !== 93) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value: value2,
          namespace,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName(2).toLowerCase(),
            data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name = getName(1).toLowerCase();
        let data = null;
        if (selector.charCodeAt(selectorIndex) === 40) {
          if (unpackPseudos.has(name)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            }
            data = [];
            selectorIndex = parseSelector(data, selector, selectorIndex + 1);
            if (selector.charCodeAt(selectorIndex) !== 41) {
              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
            }
            selectorIndex += 1;
          } else {
            data = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name)) {
              const quot = data.charCodeAt(0);
              if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                data = data.slice(1, -1);
              }
            }
            data = unescapeCSS(data);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name, data });
        break;
      }
      case 44: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name;
        if (firstChar === 42) {
          selectorIndex += 1;
          name = "*";
        } else if (firstChar === 124) {
          name = "";
          if (selector.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name = getName(0);
        } else {
          break loop;
        }
        if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
          namespace = name;
          if (selector.charCodeAt(selectorIndex + 1) === 42) {
            name = "*";
            selectorIndex += 2;
          } else {
            name = getName(1);
          }
        }
        tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}

// ../node_modules/css-what/lib/es/stringify.js
var attribValChars = ["\\", '"'];
var pseudoValChars = [...attribValChars, "(", ")"];
var charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
var charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
var charsToEscapeInName = new Set([
  ...pseudoValChars,
  "~",
  "^",
  "$",
  "*",
  "+",
  "!",
  "|",
  ":",
  "[",
  "]",
  " ",
  "."
].map((c) => c.charCodeAt(0)));

// ../node_modules/dedent/dist/dedent.mjs
function ownKeys2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i10 = 1; i10 < arguments.length; i10++) {
    var source = null != arguments[i10] ? arguments[i10] : {};
    i10 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value2) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent = createDedent({});
var dedent_default = dedent;
function createDedent(options) {
  dedent2.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent2;
  function dedent2(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i10 = 0; i10 < raw.length; i10++) {
      let next = raw[i10];
      if (escapeSpecialCharacters) {
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
      }
      result += next;
      if (i10 < values.length) {
        result += values[i10];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l10 of lines) {
      const m = l10.match(/^(\s+)\S+/);
      if (m) {
        const indent2 = m[1].length;
        if (!mindent) {
          mindent = indent2;
        } else {
          mindent = Math.min(mindent, indent2);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent;
      result = lines.map((l10) => l10[0] === " " || l10[0] === "	" ? l10.slice(m) : l10).join("\n");
    }
    result = result.trim();
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, "\n");
    }
    return result;
  }
}

// ../node_modules/media-query-parser/dist/media-query-parser.esm.js
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t10) {
    for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
      s10 = arguments[i10];
      for (var p in s10) if (Object.prototype.hasOwnProperty.call(s10, p)) t10[p] = s10[p];
    }
    return t10;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s10, e10) {
  var t10 = {};
  for (var p in s10) if (Object.prototype.hasOwnProperty.call(s10, p) && e10.indexOf(p) < 0)
    t10[p] = s10[p];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p = Object.getOwnPropertySymbols(s10); i10 < p.length; i10++) {
      if (e10.indexOf(p[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p[i10]))
        t10[p[i10]] = s10[p[i10]];
    }
  return t10;
}
function __values(o10) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m = s10 && o10[s10], i10 = 0;
  if (m) return m.call(o10);
  if (o10 && typeof o10.length === "number") return {
    next: function() {
      if (o10 && i10 >= o10.length) o10 = void 0;
      return { value: o10 && o10[i10++], done: !o10 };
    }
  };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o10, n10) {
  var m = typeof Symbol === "function" && o10[Symbol.iterator];
  if (!m) return o10;
  var i10 = m.call(o10), r10, ar2 = [], e10;
  try {
    while ((n10 === void 0 || n10-- > 0) && !(r10 = i10.next()).done) ar2.push(r10.value);
  } catch (error2) {
    e10 = { error: error2 };
  } finally {
    try {
      if (r10 && !r10.done && (m = i10["return"])) m.call(i10);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar2;
}
var weirdNewlines = /(\u000D|\u000C|\u000D\u000A)/g;
var nullOrSurrogates = /[\u0000\uD800-\uDFFF]/g;
var commentRegex = /(\/\*)[\s\S]*?(\*\/)/g;
var lexicalAnalysis = function lexicalAnalysis2(str, index2) {
  if (index2 === void 0) {
    index2 = 0;
  }
  str = str.replace(weirdNewlines, "\n").replace(nullOrSurrogates, "�");
  str = str.replace(commentRegex, "");
  var tokens = [];
  for (; index2 < str.length; index2 += 1) {
    var code = str.charCodeAt(index2);
    if (code === 9 || code === 32 || code === 10) {
      var code_1 = str.charCodeAt(++index2);
      while (code_1 === 9 || code_1 === 32 || code_1 === 10) {
        code_1 = str.charCodeAt(++index2);
      }
      index2 -= 1;
      tokens.push({
        type: "<whitespace-token>"
      });
    } else if (code === 34) {
      var result = consumeString(str, index2);
      if (result === null) {
        return null;
      }
      var _a7 = __read(result, 2), lastIndex = _a7[0], value2 = _a7[1];
      tokens.push({
        type: "<string-token>",
        value: value2
      });
      index2 = lastIndex;
    } else if (code === 35) {
      if (index2 + 1 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1);
        if (nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128 || nextCode >= 48 && nextCode <= 57 || nextCode === 92 && index2 + 2 < str.length && str.charCodeAt(index2 + 2) !== 10) {
          var flag = wouldStartIdentifier(str, index2 + 1) ? "id" : "unrestricted";
          var result = consumeIdentUnsafe(str, index2 + 1);
          if (result !== null) {
            var _b3 = __read(result, 2), lastIndex = _b3[0], value2 = _b3[1];
            tokens.push({
              type: "<hash-token>",
              value: value2.toLowerCase(),
              flag
            });
            index2 = lastIndex;
            continue;
          }
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 39) {
      var result = consumeString(str, index2);
      if (result === null) {
        return null;
      }
      var _c2 = __read(result, 2), lastIndex = _c2[0], value2 = _c2[1];
      tokens.push({
        type: "<string-token>",
        value: value2
      });
      index2 = lastIndex;
    } else if (code === 40) {
      tokens.push({
        type: "<(-token>"
      });
    } else if (code === 41) {
      tokens.push({
        type: "<)-token>"
      });
    } else if (code === 43) {
      var plusNumeric = consumeNumeric(str, index2);
      if (plusNumeric === null) {
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      } else {
        var _d2 = __read(plusNumeric, 2), lastIndex = _d2[0], tokenTuple = _d2[1];
        if (tokenTuple[0] === "<dimension-token>") {
          tokens.push({
            type: "<dimension-token>",
            value: tokenTuple[1],
            unit: tokenTuple[2].toLowerCase(),
            flag: "number"
          });
        } else if (tokenTuple[0] === "<number-token>") {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: tokenTuple[2]
          });
        } else {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: "number"
          });
        }
        index2 = lastIndex;
      }
    } else if (code === 44) {
      tokens.push({
        type: "<comma-token>"
      });
    } else if (code === 45) {
      var minusNumeric = consumeNumeric(str, index2);
      if (minusNumeric !== null) {
        var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];
        if (tokenTuple[0] === "<dimension-token>") {
          tokens.push({
            type: "<dimension-token>",
            value: tokenTuple[1],
            unit: tokenTuple[2].toLowerCase(),
            flag: "number"
          });
        } else if (tokenTuple[0] === "<number-token>") {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: tokenTuple[2]
          });
        } else {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: "number"
          });
        }
        index2 = lastIndex;
        continue;
      }
      if (index2 + 2 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1);
        var nextNextCode = str.charCodeAt(index2 + 2);
        if (nextCode === 45 && nextNextCode === 62) {
          tokens.push({
            type: "<CDC-token>"
          });
          index2 += 2;
          continue;
        }
      }
      var result = consumeIdentLike(str, index2);
      if (result !== null) {
        var _f2 = __read(result, 3), lastIndex = _f2[0], value2 = _f2[1], type2 = _f2[2];
        tokens.push({
          type: type2,
          value: value2
        });
        index2 = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 46) {
      var minusNumeric = consumeNumeric(str, index2);
      if (minusNumeric === null) {
        tokens.push({
          type: "<delim-token>",
          value: code
        });
      } else {
        var _g2 = __read(minusNumeric, 2), lastIndex = _g2[0], tokenTuple = _g2[1];
        if (tokenTuple[0] === "<dimension-token>") {
          tokens.push({
            type: "<dimension-token>",
            value: tokenTuple[1],
            unit: tokenTuple[2].toLowerCase(),
            flag: "number"
          });
        } else if (tokenTuple[0] === "<number-token>") {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: tokenTuple[2]
          });
        } else {
          tokens.push({
            type: tokenTuple[0],
            value: tokenTuple[1],
            flag: "number"
          });
        }
        index2 = lastIndex;
        continue;
      }
    } else if (code === 58) {
      tokens.push({
        type: "<colon-token>"
      });
    } else if (code === 59) {
      tokens.push({
        type: "<semicolon-token>"
      });
    } else if (code === 60) {
      if (index2 + 3 < str.length) {
        var nextCode = str.charCodeAt(index2 + 1);
        var nextNextCode = str.charCodeAt(index2 + 2);
        var nextNextNextCode = str.charCodeAt(index2 + 3);
        if (nextCode === 33 && nextNextCode === 45 && nextNextNextCode === 45) {
          tokens.push({
            type: "<CDO-token>"
          });
          index2 += 3;
          continue;
        }
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 64) {
      var result = consumeIdent(str, index2 + 1);
      if (result !== null) {
        var _h2 = __read(result, 2), lastIndex = _h2[0], value2 = _h2[1];
        tokens.push({
          type: "<at-keyword-token>",
          value: value2.toLowerCase()
        });
        index2 = lastIndex;
        continue;
      }
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    } else if (code === 91) {
      tokens.push({
        type: "<[-token>"
      });
    } else if (code === 92) {
      var result = consumeEscape(str, index2);
      if (result === null) {
        return null;
      }
      var _j2 = __read(result, 2), lastIndex = _j2[0], value2 = _j2[1];
      str = str.slice(0, index2) + value2 + str.slice(lastIndex + 1);
      index2 -= 1;
    } else if (code === 93) {
      tokens.push({
        type: "<]-token>"
      });
    } else if (code === 123) {
      tokens.push({
        type: "<{-token>"
      });
    } else if (code === 125) {
      tokens.push({
        type: "<}-token>"
      });
    } else if (code >= 48 && code <= 57) {
      var result = consumeNumeric(str, index2);
      var _k2 = __read(result, 2), lastIndex = _k2[0], tokenTuple = _k2[1];
      if (tokenTuple[0] === "<dimension-token>") {
        tokens.push({
          type: "<dimension-token>",
          value: tokenTuple[1],
          unit: tokenTuple[2].toLowerCase(),
          flag: "number"
        });
      } else if (tokenTuple[0] === "<number-token>") {
        tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: tokenTuple[2]
        });
      } else {
        tokens.push({
          type: tokenTuple[0],
          value: tokenTuple[1],
          flag: "number"
        });
      }
      index2 = lastIndex;
    } else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
      var result = consumeIdentLike(str, index2);
      if (result === null) {
        return null;
      }
      var _l2 = __read(result, 3), lastIndex = _l2[0], value2 = _l2[1], type2 = _l2[2];
      tokens.push({
        type: type2,
        value: value2
      });
      index2 = lastIndex;
    } else {
      tokens.push({
        type: "<delim-token>",
        value: code
      });
    }
  }
  tokens.push({
    type: "<EOF-token>"
  });
  return tokens;
};
var consumeString = function consumeString2(str, index2) {
  if (str.length <= index2 + 1) return null;
  var firstCode = str.charCodeAt(index2);
  var charCodes = [];
  for (var i10 = index2 + 1; i10 < str.length; i10 += 1) {
    var code = str.charCodeAt(i10);
    if (code === firstCode) {
      return [i10, String.fromCharCode.apply(null, charCodes)];
    } else if (code === 92) {
      var result = consumeEscape(str, i10);
      if (result === null) return null;
      var _a7 = __read(result, 2), lastIndex = _a7[0], charCode = _a7[1];
      charCodes.push(charCode);
      i10 = lastIndex;
    } else if (code === 10) {
      return null;
    } else {
      charCodes.push(code);
    }
  }
  return null;
};
var wouldStartIdentifier = function wouldStartIdentifier2(str, index2) {
  if (str.length <= index2) return false;
  var code = str.charCodeAt(index2);
  if (code === 45) {
    if (str.length <= index2 + 1) return false;
    var nextCode = str.charCodeAt(index2 + 1);
    if (nextCode === 45 || nextCode === 95 || nextCode >= 65 && nextCode <= 90 || nextCode >= 97 && nextCode <= 122 || nextCode >= 128) {
      return true;
    } else if (nextCode === 92) {
      if (str.length <= index2 + 2) return false;
      var nextNextCode = str.charCodeAt(index2 + 2);
      return nextNextCode !== 10;
    } else {
      return false;
    }
  } else if (code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128) {
    return true;
  } else if (code === 92) {
    if (str.length <= index2 + 1) return false;
    var nextCode = str.charCodeAt(index2 + 1);
    return nextCode !== 10;
  } else {
    return false;
  }
};
var consumeEscape = function consumeEscape2(str, index2) {
  if (str.length <= index2 + 1) return null;
  if (str.charCodeAt(index2) !== 92) return null;
  var code = str.charCodeAt(index2 + 1);
  if (code === 10) {
    return null;
  } else if (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) {
    var hexCharCodes = [code];
    var min2 = Math.min(index2 + 7, str.length);
    var i10 = index2 + 2;
    for (; i10 < min2; i10 += 1) {
      var code_2 = str.charCodeAt(i10);
      if (code_2 >= 48 && code_2 <= 57 || code_2 >= 65 && code_2 <= 70 || code_2 >= 97 && code_2 <= 102) {
        hexCharCodes.push(code_2);
      } else {
        break;
      }
    }
    if (i10 < str.length) {
      var code_3 = str.charCodeAt(i10);
      if (code_3 === 9 || code_3 === 32 || code_3 === 10) {
        i10 += 1;
      }
    }
    return [i10 - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];
  } else {
    return [index2 + 1, code];
  }
};
var consumeNumeric = function consumeNumeric2(str, index2) {
  var numberResult = consumeNumber(str, index2);
  if (numberResult === null) return null;
  var _a7 = __read(numberResult, 3), numberEndIndex = _a7[0], numberValue = _a7[1], numberFlag = _a7[2];
  var identResult = consumeIdent(str, numberEndIndex + 1);
  if (identResult !== null) {
    var _b3 = __read(identResult, 2), identEndIndex = _b3[0], identValue = _b3[1];
    return [identEndIndex, ["<dimension-token>", numberValue, identValue]];
  }
  if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 37) {
    return [numberEndIndex + 1, ["<percentage-token>", numberValue]];
  }
  return [numberEndIndex, ["<number-token>", numberValue, numberFlag]];
};
var consumeNumber = function consumeNumber2(str, index2) {
  if (str.length <= index2) return null;
  var flag = "integer";
  var numberChars = [];
  var firstCode = str.charCodeAt(index2);
  if (firstCode === 43 || firstCode === 45) {
    index2 += 1;
    if (firstCode === 45) numberChars.push(45);
  }
  while (index2 < str.length) {
    var code = str.charCodeAt(index2);
    if (code >= 48 && code <= 57) {
      numberChars.push(code);
      index2 += 1;
    } else {
      break;
    }
  }
  if (index2 + 1 < str.length) {
    var nextCode = str.charCodeAt(index2);
    var nextNextCode = str.charCodeAt(index2 + 1);
    if (nextCode === 46 && nextNextCode >= 48 && nextNextCode <= 57) {
      numberChars.push(nextCode, nextNextCode);
      flag = "number";
      index2 += 2;
      while (index2 < str.length) {
        var code = str.charCodeAt(index2);
        if (code >= 48 && code <= 57) {
          numberChars.push(code);
          index2 += 1;
        } else {
          break;
        }
      }
    }
  }
  if (index2 + 1 < str.length) {
    var nextCode = str.charCodeAt(index2);
    var nextNextCode = str.charCodeAt(index2 + 1);
    var nextNextNextCode = str.charCodeAt(index2 + 2);
    if (nextCode === 69 || nextCode === 101) {
      var nextNextIsDigit = nextNextCode >= 48 && nextNextCode <= 57;
      if (nextNextIsDigit || (nextNextCode === 43 || nextNextCode === 45) && nextNextNextCode >= 48 && nextNextNextCode <= 57) {
        flag = "number";
        if (nextNextIsDigit) {
          numberChars.push(69, nextNextCode);
          index2 += 2;
        } else if (nextNextCode === 45) {
          numberChars.push(69, 45, nextNextNextCode);
          index2 += 3;
        } else {
          numberChars.push(69, nextNextNextCode);
          index2 += 3;
        }
        while (index2 < str.length) {
          var code = str.charCodeAt(index2);
          if (code >= 48 && code <= 57) {
            numberChars.push(code);
            index2 += 1;
          } else {
            break;
          }
        }
      }
    }
  }
  var numberString = String.fromCharCode.apply(null, numberChars);
  var value2 = flag === "number" ? parseFloat(numberString) : parseInt(numberString);
  if (value2 === -0) value2 = 0;
  return Number.isNaN(value2) ? null : [index2 - 1, value2, flag];
};
var consumeIdentUnsafe = function consumeIdentUnsafe2(str, index2) {
  if (str.length <= index2) {
    return null;
  }
  var identChars = [];
  for (var code = str.charCodeAt(index2); index2 < str.length; code = str.charCodeAt(++index2)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index2);
      if (result !== null) {
        var _a7 = __read(result, 2), lastIndex = _a7[0], code_4 = _a7[1];
        identChars.push(code_4);
        index2 = lastIndex;
        continue;
      }
    }
    break;
  }
  return index2 === 0 ? null : [index2 - 1, String.fromCharCode.apply(null, identChars)];
};
var consumeIdent = function consumeIdent2(str, index2) {
  if (str.length <= index2 || !wouldStartIdentifier(str, index2)) {
    return null;
  }
  var identChars = [];
  for (var code = str.charCodeAt(index2); index2 < str.length; code = str.charCodeAt(++index2)) {
    if (code === 45 || code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 128 || code >= 48 && code <= 57) {
      identChars.push(code);
      continue;
    } else {
      var result = consumeEscape(str, index2);
      if (result !== null) {
        var _a7 = __read(result, 2), lastIndex = _a7[0], code_5 = _a7[1];
        identChars.push(code_5);
        index2 = lastIndex;
        continue;
      }
    }
    break;
  }
  return [index2 - 1, String.fromCharCode.apply(null, identChars)];
};
var consumeUrl = function consumeUrl2(str, index2) {
  var code = str.charCodeAt(index2);
  while (code === 9 || code === 32 || code === 10) {
    code = str.charCodeAt(++index2);
  }
  var urlChars = [];
  var hasFinishedWord = false;
  while (index2 < str.length) {
    if (code === 41) {
      return [index2, String.fromCharCode.apply(null, urlChars)];
    } else if (code === 34 || code === 39 || code === 40) {
      return null;
    } else if (code === 9 || code === 32 || code === 10) {
      if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;
    } else if (code === 92) {
      var result = consumeEscape(str, index2);
      if (result === null || hasFinishedWord) return null;
      var _a7 = __read(result, 2), lastIndex = _a7[0], value2 = _a7[1];
      urlChars.push(value2);
      index2 = lastIndex;
    } else {
      if (hasFinishedWord) return null;
      urlChars.push(code);
    }
    code = str.charCodeAt(++index2);
  }
  return null;
};
var consumeIdentLike = function consumeIdentLike2(str, index2) {
  var result = consumeIdent(str, index2);
  if (result === null) return null;
  var _a7 = __read(result, 2), lastIndex = _a7[0], value2 = _a7[1];
  if (value2.toLowerCase() === "url") {
    if (str.length > lastIndex + 1) {
      var nextCode = str.charCodeAt(lastIndex + 1);
      if (nextCode === 40) {
        for (var offset4 = 2; lastIndex + offset4 < str.length; offset4 += 1) {
          var nextNextCode = str.charCodeAt(lastIndex + offset4);
          if (nextNextCode === 34 || nextNextCode === 39) {
            return [lastIndex + 1, value2.toLowerCase(), "<function-token>"];
          } else if (nextNextCode !== 9 && nextNextCode !== 32 && nextNextCode !== 10) {
            var result_1 = consumeUrl(str, lastIndex + offset4);
            if (result_1 === null) return null;
            var _b3 = __read(result_1, 2), lastUrlIndex = _b3[0], value_1 = _b3[1];
            return [lastUrlIndex, value_1, "<url-token>"];
          }
        }
        return [lastIndex + 1, value2.toLowerCase(), "<function-token>"];
      }
    }
  } else if (str.length > lastIndex + 1) {
    var nextCode = str.charCodeAt(lastIndex + 1);
    if (nextCode === 40) {
      return [lastIndex + 1, value2.toLowerCase(), "<function-token>"];
    }
  }
  return [lastIndex, value2.toLowerCase(), "<ident-token>"];
};
var simplifyAST = function simplifyAST2(ast) {
  for (var i10 = ast.length - 1; i10 >= 0; i10--) {
    ast[i10] = simplifyMediaQuery(ast[i10]);
  }
  return ast;
};
var simplifyMediaQuery = function simplifyMediaQuery2(mediaQuery) {
  if (mediaQuery.mediaCondition === null) return mediaQuery;
  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);
  if (mediaCondition.operator === null && mediaCondition.children.length === 1 && "children" in mediaCondition.children[0]) {
    mediaCondition = mediaCondition.children[0];
  }
  return {
    mediaPrefix: mediaQuery.mediaPrefix,
    mediaType: mediaQuery.mediaType,
    mediaCondition
  };
};
var simplifyMediaCondition = function simplifyMediaCondition2(mediaCondition) {
  for (var i10 = mediaCondition.children.length - 1; i10 >= 0; i10--) {
    var unsimplifiedChild = mediaCondition.children[i10];
    if (!("context" in unsimplifiedChild)) {
      var child = simplifyMediaCondition2(unsimplifiedChild);
      if (child.operator === null && child.children.length === 1) {
        mediaCondition.children[i10] = child.children[0];
      } else if (child.operator === mediaCondition.operator && (child.operator === "and" || child.operator === "or")) {
        var spliceArgs = [i10, 1];
        for (var i_1 = 0; i_1 < child.children.length; i_1++) {
          spliceArgs.push(child.children[i_1]);
        }
        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);
      }
    }
  }
  return mediaCondition;
};
var createError = function createError2(message, err) {
  if (err instanceof Error) {
    return new Error("".concat(err.message.trim(), "\n").concat(message.trim()));
  } else {
    return new Error(message.trim());
  }
};
var toAST = function toAST2(str) {
  return simplifyAST(toUnflattenedAST(str));
};
var toUnflattenedAST = function toUnflattenedAST2(str) {
  var tokenList = lexicalAnalysis(str.trim());
  if (tokenList === null) {
    throw createError("Failed tokenizing");
  }
  var startIndex = 0;
  var endIndex = tokenList.length - 1;
  if (tokenList[0].type === "<at-keyword-token>" && tokenList[0].value === "media") {
    if (tokenList[1].type !== "<whitespace-token>") {
      throw createError("Expected whitespace after media");
    }
    startIndex = 2;
    for (var i10 = 2; i10 < tokenList.length - 1; i10++) {
      var token = tokenList[i10];
      if (token.type === "<{-token>") {
        endIndex = i10;
        break;
      } else if (token.type === "<semicolon-token>") {
        throw createError("Expected '{' in media query but found ';'");
      }
    }
  }
  tokenList = tokenList.slice(startIndex, endIndex);
  return syntacticAnalysis(tokenList);
};
var removeWhitespace = function removeWhitespace2(tokenList) {
  var newTokenList = [];
  var before = false;
  for (var i10 = 0; i10 < tokenList.length; i10++) {
    if (tokenList[i10].type === "<whitespace-token>") {
      before = true;
      if (newTokenList.length > 0) {
        newTokenList[newTokenList.length - 1].wsAfter = true;
      }
    } else {
      newTokenList.push(__assign2(__assign2({}, tokenList[i10]), {
        wsBefore: before,
        wsAfter: false
      }));
      before = false;
    }
  }
  return newTokenList;
};
var syntacticAnalysis = function syntacticAnalysis2(tokenList) {
  var e_1, _a7;
  var mediaQueryList = [[]];
  for (var i10 = 0; i10 < tokenList.length; i10++) {
    var token = tokenList[i10];
    if (token.type === "<comma-token>") {
      mediaQueryList.push([]);
    } else {
      mediaQueryList[mediaQueryList.length - 1].push(token);
    }
  }
  var mediaQueries = mediaQueryList.map(removeWhitespace);
  if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {
    return [{
      mediaCondition: null,
      mediaPrefix: null,
      mediaType: "all"
    }];
  } else {
    var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens2) {
      if (mediaQueryTokens2.length === 0) {
        return null;
      } else {
        return tokenizeMediaQuery(mediaQueryTokens2);
      }
    });
    var nonNullMediaQueryTokens = [];
    try {
      for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {
        var mediaQueryToken = mediaQueryTokens_1_1.value;
        if (mediaQueryToken !== null) {
          nonNullMediaQueryTokens.push(mediaQueryToken);
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a7 = mediaQueryTokens_1["return"])) _a7.call(mediaQueryTokens_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (nonNullMediaQueryTokens.length === 0) {
      throw createError("No valid media queries");
    }
    return nonNullMediaQueryTokens;
  }
};
var tokenizeMediaQuery = function tokenizeMediaQuery2(tokens) {
  var firstToken = tokens[0];
  if (firstToken.type === "<(-token>") {
    try {
      return {
        mediaPrefix: null,
        mediaType: "all",
        mediaCondition: tokenizeMediaCondition(tokens, true)
      };
    } catch (err) {
      throw createError("Expected media condition after '('", err);
    }
  } else if (firstToken.type === "<ident-token>") {
    var mediaPrefix = null;
    var mediaType = void 0;
    var value2 = firstToken.value;
    if (value2 === "only" || value2 === "not") {
      mediaPrefix = value2;
    }
    var firstIndex = mediaPrefix === null ? 0 : 1;
    if (tokens.length <= firstIndex) {
      throw createError("Expected extra token in media query");
    }
    var firstNonUnaryToken = tokens[firstIndex];
    if (firstNonUnaryToken.type === "<ident-token>") {
      var value_1 = firstNonUnaryToken.value;
      if (value_1 === "all") {
        mediaType = "all";
      } else if (value_1 === "print" || value_1 === "screen") {
        mediaType = value_1;
      } else if (value_1 === "tty" || value_1 === "tv" || value_1 === "projection" || value_1 === "handheld" || value_1 === "braille" || value_1 === "embossed" || value_1 === "aural" || value_1 === "speech") {
        mediaPrefix = mediaPrefix === "not" ? null : "not";
        mediaType = "all";
      } else {
        throw createError("Unknown ident '".concat(value_1, "' in media query"));
      }
    } else if (mediaPrefix === "not" && firstNonUnaryToken.type === "<(-token>") {
      var tokensWithParens = [{
        type: "<(-token>",
        wsBefore: false,
        wsAfter: false
      }];
      tokensWithParens.push.apply(tokensWithParens, tokens);
      tokensWithParens.push({
        type: "<)-token>",
        wsBefore: false,
        wsAfter: false
      });
      try {
        return {
          mediaPrefix: null,
          mediaType: "all",
          mediaCondition: tokenizeMediaCondition(tokensWithParens, true)
        };
      } catch (err) {
        throw createError("Expected media condition after '('", err);
      }
    } else {
      throw createError("Invalid media query");
    }
    if (firstIndex + 1 === tokens.length) {
      return {
        mediaPrefix,
        mediaType,
        mediaCondition: null
      };
    } else if (firstIndex + 4 < tokens.length) {
      var secondNonUnaryToken = tokens[firstIndex + 1];
      if (secondNonUnaryToken.type === "<ident-token>" && secondNonUnaryToken.value === "and") {
        try {
          return {
            mediaPrefix,
            mediaType,
            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)
          };
        } catch (err) {
          throw createError("Expected media condition after 'and'", err);
        }
      } else {
        throw createError("Expected 'and' after media prefix");
      }
    } else {
      throw createError("Expected media condition after media prefix");
    }
  } else {
    throw createError("Expected media condition or media prefix");
  }
};
var tokenizeMediaCondition = function tokenizeMediaCondition2(tokens, mayContainOr, previousOperator) {
  if (previousOperator === void 0) {
    previousOperator = null;
  }
  if (tokens.length < 3 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>") {
    throw new Error("Invalid media condition");
  }
  var endIndexOfFirstFeature = tokens.length - 1;
  var maxDepth = 0;
  var count3 = 0;
  for (var i10 = 0; i10 < tokens.length; i10++) {
    var token = tokens[i10];
    if (token.type === "<(-token>") {
      count3 += 1;
      maxDepth = Math.max(maxDepth, count3);
    } else if (token.type === "<)-token>") {
      count3 -= 1;
    }
    if (count3 === 0) {
      endIndexOfFirstFeature = i10;
      break;
    }
  }
  if (count3 !== 0) {
    throw new Error("Mismatched parens\nInvalid media condition");
  }
  var child;
  var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);
  if (maxDepth === 1) {
    child = tokenizeMediaFeature(featureTokens);
  } else {
    if (featureTokens[1].type === "<ident-token>" && featureTokens[1].value === "not") {
      child = tokenizeMediaCondition2(featureTokens.slice(2, -1), true, "not");
    } else {
      child = tokenizeMediaCondition2(featureTokens.slice(1, -1), true);
    }
  }
  if (endIndexOfFirstFeature === tokens.length - 1) {
    return {
      operator: previousOperator,
      children: [child]
    };
  } else {
    var nextToken = tokens[endIndexOfFirstFeature + 1];
    if (nextToken.type !== "<ident-token>") {
      throw new Error("Invalid operator\nInvalid media condition");
    } else if (previousOperator !== null && previousOperator !== nextToken.value) {
      throw new Error("'".concat(nextToken.value, "' and '").concat(previousOperator, "' must not be at same level\nInvalid media condition"));
    } else if (nextToken.value === "or" && !mayContainOr) {
      throw new Error("Cannot use 'or' at top level of a media query\nInvalid media condition");
    } else if (nextToken.value !== "and" && nextToken.value !== "or") {
      throw new Error("Invalid operator: '".concat(nextToken.value, "'\nInvalid media condition"));
    }
    var siblings = tokenizeMediaCondition2(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);
    return {
      operator: nextToken.value,
      children: [child].concat(siblings.children)
    };
  }
};
var tokenizeMediaFeature = function tokenizeMediaFeature2(rawTokens) {
  if (rawTokens.length < 3 || rawTokens[0].type !== "<(-token>" || rawTokens[rawTokens.length - 1].type !== "<)-token>") {
    throw new Error("Invalid media feature");
  }
  var tokens = [rawTokens[0]];
  for (var i10 = 1; i10 < rawTokens.length; i10++) {
    if (i10 < rawTokens.length - 2) {
      var a10 = rawTokens[i10];
      var b = rawTokens[i10 + 1];
      var c = rawTokens[i10 + 2];
      if (a10.type === "<number-token>" && a10.value > 0 && b.type === "<delim-token>" && b.value === 47 && c.type === "<number-token>" && c.value > 0) {
        tokens.push({
          type: "<ratio-token>",
          numerator: a10.value,
          denominator: c.value,
          wsBefore: a10.wsBefore,
          wsAfter: c.wsAfter
        });
        i10 += 2;
        continue;
      }
    }
    tokens.push(rawTokens[i10]);
  }
  var nextToken = tokens[1];
  if (nextToken.type === "<ident-token>" && tokens.length === 3) {
    return {
      context: "boolean",
      feature: nextToken.value
    };
  } else if (tokens.length === 5 && tokens[1].type === "<ident-token>" && tokens[2].type === "<colon-token>") {
    var valueToken = tokens[3];
    if (valueToken.type === "<number-token>" || valueToken.type === "<dimension-token>" || valueToken.type === "<ratio-token>" || valueToken.type === "<ident-token>") {
      var feature = tokens[1].value;
      var prefix = null;
      var slice = feature.slice(0, 4);
      if (slice === "min-") {
        prefix = "min";
        feature = feature.slice(4);
      } else if (slice === "max-") {
        prefix = "max";
        feature = feature.slice(4);
      }
      valueToken.wsBefore;
      valueToken.wsAfter;
      var value2 = __rest2(valueToken, ["wsBefore", "wsAfter"]);
      return {
        context: "value",
        prefix,
        feature,
        value: value2
      };
    }
  } else if (tokens.length >= 5) {
    try {
      var range = tokenizeRange(tokens);
      return {
        context: "range",
        feature: range.featureName,
        range
      };
    } catch (err) {
      throw createError("Invalid media feature", err);
    }
  }
  throw new Error("Invalid media feature");
};
var tokenizeRange = function tokenizeRange2(tokens) {
  var _a7, _b3, _c2, _d2;
  if (tokens.length < 5 || tokens[0].type !== "<(-token>" || tokens[tokens.length - 1].type !== "<)-token>") {
    throw new Error("Invalid range");
  }
  var range = {
    leftToken: null,
    leftOp: null,
    featureName: "",
    rightOp: null,
    rightToken: null
  };
  var hasLeft = tokens[1].type === "<number-token>" || tokens[1].type === "<dimension-token>" || tokens[1].type === "<ratio-token>" || tokens[1].type === "<ident-token>" && tokens[1].value === "infinite";
  if (tokens[2].type === "<delim-token>") {
    if (tokens[2].value === 60) {
      if (tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore) {
        range[hasLeft ? "leftOp" : "rightOp"] = "<=";
      } else {
        range[hasLeft ? "leftOp" : "rightOp"] = "<";
      }
    } else if (tokens[2].value === 62) {
      if (tokens[3].type === "<delim-token>" && tokens[3].value === 61 && !tokens[3].wsBefore) {
        range[hasLeft ? "leftOp" : "rightOp"] = ">=";
      } else {
        range[hasLeft ? "leftOp" : "rightOp"] = ">";
      }
    } else if (tokens[2].value === 61) {
      range[hasLeft ? "leftOp" : "rightOp"] = "=";
    } else {
      throw new Error("Invalid range");
    }
    if (hasLeft) {
      range.leftToken = tokens[1];
    } else if (tokens[1].type === "<ident-token>") {
      range.featureName = tokens[1].value;
    } else {
      throw new Error("Invalid range");
    }
    var tokenIndexAfterFirstOp = 2 + ((_b3 = (_a7 = range[hasLeft ? "leftOp" : "rightOp"]) === null || _a7 === void 0 ? void 0 : _a7.length) !== null && _b3 !== void 0 ? _b3 : 0);
    var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];
    if (hasLeft) {
      if (tokenAfterFirstOp.type === "<ident-token>") {
        range.featureName = tokenAfterFirstOp.value;
        if (tokens.length >= 7) {
          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];
          var followingToken = tokens[tokenIndexAfterFirstOp + 2];
          if (secondOpToken.type === "<delim-token>") {
            var charCode = secondOpToken.value;
            if (charCode === 60) {
              if (followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore) {
                range.rightOp = "<=";
              } else {
                range.rightOp = "<";
              }
            } else if (charCode === 62) {
              if (followingToken.type === "<delim-token>" && followingToken.value === 61 && !followingToken.wsBefore) {
                range.rightOp = ">=";
              } else {
                range.rightOp = ">";
              }
            } else {
              throw new Error("Invalid range");
            }
            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d2 = (_c2 = range.rightOp) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0)];
            range.rightToken = tokenAfterSecondOp;
          } else {
            throw new Error("Invalid range");
          }
        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {
          throw new Error("Invalid range");
        }
      } else {
        throw new Error("Invalid range");
      }
    } else {
      range.rightToken = tokenAfterFirstOp;
    }
    var validRange = null;
    var lt = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt = range.rightToken;
    var leftToken = null;
    if (lt !== null) {
      if (lt.type === "<ident-token>") {
        var type2 = lt.type, value2 = lt.value;
        if (value2 === "infinite") {
          leftToken = {
            type: type2,
            value: value2
          };
        }
      } else if (lt.type === "<number-token>" || lt.type === "<dimension-token>" || lt.type === "<ratio-token>") {
        lt.wsBefore;
        lt.wsAfter;
        var ltNoWS = __rest2(lt, ["wsBefore", "wsAfter"]);
        leftToken = ltNoWS;
      }
    }
    var rightToken = null;
    if (rt !== null) {
      if (rt.type === "<ident-token>") {
        var type2 = rt.type, value2 = rt.value;
        if (value2 === "infinite") {
          rightToken = {
            type: type2,
            value: value2
          };
        }
      } else if (rt.type === "<number-token>" || rt.type === "<dimension-token>" || rt.type === "<ratio-token>") {
        rt.wsBefore;
        rt.wsAfter;
        var rtNoWS = __rest2(rt, ["wsBefore", "wsAfter"]);
        rightToken = rtNoWS;
      }
    }
    if (leftToken !== null && rightToken !== null) {
      if ((leftOp === "<" || leftOp === "<=") && (rightOp === "<" || rightOp === "<=")) {
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      } else if ((leftOp === ">" || leftOp === ">=") && (rightOp === ">" || rightOp === ">=")) {
        validRange = {
          leftToken,
          leftOp,
          featureName,
          rightOp,
          rightToken
        };
      } else {
        throw new Error("Invalid range");
      }
    } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {
      validRange = {
        leftToken,
        leftOp,
        featureName,
        rightOp,
        rightToken
      };
    } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {
      validRange = {
        leftToken,
        leftOp,
        featureName,
        rightOp,
        rightToken
      };
    }
    return validRange;
  } else {
    throw new Error("Invalid range");
  }
};

// ../node_modules/@vanilla-extract/css/dist/transformCss-830a230d.browser.esm.js
function toPrimitive2(t10, r10) {
  if ("object" != typeof t10 || !t10) return t10;
  var e10 = t10[Symbol.toPrimitive];
  if (void 0 !== e10) {
    var i10 = e10.call(t10, r10 || "default");
    if ("object" != typeof i10) return i10;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r10 ? String : Number)(t10);
}
function toPropertyKey2(t10) {
  var i10 = toPrimitive2(t10, "string");
  return "symbol" == typeof i10 ? i10 : String(i10);
}
function _defineProperty3(obj, key, value2) {
  key = toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function ownKeys3(e10, r10) {
  var t10 = Object.keys(e10);
  if (Object.getOwnPropertySymbols) {
    var o10 = Object.getOwnPropertySymbols(e10);
    r10 && (o10 = o10.filter(function(r11) {
      return Object.getOwnPropertyDescriptor(e10, r11).enumerable;
    })), t10.push.apply(t10, o10);
  }
  return t10;
}
function _objectSpread22(e10) {
  for (var r10 = 1; r10 < arguments.length; r10++) {
    var t10 = null != arguments[r10] ? arguments[r10] : {};
    r10 % 2 ? ownKeys3(Object(t10), true).forEach(function(r11) {
      _defineProperty3(e10, r11, t10[r11]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(t10)) : ownKeys3(Object(t10)).forEach(function(r11) {
      Object.defineProperty(e10, r11, Object.getOwnPropertyDescriptor(t10, r11));
    });
  }
  return e10;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i10;
  for (i10 = 0; i10 < sourceKeys.length; i10++) {
    key = sourceKeys[i10];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i10;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i10 = 0; i10 < sourceSymbolKeys.length; i10++) {
      key = sourceSymbolKeys[i10];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function forEach(obj, fn2) {
  for (var _key in obj) {
    fn2(obj[_key], _key);
  }
}
function omit(obj, omitKeys) {
  var result = {};
  for (var _key2 in obj) {
    if (omitKeys.indexOf(_key2) === -1) {
      result[_key2] = obj[_key2];
    }
  }
  return result;
}
function mapKeys(obj, fn2) {
  var result = {};
  for (var _key3 in obj) {
    result[fn2(obj[_key3], _key3)] = obj[_key3];
  }
  return result;
}
var _templateObject$1;
function escapeRegex(string2) {
  return string2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var validateSelector = (selector, targetClassName) => {
  var replaceTarget = () => {
    var targetRegex = new RegExp(".".concat(escapeRegex((0, import_cssesc.default)(targetClassName, {
      isIdentifier: true
    }))), "g");
    return selector.replace(targetRegex, "&");
  };
  var selectorParts;
  try {
    selectorParts = parse5(selector);
  } catch (err) {
    throw new Error("Invalid selector: ".concat(replaceTarget()));
  }
  selectorParts.forEach((tokens) => {
    try {
      for (var i10 = tokens.length - 1; i10 >= -1; i10--) {
        if (!tokens[i10]) {
          throw new Error();
        }
        var token = tokens[i10];
        if (token.type === "child" || token.type === "parent" || token.type === "sibling" || token.type === "adjacent" || token.type === "descendant") {
          throw new Error();
        }
        if (token.type === "attribute" && token.name === "class" && token.value === targetClassName) {
          return;
        }
      }
    } catch (err) {
      throw new Error(dedent_default(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n        Invalid selector: ", "\n    \n        Style selectors must target the '&' character (along with any modifiers), e.g. ", " or ", ".\n        \n        This is to ensure that each style block only affects the styling of a single class.\n        \n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of ", ") to 'parent', you should add ", " to 'child').\n        \n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write ", ", you should instead write 'globalStyle(", ", { ... })'\n      "])), replaceTarget(), "`${parent} &`", "`${parent} &:hover`", "`& ${child}`", "`${parent} &`", "`& h1`", "`${parent} h1`"));
    }
  });
};
var ConditionalRuleset = class _ConditionalRuleset {
  /**
   * Stores information about where conditions must be in relation to other conditions
   *
   * e.g. mobile -> tablet, desktop
   */
  constructor() {
    this.ruleset = /* @__PURE__ */ new Map();
    this.precedenceLookup = /* @__PURE__ */ new Map();
  }
  findOrCreateCondition(conditionQuery) {
    var targetCondition = this.ruleset.get(conditionQuery);
    if (!targetCondition) {
      targetCondition = {
        query: conditionQuery,
        rules: [],
        children: new _ConditionalRuleset()
      };
      this.ruleset.set(conditionQuery, targetCondition);
    }
    return targetCondition;
  }
  getConditionalRulesetByPath(conditionPath) {
    var currRuleset = this;
    for (var query of conditionPath) {
      var condition = currRuleset.findOrCreateCondition(query);
      currRuleset = condition.children;
    }
    return currRuleset;
  }
  addRule(rule, conditionQuery, conditionPath) {
    var ruleset = this.getConditionalRulesetByPath(conditionPath);
    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);
    if (!targetCondition) {
      throw new Error("Failed to add conditional rule");
    }
    targetCondition.rules.push(rule);
  }
  addConditionPrecedence(conditionPath, conditionOrder) {
    var ruleset = this.getConditionalRulesetByPath(conditionPath);
    for (var i10 = 0; i10 < conditionOrder.length; i10++) {
      var _ruleset$precedenceLo;
      var query = conditionOrder[i10];
      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : /* @__PURE__ */ new Set();
      for (var lowerPrecedenceCondition of conditionOrder.slice(i10 + 1)) {
        conditionPrecedence.add(lowerPrecedenceCondition);
      }
      ruleset.precedenceLookup.set(query, conditionPrecedence);
    }
  }
  isCompatible(incomingRuleset) {
    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {
      for (var lowerPrecedenceCondition of orderPrecedence) {
        var _incomingRuleset$prec;
        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {
          return false;
        }
      }
    }
    for (var {
      query,
      children
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {
        return false;
      }
    }
    return true;
  }
  merge(incomingRuleset) {
    for (var {
      query,
      rules,
      children
    } of incomingRuleset.ruleset.values()) {
      var matchingCondition = this.ruleset.get(query);
      if (matchingCondition) {
        matchingCondition.rules.push(...rules);
        matchingCondition.children.merge(children);
      } else {
        this.ruleset.set(query, {
          query,
          rules,
          children
        });
      }
    }
    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {
      var _this$precedenceLooku;
      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : /* @__PURE__ */ new Set();
      this.precedenceLookup.set(condition, /* @__PURE__ */ new Set([...orderPrecedence, ...incomingOrderPrecedence]));
    }
  }
  /**
   * Merge another ConditionalRuleset into this one if they are compatible
   *
   * @returns true if successful, false if the ruleset is incompatible
   */
  mergeIfCompatible(incomingRuleset) {
    if (!this.isCompatible(incomingRuleset)) {
      return false;
    }
    this.merge(incomingRuleset);
    return true;
  }
  getSortedRuleset() {
    var _this = this;
    var sortedRuleset = [];
    var _loop = function _loop2(dependents2) {
      var conditionForQuery = _this.ruleset.get(query);
      if (!conditionForQuery) {
        throw new Error("Can't find condition for ".concat(query));
      }
      var firstMatchingDependent = sortedRuleset.findIndex((condition) => dependents2.has(condition.query));
      if (firstMatchingDependent > -1) {
        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);
      } else {
        sortedRuleset.push(conditionForQuery);
      }
    };
    for (var [query, dependents] of this.precedenceLookup.entries()) {
      _loop(dependents);
    }
    return sortedRuleset;
  }
  renderToArray() {
    var arr = [];
    for (var {
      query,
      rules,
      children
    } of this.getSortedRuleset()) {
      var selectors = {};
      for (var rule of rules) {
        selectors[rule.selector] = _objectSpread22(_objectSpread22({}, selectors[rule.selector]), rule.rule);
      }
      Object.assign(selectors, ...children.renderToArray());
      arr.push({
        [query]: selectors
      });
    }
    return arr;
  }
};
var simplePseudoMap = {
  ":-moz-any-link": true,
  ":-moz-full-screen": true,
  ":-moz-placeholder": true,
  ":-moz-read-only": true,
  ":-moz-read-write": true,
  ":-ms-fullscreen": true,
  ":-ms-input-placeholder": true,
  ":-webkit-any-link": true,
  ":-webkit-full-screen": true,
  "::-moz-color-swatch": true,
  "::-moz-list-bullet": true,
  "::-moz-list-number": true,
  "::-moz-page-sequence": true,
  "::-moz-page": true,
  "::-moz-placeholder": true,
  "::-moz-progress-bar": true,
  "::-moz-range-progress": true,
  "::-moz-range-thumb": true,
  "::-moz-range-track": true,
  "::-moz-scrolled-page-sequence": true,
  "::-moz-selection": true,
  "::-ms-backdrop": true,
  "::-ms-browse": true,
  "::-ms-check": true,
  "::-ms-clear": true,
  "::-ms-fill-lower": true,
  "::-ms-fill-upper": true,
  "::-ms-fill": true,
  "::-ms-reveal": true,
  "::-ms-thumb": true,
  "::-ms-ticks-after": true,
  "::-ms-ticks-before": true,
  "::-ms-tooltip": true,
  "::-ms-track": true,
  "::-ms-value": true,
  "::-webkit-backdrop": true,
  "::-webkit-calendar-picker-indicator": true,
  "::-webkit-inner-spin-button": true,
  "::-webkit-input-placeholder": true,
  "::-webkit-meter-bar": true,
  "::-webkit-meter-even-less-good-value": true,
  "::-webkit-meter-inner-element": true,
  "::-webkit-meter-optimum-value": true,
  "::-webkit-meter-suboptimum-value": true,
  "::-webkit-outer-spin-button": true,
  "::-webkit-progress-bar": true,
  "::-webkit-progress-inner-element": true,
  "::-webkit-progress-inner-value": true,
  "::-webkit-progress-value": true,
  "::-webkit-resizer": true,
  "::-webkit-scrollbar-button": true,
  "::-webkit-scrollbar-corner": true,
  "::-webkit-scrollbar-thumb": true,
  "::-webkit-scrollbar-track-piece": true,
  "::-webkit-scrollbar-track": true,
  "::-webkit-scrollbar": true,
  "::-webkit-search-cancel-button": true,
  "::-webkit-search-results-button": true,
  "::-webkit-slider-runnable-track": true,
  "::-webkit-slider-thumb": true,
  "::after": true,
  "::backdrop": true,
  "::before": true,
  "::cue": true,
  "::file-selector-button": true,
  "::first-letter": true,
  "::first-line": true,
  "::grammar-error": true,
  "::marker": true,
  "::placeholder": true,
  "::selection": true,
  "::spelling-error": true,
  "::target-text": true,
  "::view-transition-group": true,
  "::view-transition-image-pair": true,
  "::view-transition-new": true,
  "::view-transition-old": true,
  "::view-transition": true,
  ":active": true,
  ":after": true,
  ":any-link": true,
  ":before": true,
  ":blank": true,
  ":checked": true,
  ":default": true,
  ":defined": true,
  ":disabled": true,
  ":empty": true,
  ":enabled": true,
  ":first-child": true,
  ":first-letter": true,
  ":first-line": true,
  ":first-of-type": true,
  ":first": true,
  ":focus-visible": true,
  ":focus-within": true,
  ":focus": true,
  ":fullscreen": true,
  ":hover": true,
  ":in-range": true,
  ":indeterminate": true,
  ":invalid": true,
  ":last-child": true,
  ":last-of-type": true,
  ":left": true,
  ":link": true,
  ":only-child": true,
  ":only-of-type": true,
  ":optional": true,
  ":out-of-range": true,
  ":placeholder-shown": true,
  ":read-only": true,
  ":read-write": true,
  ":required": true,
  ":right": true,
  ":root": true,
  ":scope": true,
  ":target": true,
  ":valid": true,
  ":visited": true
};
var simplePseudos = Object.keys(simplePseudoMap);
var simplePseudoLookup = simplePseudoMap;
var _templateObject;
var createMediaQueryError = (mediaQuery, msg) => new Error(dedent_default(_templateObject || (_templateObject = _taggedTemplateLiteral(['\n    Invalid media query: "', '"\n\n    ', "\n\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\n  "])), mediaQuery, msg));
var validateMediaQuery = (mediaQuery) => {
  if (mediaQuery === "@media ") {
    throw createMediaQueryError(mediaQuery, "Query is empty");
  }
  try {
    toAST(mediaQuery);
  } catch (e10) {
    throw createMediaQueryError(mediaQuery, e10.message);
  }
};
var _excluded = ["vars"];
var _excluded2 = ["content"];
var DECLARATION = "__DECLARATION";
var UNITLESS = {
  animationIterationCount: true,
  borderImage: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  gridArea: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  initialLetter: true,
  lineClamp: true,
  lineHeight: true,
  maxLines: true,
  opacity: true,
  order: true,
  orphans: true,
  scale: true,
  tabSize: true,
  WebkitLineClamp: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // svg properties
  fillOpacity: true,
  floodOpacity: true,
  maskBorder: true,
  maskBorderOutset: true,
  maskBorderSlice: true,
  maskBorderWidth: true,
  shapeImageThreshold: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
function dashify(str) {
  return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function replaceBetweenIndexes(target, startIndex, endIndex, replacement) {
  var start = target.slice(0, startIndex);
  var end = target.slice(endIndex);
  return "".concat(start).concat(replacement).concat(end);
}
var DOUBLE_SPACE = "  ";
var specialKeys = [...simplePseudos, "@layer", "@media", "@supports", "@container", "selectors"];
var Stylesheet = class {
  constructor(localClassNames2, composedClassLists2) {
    this.rules = [];
    this.conditionalRulesets = [new ConditionalRuleset()];
    this.fontFaceRules = [];
    this.keyframesRules = [];
    this.propertyRules = [];
    this.localClassNamesMap = new Map(localClassNames2.map((localClassName) => [localClassName, localClassName]));
    this.localClassNamesSearch = new AhoCorasick(localClassNames2);
    this.layers = /* @__PURE__ */ new Map();
    this.composedClassLists = composedClassLists2.map((_ref) => {
      var {
        identifier,
        classList
      } = _ref;
      return {
        identifier,
        regex: RegExp("(".concat(classList, ")"), "g")
      };
    }).reverse();
  }
  processCssObj(root) {
    if (root.type === "fontFace") {
      this.fontFaceRules.push(root.rule);
      return;
    }
    if (root.type === "property") {
      this.propertyRules.push(root);
      return;
    }
    if (root.type === "keyframes") {
      root.rule = Object.fromEntries(Object.entries(root.rule).map((_ref2) => {
        var [keyframe, rule] = _ref2;
        return [keyframe, this.transformVars(this.transformProperties(rule))];
      }));
      this.keyframesRules.push(root);
      return;
    }
    this.currConditionalRuleset = new ConditionalRuleset();
    if (root.type === "layer") {
      var layerDefinition = "@layer ".concat(root.name);
      this.addLayer([layerDefinition]);
    } else {
      var mainRule = omit(root.rule, specialKeys);
      this.addRule({
        selector: root.selector,
        rule: mainRule
      });
      this.transformLayer(root, root.rule["@layer"]);
      this.transformMedia(root, root.rule["@media"]);
      this.transformSupports(root, root.rule["@supports"]);
      this.transformContainer(root, root.rule["@container"]);
      this.transformSimplePseudos(root, root.rule);
      this.transformSelectors(root, root.rule);
    }
    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];
    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {
      this.conditionalRulesets.push(this.currConditionalRuleset);
    }
  }
  addConditionalRule(cssRule, conditions) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule));
    var selector = this.transformSelector(cssRule.selector);
    if (!this.currConditionalRuleset) {
      throw new Error("Couldn't add conditional rule");
    }
    var conditionQuery = conditions[conditions.length - 1];
    var parentConditions = conditions.slice(0, conditions.length - 1);
    this.currConditionalRuleset.addRule({
      selector,
      rule
    }, conditionQuery, parentConditions);
  }
  addRule(cssRule) {
    var rule = this.transformVars(this.transformProperties(cssRule.rule));
    var selector = this.transformSelector(cssRule.selector);
    this.rules.push({
      selector,
      rule
    });
  }
  addLayer(layer) {
    var uniqueLayerKey = layer.join(" - ");
    this.layers.set(uniqueLayerKey, layer);
  }
  transformProperties(cssRule) {
    return this.transformContent(this.pixelifyProperties(cssRule));
  }
  pixelifyProperties(cssRule) {
    forEach(cssRule, (value2, key) => {
      if (typeof value2 === "number" && value2 !== 0 && !UNITLESS[key]) {
        cssRule[key] = "".concat(value2, "px");
      }
    });
    return cssRule;
  }
  transformVars(_ref3) {
    var {
      vars
    } = _ref3, rest = _objectWithoutProperties(_ref3, _excluded);
    if (!vars) {
      return rest;
    }
    return _objectSpread22(_objectSpread22({}, mapKeys(vars, (_value, key) => getVarName(key))), rest);
  }
  transformContent(_ref4) {
    var {
      content: content4
    } = _ref4, rest = _objectWithoutProperties(_ref4, _excluded2);
    if (typeof content4 === "undefined") {
      return rest;
    }
    var contentArray = Array.isArray(content4) ? content4 : [content4];
    return _objectSpread22({
      content: contentArray.map((value2) => (
        // This logic was adapted from Stitches :)
        value2 && (value2.includes('"') || value2.includes("'") || /^([A-Za-z\-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(value2)) ? value2 : '"'.concat(value2, '"')
      ))
    }, rest);
  }
  transformClassname(identifier) {
    return ".".concat((0, import_cssesc.default)(identifier, {
      isIdentifier: true
    }));
  }
  transformSelector(selector) {
    var transformedSelector = selector;
    var _loop = function _loop2(identifier2) {
      transformedSelector = transformedSelector.replace(regex, () => {
        markCompositionUsed(identifier2);
        return identifier2;
      });
    };
    for (var {
      identifier,
      regex
    } of this.composedClassLists) {
      _loop(identifier);
    }
    if (this.localClassNamesMap.has(transformedSelector)) {
      return this.transformClassname(transformedSelector);
    }
    var results = this.localClassNamesSearch.search(transformedSelector);
    var lastReplaceIndex = transformedSelector.length;
    for (var i10 = results.length - 1; i10 >= 0; i10--) {
      var [endIndex, [firstMatch]] = results[i10];
      var startIndex = endIndex - firstMatch.length + 1;
      var skipReplacement = lastReplaceIndex <= endIndex;
      if (skipReplacement) {
        continue;
      }
      lastReplaceIndex = startIndex;
      if (transformedSelector[startIndex - 1] !== ".") {
        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));
      }
    }
    return transformedSelector;
  }
  transformSelectors(root, rule, conditions) {
    forEach(rule.selectors, (selectorRule, selector) => {
      if (root.type !== "local") {
        throw new Error("Selectors are not allowed within ".concat(root.type === "global" ? '"globalStyle"' : '"selectors"'));
      }
      var transformedSelector = this.transformSelector(selector.replace(RegExp("&", "g"), root.selector));
      validateSelector(transformedSelector, root.selector);
      var rule2 = {
        selector: transformedSelector,
        rule: omit(selectorRule, specialKeys)
      };
      if (conditions) {
        this.addConditionalRule(rule2, conditions);
      } else {
        this.addRule(rule2);
      }
      var selectorRoot = {
        type: "selector",
        selector: transformedSelector,
        rule: selectorRule
      };
      this.transformLayer(selectorRoot, selectorRule["@layer"], conditions);
      this.transformSupports(selectorRoot, selectorRule["@supports"], conditions);
      this.transformMedia(selectorRoot, selectorRule["@media"], conditions);
      this.transformContainer(selectorRoot, selectorRule["@container"], conditions);
    });
  }
  transformMedia(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional;
      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map((query2) => "@media ".concat(query2)));
      for (var [query, mediaRule] of Object.entries(rules)) {
        var mediaQuery = "@media ".concat(query);
        validateMediaQuery(mediaQuery);
        var conditions = [...parentConditions, mediaQuery];
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(mediaRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, mediaRule, conditions);
          this.transformSelectors(root, mediaRule, conditions);
        }
        this.transformLayer(root, mediaRule["@layer"], conditions);
        this.transformSupports(root, mediaRule["@supports"], conditions);
        this.transformContainer(root, mediaRule["@container"], conditions);
      }
    }
  }
  transformContainer(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional2;
      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@container ".concat(query)));
      forEach(rules, (containerRule, query) => {
        var containerQuery = "@container ".concat(query);
        var conditions = [...parentConditions, containerQuery];
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(containerRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, containerRule, conditions);
          this.transformSelectors(root, containerRule, conditions);
        }
        this.transformLayer(root, containerRule["@layer"], conditions);
        this.transformSupports(root, containerRule["@supports"], conditions);
        this.transformMedia(root, containerRule["@media"], conditions);
      });
    }
  }
  transformLayer(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional3;
      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map((name) => "@layer ".concat(name)));
      forEach(rules, (layerRule, name) => {
        var conditions = [...parentConditions, "@layer ".concat(name)];
        this.addLayer(conditions);
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(layerRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, layerRule, conditions);
          this.transformSelectors(root, layerRule, conditions);
        }
        this.transformMedia(root, layerRule["@media"], conditions);
        this.transformSupports(root, layerRule["@supports"], conditions);
        this.transformContainer(root, layerRule["@container"], conditions);
      });
    }
  }
  transformSupports(root, rules) {
    var parentConditions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (rules) {
      var _this$currConditional4;
      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map((query) => "@supports ".concat(query)));
      forEach(rules, (supportsRule, query) => {
        var conditions = [...parentConditions, "@supports ".concat(query)];
        this.addConditionalRule({
          selector: root.selector,
          rule: omit(supportsRule, specialKeys)
        }, conditions);
        if (root.type === "local") {
          this.transformSimplePseudos(root, supportsRule, conditions);
          this.transformSelectors(root, supportsRule, conditions);
        }
        this.transformLayer(root, supportsRule["@layer"], conditions);
        this.transformMedia(root, supportsRule["@media"], conditions);
        this.transformContainer(root, supportsRule["@container"], conditions);
      });
    }
  }
  transformSimplePseudos(root, rule, conditions) {
    for (var key of Object.keys(rule)) {
      if (simplePseudoLookup[key]) {
        if (root.type !== "local") {
          throw new Error("Simple pseudos are not valid in ".concat(root.type === "global" ? '"globalStyle"' : '"selectors"'));
        }
        if (conditions) {
          this.addConditionalRule({
            selector: "".concat(root.selector).concat(key),
            rule: rule[key]
          }, conditions);
        } else {
          this.addRule({
            conditions,
            selector: "".concat(root.selector).concat(key),
            rule: rule[key]
          });
        }
      }
    }
  }
  toCss() {
    var css = [];
    for (var fontFaceRule of this.fontFaceRules) {
      css.push(renderCss({
        "@font-face": fontFaceRule
      }));
    }
    for (var property of this.propertyRules) {
      css.push(renderCss({
        ["@property ".concat(property.name)]: property.rule
      }));
    }
    for (var keyframe of this.keyframesRules) {
      css.push(renderCss({
        ["@keyframes ".concat(keyframe.name)]: keyframe.rule
      }));
    }
    for (var layer of this.layers.values()) {
      var [definition, ...nesting] = layer.reverse();
      var cssObj = {
        [definition]: DECLARATION
      };
      for (var part of nesting) {
        cssObj = {
          [part]: cssObj
        };
      }
      css.push(renderCss(cssObj));
    }
    for (var rule of this.rules) {
      css.push(renderCss({
        [rule.selector]: rule.rule
      }));
    }
    for (var conditionalRuleset of this.conditionalRulesets) {
      for (var conditionalRule of conditionalRuleset.renderToArray()) {
        css.push(renderCss(conditionalRule));
      }
    }
    return css.filter(Boolean);
  }
};
function renderCss(v10) {
  var indent2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var rules = [];
  var _loop2 = function _loop22(key2) {
    var value2 = v10[key2];
    if (value2 && Array.isArray(value2)) {
      rules.push(...value2.map((v11) => renderCss({
        [key2]: v11
      }, indent2)));
    } else if (value2 && typeof value2 === "object") {
      var isEmpty2 = Object.keys(value2).length === 0;
      if (!isEmpty2) {
        rules.push("".concat(indent2).concat(key2, " {\n").concat(renderCss(value2, indent2 + DOUBLE_SPACE), "\n").concat(indent2, "}"));
      }
    } else if (value2 === DECLARATION) {
      rules.push("".concat(indent2).concat(key2, ";"));
    } else {
      rules.push("".concat(indent2).concat(key2.startsWith("--") ? key2 : dashify(key2), ": ").concat(value2, ";"));
    }
  };
  for (var key of Object.keys(v10)) {
    _loop2(key);
  }
  return rules.join("\n");
}
function transformCss(_ref5) {
  var {
    localClassNames: localClassNames2,
    cssObjs,
    composedClassLists: composedClassLists2
  } = _ref5;
  var stylesheet = new Stylesheet(localClassNames2, composedClassLists2);
  for (var root of cssObjs) {
    stylesheet.processCssObj(root);
  }
  return stylesheet.toCss();
}

// ../node_modules/@vanilla-extract/css/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type2, code, fn2) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn2) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a4;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_, fn2) {
      this._onabort.push(fn2);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a7, _b3;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn2 of this.signal._onabort) {
        fn2(reason);
      }
      (_b3 = (_a7 = this.signal).onabort) == null ? void 0 : _b3.call(_a7, reason);
    }
  };
  let printACPolyfillWarning = ((_a4 = PROCESS.env) == null ? void 0 : _a4.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n10) => n10 && n10 === Math.floor(n10) && n10 > 0 && isFinite(n10);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size4) {
    super(size4);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max2, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max2);
    this.length = 0;
  }
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s10 = new _Stack(max2, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s10;
  }
  push(n10) {
    this.heap[this.length++] = n10;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _a5, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _LRUCache_instances);
    // options that cannot be changed without disaster
    __privateAdd(this, _max);
    __privateAdd(this, _maxSize);
    __privateAdd(this, _dispose);
    __privateAdd(this, _disposeAfter);
    __privateAdd(this, _fetchMethod);
    __privateAdd(this, _memoMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size);
    __privateAdd(this, _calculatedSize);
    __privateAdd(this, _keyMap);
    __privateAdd(this, _keyList);
    __privateAdd(this, _valList);
    __privateAdd(this, _next);
    __privateAdd(this, _prev);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _free);
    __privateAdd(this, _disposed);
    __privateAdd(this, _sizes);
    __privateAdd(this, _starts);
    __privateAdd(this, _ttls);
    __privateAdd(this, _hasDispose);
    __privateAdd(this, _hasFetchMethod);
    __privateAdd(this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i2) => {
    });
    __privateAdd(this, _addItemSize, (_i2, _s2, _st) => {
    });
    __privateAdd(this, _requireSize, (_k2, _v2, size4, sizeCalculation) => {
      if (size4 || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    __publicField(this, _a5, "LRUCache");
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    __privateSet(this, _max, max2);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    __privateSet(this, _memoMethod, memoMethod);
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max2).fill(void 0));
    __privateSet(this, _valList, new Array(max2).fill(void 0));
    __privateSet(this, _next, new UintArray(max2));
    __privateSet(this, _prev, new UintArray(max2));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max2));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: __privateGet(c, _starts),
      ttls: __privateGet(c, _ttls),
      sizes: __privateGet(c, _sizes),
      keyMap: __privateGet(c, _keyMap),
      keyList: __privateGet(c, _keyList),
      valList: __privateGet(c, _valList),
      next: __privateGet(c, _next),
      prev: __privateGet(c, _prev),
      get head() {
        return __privateGet(c, _head);
      },
      get tail() {
        return __privateGet(c, _tail);
      },
      free: __privateGet(c, _free),
      // methods
      isBackgroundFetch: (p) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a7, p);
      },
      backgroundFetch: (k, index2, options, context) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, backgroundFetch_fn).call(_a7, k, index2, options, context);
      },
      moveToTail: (index2) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, moveToTail_fn).call(_a7, index2);
      },
      indexes: (options) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, indexes_fn).call(_a7, options);
      },
      rindexes: (options) => {
        var _a7;
        return __privateMethod(_a7 = c, _LRUCache_instances, rindexes_fn).call(_a7, options);
      },
      isStale: (index2) => {
        var _a7;
        return __privateGet(_a7 = c, _isStale).call(_a7, index2);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  get memoMethod() {
    return __privateGet(this, _memoMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i10 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i10] !== void 0 && __privateGet(this, _keyList)[i10] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i10])) {
        yield [__privateGet(this, _keyList)[i10], __privateGet(this, _valList)[i10]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i10 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i10] !== void 0 && __privateGet(this, _keyList)[i10] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i10])) {
        yield [__privateGet(this, _keyList)[i10], __privateGet(this, _valList)[i10]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i10 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const k = __privateGet(this, _keyList)[i10];
      if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i10])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i10 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k = __privateGet(this, _keyList)[i10];
      if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i10])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i10 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v10 = __privateGet(this, _valList)[i10];
      if (v10 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i10])) {
        yield __privateGet(this, _valList)[i10];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i10 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v10 = __privateGet(this, _valList)[i10];
      if (v10 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i10])) {
        yield __privateGet(this, _valList)[i10];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b = Symbol.iterator, _a5 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn2, getOptions = {}) {
    for (const i10 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v10 = __privateGet(this, _valList)[i10];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) ? v10.__staleWhileFetching : v10;
      if (value2 === void 0)
        continue;
      if (fn2(value2, __privateGet(this, _keyList)[i10], this)) {
        return this.get(__privateGet(this, _keyList)[i10], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn2, thisp = this) {
    for (const i10 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v10 = __privateGet(this, _valList)[i10];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) ? v10.__staleWhileFetching : v10;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, __privateGet(this, _keyList)[i10], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn2, thisp = this) {
    for (const i10 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v10 = __privateGet(this, _valList)[i10];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) ? v10.__staleWhileFetching : v10;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, __privateGet(this, _keyList)[i10], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i10 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i10)) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i10], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i10 = __privateGet(this, _keyMap).get(key);
    if (i10 === void 0)
      return void 0;
    const v10 = __privateGet(this, _valList)[i10];
    const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) ? v10.__staleWhileFetching : v10;
    if (value2 === void 0)
      return void 0;
    const entry = { value: value2 };
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      const ttl = __privateGet(this, _ttls)[i10];
      const start = __privateGet(this, _starts)[i10];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (__privateGet(this, _sizes)) {
      entry.size = __privateGet(this, _sizes)[i10];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i10 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i10];
      const v10 = __privateGet(this, _valList)[i10];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) ? v10.__staleWhileFetching : v10;
      if (value2 === void 0 || key === void 0)
        continue;
      const entry = { value: value2 };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i10];
        const age = perf.now() - __privateGet(this, _starts)[i10];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i10];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v10, setOptions = {}) {
    var _a7, _b3, _c2, _d2, _e;
    if (v10 === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size4 = __privateGet(this, _requireSize).call(this, k, v10, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size4 > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "set");
      return this;
    }
    let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
    if (index2 === void 0) {
      index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index2] = k;
      __privateGet(this, _valList)[index2] = v10;
      __privateGet(this, _keyMap).set(k, index2);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index2;
      __privateGet(this, _prev)[index2] = __privateGet(this, _tail);
      __privateSet(this, _tail, index2);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index2, size4, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
      const oldVal = __privateGet(this, _valList)[index2];
      if (v10 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s10 } = oldVal;
          if (s10 !== void 0 && !noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, s10, k, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([s10, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_c2 = __privateGet(this, _dispose)) == null ? void 0 : _c2.call(this, oldVal, k, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_d2 = __privateGet(this, _disposed)) == null ? void 0 : _d2.push([oldVal, k, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index2);
        __privateGet(this, _addItemSize).call(this, index2, size4, status);
        __privateGet(this, _valList)[index2] = v10;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index2, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt2 = __privateGet(this, _disposed);
      let task;
      while (task = dt2 == null ? void 0 : dt2.shift()) {
        (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a7;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt2 = __privateGet(this, _disposed);
        let task;
        while (task = dt2 == null ? void 0 : dt2.shift()) {
          (_a7 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a7.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index2 = __privateGet(this, _keyMap).get(k);
    if (index2 !== void 0) {
      const v10 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) && v10.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index2)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index2);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index2 = __privateGet(this, _keyMap).get(k);
    if (index2 === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index2)) {
      return;
    }
    const v10 = __privateGet(this, _valList)[index2];
    return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10) ? v10.__staleWhileFetching : v10;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size4 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size4,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = __privateGet(this, _keyMap).get(k);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index2, options, context);
      return p.__returned = p;
    } else {
      const v10 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10)) {
        const stale = allowStale && v10.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v10.__staleWhileFetching : v10.__returned = v10;
      }
      const isStale = __privateGet(this, _isStale).call(this, index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index2);
        return v10;
      }
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index2, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v10 = await this.fetch(k, fetchOptions);
    if (v10 === void 0)
      throw new Error("fetch() returned undefined");
    return v10;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = __privateGet(this, _memoMethod);
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v10 = this.get(k, options);
    if (!forceRefresh && v10 !== void 0)
      return v10;
    const vv2 = memoMethod(k, v10, {
      options,
      context
    });
    this.set(k, vv2, options);
    return vv2;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index2 = __privateGet(this, _keyMap).get(k);
    if (index2 !== void 0) {
      const value2 = __privateGet(this, _valList)[index2];
      const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value2);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
      if (__privateGet(this, _isStale).call(this, index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value2 : void 0;
        } else {
          if (status && allowStale && value2.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value2.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value2.__staleWhileFetching;
        }
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        return value2;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_memoMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_LRUCache_instances = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index2, ttl, start = perf.now()) => {
    starts[index2] = ttl !== 0 ? start : 0;
    ttls[index2] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t10 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index2)) {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index2], "expire");
        }
      }, ttl + 1);
      if (t10.unref) {
        t10.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index2) => {
    starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index2) => {
    if (ttls[index2]) {
      const ttl = ttls[index2];
      const start = starts[index2];
      if (!ttl || !start)
        return;
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n10 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n10;
      const t10 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t10.unref) {
        t10.unref();
      }
    }
    return n10;
  };
  this.getRemainingTTL = (key) => {
    const index2 = __privateGet(this, _keyMap).get(key);
    if (index2 === void 0) {
      return 0;
    }
    const ttl = ttls[index2];
    const start = starts[index2];
    if (!ttl || !start) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index2) => {
    const s10 = starts[index2];
    const t10 = ttls[index2];
    return !!t10 && !!s10 && (cachedNow || getNow()) - s10 > t10;
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index2) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]);
    sizes[index2] = 0;
  });
  __privateSet(this, _requireSize, (k, v10, size4, sizeCalculation) => {
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10)) {
      return 0;
    }
    if (!isPosInt(size4)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size4 = sizeCalculation(v10, k);
        if (!isPosInt(size4)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size4;
  });
  __privateSet(this, _addItemSize, (index2, size4, status) => {
    sizes[index2] = size4;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index2];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]);
    if (status) {
      status.entrySize = size4;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i10 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i10)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i10)) {
        yield i10;
      }
      if (i10 === __privateGet(this, _head)) {
        break;
      } else {
        i10 = __privateGet(this, _prev)[i10];
      }
    }
  }
};
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i10 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i10)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i10)) {
        yield i10;
      }
      if (i10 === __privateGet(this, _tail)) {
        break;
      } else {
        i10 = __privateGet(this, _next)[i10];
      }
    }
  }
};
isValidIndex_fn = function(index2) {
  return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
};
evict_fn = function(free) {
  var _a7, _b3;
  const head = __privateGet(this, _head);
  const k = __privateGet(this, _keyList)[head];
  const v10 = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10)) {
    v10.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, v10, k, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([v10, k, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k);
  __privateWrapper(this, _size)._--;
  return head;
};
backgroundFetch_fn = function(k, index2, options, context) {
  const v10 = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
  if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10)) {
    return v10;
  }
  const ac2 = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac2.abort(signal.reason), {
    signal: ac2.signal
  });
  const fetchOpts = {
    signal: ac2.signal,
    options,
    context
  };
  const cb2 = (v11, updateCache = false) => {
    const { aborted } = ac2.signal;
    const ignoreAbort = options.ignoreFetchAbort && v11 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac2.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac2.signal.reason);
    }
    const bf3 = p;
    if (__privateGet(this, _valList)[index2] === p) {
      if (v11 === void 0) {
        if (bf3.__staleWhileFetching) {
          __privateGet(this, _valList)[index2] = bf3.__staleWhileFetching;
        } else {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k, v11, fetchOpts.options);
      }
    }
    return v11;
  };
  const eb2 = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac2.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf3 = p;
    if (__privateGet(this, _valList)[index2] === p) {
      const del = !noDelete || bf3.__staleWhileFetching === void 0;
      if (del) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index2] = bf3.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf3.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf3.__staleWhileFetching;
    } else if (bf3.__returned === bf3) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a7;
    const fmp = (_a7 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a7.call(this, k, v10, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v11) => res(v11 === void 0 ? void 0 : v11), rej);
    }
    ac2.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v11) => cb2(v11, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p = new Promise(pcall).then(cb2, eb2);
  const bf2 = Object.assign(p, {
    __abortController: ac2,
    __staleWhileFetching: v10,
    __returned: void 0
  });
  if (index2 === void 0) {
    this.set(k, bf2, { ...fetchOpts.options, status: void 0 });
    index2 = __privateGet(this, _keyMap).get(k);
  } else {
    __privateGet(this, _valList)[index2] = bf2;
  }
  return bf2;
};
isBackgroundFetch_fn = function(p) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b = p;
  return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
};
connect_fn = function(p, n10) {
  __privateGet(this, _prev)[n10] = p;
  __privateGet(this, _next)[p] = n10;
};
moveToTail_fn = function(index2) {
  if (index2 !== __privateGet(this, _tail)) {
    if (index2 === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index2]);
    } else {
      __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]);
    }
    __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index2);
    __privateSet(this, _tail, index2);
  }
};
delete_fn = function(k, reason) {
  var _a7, _b3, _c2, _d2;
  let deleted = false;
  if (__privateGet(this, _size) !== 0) {
    const index2 = __privateGet(this, _keyMap).get(k);
    if (index2 !== void 0) {
      deleted = true;
      if (__privateGet(this, _size) === 1) {
        __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
      } else {
        __privateGet(this, _removeItemSize).call(this, index2);
        const v10 = __privateGet(this, _valList)[index2];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10)) {
          v10.__abortController.abort(new Error("deleted"));
        } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
          if (__privateGet(this, _hasDispose)) {
            (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, v10, k, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([v10, k, reason]);
          }
        }
        __privateGet(this, _keyMap).delete(k);
        __privateGet(this, _keyList)[index2] = void 0;
        __privateGet(this, _valList)[index2] = void 0;
        if (index2 === __privateGet(this, _tail)) {
          __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
        } else if (index2 === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index2]);
        } else {
          const pi2 = __privateGet(this, _prev)[index2];
          __privateGet(this, _next)[pi2] = __privateGet(this, _next)[index2];
          const ni2 = __privateGet(this, _next)[index2];
          __privateGet(this, _prev)[ni2] = __privateGet(this, _prev)[index2];
        }
        __privateWrapper(this, _size)._--;
        __privateGet(this, _free).push(index2);
      }
    }
  }
  if (__privateGet(this, _hasDisposeAfter) && ((_c2 = __privateGet(this, _disposed)) == null ? void 0 : _c2.length)) {
    const dt2 = __privateGet(this, _disposed);
    let task;
    while (task = dt2 == null ? void 0 : dt2.shift()) {
      (_d2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _d2.call(this, ...task);
    }
  }
  return deleted;
};
clear_fn = function(reason) {
  var _a7, _b3, _c2;
  for (const index2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
    const v10 = __privateGet(this, _valList)[index2];
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v10)) {
      v10.__abortController.abort(new Error("deleted"));
    } else {
      const k = __privateGet(this, _keyList)[index2];
      if (__privateGet(this, _hasDispose)) {
        (_a7 = __privateGet(this, _dispose)) == null ? void 0 : _a7.call(this, v10, k, reason);
      }
      if (__privateGet(this, _hasDisposeAfter)) {
        (_b3 = __privateGet(this, _disposed)) == null ? void 0 : _b3.push([v10, k, reason]);
      }
    }
  }
  __privateGet(this, _keyMap).clear();
  __privateGet(this, _valList).fill(void 0);
  __privateGet(this, _keyList).fill(void 0);
  if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
    __privateGet(this, _ttls).fill(0);
    __privateGet(this, _starts).fill(0);
  }
  if (__privateGet(this, _sizes)) {
    __privateGet(this, _sizes).fill(0);
  }
  __privateSet(this, _head, 0);
  __privateSet(this, _tail, 0);
  __privateGet(this, _free).length = 0;
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _size, 0);
  if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
    const dt2 = __privateGet(this, _disposed);
    let task;
    while (task = dt2 == null ? void 0 : dt2.shift()) {
      (_c2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _c2.call(this, ...task);
    }
  }
};
var LRUCache = _LRUCache;

// ../node_modules/@vanilla-extract/css/dist/vanilla-extract-css.browser.esm.js
var import_cssesc2 = __toESM(require_cssesc());
var import_picocolors = __toESM(require_picocolors_browser());
var import_deepmerge = __toESM(require_cjs());
var localClassNames = /* @__PURE__ */ new Set();
var composedClassLists = [];
var bufferedCSSObjs = [];
var browserRuntimeAdapter = {
  appendCss: (cssObj) => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: (className) => {
    localClassNames.add(className);
  },
  registerComposition: (composition) => {
    composedClassLists.push(composition);
  },
  markCompositionUsed: () => {
  },
  onEndFileScope: (fileScope) => {
    var css = transformCss({
      localClassNames: Array.from(localClassNames),
      composedClassLists,
      cssObjs: bufferedCSSObjs
    }).join("\n");
    injectStyles2({
      fileScope,
      css
    });
    bufferedCSSObjs = [];
  },
  getIdentOption: () => false ? "short" : "debug"
};
{
  setAdapterIfNotSet(browserRuntimeAdapter);
}
var getLastSlashBeforeIndex = (path, index2) => {
  var pathIndex = index2 - 1;
  while (pathIndex >= 0) {
    if (path[pathIndex] === "/") {
      return pathIndex;
    }
    pathIndex--;
  }
  return -1;
};
var _getDebugFileName = (path) => {
  var file;
  var lastIndexOfDotCss = path.lastIndexOf(".css");
  if (lastIndexOfDotCss === -1) {
    return "";
  }
  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);
  file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);
  if (lastSlashIndex === -1) {
    return file;
  }
  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);
  var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);
  var debugFileName = file !== "index" ? file : dir;
  return debugFileName;
};
var memoizedGetDebugFileName = () => {
  var cache = new LRUCache({
    max: 500
  });
  return (path) => {
    var cachedResult = cache.get(path);
    if (cachedResult) {
      return cachedResult;
    }
    var result = _getDebugFileName(path);
    cache.set(path, result);
    return result;
  };
};
var getDebugFileName = memoizedGetDebugFileName();
function createGlobalThemeContract(tokens, mapFn) {
  return walkObject(tokens, (value2, path) => {
    var rawVarName = typeof mapFn === "function" ? mapFn(value2, path) : value2;
    var varName = typeof rawVarName === "string" ? rawVarName.replace(/^\-\-/, "") : null;
    if (typeof varName !== "string" || varName !== (0, import_cssesc2.default)(varName, {
      isIdentifier: true
    })) {
      throw new Error('Invalid variable name for "'.concat(path.join("."), '": ').concat(varName));
    }
    return "var(--".concat(varName, ")");
  });
}

// ../node_modules/@mysten/dapp-kit/dist/esm/index.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS2 = (cb2, mod2) => function __require2() {
  return mod2 || (0, cb2[__getOwnPropNames(cb2)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var init_StyleMarker_css_ts_vanilla = __esm({
  "vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9"() {
  }
});
var require_StyleMarker_css = __commonJS2({
  "src/components/styling/StyleMarker.css.ts"() {
    "use strict";
    init_StyleMarker_css_ts_vanilla();
  }
});
function createInMemoryStore() {
  const store5 = /* @__PURE__ */ new Map();
  return {
    getItem(key) {
      return store5.get(key);
    },
    setItem(key, value2) {
      store5.set(key, value2);
    },
    removeItem(key) {
      store5.delete(key);
    }
  };
}
var DEFAULT_STORAGE = typeof window !== "undefined" && window.localStorage ? localStorage : createInMemoryStore();
var SIGN_FEATURES = [
  "sui:signTransaction",
  "sui:signTransactionBlock"
];
var DEFAULT_WALLET_FILTER = (wallet) => SIGN_FEATURES.some((feature) => wallet.features[feature]);
var walletMutationKeys = {
  all: { baseScope: "wallet" },
  connectWallet: formMutationKeyFn("connect-wallet"),
  autoconnectWallet: formMutationKeyFn("autoconnect-wallet"),
  disconnectWallet: formMutationKeyFn("disconnect-wallet"),
  signPersonalMessage: formMutationKeyFn("sign-personal-message"),
  signTransaction: formMutationKeyFn("sign-transaction"),
  signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction"),
  switchAccount: formMutationKeyFn("switch-account"),
  reportTransactionEffects: formMutationKeyFn("report-transaction-effects")
};
function formMutationKeyFn(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var WalletContext = (0, import_react10.createContext)(null);
function useWalletStore(selector) {
  const store5 = (0, import_react9.useContext)(WalletContext);
  if (!store5) {
    throw new Error(
      "Could not find WalletContext. Ensure that you have set up the WalletProvider."
    );
  }
  return useStore(store5, selector);
}
function useConnectWallet({
  mutationKey,
  ...mutationOptions
} = {}) {
  const setWalletConnected = useWalletStore((state) => state.setWalletConnected);
  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
  return useMutation({
    mutationKey: walletMutationKeys.connectWallet(mutationKey),
    mutationFn: async ({ wallet, accountAddress, ...connectArgs }) => {
      try {
        setConnectionStatus("connecting");
        const connectResult = await wallet.features["standard:connect"].connect(connectArgs);
        const connectedSuiAccounts = connectResult.accounts.filter(
          (account) => account.chains.some((chain2) => chain2.split(":")[0] === "sui")
        );
        const selectedAccount = getSelectedAccount(connectedSuiAccounts, accountAddress);
        setWalletConnected(
          wallet,
          connectedSuiAccounts,
          selectedAccount,
          connectResult.supportedIntents
        );
        return { accounts: connectedSuiAccounts };
      } catch (error2) {
        setConnectionStatus("disconnected");
        throw error2;
      }
    },
    ...mutationOptions
  });
}
function getSelectedAccount(connectedAccounts, accountAddress) {
  if (connectedAccounts.length === 0) {
    return null;
  }
  if (accountAddress) {
    const selectedAccount = connectedAccounts.find((account) => account.address === accountAddress);
    return selectedAccount ?? connectedAccounts[0];
  }
  return connectedAccounts[0];
}
function useWallets() {
  return useWalletStore((state) => state.wallets);
}
function getWalletUniqueIdentifier(wallet) {
  return (wallet == null ? void 0 : wallet.id) ?? (wallet == null ? void 0 : wallet.name);
}
function BackIcon(props) {
  return (0, import_jsx_runtime18.jsx)("svg", { width: 24, height: 24, fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime18.jsx)(
    "path",
    {
      d: "M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z",
      fill: "currentColor"
    }
  ) });
}
function CloseIcon(props) {
  return (0, import_jsx_runtime19.jsx)("svg", { width: 10, height: 10, fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime19.jsx)(
    "path",
    {
      d: "M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z",
      fill: "currentColor"
    }
  ) });
}
var styleDataAttributeName = "data-dapp-kit";
var styleDataAttributeSelector = `[${styleDataAttributeName}]`;
var styleDataAttribute = { [styleDataAttributeName]: "" };
var import_StyleMarker_css = __toESM2(require_StyleMarker_css());
var StyleMarker = (0, import_react11.forwardRef)(({ children, ...props }, forwardedRef) => (0, import_jsx_runtime20.jsx)(Slot, { ref: forwardedRef, ...props, ...styleDataAttribute, children }));
StyleMarker.displayName = "StyleMarker";
var headingVariants = createRuntimeFn({ defaultClassName: "Heading__1aa835k0", variantClassNames: { size: { sm: "Heading_headingVariants_size_sm__1aa835k1", md: "Heading_headingVariants_size_md__1aa835k2", lg: "Heading_headingVariants_size_lg__1aa835k3", xl: "Heading_headingVariants_size_xl__1aa835k4" }, weight: { normal: "Heading_headingVariants_weight_normal__1aa835k5", bold: "Heading_headingVariants_weight_bold__1aa835k6" }, truncate: { true: "Heading_headingVariants_truncate_true__1aa835k7" } }, defaultVariants: { size: "lg", weight: "bold" }, compoundVariants: [] });
var Heading = (0, import_react12.forwardRef)(
  ({
    children,
    className,
    asChild = false,
    as: Tag = "h1",
    size: size4,
    weight,
    truncate,
    ...headingProps
  }, forwardedRef) => {
    return (0, import_jsx_runtime21.jsx)(
      Slot,
      {
        ...headingProps,
        ref: forwardedRef,
        className: clsx_default(headingVariants({ size: size4, weight, truncate }), className),
        children: asChild ? children : (0, import_jsx_runtime21.jsx)(Tag, { children })
      }
    );
  }
);
Heading.displayName = "Heading";
var container = "IconButton_container__s6n7bq0";
var IconButton = (0, import_react13.forwardRef)(
  ({ className, asChild = false, ...props }, forwardedRef) => {
    const Comp = asChild ? Slot : "button";
    return (0, import_jsx_runtime22.jsx)(Comp, { ...props, className: clsx_default(container, className), ref: forwardedRef });
  }
);
IconButton.displayName = "Button";
var backButtonContainer = "ConnectModal_backButtonContainer__gz8z96";
var closeButtonContainer = "ConnectModal_closeButtonContainer__gz8z97";
var content = "ConnectModal_content__gz8z92";
var overlay = "ConnectModal_overlay__gz8z90";
var selectedViewContainer = "ConnectModal_selectedViewContainer__gz8z95";
var title = "ConnectModal_title__gz8z91";
var viewContainer = "ConnectModal_viewContainer__gz8z94";
var walletListContainer = "ConnectModal_walletListContainer__gz8z99";
var walletListContainerWithViewSelected = "ConnectModal_walletListContainerWithViewSelected__gz8z9a";
var walletListContent = "ConnectModal_walletListContent__gz8z98";
var whatIsAWalletButton = "ConnectModal_whatIsAWalletButton__gz8z93";
var buttonVariants = createRuntimeFn({ defaultClassName: "Button_buttonVariants__x1s81q0", variantClassNames: { variant: { primary: "Button_buttonVariants_variant_primary__x1s81q1", outline: "Button_buttonVariants_variant_outline__x1s81q2" }, size: { md: "Button_buttonVariants_size_md__x1s81q3", lg: "Button_buttonVariants_size_lg__x1s81q4" } }, defaultVariants: { variant: "primary", size: "md" }, compoundVariants: [] });
var Button = (0, import_react14.forwardRef)(
  ({ className, variant: variant2, size: size4, asChild = false, ...props }, forwardedRef) => {
    const Comp = asChild ? Slot : "button";
    return (0, import_jsx_runtime23.jsx)(
      Comp,
      {
        ...props,
        className: clsx_default(buttonVariants({ variant: variant2, size: size4 }), className),
        ref: forwardedRef
      }
    );
  }
);
Button.displayName = "Button";
var textVariants = createRuntimeFn({ defaultClassName: "Text__2bv1ur0", variantClassNames: { size: { sm: "Text_textVariants_size_sm__2bv1ur1" }, weight: { normal: "Text_textVariants_weight_normal__2bv1ur2", medium: "Text_textVariants_weight_medium__2bv1ur3", bold: "Text_textVariants_weight_bold__2bv1ur4" }, color: { muted: "Text_textVariants_color_muted__2bv1ur5", danger: "Text_textVariants_color_danger__2bv1ur6" }, mono: { true: "Text_textVariants_mono_true__2bv1ur7" } }, defaultVariants: { size: "sm", weight: "normal" }, compoundVariants: [] });
var Text = (0, import_react15.forwardRef)(
  ({
    children,
    className,
    asChild = false,
    as: Tag = "div",
    size: size4,
    weight,
    color,
    mono,
    ...textProps
  }, forwardedRef) => {
    return (0, import_jsx_runtime24.jsx)(
      Slot,
      {
        ...textProps,
        ref: forwardedRef,
        className: clsx_default(textVariants({ size: size4, weight, color, mono }), className),
        children: asChild ? children : (0, import_jsx_runtime24.jsx)(Tag, { children })
      }
    );
  }
);
Text.displayName = "Text";
var connectionStatus = "ConnectionStatus_connectionStatus__nckm2d3";
var container2 = "ConnectionStatus_container__nckm2d0";
var retryButtonContainer = "ConnectionStatus_retryButtonContainer__nckm2d4";
var title2 = "ConnectionStatus_title__nckm2d2";
var walletIcon = "ConnectionStatus_walletIcon__nckm2d1";
function ConnectionStatus({
  selectedWallet,
  hadConnectionError,
  onRetryConnection
}) {
  return (0, import_jsx_runtime25.jsxs)("div", { className: container2, children: [
    selectedWallet.icon && (0, import_jsx_runtime25.jsx)(
      "img",
      {
        className: walletIcon,
        src: selectedWallet.icon,
        alt: `${selectedWallet.name} logo`
      }
    ),
    (0, import_jsx_runtime25.jsx)("div", { className: title2, children: (0, import_jsx_runtime25.jsxs)(Heading, { as: "h2", size: "xl", children: [
      "Opening ",
      selectedWallet.name
    ] }) }),
    (0, import_jsx_runtime25.jsx)("div", { className: connectionStatus, children: hadConnectionError ? (0, import_jsx_runtime25.jsx)(Text, { color: "danger", children: "Connection failed" }) : (0, import_jsx_runtime25.jsx)(Text, { color: "muted", children: "Confirm connection in the wallet..." }) }),
    hadConnectionError ? (0, import_jsx_runtime25.jsx)("div", { className: retryButtonContainer, children: (0, import_jsx_runtime25.jsx)(Button, { type: "button", variant: "outline", onClick: () => onRetryConnection(selectedWallet), children: "Retry Connection" }) }) : null
  ] });
}
var container3 = "InfoSection_container__1wtioi70";
function InfoSection({ title: title3, children }) {
  return (0, import_jsx_runtime26.jsxs)("section", { className: container3, children: [
    (0, import_jsx_runtime26.jsx)(Heading, { as: "h3", size: "sm", weight: "normal", children: title3 }),
    (0, import_jsx_runtime26.jsx)(Text, { weight: "medium", color: "muted", children })
  ] });
}
var container4 = "GettingStarted_container__1fp07e10";
var content2 = "GettingStarted_content__1fp07e11";
var installButtonContainer = "GettingStarted_installButtonContainer__1fp07e12";
function GettingStarted() {
  return (0, import_jsx_runtime27.jsxs)("div", { className: container4, children: [
    (0, import_jsx_runtime27.jsx)(Heading, { as: "h2", children: "Get Started with Sui" }),
    (0, import_jsx_runtime27.jsxs)("div", { className: content2, children: [
      (0, import_jsx_runtime27.jsx)(InfoSection, { title: "Install the Sui Wallet Extension", children: "We recommend pinning Sui Wallet to your taskbar for quicker access." }),
      (0, import_jsx_runtime27.jsx)(InfoSection, { title: "Create or Import a Wallet", children: "Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone." }),
      (0, import_jsx_runtime27.jsx)(InfoSection, { title: "Refresh Your Browser", children: "Once you set up your wallet, refresh this window browser to load up the extension." }),
      (0, import_jsx_runtime27.jsx)("div", { className: installButtonContainer, children: (0, import_jsx_runtime27.jsx)(Button, { variant: "outline", asChild: true, children: (0, import_jsx_runtime27.jsx)(
        "a",
        {
          href: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil",
          target: "_blank",
          rel: "noreferrer",
          children: "Install Wallet Extension"
        }
      ) }) })
    ] })
  ] });
}
var container5 = "WhatIsAWallet_container__1ktpkq90";
var content3 = "WhatIsAWallet_content__1ktpkq91";
function WhatIsAWallet() {
  return (0, import_jsx_runtime28.jsxs)("div", { className: container5, children: [
    (0, import_jsx_runtime28.jsx)(Heading, { as: "h2", children: "What is a Wallet" }),
    (0, import_jsx_runtime28.jsxs)("div", { className: content3, children: [
      (0, import_jsx_runtime28.jsx)(InfoSection, { title: "Easy Login", children: "No need to create new accounts and passwords for every website. Just connect your wallet and get going." }),
      (0, import_jsx_runtime28.jsx)(InfoSection, { title: "Store your Digital Assets", children: "Send, receive, store, and display your digital assets like NFTs & coins." })
    ] })
  ] });
}
function SuiIcon(props) {
  return (0, import_jsx_runtime29.jsxs)("svg", { width: 28, height: 28, fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
    (0, import_jsx_runtime29.jsx)("rect", { width: 28, height: 28, rx: 6, fill: "#6FBCF0" }),
    (0, import_jsx_runtime29.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7.942 20.527A6.875 6.875 0 0 0 13.957 24c2.51 0 4.759-1.298 6.015-3.473a6.875 6.875 0 0 0 0-6.945l-5.29-9.164a.837.837 0 0 0-1.45 0l-5.29 9.164a6.875 6.875 0 0 0 0 6.945Zm4.524-11.75 1.128-1.953a.418.418 0 0 1 .725 0l4.34 7.516a5.365 5.365 0 0 1 .449 4.442 4.675 4.675 0 0 0-.223-.73c-.599-1.512-1.954-2.68-4.029-3.47-1.426-.54-2.336-1.336-2.706-2.364-.476-1.326.021-2.77.316-3.44Zm-1.923 3.332L9.255 14.34a5.373 5.373 0 0 0 0 5.43 5.373 5.373 0 0 0 4.702 2.714 5.38 5.38 0 0 0 3.472-1.247c.125-.314.51-1.462.034-2.646-.44-1.093-1.5-1.965-3.15-2.594-1.864-.707-3.076-1.811-3.6-3.28a4.601 4.601 0 0 1-.17-.608Z",
        fill: "#fff"
      }
    )
  ] });
}
var container6 = "WalletList_container__1v2s6cz0";
var container7 = "WalletListItem_container__1dqqtqs0";
var selectedWalletItem = "WalletListItem_selectedWalletItem__1dqqtqs2";
var walletIcon2 = "WalletListItem_walletIcon__1dqqtqs3";
var walletItem = "WalletListItem_walletItem__1dqqtqs1";
function WalletListItem({ name, icon, onClick, isSelected = false }) {
  return (0, import_jsx_runtime30.jsx)("li", { className: container7, children: (0, import_jsx_runtime30.jsxs)(
    "button",
    {
      className: clsx(walletItem, { [selectedWalletItem]: isSelected }),
      type: "button",
      onClick,
      children: [
        icon && typeof icon === "string" ? (0, import_jsx_runtime30.jsx)("img", { className: walletIcon2, src: icon, alt: `${name} logo` }) : icon,
        (0, import_jsx_runtime30.jsx)(Heading, { size: "md", truncate: true, asChild: true, children: (0, import_jsx_runtime30.jsx)("div", { children: name }) })
      ]
    }
  ) });
}
function WalletList({
  selectedWalletName,
  onPlaceholderClick,
  onSelect,
  wallets
}) {
  return (0, import_jsx_runtime31.jsx)("ul", { className: container6, children: wallets.length > 0 ? wallets.map((wallet) => (0, import_jsx_runtime31.jsx)(
    WalletListItem,
    {
      name: wallet.name,
      icon: wallet.icon,
      isSelected: getWalletUniqueIdentifier(wallet) === selectedWalletName,
      onClick: () => onSelect(wallet)
    },
    getWalletUniqueIdentifier(wallet)
  )) : (0, import_jsx_runtime31.jsx)(
    WalletListItem,
    {
      name: "Sui Wallet",
      icon: (0, import_jsx_runtime31.jsx)(SuiIcon, {}),
      onClick: onPlaceholderClick,
      isSelected: true
    }
  ) });
}
function ConnectModal({
  trigger,
  open,
  defaultOpen,
  onOpenChange,
  walletFilter = DEFAULT_WALLET_FILTER
}) {
  const [isModalOpen, setModalOpen] = (0, import_react8.useState)(open ?? defaultOpen);
  const [currentView, setCurrentView] = (0, import_react8.useState)();
  const [selectedWallet, setSelectedWallet] = (0, import_react8.useState)();
  const wallets = useWallets().filter(walletFilter);
  const { mutate, isError } = useConnectWallet();
  const resetSelection = () => {
    setSelectedWallet(void 0);
    setCurrentView(void 0);
  };
  const handleOpenChange = (open2) => {
    if (!open2) {
      resetSelection();
    }
    setModalOpen(open2);
    onOpenChange == null ? void 0 : onOpenChange(open2);
  };
  const connectWallet = (wallet) => {
    setCurrentView("connection-status");
    mutate(
      { wallet },
      {
        onSuccess: () => handleOpenChange(false)
      }
    );
  };
  let modalContent;
  switch (currentView) {
    case "what-is-a-wallet":
      modalContent = (0, import_jsx_runtime32.jsx)(WhatIsAWallet, {});
      break;
    case "getting-started":
      modalContent = (0, import_jsx_runtime32.jsx)(GettingStarted, {});
      break;
    case "connection-status":
      modalContent = (0, import_jsx_runtime32.jsx)(
        ConnectionStatus,
        {
          selectedWallet,
          hadConnectionError: isError,
          onRetryConnection: connectWallet
        }
      );
      break;
    default:
      modalContent = (0, import_jsx_runtime32.jsx)(WhatIsAWallet, {});
  }
  return (0, import_jsx_runtime32.jsxs)(Root, { open: open ?? isModalOpen, onOpenChange: handleOpenChange, children: [
    (0, import_jsx_runtime32.jsx)(Trigger, { asChild: true, children: trigger }),
    (0, import_jsx_runtime32.jsx)(Portal2, { children: (0, import_jsx_runtime32.jsx)(StyleMarker, { children: (0, import_jsx_runtime32.jsx)(Overlay, { className: overlay, children: (0, import_jsx_runtime32.jsxs)(Content, { className: content, "aria-describedby": void 0, children: [
      (0, import_jsx_runtime32.jsxs)(
        "div",
        {
          className: clsx_default(walletListContainer, {
            [walletListContainerWithViewSelected]: !!currentView
          }),
          children: [
            (0, import_jsx_runtime32.jsxs)("div", { className: walletListContent, children: [
              (0, import_jsx_runtime32.jsx)(Title, { className: title, asChild: true, children: (0, import_jsx_runtime32.jsx)(Heading, { as: "h2", children: "Connect a Wallet" }) }),
              (0, import_jsx_runtime32.jsx)(
                WalletList,
                {
                  wallets,
                  selectedWalletName: getWalletUniqueIdentifier(selectedWallet),
                  onPlaceholderClick: () => setCurrentView("getting-started"),
                  onSelect: (wallet) => {
                    if (getWalletUniqueIdentifier(selectedWallet) !== getWalletUniqueIdentifier(wallet)) {
                      setSelectedWallet(wallet);
                      connectWallet(wallet);
                    }
                  }
                }
              )
            ] }),
            (0, import_jsx_runtime32.jsx)(
              "button",
              {
                className: whatIsAWalletButton,
                onClick: () => setCurrentView("what-is-a-wallet"),
                type: "button",
                children: "What is a Wallet?"
              }
            )
          ]
        }
      ),
      (0, import_jsx_runtime32.jsxs)(
        "div",
        {
          className: clsx_default(viewContainer, {
            [selectedViewContainer]: !!currentView
          }),
          children: [
            (0, import_jsx_runtime32.jsx)("div", { className: backButtonContainer, children: (0, import_jsx_runtime32.jsx)(IconButton, { type: "button", "aria-label": "Back", onClick: () => resetSelection(), children: (0, import_jsx_runtime32.jsx)(BackIcon, {}) }) }),
            modalContent
          ]
        }
      ),
      (0, import_jsx_runtime32.jsx)(Close, { className: closeButtonContainer, asChild: true, children: (0, import_jsx_runtime32.jsx)(IconButton, { type: "button", "aria-label": "Close", children: (0, import_jsx_runtime32.jsx)(CloseIcon, {}) }) })
    ] }) }) }) })
  ] });
}
function useCurrentAccount() {
  return useWalletStore((state) => state.currentAccount);
}
var SuiClientContext = (0, import_react18.createContext)(null);
var DEFAULT_NETWORKS = {
  localnet: { url: getFullnodeUrl("localnet") }
};
function useSuiClientContext() {
  const suiClient = (0, import_react17.useContext)(SuiClientContext);
  if (!suiClient) {
    throw new Error(
      "Could not find SuiClientContext. Ensure that you have set up the SuiClientProvider"
    );
  }
  return suiClient;
}
function useAccounts() {
  return useWalletStore((state) => state.accounts);
}
var WalletNotConnectedError = class extends Error {
};
var WalletNoAccountSelectedError = class extends Error {
};
var WalletFeatureNotSupportedError = class extends Error {
};
var WalletAccountNotFoundError = class extends Error {
};
function useCurrentWallet() {
  const currentWallet = useWalletStore((state) => state.currentWallet);
  const connectionStatus2 = useWalletStore((state) => state.connectionStatus);
  const supportedIntents = useWalletStore((state) => state.supportedIntents);
  switch (connectionStatus2) {
    case "connecting":
      return {
        connectionStatus: connectionStatus2,
        currentWallet: null,
        isDisconnected: false,
        isConnecting: true,
        isConnected: false,
        supportedIntents: []
      };
    case "disconnected":
      return {
        connectionStatus: connectionStatus2,
        currentWallet: null,
        isDisconnected: true,
        isConnecting: false,
        isConnected: false,
        supportedIntents: []
      };
    case "connected": {
      return {
        connectionStatus: connectionStatus2,
        currentWallet,
        isDisconnected: false,
        isConnecting: false,
        isConnected: true,
        supportedIntents
      };
    }
  }
}
function useDisconnectWallet({
  mutationKey,
  ...mutationOptions
} = {}) {
  const { currentWallet } = useCurrentWallet();
  const setWalletDisconnected = useWalletStore((state) => state.setWalletDisconnected);
  return useMutation({
    mutationKey: walletMutationKeys.disconnectWallet(mutationKey),
    mutationFn: async () => {
      var _a7;
      if (!currentWallet) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      try {
        await ((_a7 = currentWallet.features["standard:disconnect"]) == null ? void 0 : _a7.disconnect());
      } catch (error2) {
        console.error("Failed to disconnect the application from the current wallet.", error2);
      }
      setWalletDisconnected();
    },
    ...mutationOptions
  });
}
function useSwitchAccount({
  mutationKey,
  ...mutationOptions
} = {}) {
  const { currentWallet } = useCurrentWallet();
  const setAccountSwitched = useWalletStore((state) => state.setAccountSwitched);
  return useMutation({
    mutationKey: walletMutationKeys.switchAccount(mutationKey),
    mutationFn: async ({ account }) => {
      if (!currentWallet) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      const accountToSelect = currentWallet.accounts.find(
        (walletAccount) => walletAccount.address === account.address
      );
      if (!accountToSelect) {
        throw new WalletAccountNotFoundError(
          `No account with address ${account.address} is connected to ${currentWallet.name}.`
        );
      }
      setAccountSwitched(accountToSelect);
    },
    ...mutationOptions
  });
}
var themeContractValues = {
  blurs: {
    modalOverlay: ""
  },
  backgroundColors: {
    primaryButton: "",
    primaryButtonHover: "",
    outlineButtonHover: "",
    walletItemHover: "",
    walletItemSelected: "",
    modalOverlay: "",
    modalPrimary: "",
    modalSecondary: "",
    iconButton: "",
    iconButtonHover: "",
    dropdownMenu: "",
    dropdownMenuSeparator: ""
  },
  borderColors: {
    outlineButton: ""
  },
  colors: {
    primaryButton: "",
    outlineButton: "",
    body: "",
    bodyMuted: "",
    bodyDanger: "",
    iconButton: ""
  },
  radii: {
    small: "",
    medium: "",
    large: "",
    xlarge: ""
  },
  shadows: {
    primaryButton: "",
    walletItemSelected: ""
  },
  fontWeights: {
    normal: "",
    medium: "",
    bold: ""
  },
  fontSizes: {
    small: "",
    medium: "",
    large: "",
    xlarge: ""
  },
  typography: {
    fontFamily: "",
    fontStyle: "",
    lineHeight: "",
    letterSpacing: ""
  }
};
var themeVars = createGlobalThemeContract(
  themeContractValues,
  (_, path) => `dapp-kit-${path.join("-")}`
);
function useReportTransactionEffects({
  mutationKey,
  ...mutationOptions
} = {}) {
  const { currentWallet } = useCurrentWallet();
  const currentAccount = useCurrentAccount();
  return useMutation({
    mutationKey: walletMutationKeys.reportTransactionEffects(mutationKey),
    mutationFn: async ({ effects, chain: chain2 = currentWallet == null ? void 0 : currentWallet.chains[0], account = currentAccount }) => {
      if (!currentWallet) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      if (!account) {
        throw new WalletNoAccountSelectedError(
          "No wallet account is selected to report transaction effects for"
        );
      }
      const reportTransactionEffectsFeature = currentWallet.features["sui:reportTransactionEffects"];
      if (reportTransactionEffectsFeature) {
        return await reportTransactionEffectsFeature.reportTransactionEffects({
          effects: Array.isArray(effects) ? toBase64(new Uint8Array(effects)) : effects,
          account,
          chain: chain2 ?? (currentWallet == null ? void 0 : currentWallet.chains[0])
        });
      }
    },
    ...mutationOptions
  });
}
function useSignAndExecuteTransaction({
  mutationKey,
  execute: execute2,
  ...mutationOptions
} = {}) {
  const { currentWallet, supportedIntents } = useCurrentWallet();
  const currentAccount = useCurrentAccount();
  const { client, network } = useSuiClientContext();
  const { mutate: reportTransactionEffects } = useReportTransactionEffects();
  const executeTransaction = execute2 ?? (async ({ bytes, signature }) => {
    const { digest, rawEffects } = await client.executeTransactionBlock({
      transactionBlock: bytes,
      signature,
      options: {
        showRawEffects: true
      }
    });
    return {
      digest,
      rawEffects,
      effects: toBase64(new Uint8Array(rawEffects)),
      bytes,
      signature
    };
  });
  return useMutation({
    mutationKey: walletMutationKeys.signAndExecuteTransaction(mutationKey),
    mutationFn: async ({ transaction, ...signTransactionArgs }) => {
      var _a7;
      if (!currentWallet) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      const signerAccount = signTransactionArgs.account ?? currentAccount;
      if (!signerAccount) {
        throw new WalletNoAccountSelectedError(
          "No wallet account is selected to sign the transaction with."
        );
      }
      if (!currentWallet.features["sui:signTransaction"] && !currentWallet.features["sui:signTransactionBlock"]) {
        throw new WalletFeatureNotSupportedError(
          "This wallet doesn't support the `signTransaction` feature."
        );
      }
      const chain2 = signTransactionArgs.chain ?? `sui:${network}`;
      const { signature, bytes } = await signTransaction2(currentWallet, {
        ...signTransactionArgs,
        transaction: {
          async toJSON() {
            return typeof transaction === "string" ? transaction : await transaction.toJSON({
              supportedIntents,
              client
            });
          }
        },
        account: signerAccount,
        chain: chain2
      });
      const result = await executeTransaction({ bytes, signature });
      let effects;
      if ("effects" in result && ((_a7 = result.effects) == null ? void 0 : _a7.bcs)) {
        effects = result.effects.bcs;
      } else if ("rawEffects" in result) {
        effects = toBase64(new Uint8Array(result.rawEffects));
      } else {
        throw new Error("Could not parse effects from transaction result.");
      }
      reportTransactionEffects({ effects, account: signerAccount, chain: chain2 });
      return result;
    },
    ...mutationOptions
  });
}
function useSignTransaction({
  mutationKey,
  ...mutationOptions
} = {}) {
  const { currentWallet } = useCurrentWallet();
  const currentAccount = useCurrentAccount();
  const { client, network } = useSuiClientContext();
  const { mutate: reportTransactionEffects } = useReportTransactionEffects();
  return useMutation({
    mutationKey: walletMutationKeys.signTransaction(mutationKey),
    mutationFn: async ({ transaction, ...signTransactionArgs }) => {
      if (!currentWallet) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      const signerAccount = signTransactionArgs.account ?? currentAccount;
      if (!signerAccount) {
        throw new WalletNoAccountSelectedError(
          "No wallet account is selected to sign the transaction with."
        );
      }
      if (!currentWallet.features["sui:signTransaction"] && !currentWallet.features["sui:signTransactionBlock"]) {
        throw new WalletFeatureNotSupportedError(
          "This wallet doesn't support the `signTransaction` feature."
        );
      }
      const chain2 = signTransactionArgs.chain ?? `sui:${network}`;
      const { bytes, signature } = await signTransaction2(currentWallet, {
        ...signTransactionArgs,
        transaction: {
          toJSON: async () => {
            return typeof transaction === "string" ? transaction : await transaction.toJSON({
              supportedIntents: [],
              client
            });
          }
        },
        account: signerAccount,
        chain: chain2
      });
      return {
        bytes,
        signature,
        reportTransactionEffects: (effects) => {
          reportTransactionEffects({
            effects,
            account: signerAccount,
            chain: chain2
          });
        }
      };
    },
    ...mutationOptions
  });
}

// ../node_modules/@cetusprotocol/terminal/dist/cetus-swap.es.js
var m6 = Object.defineProperty;
var g6 = (e10, t10, r10) => t10 in e10 ? m6(e10, t10, { enumerable: true, configurable: true, writable: true, value: r10 }) : e10[t10] = r10;
var mt = (e10, t10, r10) => (g6(e10, typeof t10 != "symbol" ? t10 + "" : t10, r10), r10);
function I6(e10) {
  return e10 && e10.__esModule && Object.prototype.hasOwnProperty.call(e10, "default") ? e10.default : e10;
}
var Wm = { exports: {} };
var pr = Wm.exports = {};
var Kn;
var Yn;
function hf() {
  throw new Error("setTimeout has not been defined");
}
function pf() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Kn = setTimeout : Kn = hf;
  } catch {
    Kn = hf;
  }
  try {
    typeof clearTimeout == "function" ? Yn = clearTimeout : Yn = pf;
  } catch {
    Yn = pf;
  }
})();
function Gm(e10) {
  if (Kn === setTimeout)
    return setTimeout(e10, 0);
  if ((Kn === hf || !Kn) && setTimeout)
    return Kn = setTimeout, setTimeout(e10, 0);
  try {
    return Kn(e10, 0);
  } catch {
    try {
      return Kn.call(null, e10, 0);
    } catch {
      return Kn.call(this, e10, 0);
    }
  }
}
function O6(e10) {
  if (Yn === clearTimeout)
    return clearTimeout(e10);
  if ((Yn === pf || !Yn) && clearTimeout)
    return Yn = clearTimeout, clearTimeout(e10);
  try {
    return Yn(e10);
  } catch {
    try {
      return Yn.call(null, e10);
    } catch {
      return Yn.call(this, e10);
    }
  }
}
var Si = [];
var us = false;
var Ao;
var fc = -1;
function R6() {
  !us || !Ao || (us = false, Ao.length ? Si = Ao.concat(Si) : fc = -1, Si.length && Km());
}
function Km() {
  if (!us) {
    var e10 = Gm(R6);
    us = true;
    for (var t10 = Si.length; t10; ) {
      for (Ao = Si, Si = []; ++fc < t10; )
        Ao && Ao[fc].run();
      fc = -1, t10 = Si.length;
    }
    Ao = null, us = false, O6(e10);
  }
}
pr.nextTick = function(e10) {
  var t10 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r10 = 1; r10 < arguments.length; r10++)
      t10[r10 - 1] = arguments[r10];
  Si.push(new Ym(e10, t10)), Si.length === 1 && !us && Gm(Km);
};
function Ym(e10, t10) {
  this.fun = e10, this.array = t10;
}
Ym.prototype.run = function() {
  this.fun.apply(null, this.array);
};
pr.title = "browser";
pr.browser = true;
pr.env = {};
pr.argv = [];
pr.version = "";
pr.versions = {};
function ji() {
}
pr.on = ji;
pr.addListener = ji;
pr.once = ji;
pr.off = ji;
pr.removeListener = ji;
pr.removeAllListeners = ji;
pr.emit = ji;
pr.prependListener = ji;
pr.prependOnceListener = ji;
pr.listeners = function(e10) {
  return [];
};
pr.binding = function(e10) {
  throw new Error("process.binding is not supported");
};
pr.cwd = function() {
  return "/";
};
pr.chdir = function(e10) {
  throw new Error("process.chdir is not supported");
};
pr.umask = function() {
  return 0;
};
var P6 = Wm.exports;
var Rn = I6(P6);
var Rr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oa(e10) {
  return e10 && e10.__esModule && Object.prototype.hasOwnProperty.call(e10, "default") ? e10.default : e10;
}
function Xm(e10) {
  if (e10.__esModule)
    return e10;
  var t10 = e10.default;
  if (typeof t10 == "function") {
    var r10 = function n10() {
      return this instanceof n10 ? Reflect.construct(t10, arguments, this.constructor) : t10.apply(this, arguments);
    };
    r10.prototype = t10.prototype;
  } else
    r10 = {};
  return Object.defineProperty(r10, "__esModule", { value: true }), Object.keys(e10).forEach(function(n10) {
    var i10 = Object.getOwnPropertyDescriptor(e10, n10);
    Object.defineProperty(r10, n10, i10.get ? i10 : {
      enumerable: true,
      get: function() {
        return e10[n10];
      }
    });
  }), r10;
}
var mf = { exports: {} };
var Vs = {};
var lh;
function N6() {
  if (lh)
    return Vs;
  lh = 1;
  var e10 = import_react25.default, t10 = Symbol.for("react.element"), r10 = Symbol.for("react.fragment"), n10 = Object.prototype.hasOwnProperty, i10 = e10.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o10 = { key: true, ref: true, __self: true, __source: true };
  function s10(a10, c, l10) {
    var u10, d6 = {}, p = null, y = null;
    l10 !== void 0 && (p = "" + l10), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (y = c.ref);
    for (u10 in c)
      n10.call(c, u10) && !o10.hasOwnProperty(u10) && (d6[u10] = c[u10]);
    if (a10 && a10.defaultProps)
      for (u10 in c = a10.defaultProps, c)
        d6[u10] === void 0 && (d6[u10] = c[u10]);
    return { $$typeof: t10, type: a10, key: p, ref: y, props: d6, _owner: i10.current };
  }
  return Vs.Fragment = r10, Vs.jsx = s10, Vs.jsxs = s10, Vs;
}
var zs = {};
var uh;
function j6() {
  return uh || (uh = 1, Rn.env.NODE_ENV !== "production" && function() {
    var e10 = import_react25.default, t10 = Symbol.for("react.element"), r10 = Symbol.for("react.portal"), n10 = Symbol.for("react.fragment"), i10 = Symbol.for("react.strict_mode"), o10 = Symbol.for("react.profiler"), s10 = Symbol.for("react.provider"), a10 = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l10 = Symbol.for("react.suspense"), u10 = Symbol.for("react.suspense_list"), d6 = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), x = Symbol.iterator, b = "@@iterator";
    function M(V) {
      if (V === null || typeof V != "object")
        return null;
      var se = x && V[x] || V[b];
      return typeof se == "function" ? se : null;
    }
    var O = e10.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function P(V) {
      {
        for (var se = arguments.length, ue = new Array(se > 1 ? se - 1 : 0), Oe = 1; Oe < se; Oe++)
          ue[Oe - 1] = arguments[Oe];
        j("error", V, ue);
      }
    }
    function j(V, se, ue) {
      {
        var Oe = O.ReactDebugCurrentFrame, ze = Oe.getStackAddendum();
        ze !== "" && (se += "%s", ue = ue.concat([ze]));
        var Re = ue.map(function(Ue) {
          return String(Ue);
        });
        Re.unshift("Warning: " + se), Function.prototype.apply.call(console[V], console, Re);
      }
    }
    var F = false, B = false, W = false, z = false, G = false, re;
    re = Symbol.for("react.module.reference");
    function ie(V) {
      return !!(typeof V == "string" || typeof V == "function" || V === n10 || V === o10 || G || V === i10 || V === l10 || V === u10 || z || V === y || F || B || W || typeof V == "object" && V !== null && (V.$$typeof === p || V.$$typeof === d6 || V.$$typeof === s10 || V.$$typeof === a10 || V.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      V.$$typeof === re || V.getModuleId !== void 0));
    }
    function oe(V, se, ue) {
      var Oe = V.displayName;
      if (Oe)
        return Oe;
      var ze = se.displayName || se.name || "";
      return ze !== "" ? ue + "(" + ze + ")" : ue;
    }
    function q(V) {
      return V.displayName || "Context";
    }
    function L(V) {
      if (V == null)
        return null;
      if (typeof V.tag == "number" && P("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof V == "function")
        return V.displayName || V.name || null;
      if (typeof V == "string")
        return V;
      switch (V) {
        case n10:
          return "Fragment";
        case r10:
          return "Portal";
        case o10:
          return "Profiler";
        case i10:
          return "StrictMode";
        case l10:
          return "Suspense";
        case u10:
          return "SuspenseList";
      }
      if (typeof V == "object")
        switch (V.$$typeof) {
          case a10:
            var se = V;
            return q(se) + ".Consumer";
          case s10:
            var ue = V;
            return q(ue._context) + ".Provider";
          case c:
            return oe(V, V.render, "ForwardRef");
          case d6:
            var Oe = V.displayName || null;
            return Oe !== null ? Oe : L(V.type) || "Memo";
          case p: {
            var ze = V, Re = ze._payload, Ue = ze._init;
            try {
              return L(Ue(Re));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var h = Object.assign, f = 0, m, S, T, E, I, C, g;
    function v10() {
    }
    v10.__reactDisabledLog = true;
    function k() {
      {
        if (f === 0) {
          m = console.log, S = console.info, T = console.warn, E = console.error, I = console.group, C = console.groupCollapsed, g = console.groupEnd;
          var V = {
            configurable: true,
            enumerable: true,
            value: v10,
            writable: true
          };
          Object.defineProperties(console, {
            info: V,
            log: V,
            warn: V,
            error: V,
            group: V,
            groupCollapsed: V,
            groupEnd: V
          });
        }
        f++;
      }
    }
    function Q() {
      {
        if (f--, f === 0) {
          var V = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: h({}, V, {
              value: m
            }),
            info: h({}, V, {
              value: S
            }),
            warn: h({}, V, {
              value: T
            }),
            error: h({}, V, {
              value: E
            }),
            group: h({}, V, {
              value: I
            }),
            groupCollapsed: h({}, V, {
              value: C
            }),
            groupEnd: h({}, V, {
              value: g
            })
          });
        }
        f < 0 && P("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Z = O.ReactCurrentDispatcher, ae;
    function ve(V, se, ue) {
      {
        if (ae === void 0)
          try {
            throw Error();
          } catch (ze) {
            var Oe = ze.stack.trim().match(/\n( *(at )?)/);
            ae = Oe && Oe[1] || "";
          }
        return `
` + ae + V;
      }
    }
    var we = false, he;
    {
      var De = typeof WeakMap == "function" ? WeakMap : Map;
      he = new De();
    }
    function Te(V, se) {
      if (!V || we)
        return "";
      {
        var ue = he.get(V);
        if (ue !== void 0)
          return ue;
      }
      var Oe;
      we = true;
      var ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Re;
      Re = Z.current, Z.current = null, k();
      try {
        if (se) {
          var Ue = function() {
            throw Error();
          };
          if (Object.defineProperty(Ue.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ue, []);
            } catch (er) {
              Oe = er;
            }
            Reflect.construct(V, [], Ue);
          } else {
            try {
              Ue.call();
            } catch (er) {
              Oe = er;
            }
            V.call(Ue.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (er) {
            Oe = er;
          }
          V();
        }
      } catch (er) {
        if (er && Oe && typeof er.stack == "string") {
          for (var it = er.stack.split(`
`), Qt = Oe.stack.split(`
`), Lt = it.length - 1, Vt = Qt.length - 1; Lt >= 1 && Vt >= 0 && it[Lt] !== Qt[Vt]; )
            Vt--;
          for (; Lt >= 1 && Vt >= 0; Lt--, Vt--)
            if (it[Lt] !== Qt[Vt]) {
              if (Lt !== 1 || Vt !== 1)
                do
                  if (Lt--, Vt--, Vt < 0 || it[Lt] !== Qt[Vt]) {
                    var cr = `
` + it[Lt].replace(" at new ", " at ");
                    return V.displayName && cr.includes("<anonymous>") && (cr = cr.replace("<anonymous>", V.displayName)), typeof V == "function" && he.set(V, cr), cr;
                  }
                while (Lt >= 1 && Vt >= 0);
              break;
            }
        }
      } finally {
        we = false, Z.current = Re, Q(), Error.prepareStackTrace = ze;
      }
      var Ar = V ? V.displayName || V.name : "", dr = Ar ? ve(Ar) : "";
      return typeof V == "function" && he.set(V, dr), dr;
    }
    function Xe(V, se, ue) {
      return Te(V, false);
    }
    function ft(V) {
      var se = V.prototype;
      return !!(se && se.isReactComponent);
    }
    function je(V, se, ue) {
      if (V == null)
        return "";
      if (typeof V == "function")
        return Te(V, ft(V));
      if (typeof V == "string")
        return ve(V);
      switch (V) {
        case l10:
          return ve("Suspense");
        case u10:
          return ve("SuspenseList");
      }
      if (typeof V == "object")
        switch (V.$$typeof) {
          case c:
            return Xe(V.render);
          case d6:
            return je(V.type, se, ue);
          case p: {
            var Oe = V, ze = Oe._payload, Re = Oe._init;
            try {
              return je(Re(ze), se, ue);
            } catch {
            }
          }
        }
      return "";
    }
    var ht = Object.prototype.hasOwnProperty, ye = {}, de = O.ReactDebugCurrentFrame;
    function Ee(V) {
      if (V) {
        var se = V._owner, ue = je(V.type, V._source, se ? se.type : null);
        de.setExtraStackFrame(ue);
      } else
        de.setExtraStackFrame(null);
    }
    function $e(V, se, ue, Oe, ze) {
      {
        var Re = Function.call.bind(ht);
        for (var Ue in V)
          if (Re(V, Ue)) {
            var it = void 0;
            try {
              if (typeof V[Ue] != "function") {
                var Qt = Error((Oe || "React class") + ": " + ue + " type `" + Ue + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof V[Ue] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Qt.name = "Invariant Violation", Qt;
              }
              it = V[Ue](se, Ue, Oe, ue, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Lt) {
              it = Lt;
            }
            it && !(it instanceof Error) && (Ee(ze), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Oe || "React class", ue, Ue, typeof it), Ee(null)), it instanceof Error && !(it.message in ye) && (ye[it.message] = true, Ee(ze), P("Failed %s type: %s", ue, it.message), Ee(null));
          }
      }
    }
    var Ne = Array.isArray;
    function Ce(V) {
      return Ne(V);
    }
    function Ae(V) {
      {
        var se = typeof Symbol == "function" && Symbol.toStringTag, ue = se && V[Symbol.toStringTag] || V.constructor.name || "Object";
        return ue;
      }
    }
    function Be(V) {
      try {
        return lt(V), false;
      } catch {
        return true;
      }
    }
    function lt(V) {
      return "" + V;
    }
    function ut(V) {
      if (Be(V))
        return P("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ae(V)), lt(V);
    }
    var Ve = O.ReactCurrentOwner, kt = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, _t, Ge, Ot;
    Ot = {};
    function $t(V) {
      if (ht.call(V, "ref")) {
        var se = Object.getOwnPropertyDescriptor(V, "ref").get;
        if (se && se.isReactWarning)
          return false;
      }
      return V.ref !== void 0;
    }
    function Qe(V) {
      if (ht.call(V, "key")) {
        var se = Object.getOwnPropertyDescriptor(V, "key").get;
        if (se && se.isReactWarning)
          return false;
      }
      return V.key !== void 0;
    }
    function Et(V, se) {
      if (typeof V.ref == "string" && Ve.current && se && Ve.current.stateNode !== se) {
        var ue = L(Ve.current.type);
        Ot[ue] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', L(Ve.current.type), V.ref), Ot[ue] = true);
      }
    }
    function Rt(V, se) {
      {
        var ue = function() {
          _t || (_t = true, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        ue.isReactWarning = true, Object.defineProperty(V, "key", {
          get: ue,
          configurable: true
        });
      }
    }
    function rt(V, se) {
      {
        var ue = function() {
          Ge || (Ge = true, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        ue.isReactWarning = true, Object.defineProperty(V, "ref", {
          get: ue,
          configurable: true
        });
      }
    }
    var Dt = function(V, se, ue, Oe, ze, Re, Ue) {
      var it = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t10,
        // Built-in properties that belong on the element
        type: V,
        key: se,
        ref: ue,
        props: Ue,
        // Record the component responsible for creating this element.
        _owner: Re
      };
      return it._store = {}, Object.defineProperty(it._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(it, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Oe
      }), Object.defineProperty(it, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: ze
      }), Object.freeze && (Object.freeze(it.props), Object.freeze(it)), it;
    };
    function Nt(V, se, ue, Oe, ze) {
      {
        var Re, Ue = {}, it = null, Qt = null;
        ue !== void 0 && (ut(ue), it = "" + ue), Qe(se) && (ut(se.key), it = "" + se.key), $t(se) && (Qt = se.ref, Et(se, ze));
        for (Re in se)
          ht.call(se, Re) && !kt.hasOwnProperty(Re) && (Ue[Re] = se[Re]);
        if (V && V.defaultProps) {
          var Lt = V.defaultProps;
          for (Re in Lt)
            Ue[Re] === void 0 && (Ue[Re] = Lt[Re]);
        }
        if (it || Qt) {
          var Vt = typeof V == "function" ? V.displayName || V.name || "Unknown" : V;
          it && Rt(Ue, Vt), Qt && rt(Ue, Vt);
        }
        return Dt(V, it, Qt, ze, Oe, Ve.current, Ue);
      }
    }
    var et = O.ReactCurrentOwner, wt = O.ReactDebugCurrentFrame;
    function Ct(V) {
      if (V) {
        var se = V._owner, ue = je(V.type, V._source, se ? se.type : null);
        wt.setExtraStackFrame(ue);
      } else
        wt.setExtraStackFrame(null);
    }
    var We;
    We = false;
    function pt(V) {
      return typeof V == "object" && V !== null && V.$$typeof === t10;
    }
    function jt() {
      {
        if (et.current) {
          var V = L(et.current.type);
          if (V)
            return `

Check the render method of \`` + V + "`.";
        }
        return "";
      }
    }
    function nt(V) {
      {
        if (V !== void 0) {
          var se = V.fileName.replace(/^.*[\\\/]/, ""), ue = V.lineNumber;
          return `

Check your code at ` + se + ":" + ue + ".";
        }
        return "";
      }
    }
    var xt = {};
    function Ht(V) {
      {
        var se = jt();
        if (!se) {
          var ue = typeof V == "string" ? V : V.displayName || V.name;
          ue && (se = `

Check the top-level render call using <` + ue + ">.");
        }
        return se;
      }
    }
    function N(V, se) {
      {
        if (!V._store || V._store.validated || V.key != null)
          return;
        V._store.validated = true;
        var ue = Ht(se);
        if (xt[ue])
          return;
        xt[ue] = true;
        var Oe = "";
        V && V._owner && V._owner !== et.current && (Oe = " It was passed a child from " + L(V._owner.type) + "."), Ct(V), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ue, Oe), Ct(null);
      }
    }
    function _(V, se) {
      {
        if (typeof V != "object")
          return;
        if (Ce(V))
          for (var ue = 0; ue < V.length; ue++) {
            var Oe = V[ue];
            pt(Oe) && N(Oe, se);
          }
        else if (pt(V))
          V._store && (V._store.validated = true);
        else if (V) {
          var ze = M(V);
          if (typeof ze == "function" && ze !== V.entries)
            for (var Re = ze.call(V), Ue; !(Ue = Re.next()).done; )
              pt(Ue.value) && N(Ue.value, se);
        }
      }
    }
    function A(V) {
      {
        var se = V.type;
        if (se == null || typeof se == "string")
          return;
        var ue;
        if (typeof se == "function")
          ue = se.propTypes;
        else if (typeof se == "object" && (se.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        se.$$typeof === d6))
          ue = se.propTypes;
        else
          return;
        if (ue) {
          var Oe = L(se);
          $e(ue, V.props, "prop", Oe, V);
        } else if (se.PropTypes !== void 0 && !We) {
          We = true;
          var ze = L(se);
          P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ze || "Unknown");
        }
        typeof se.getDefaultProps == "function" && !se.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function U(V) {
      {
        for (var se = Object.keys(V.props), ue = 0; ue < se.length; ue++) {
          var Oe = se[ue];
          if (Oe !== "children" && Oe !== "key") {
            Ct(V), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Oe), Ct(null);
            break;
          }
        }
        V.ref !== null && (Ct(V), P("Invalid attribute `ref` supplied to `React.Fragment`."), Ct(null));
      }
    }
    var Y = {};
    function ee(V, se, ue, Oe, ze, Re) {
      {
        var Ue = ie(V);
        if (!Ue) {
          var it = "";
          (V === void 0 || typeof V == "object" && V !== null && Object.keys(V).length === 0) && (it += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Qt = nt(ze);
          Qt ? it += Qt : it += jt();
          var Lt;
          V === null ? Lt = "null" : Ce(V) ? Lt = "array" : V !== void 0 && V.$$typeof === t10 ? (Lt = "<" + (L(V.type) || "Unknown") + " />", it = " Did you accidentally export a JSX literal instead of a component?") : Lt = typeof V, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Lt, it);
        }
        var Vt = Nt(V, se, ue, ze, Re);
        if (Vt == null)
          return Vt;
        if (Ue) {
          var cr = se.children;
          if (cr !== void 0)
            if (Oe)
              if (Ce(cr)) {
                for (var Ar = 0; Ar < cr.length; Ar++)
                  _(cr[Ar], V);
                Object.freeze && Object.freeze(cr);
              } else
                P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _(cr, V);
        }
        if (ht.call(se, "key")) {
          var dr = L(V), er = Object.keys(se).filter(function(Wr) {
            return Wr !== "key";
          }), _r = er.length > 0 ? "{key: someKey, " + er.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Y[dr + _r]) {
            var wn = er.length > 0 ? "{" + er.join(": ..., ") + ": ...}" : "{}";
            P(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, _r, dr, wn, dr), Y[dr + _r] = true;
          }
        }
        return V === n10 ? U(Vt) : A(Vt), Vt;
      }
    }
    function ne(V, se, ue) {
      return ee(V, se, ue, true);
    }
    function ke(V, se, ue) {
      return ee(V, se, ue, false);
    }
    var Je = ke, Pe = ne;
    zs.Fragment = n10, zs.jsx = Je, zs.jsxs = Pe;
  }()), zs;
}
Rn.env.NODE_ENV === "production" ? mf.exports = N6() : mf.exports = j6();
var w = mf.exports;
window._iconfont_svg_string_4776227 = '<svg><symbol id="icon-link2" viewBox="0 0 1024 1024"><path d="M642.7648 217.6a166.5024 166.5024 0 0 1 166.5024 166.5024v256.256a166.5024 166.5024 0 0 1-166.5024 166.5024H386.5088a92.16 92.16 0 0 1-64.9728-157.5936L506.88 465.2032H429.2096a38.4 38.4 0 0 1-38.0416-33.1776l-0.3584-5.2224a38.4 38.4 0 0 1 38.4-38.4h170.8544l1.4336 0.0512c0.8704 0 1.6896 0.1024 2.56 0.1536l-3.9936-0.2048a38.656 38.656 0 0 1 27.2384 11.3664l1.792 1.9456 1.536 1.8944-3.328-3.84a38.6048 38.6048 0 0 1 11.1616 27.0336v170.8544a38.4 38.4 0 0 1-76.8 0l-0.0512-78.592-185.9584 184.6784a15.36 15.36 0 0 0 7.3216 25.9072l3.584 0.4096h256.2048c49.5616 0 89.7024-40.1408 89.7024-89.7024V384.1024c0-49.5104-40.1408-89.7024-89.7024-89.7024H386.5088c-49.5616 0-89.7024 40.192-89.7024 89.7024V563.2a38.4 38.4 0 0 1-76.8 0V384.1024A166.5024 166.5024 0 0 1 386.5088 217.6h256.256z"  ></path></symbol><symbol id="icon-more" viewBox="0 0 1024 1024"><path d="M499.2 217.6m0-64a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"  ></path><path d="M499.2 524.8m0-64a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"  ></path><path d="M499.2 832m0-64a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"  ></path></symbol><symbol id="icon-docs" viewBox="0 0 1024 1024"><path d="M665.6 41.728c65.9456 0 121.2928 45.312 136.6016 106.496 5.0688-2.6624 10.8544-4.096 16.9984-4.096a140.8 140.8 0 0 1 140.8 140.8v563.2a140.8 140.8 0 0 1-140.8 140.8H358.4a140.8512 140.8512 0 0 1-135.4752-102.4H204.8a140.8 140.8 0 0 1-140.8-140.8v-563.2A140.8 140.8 0 0 1 204.8 41.728h460.8z m140.8 177.0496v526.9504a140.8 140.8 0 0 1-140.8 140.8l-358.4 0.1024c11.7248 15.5136 30.3104 25.4976 51.2 25.4976h460.8c35.328 0 64-28.672 64-64v-563.2c0-35.328-28.672-64-64-64a38.3488 38.3488 0 0 1-12.8-2.1504zM665.6 118.528H204.8c-35.328 0-64 28.672-64 64v563.2c0 35.328 28.672 64 64 64h460.8c35.328 0 64-28.672 64-64v-563.2c0-35.328-28.672-64-64-64z m-153.6 281.6a38.4 38.4 0 1 1 0 76.8H256a38.4 38.4 0 1 1 0-76.8h256z m102.4-153.6a38.4 38.4 0 1 1 0 76.8H256a38.4 38.4 0 1 1 0-76.8h358.4z"  ></path></symbol><symbol id="icon-link1" viewBox="0 0 1024 1024"><path d="M719.872 268.8l3.738 0.205 0.768 0.051-4.506-0.256a38.502 38.502 0 0 1 28.416 12.544l0.973 1.126a38.554 38.554 0 0 1 1.74 2.253l-2.713-3.379a38.605 38.605 0 0 1 9.984 25.549V563.2a38.4 38.4 0 1 1-76.8 0V394.086L281.856 758.221a38.4 38.4 0 0 1-51.712-56.832L620.646 345.6H463.872a38.4 38.4 0 0 1-38.042-33.178l-0.358-5.222a38.4 38.4 0 0 1 38.4-38.4h256z"  ></path></symbol><symbol id="icon-icon-kfckfc" viewBox="0 0 1024 1024"><path d="M53.504 102.912c-0.41 0.563 30.208 42.086 67.84 92.006L299.008 430.9 408.32 576l-7.014 7.885c-3.943 4.352-84.327 90.521-178.432 191.488C128.717 876.595 51.354 960 51.2 960.87c-0.358 0.922 16.077 1.69 39.731 1.536l40.243-0.204 13.21-14.49A217385.626 217385.626 0 0 0 440.32 629.914l4.71-5.479 37.837 50.33L610.048 843.93l89.6 118.63H836.71c114.023 0 136.858-0.358 136.141-2.458-0.563-1.484-35.328-48.025-77.312-103.782-41.984-55.603-90.01-119.398-106.65-141.568-16.793-22.17-66.15-88.064-110.028-146.074-43.879-58.163-79.821-106.598-79.821-107.366 0-1.331 231.782-251.187 310.58-334.746l22.527-23.808h-41.42l-41.217 0.154-48.179 51.814a48197.632 48197.632 0 0 1-144.23 154.88l-95.847 102.912L445.03 258.202 328.55 103.68l-137.062-0.922c-75.418-0.563-137.626-0.41-137.984 0.154z m324.762 166.4c44.8 59.7 113.97 151.5 153.65 204.288 39.732 52.531 127.796 169.677 195.892 259.994 68.045 90.47 124.365 165.376 125.286 166.707 1.178 1.69-12.288 2.253-61.235 2.253h-62.566L605.286 737.69c-286.208-379.802-430.592-571.7-432.332-574.516-1.127-1.69 11.724-2.252 61.081-2.252h62.567l81.664 108.39z"  ></path></symbol><symbol id="icon-icon_telegram" viewBox="0 0 1024 1024"><path d="M824.87808 503.6032c55.8592 0 100.096 12.544 133.4272 37.5296 34.2016 26.7264 55.9104 66.7136 64.2048 120.9344h-94.208c-5.8368-27.4944-17.5104-47.5136-34.2016-60.8768-17.5104-13.312-40.8576-19.968-69.2224-19.968-35.0208 0-62.5664 12.4928-82.5856 39.168-19.968 25.856-30.0032 62.5152-30.0032 109.2608 0 47.5136 9.216 85.0432 29.184 111.7184 18.3296 25.856 45.8752 39.2192 82.5856 39.2192 63.3856 0 98.4064-31.6928 105.8816-94.208H1024.19968c-9.984 58.368-32.512 101.7344-66.7136 130.048-33.3824 27.5456-78.3872 41.728-134.2976 41.728-66.7136 0-118.4256-21.7088-155.136-65.024-35.84-41.728-53.3504-95.9488-53.3504-162.6624 0-65.024 17.5104-118.4256 52.5312-159.2832 37.5296-45.056 90.112-67.584 157.6448-67.584z m75.7248-333.6704l-53.76 245.4528a353.792 353.792 0 0 0-12.6464-0.256c-164.096 0-316.3648 113.7664-357.0176 266.752L381.63968 771.9424c-11.6224 10.9056-20.7872 20.1216-41.5744 20.1216l14.1824-205.2608 385.1776-336.7424c16.896-14.5408-3.6352-21.6576-26.112-8.3968L237.76768 532.2752 32.35328 470.1696c-44.288-13.1584-44.544-42.7008 10.0352-64l800.3072-298.9568c36.5568-15.9744 71.8336 8.5504 57.856 62.72z"  ></path></symbol><symbol id="icon-icon_medium" viewBox="0 0 1024 1024"><path d="M576.819712 497.6128c-0.7168 169.6768-139.5712 294.7584-293.376 292.3008C127.795712 787.4048-0.357888 656.1792 0.000512 495.2064 0.358912 334.9504 130.611712 204.032 288.819712 204.8c159.9488 0.768 288.2048 131.1744 288 292.8128m27.904-1.536c0.9216-72.9088 12.3904-143.3088 50.1248-207.0528 7.168-12.1856 15.872-23.8592 25.6512-33.9968 44.4928-46.08 99.4816-44.0832 141.312 4.5056 28.8768 33.5872 45.8752 73.216 56.064 115.8656 24.576 102.5536 21.2992 203.5712-19.968 301.6704-11.9808 28.416-28.5184 54.2208-52.9408 73.728-36.2496 29.1328-76.8 29.3888-112.5376-0.3072-39.2704-32.6656-59.4944-77.5168-70.7584-125.696-9.8304-41.984-14.2848-85.248-21.0944-128l4.1472-0.7168M1024.000512 470.5792c-3.1744 93.952-4.9152 159.8976-22.1696 224.0512-3.0208 11.264-6.656 22.7328-12.4928 32.6656-3.8912 6.656-11.776 14.3872-18.3296 14.8992-5.3248 0.4096-14.08-8.192-16.6912-14.6944-7.5776-18.7392-14.848-38.0928-18.6368-57.9584-16.384-86.3744-18.4832-173.7216-10.496-261.0176 3.584-39.424 11.9296-78.4896 19.1488-117.5552 1.792-9.728 6.7584-19.2512 11.776-27.9552 9.728-16.4864 22.3744-16.896 30.9248 0 7.68 15.2576 15.0528 31.744 17.408 48.4864 8.8064 62.0544 15.4112 124.416 19.5584 159.0784"  ></path></symbol><symbol id="icon-icon_discord" viewBox="0 0 1024 1024"><path d="M831.8976 213.6064A748.032 748.032 0 0 0 641.7408 153.6c-8.192 14.848-17.7664 34.8672-24.3712 50.7904a694.8864 694.8864 0 0 0-210.688 0c-6.6048-15.872-16.384-35.8912-24.6272-50.7904a745.5744 745.5744 0 0 0-190.3104 60.16C71.424 396.4928 38.8096 574.6176 55.0912 750.2848a758.784 758.784 0 0 0 233.216 120.064c18.7904-26.0096 35.5328-53.6064 49.92-82.688a490.0864 490.0864 0 0 1-78.6432-38.4c6.656-4.9664 13.056-10.0864 19.3024-15.36 151.6544 71.2704 316.416 71.2704 466.2272 0 6.2976 5.2736 12.8 10.3936 19.3024 15.36a488.8576 488.8576 0 0 1-78.848 38.5024c14.4384 28.9792 31.1296 56.6784 49.9712 82.6368a757.2992 757.2992 0 0 0 233.3184-120.1152c19.1488-203.6224-32.6656-380.16-136.96-536.6784zM358.912 642.2528c-45.568 0-82.8416-42.7008-82.8416-94.72 0-51.968 36.5056-94.72 82.8416-94.72 46.336 0 83.6608 42.6496 82.8416 94.72 0.1024 52.0192-36.5056 94.72-82.8416 94.72z m306.176 0c-45.5168 0-82.8416-42.7008-82.8416-94.72 0-51.968 36.5056-94.72 82.8416-94.72 46.336 0 83.6608 42.6496 82.8416 94.72 0 52.0192-36.5056 94.72-82.8416 94.72z"  ></path></symbol><symbol id="icon-icon_del" viewBox="0 0 1024 1024"><path d="M512 64a243.2512 243.2512 0 0 1 240.1792 204.8h-1.3312a140.8 140.8 0 0 1 139.1104 162.4576l-63.6928 409.6a140.8 140.8 0 0 1-139.1616 119.1424H336.896a140.8 140.8 0 0 1-139.1616-119.1424l-63.6928-409.6A140.8 140.8 0 0 1 271.8208 268.8a243.2 243.2 0 0 1 240.1792-204.8z m238.848 281.6h-477.696A64 64 0 0 0 209.92 419.4304l63.6928 409.6A64 64 0 0 0 336.896 883.2h350.208a64 64 0 0 0 63.2832-54.1696l63.6928-409.6a64 64 0 0 0-63.232-73.8304zM409.6 473.6a38.4 38.4 0 0 1 38.4 38.4v204.8a38.4 38.4 0 1 1-76.8 0v-204.8A38.4 38.4 0 0 1 409.6 473.6z m204.8 0a38.4 38.4 0 0 1 38.4 38.4v204.8a38.4 38.4 0 1 1-76.8 0v-204.8a38.4 38.4 0 0 1 38.4-38.4z m-102.4-332.8a166.4512 166.4512 0 0 0-160.0512 120.7296l-1.8944 7.2704h323.84l-1.8432-7.2704a166.5024 166.5024 0 0 0-150.6304-120.4736L512 140.8z"  ></path></symbol><symbol id="icon-plorer" viewBox="0 0 1024 1024"><path d="M608 62.31l245.453 141.67a192 192 0 0 1 96 166.298v283.444a192 192 0 0 1-96 166.297L608 961.69a192 192 0 0 1-192 0L170.547 820.02a192 192 0 0 1-96-166.297V370.278a192 192 0 0 1 95.949-166.297L415.949 62.31a192 192 0 0 1 192 0z m-153.6 66.51L208.947 270.49a115.2 115.2 0 0 0-57.6 99.84v283.392a115.2 115.2 0 0 0 57.6 99.788L454.4 895.18a115.2 115.2 0 0 0 115.2 0l245.453-141.67a115.2 115.2 0 0 0 57.6-99.84V370.33a115.2 115.2 0 0 0-57.6-99.79L569.6 128.87a115.2 115.2 0 0 0-115.2 0zM726.886 324.3L577.741 764.11c-11.776 34.713-60.826 34.816-72.704 0.051L440.73 575.59l-197.94-71.987c-31.744-11.622-33.536-54.63-5.427-69.785l5.632-2.458 434.586-155.546a38.4 38.4 0 0 1 49.305 48.487z m-98.252 50.586L369.05 467.763l115.2 41.984a38.4 38.4 0 0 1 20.992 18.381l2.252 5.325 33.792 98.97 87.348-257.537z"  ></path></symbol><symbol id="icon-disconnect" viewBox="0 0 1024 1024"><path d="M575.357 738.274a38.4 38.4 0 0 1 0 54.306l-72.408 72.408A243.2 243.2 0 1 1 159.012 521.05l72.408-72.408a38.4 38.4 0 1 1 54.306 54.306l-72.408 72.408a166.4 166.4 0 0 0 235.325 235.325l72.408-72.408a38.4 38.4 0 0 1 54.306 0z m-108.612-181.02a38.4 38.4 0 0 1 0 54.307L358.134 720.172a38.4 38.4 0 1 1-54.306-54.306l108.611-108.611a38.4 38.4 0 0 1 54.306 0zM756.376 702.07a38.4 38.4 0 1 1-54.306 54.306L267.624 321.93a38.4 38.4 0 1 1 54.306-54.306L756.376 702.07z m-36.204-398.242a38.4 38.4 0 0 1 0 54.306L611.561 466.745a38.4 38.4 0 1 1-54.306-54.306l108.611-108.611a38.4 38.4 0 0 1 54.306 0z m144.816-144.816a243.2 243.2 0 0 1 0 343.937l-72.408 72.408a38.4 38.4 0 1 1-54.306-54.306l72.408-72.408a166.4 166.4 0 0 0-235.325-235.325l-72.408 72.408a38.4 38.4 0 0 1-54.306-54.306l72.408-72.408a243.2 243.2 0 0 1 343.937 0z"  ></path></symbol><symbol id="icon-copy" viewBox="0 0 1024 1024"><path d="M665.6 396.8a140.8 140.8 0 0 1 140.8 140.8v128a140.8 140.8 0 0 1-140.8 140.8h-128a140.8 140.8 0 0 1-140.8-140.8v-128a140.8 140.8 0 0 1 140.8-140.8h128z m0 76.8h-128c-35.328 0-64 28.672-64 64v128c0 35.328 28.672 64 64 64h128c35.328 0 64-28.672 64-64v-128c0-35.328-28.672-64-64-64z"  ></path><path d="M537.6 217.6c49.46 0 89.6 40.14 89.6 89.6v25.6a38.4 38.4 0 0 1-76.8 0v-25.6a12.8 12.8 0 0 0-12.8-12.8H307.2a12.8 12.8 0 0 0-12.8 12.8v230.4c0 7.066 5.734 12.8 12.8 12.8h25.6a38.4 38.4 0 0 1 0 76.8h-25.6a89.6 89.6 0 0 1-89.6-89.6V307.2c0-49.46 40.14-89.6 89.6-89.6h230.4z"  ></path></symbol><symbol id="icon-link" viewBox="0 0 1024 1024"><path d="M436.992 281.6a38.4 38.4 0 0 1 0 76.8 217.6 217.6 0 1 0 217.6 217.6 38.4 38.4 0 1 1 76.8 0 294.4 294.4 0 1 1-294.4-294.4z m385.28-102.4l3.8912 0.2048 0.6144 0.0512-4.5056-0.256a38.2464 38.2464 0 0 1 28.416 12.544l0.8704 1.024a38.5536 38.5536 0 0 1 2.0992 2.7136l-2.9696-3.7376a38.656 38.656 0 0 1 9.984 25.5488V473.6a38.4 38.4 0 1 1-76.8 0V304.4864l-399.616 364.1344a38.4 38.4 0 0 1-51.712-56.832L723.0464 256H566.272a38.4 38.4 0 0 1-38.0416-33.1776l-0.3584-5.2224a38.4 38.4 0 0 1 38.4-38.4h256z"  ></path></symbol><symbol id="icon-unfold" viewBox="0 0 2048 1024"><path d="M565.248 78.131a76.8 76.8 0 0 1 108.544 0l362.086 361.984a25.6 25.6 0 0 0 36.25 0l361.984-361.984a76.8 76.8 0 0 1 108.544 108.544l-361.984 362.189a179.2 179.2 0 0 1-253.44 0L565.248 186.675a76.8 76.8 0 0 1 0-108.544z"  ></path></symbol><symbol id="icon-rpc" viewBox="0 0 1024 1024"><path d="M204.8 678.4a140.8 140.8 0 1 1 0 281.6 140.8 140.8 0 0 1 0-281.6z m168.96-573.44a268.8 268.8 0 0 1 207.872 439.245l38.144 38.144a192 192 0 1 1-55.603 53.094l-39.27-39.373A268.8 268.8 0 1 1 373.76 104.96zM204.8 755.2a64 64 0 1 0 0 128 64 64 0 0 0 0-128z m517.12-125.44a115.2 115.2 0 1 0 0 230.4 115.2 115.2 0 0 0 0-230.4z m-348.16-448a192 192 0 1 0 0 384 192 192 0 0 0 0-384zM819.2 64a140.8 140.8 0 1 1 0 281.6 140.8 140.8 0 0 1 0-281.6z m0 76.8a64 64 0 1 0 0 128 64 64 0 0 0 0-128z"  ></path></symbol><symbol id="icon-mev" viewBox="0 0 1024 1024"><path d="M651.162 95.488c53.401 56.422 131.84 113.818 235.212 171.674a38.4 38.4 0 0 1 19.456 29.9c12.032 129.024-12.544 251.75-73.625 367.156-60.211 113.817-158.976 226.457-295.936 338.33a38.4 38.4 0 0 1-48.589 0C356.608 895.436 259.328 782.181 196.045 662.681c-64.103-121.19-90.266-243.405-77.824-365.876a38.4 38.4 0 0 1 20.531-30.259C239.923 214.323 319.846 156.98 378.624 94.925c104.96-110.95 169.37-108.442 272.538 0.512z m126.464 196.506l-1.178 0.819a41.933 41.933 0 0 1-10.035 3.84c-4.25 1.024-5.427 1.28-14.695 3.328a122.368 122.368 0 0 0-16.896 4.403c-43.878 16.384-71.168 47.411-83.097 96.666-2.304 9.625-3.328 20.838-3.687 38.4l-0.204 13.516v15.872l0.05 9.728v2.048l0.052 3.482c0.256 35.328 0.154 51.2-1.024 71.424-4.506 79.36-42.291 140.39-108.954 178.483-29.542 16.896-61.9 23.962-99.328 23.91h-8.704a9243.136 9243.136 0 0 0-29.286-0.153h-17.46l-10.034-0.051h-22.938c40.448 50.841 88.371 100.71 143.77 149.504l17.97 15.513 17.511-14.899c101.018-88.064 176.077-175.513 225.28-262.144l9.523-17.408c50.893-96.205 73.063-197.273 66.56-303.974l-3.584-2.407a1479.786 1479.786 0 0 1-49.664-29.9z m-171.52 5.12h-1.127c-15.155 0.102-30.054 3.584-45.107 10.598-46.285 21.504-77.056 71.373-76.39 128.051 0.307 25.703 0.256 51.354 0 87.603l-0.103 10.445c-0.102 14.49-0.512 24.371-1.74 34.816-4.865 42.803-19.661 79.77-43.674 110.285l-1.792 2.15 1.331 0.052h1.331c24.832 0 44.288-4.199 61.03-13.824 44.033-25.19 67.38-62.72 70.4-116.122 1.025-18.022 1.127-32.768 0.871-66.56v-5.478l-0.051-5.223v-21.504c0-5.12 0.051-9.728 0.153-14.49 0.512-22.681 1.895-38.604 5.837-54.937a225.075 225.075 0 0 1 35.687-79.514l4.71-6.246h-11.366z m1.484-136.295l-12.236-12.544c-73.728-77.926-87.245-78.438-160.973-0.563-60.467 63.898-139.674 122.112-237.466 174.95l-3.942 2.048-0.768 17.562c-2.407 88.064 18.176 176.384 61.952 265.42l9.779 19.047c9.267 17.51 19.354 34.919 30.26 52.224l-0.871 0.154c2.406-0.512 2.406-0.512 6.144-0.973 15.104-1.536 29.593-6.86 43.776-15.974 36.454-23.552 56.883-56.576 62.105-102.247 0.82-7.168 1.127-14.848 1.23-26.726l0.102-10.343c0.256-35.84 0.307-61.132 0-86.22-1.024-86.58 46.899-164.199 120.78-198.554a183.552 183.552 0 0 1 77.312-17.766h1.536l53.044 0.256h16.076a775.117 775.117 0 0 1-67.84-59.75z"  ></path></symbol><symbol id="icon-caution" viewBox="0 0 1024 1024"><path d="M512 682.666667c-47.146667 0-85.333333-42.112-85.333333-94.037334V94.037333C426.666667 42.112 464.853333 0 512 0s85.333333 42.112 85.333333 94.037333v494.592C597.333333 640.554667 559.146667 682.666667 512 682.666667zM512 1024c-47.146667 0-85.333333-35.2-85.333333-78.592v-98.816C426.666667 803.2 464.853333 768 512 768s85.333333 35.2 85.333333 78.592v98.816C597.333333 988.8 559.146667 1024 512 1024z"  ></path></symbol><symbol id="icon-settings" viewBox="0 0 1024 1024"><path d="M608 62.31l245.453 141.67a192 192 0 0 1 96 166.298v283.444a192 192 0 0 1-96 166.297L608 961.69a192 192 0 0 1-192 0L170.547 820.02a192 192 0 0 1-96-166.297V370.278a192 192 0 0 1 95.949-166.297L415.949 62.31a192 192 0 0 1 192 0z m-153.6 66.51L208.947 270.49a115.2 115.2 0 0 0-57.6 99.84v283.392a115.2 115.2 0 0 0 57.6 99.788L454.4 895.18a115.2 115.2 0 0 0 115.2 0l245.453-141.67a115.2 115.2 0 0 0 57.6-99.84V370.33a115.2 115.2 0 0 0-57.6-99.79L569.6 128.87a115.2 115.2 0 0 0-115.2 0z m104.858 211.762a89.6 89.6 0 0 1 77.568 44.8l47.257 81.818a89.6 89.6 0 0 1 0 89.6l-47.257 81.818a89.6 89.6 0 0 1-77.568 44.8h-94.516a89.6 89.6 0 0 1-77.568-44.8L339.917 556.8a89.6 89.6 0 0 1 0-89.6l47.257-81.818a89.6 89.6 0 0 1 77.568-44.8h94.516z m0 76.8h-94.516a12.8 12.8 0 0 0-11.059 6.4L406.426 505.6a12.8 12.8 0 0 0 0 12.8l47.257 81.818a12.8 12.8 0 0 0 11.06 6.4h94.515a12.8 12.8 0 0 0 11.059-6.4l47.257-81.818a12.8 12.8 0 0 0 0-12.8l-47.257-81.818a12.8 12.8 0 0 0-11.06-6.4z"  ></path></symbol><symbol id="icon-back" viewBox="0 0 1024 1024"><path d="M67.738 495.616l36.3 32.358 220.468 194.868c13.926 12.236 14.438 33.792 1.024 46.796l-0.41 0.41a31.898 31.898 0 0 1-44.288 0L20.736 518.554a31.744 31.744 0 0 1 0-45.773l260.096-251.597a31.898 31.898 0 0 1 44.288 0l0.46 0.41a31.846 31.846 0 0 1-1.023 46.848l-220.57 194.816-36.352 32.358z"  ></path></symbol><symbol id="icon-wallet" viewBox="0 0 1024 1024"><path d="M825.6 115.2A134.4 134.4 0 0 1 960 249.6v384c0 60.877-40.448 112.282-95.949 128.82L864 785.868a140.8 140.8 0 0 1-179.456 135.373l-467.2-133.479A140.8 140.8 0 0 1 115.2 652.288V249.6a134.4 134.4 0 0 1 134.4-134.4h576zM256 225.331c-35.328 0-64 28.672-64 64V652.34c0 28.57 18.944 53.709 46.438 61.543l467.2 133.478a64 64 0 0 0 81.562-61.491v-47.616a38.502 38.502 0 0 1 0-17.306V422.861a64 64 0 0 0-46.438-61.543l-467.2-133.478A64 64 0 0 0 256 225.28zM825.6 192H427.827l334.029 95.437A140.8 140.8 0 0 1 864 422.86v253.645c11.776-10.548 19.2-25.856 19.2-42.906v-384c0-31.795-25.805-57.6-57.6-57.6z m-192 259.226a38.4 38.4 0 0 1 38.4 38.4V633.6a38.4 38.4 0 1 1-76.8 0V489.574a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-star" viewBox="0 0 1024 1024"><path d="M474.778 72.653a84.992 84.992 0 0 1 113.1 37.683l90.727 179.712c1.024 2.15 3.277 3.686 5.939 4.096l202.906 29.082c18.278 2.56 35.174 11.059 48.128 24.064a83.302 83.302 0 0 1-1.23 119.09l-148.12 142.542a6.605 6.605 0 0 0-2.049 5.939l34.765 195.584c3.277 18.483 0.154 37.58-8.806 54.17a85.043 85.043 0 0 1-114.176 34.457L515.84 804.659a8.55 8.55 0 0 0-7.885 0l-179.968 94.31c-16.589 8.705-35.635 11.674-54.118 8.5a83.968 83.968 0 0 1-68.813-97.28l34.97-195.328a6.605 6.605 0 0 0-2.048-5.94L89.702 466.484a83.61 83.61 0 0 1-24.832-48.128 83.968 83.968 0 0 1 71.732-95.078l204.339-29.184a7.834 7.834 0 0 0 5.939-4.096l89.395-179.251c8.192-16.59 21.76-29.952 38.503-38.093z m36.198 68.25l-2.56 0.767a7.475 7.475 0 0 0-3.43 3.328l-89.344 179.303c-12.39 24.832-36.301 41.933-63.847 45.875l-204.339 29.133c-4.352 0.614-7.168 4.198-6.605 7.885a6.81 6.81 0 0 0 2.048 3.89l148.275 142.49c20.173 19.354 29.338 47.36 24.423 74.804l-34.919 195.379c-0.665 3.584 1.946 7.27 6.247 8.038 1.894 0.307 3.789 0 5.427-0.819l179.968-94.31a85.35 85.35 0 0 1 79.155 0l180.173 94.361c3.994 2.1 9.011 0.615 10.957-3.02a6.4 6.4 0 0 0 0.717-4.199l-34.714-195.533a83.354 83.354 0 0 1 24.371-74.65l148.122-142.591a6.502 6.502 0 0 0 0.102-9.524 8.14 8.14 0 0 0-4.608-2.252l-202.957-29.082c-27.392-3.942-51.2-20.89-63.59-45.517l-90.726-179.712c-1.844-3.635-6.81-5.273-10.906-3.277l2.56-0.768z"  ></path></symbol><symbol id="icon-trade" viewBox="0 0 1024 1024"><path d="M1002.93153 563.627l-433.237 432.64a67.243 67.243 0 0 1-29.696 21.93c-0.853 0.171-1.45 0.342-1.963 0.342a61.27 61.27 0 0 1-22.442 4.608c-1.11 0-2.304 0.853-3.414 0.853-2.048 0-3.84-1.365-5.973-1.365a54.87 54.87 0 0 1-13.653-2.987 77.312 77.312 0 0 1-15.275-6.144c-2.987-1.621-5.803-3.67-8.533-5.803-2.56-1.962-5.718-2.816-7.936-5.461L21.34153 563.627a71.68 71.68 0 0 1 0-102.059 72.704 72.704 0 0 1 102.57 0l316.16 315.477V73.472C440.07353 33.109 472.92753 0 513.29053 0a73.387 73.387 0 0 1 73.216 73.472v701.355L900.53153 461.653a72.363 72.363 0 0 1 102.4 102.059z"  ></path></symbol><symbol id="icon-verticalslider" viewBox="0 0 1024 1024"><path d="M310.426 441.6a166.4 166.4 0 0 1 38.4 328.346V870.4a38.4 38.4 0 1 1-76.8 0V769.946a166.451 166.451 0 0 1 38.4-328.346z m0 76.8a89.6 89.6 0 1 0 0 179.2 89.6 89.6 0 0 0 0-179.2z m403.2-403.2a38.4 38.4 0 0 1 38.4 38.4v55.654a166.451 166.451 0 0 1-38.4 328.346 166.4 166.4 0 0 1-38.4-328.346V153.6a38.4 38.4 0 0 1 38.4-38.4z m0 166.4a89.6 89.6 0 1 0 0 179.2 89.6 89.6 0 0 0 0-179.2zM310.323 115.2a38.4 38.4 0 0 1 38.4 38.4v146.534a38.4 38.4 0 0 1-76.8 0V153.6a38.4 38.4 0 0 1 38.4-38.4z m403.2 525.26a38.4 38.4 0 0 1 38.4 38.4V870.4a38.4 38.4 0 1 1-76.8 0V678.86a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-swap" viewBox="0 0 1024 1024"><path d="M321.434 116.224a51.2 51.2 0 0 1 69.888 74.752c-47.77 44.646-87.04 81.818-117.658 111.462l-1.997 1.844h289.229a51.2 51.2 0 0 1 50.842 45.26l0.358 5.94a51.2 51.2 0 0 1-51.2 51.2H154.47a51.763 51.763 0 0 1-52.07-52.839c0.205-11.52 3.123-19.097 7.782-27.136 3.226-5.53 7.22-10.752 12.8-17.203 8.192-9.626 20.992-23.04 38.656-40.704a7171.584 7171.584 0 0 1 159.744-152.576z m509.593 188.058a51.2 51.2 0 0 1 0 102.4h-93.593a51.2 51.2 0 0 1 0-102.4h93.593zM663.194 853.709a51.2 51.2 0 0 1-69.888-74.803c47.77-44.647 87.04-81.818 117.657-111.412l2.048-1.894H153.6a51.2 51.2 0 0 1-50.842-45.21l-0.358-5.99a51.2 51.2 0 0 1 51.2-51.2h676.557c27.904 0 52.582 22.272 52.07 52.838a51.456 51.456 0 0 1-7.782 27.136c-3.226 5.53-7.22 10.752-12.8 17.204-8.192 9.625-20.992 23.04-38.656 40.704a7171.584 7171.584 0 0 1-159.744 152.627z"  ></path></symbol><symbol id="icon-star_sel" viewBox="0 0 1024 1024"><path d="M470.63 127.846L381.286 307.2a46.182 46.182 0 0 1-34.918 24.986l-204.34 29.184a45.568 45.568 0 0 0-39.167 51.456 45.344 45.344 0 0 0 13.465 26.01l148.276 142.438c10.905 10.496 15.872 25.6 13.21 40.448l-34.97 195.328a45.568 45.568 0 0 0 37.58 52.633 46.95 46.95 0 0 0 29.748-4.659l179.968-94.31a46.95 46.95 0 0 1 43.52 0l180.121 94.361c22.528 11.827 50.586 3.43 62.618-18.688a44.8 44.8 0 0 0 4.71-29.184L746.394 621.62a45.005 45.005 0 0 1 13.21-40.294l148.12-142.592a44.902 44.902 0 0 0 0.666-64.256 46.54 46.54 0 0 0-26.368-13.21l-202.956-29.081a46.182 46.182 0 0 1-34.765-24.781l-90.727-179.712a46.592 46.592 0 0 0-82.944 0.205z"  ></path></symbol><symbol id="icon-tips" viewBox="0 0 1024 1024"><path d="M512 166.4a345.6 345.6 0 1 1 0 691.2 345.6 345.6 0 0 1 0-691.2z m0 76.8a268.8 268.8 0 1 0 0 537.6 268.8 268.8 0 0 0 0-537.6z m0 196.3a38.4 38.4 0 0 1 38.4 38.4v219.29a38.4 38.4 0 1 1-76.8 0V477.9a38.4 38.4 0 0 1 38.4-38.4z m0-153.087a38.4 38.4 0 0 1 38.4 38.4v45.414a38.4 38.4 0 1 1-76.8 0v-45.363a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-sel" viewBox="0 0 1024 1024"><path d="M783.36 281.2416a51.2 51.2 0 0 1 71.68 73.0624l-407.9616 400.384a51.2 51.2 0 0 1-67.8912 3.4304l-206.3872-165.376a51.2 51.2 0 1 1 64-79.9232l170.9568 137.0112 375.6032-368.64z"  ></path></symbol><symbol id="icon-spread" viewBox="0 0 1024 1024"><path d="M143.36 678.4a38.4 38.4 0 0 1 38.4 38.4v112.64c0 7.066 5.734 12.8 12.8 12.8H307.2a38.4 38.4 0 1 1 0 76.8H194.56a89.6 89.6 0 0 1-89.6-89.6V716.8a38.4 38.4 0 0 1 38.4-38.4z m327.68-573.44a38.4 38.4 0 0 1 0 76.8H234.342L842.24 790.477v-242.33a38.4 38.4 0 1 1 76.8 0V829.44a89.6 89.6 0 0 1-89.6 89.6H552.96a38.4 38.4 0 1 1 0-76.8l232.346-0.051L181.76 237.773V471.04a38.4 38.4 0 0 1-76.8 0V194.56c0-49.46 40.14-89.6 89.6-89.6h276.48z m358.4 0c49.46 0 89.6 40.14 89.6 89.6V307.2a38.4 38.4 0 1 1-76.8 0V194.56a12.8 12.8 0 0 0-12.8-12.8H716.8a38.4 38.4 0 1 1 0-76.8h112.64z"  ></path></symbol><symbol id="icon-refresh" viewBox="0 0 1024 1024"><path d="M601.446 178.176a344.576 344.576 0 0 1 124.621 62.413 38.4 38.4 0 0 1 5.12 55.45l-94.566 107.878a38.4 38.4 0 1 1-57.754-50.586l65.741-75.11-4.915-2.816a268.646 268.646 0 0 0-43.008-18.535l-15.104-4.505A268.8 268.8 0 1 0 771.635 581.58a38.4 38.4 0 1 1 74.189 19.865 345.6 345.6 0 1 1-244.378-423.27z"  ></path></symbol><symbol id="icon-close" viewBox="0 0 1024 1024"><path d="M763.392 256.512a51.2 51.2 0 0 1 0 72.3968L582.2464 509.952l183.1424 183.1424a51.2 51.2 0 0 1-72.3968 72.3968l-183.1424-183.1424-180.992 181.0432a51.2 51.2 0 0 1-72.3968-72.3968L437.504 509.952 258.56 330.9568A51.2 51.2 0 0 1 330.9568 258.56L509.952 437.504l181.0432-180.992a51.2 51.2 0 0 1 72.3968 0z"  ></path></symbol><symbol id="icon-alert" viewBox="0 0 1024 1024"><path d="M558.08 125.0816c12.6464 7.5776 23.1936 18.1248 30.72 30.72L959.232 773.12a89.6 89.6 0 0 1-76.8 135.68H141.6192a89.6 89.6 0 0 1-76.8-135.68L435.1488 155.8016a89.6 89.6 0 0 1 122.9312-30.72zM501.0432 195.328L130.6624 812.5952a12.8 12.8 0 0 0 10.9568 19.4048h740.7616a12.8 12.8 0 0 0 10.9568-19.4048L522.9568 195.328a12.8 12.8 0 0 0-21.9136 0zM512 524.8a38.4 38.4 0 0 1 38.4 38.4v153.6a38.4 38.4 0 1 1-76.8 0v-153.6a38.4 38.4 0 0 1 38.4-38.4z m0-204.8a38.4 38.4 0 0 1 38.4 38.4v51.2a38.4 38.4 0 1 1-76.8 0V358.4a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-arrow" viewBox="0 0 1024 1024"><path d="M572.33 707.67l220.673-220.673a85.333 85.333 0 0 0-60.331-145.664H291.328a85.333 85.333 0 0 0-60.33 145.664L451.668 707.67a85.333 85.333 0 0 0 120.662 0z"  ></path></symbol></svg>', ((e10) => {
  var t10 = (r10 = (r10 = document.getElementsByTagName("script"))[r10.length - 1]).getAttribute("data-injectcss"), r10 = r10.getAttribute("data-disable-injectsvg");
  if (!r10) {
    var n10, i10, o10, s10, a10, c = function(d6, p) {
      p.parentNode.insertBefore(d6, p);
    };
    if (t10 && !e10.__iconfont__svg__cssinject__) {
      e10.__iconfont__svg__cssinject__ = true;
      try {
        document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>");
      } catch {
      }
    }
    n10 = function() {
      var d6, p = document.createElement("div");
      p.innerHTML = e10._iconfont_svg_string_4776227, (p = p.getElementsByTagName("svg")[0]) && (p.setAttribute("aria-hidden", "true"), p.style.position = "absolute", p.style.width = 0, p.style.height = 0, p.style.overflow = "hidden", p = p, (d6 = document.body).firstChild ? c(p, d6.firstChild) : d6.appendChild(p));
    }, document.addEventListener ? ~["complete", "loaded", "interactive"].indexOf(document.readyState) ? setTimeout(n10, 0) : (i10 = function() {
      document.removeEventListener("DOMContentLoaded", i10, false), n10();
    }, document.addEventListener("DOMContentLoaded", i10, false)) : document.attachEvent && (o10 = n10, s10 = e10.document, a10 = false, u10(), s10.onreadystatechange = function() {
      s10.readyState == "complete" && (s10.onreadystatechange = null, l10());
    });
  }
  function l10() {
    a10 || (a10 = true, o10());
  }
  function u10() {
    try {
      s10.documentElement.doScroll("left");
    } catch {
      return void setTimeout(u10, 50);
    }
    l10();
  }
})(window);
var k6 = "1.26.1";
var D6 = "1.47.0";
var L6 = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
var Jm = class extends Error {
};
var Zm = class extends Jm {
  constructor(t10, r10) {
    super(t10), this.code = r10, this.type = L6[r10] ?? "ServerError";
  }
};
var B6 = class extends Jm {
  constructor(t10, r10, n10) {
    super(t10), this.status = r10, this.statusText = n10;
  }
};
var Qm = (e10) => {
  throw TypeError(e10);
};
var pd = (e10, t10, r10) => t10.has(e10) || Qm("Cannot " + r10);
var lr = (e10, t10, r10) => (pd(e10, t10, "read from private field"), r10 ? r10.call(e10) : t10.get(e10));
var ho = (e10, t10, r10) => t10.has(e10) ? Qm("Cannot add the same private member more than once") : t10 instanceof WeakSet ? t10.add(e10) : t10.set(e10, r10);
var fs = (e10, t10, r10, n10) => (pd(e10, t10, "write to private field"), n10 ? n10.call(e10, r10) : t10.set(e10, r10), r10);
var eg = (e10, t10, r10) => (pd(e10, t10, "access private method"), r10);
var U6 = (e10, t10, r10, n10) => ({
  set _(i10) {
    fs(e10, t10, i10, r10);
  },
  get _() {
    return lr(e10, t10, n10);
  }
});
var xo;
var ia;
var yi;
var Mo;
var da;
var ds;
var Rc;
var tg;
var rg;
function F6(e10) {
  const t10 = new URL(e10);
  return t10.protocol = t10.protocol.replace("http", "ws"), t10.toString();
}
var $6 = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket < "u" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var V6 = class {
  constructor(t10, r10 = {}) {
    if (ho(this, Rc), ho(this, xo, 0), ho(this, ia, 0), ho(this, yi, null), ho(this, Mo, null), ho(this, da, /* @__PURE__ */ new Set()), ho(this, ds, /* @__PURE__ */ new Map()), this.endpoint = t10, this.options = { ...$6, ...r10 }, !this.options.WebSocketConstructor)
      throw new Error("Missing WebSocket constructor");
    this.endpoint.startsWith("http") && (this.endpoint = F6(this.endpoint));
  }
  async makeRequest(t10, r10) {
    const n10 = await eg(this, Rc, tg).call(this);
    return new Promise((i10, o10) => {
      fs(this, xo, lr(this, xo) + 1), lr(this, ds).set(lr(this, xo), {
        resolve: i10,
        reject: o10,
        timeout: setTimeout(() => {
          lr(this, ds).delete(lr(this, xo)), o10(new Error(`Request timeout: ${t10}`));
        }, this.options.callTimeout)
      }), n10.send(JSON.stringify({ jsonrpc: "2.0", id: lr(this, xo), method: t10, params: r10 }));
    }).then(({ error: i10, result: o10 }) => {
      if (i10)
        throw new Zm(i10.message, i10.code);
      return o10;
    });
  }
  async subscribe(t10) {
    const r10 = new z6(t10);
    return lr(this, da).add(r10), await r10.subscribe(this), () => r10.unsubscribe(this);
  }
};
xo = /* @__PURE__ */ new WeakMap();
ia = /* @__PURE__ */ new WeakMap();
yi = /* @__PURE__ */ new WeakMap();
Mo = /* @__PURE__ */ new WeakMap();
da = /* @__PURE__ */ new WeakMap();
ds = /* @__PURE__ */ new WeakMap();
Rc = /* @__PURE__ */ new WeakSet();
tg = function() {
  return lr(this, Mo) ? lr(this, Mo) : (fs(this, Mo, new Promise((e10) => {
    var t10;
    (t10 = lr(this, yi)) == null || t10.close(), fs(this, yi, new this.options.WebSocketConstructor(this.endpoint)), lr(this, yi).addEventListener("open", () => {
      fs(this, ia, 0), e10(lr(this, yi));
    }), lr(this, yi).addEventListener("close", () => {
      U6(this, ia)._++, lr(this, ia) <= this.options.maxReconnects && setTimeout(() => {
        eg(this, Rc, rg).call(this);
      }, this.options.reconnectTimeout);
    }), lr(this, yi).addEventListener("message", ({ data: r10 }) => {
      let n10;
      try {
        n10 = JSON.parse(r10);
      } catch (i10) {
        console.error(new Error(`Failed to parse RPC message: ${r10}`, { cause: i10 }));
        return;
      }
      if ("id" in n10 && n10.id != null && lr(this, ds).has(n10.id)) {
        const { resolve: i10, timeout: o10 } = lr(this, ds).get(n10.id);
        clearTimeout(o10), i10(n10);
      } else if ("params" in n10) {
        const { params: i10 } = n10;
        lr(this, da).forEach((o10) => {
          o10.subscriptionId === i10.subscription && i10.subscription === o10.subscriptionId && o10.onMessage(i10.result);
        });
      }
    });
  })), lr(this, Mo));
};
rg = async function() {
  var e10;
  return (e10 = lr(this, yi)) == null || e10.close(), fs(this, Mo, null), Promise.allSettled(
    [...lr(this, da)].map((t10) => t10.subscribe(this))
  );
};
var z6 = class {
  constructor(t10) {
    this.subscriptionId = null, this.subscribed = false, this.input = t10;
  }
  onMessage(t10) {
    this.subscribed && this.input.onMessage(t10);
  }
  async unsubscribe(t10) {
    const { subscriptionId: r10 } = this;
    return this.subscribed = false, r10 == null ? false : (this.subscriptionId = null, t10.makeRequest(this.input.unsubscribe, [r10]));
  }
  async subscribe(t10) {
    this.subscriptionId = null, this.subscribed = true;
    const r10 = await t10.makeRequest(
      this.input.method,
      this.input.params
    );
    this.subscribed && (this.subscriptionId = r10);
  }
};
var ng = (e10) => {
  throw TypeError(e10);
};
var md = (e10, t10, r10) => t10.has(e10) || ng("Cannot " + r10);
var fn = (e10, t10, r10) => (md(e10, t10, "read from private field"), r10 ? r10.call(e10) : t10.get(e10));
var Ya = (e10, t10, r10) => t10.has(e10) ? ng("Cannot add the same private member more than once") : t10 instanceof WeakSet ? t10.add(e10) : t10.set(e10, r10);
var gf = (e10, t10, r10, n10) => (md(e10, t10, "write to private field"), n10 ? n10.call(e10, r10) : t10.set(e10, r10), r10);
var q6 = (e10, t10, r10) => (md(e10, t10, "access private method"), r10);
var Zs;
var Cn;
var oa;
var vf;
var ig;
var H6 = class {
  constructor(t10) {
    Ya(this, vf), Ya(this, Zs, 0), Ya(this, Cn), Ya(this, oa), gf(this, Cn, t10);
  }
  fetch(t10, r10) {
    const n10 = fn(this, Cn).fetch ?? fetch;
    if (!n10)
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    return n10(t10, r10);
  }
  async request(t10) {
    var i10, o10;
    gf(this, Zs, fn(this, Zs) + 1);
    const r10 = await this.fetch(((i10 = fn(this, Cn).rpc) == null ? void 0 : i10.url) ?? fn(this, Cn).url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": k6,
        "Client-Target-Api-Version": D6,
        "Client-Request-Method": t10.method,
        ...(o10 = fn(this, Cn).rpc) == null ? void 0 : o10.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: fn(this, Zs),
        method: t10.method,
        params: t10.params
      })
    });
    if (!r10.ok)
      throw new B6(
        `Unexpected status code: ${r10.status}`,
        r10.status,
        r10.statusText
      );
    const n10 = await r10.json();
    if ("error" in n10 && n10.error != null)
      throw new Zm(n10.error.message, n10.error.code);
    return n10.result;
  }
  async subscribe(t10) {
    const r10 = await q6(this, vf, ig).call(this).subscribe(t10);
    return async () => !!await r10();
  }
};
Zs = /* @__PURE__ */ new WeakMap();
Cn = /* @__PURE__ */ new WeakMap();
oa = /* @__PURE__ */ new WeakMap();
vf = /* @__PURE__ */ new WeakSet();
ig = function() {
  var e10;
  if (!fn(this, oa)) {
    const t10 = fn(this, Cn).WebSocketConstructor ?? WebSocket;
    if (!t10)
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    gf(this, oa, new V6(
      ((e10 = fn(this, Cn).websocket) == null ? void 0 : e10.url) ?? fn(this, Cn).url,
      {
        WebSocketConstructor: t10,
        ...fn(this, Cn).websocket
      }
    ));
  }
  return fn(this, oa);
};
function og(e10) {
  switch (e10) {
    case "mainnet":
      return "https://fullnode.mainnet.sui.io:443";
    case "testnet":
      return "https://fullnode.testnet.sui.io:443";
    case "devnet":
      return "https://fullnode.devnet.sui.io:443";
    case "localnet":
      return "http://127.0.0.1:9000";
    default:
      throw new Error(`Unknown network: ${e10}`);
  }
}
function W6(e10) {
  return e10 instanceof Uint8Array || ArrayBuffer.isView(e10) && e10.constructor.name === "Uint8Array";
}
function sg(e10, t10) {
  return Array.isArray(t10) ? t10.length === 0 ? true : e10 ? t10.every((r10) => typeof r10 == "string") : t10.every((r10) => Number.isSafeInteger(r10)) : false;
}
function bf(e10, t10) {
  if (typeof t10 != "string")
    throw new Error(`${e10}: string expected`);
  return true;
}
function ag(e10) {
  if (!Number.isSafeInteger(e10))
    throw new Error(`invalid integer: ${e10}`);
}
function yf(e10) {
  if (!Array.isArray(e10))
    throw new Error("array expected");
}
function cg(e10, t10) {
  if (!sg(true, t10))
    throw new Error(`${e10}: array of strings expected`);
}
function G6(e10, t10) {
  if (!sg(false, t10))
    throw new Error(`${e10}: array of numbers expected`);
}
function K6(...e10) {
  const t10 = (o10) => o10, r10 = (o10, s10) => (a10) => o10(s10(a10)), n10 = e10.map((o10) => o10.encode).reduceRight(r10, t10), i10 = e10.map((o10) => o10.decode).reduce(r10, t10);
  return { encode: n10, decode: i10 };
}
function Y6(e10) {
  const t10 = typeof e10 == "string" ? e10.split("") : e10, r10 = t10.length;
  cg("alphabet", t10);
  const n10 = new Map(t10.map((i10, o10) => [i10, o10]));
  return {
    encode: (i10) => (yf(i10), i10.map((o10) => {
      if (!Number.isSafeInteger(o10) || o10 < 0 || o10 >= r10)
        throw new Error(`alphabet.encode: digit index outside alphabet "${o10}". Allowed: ${e10}`);
      return t10[o10];
    })),
    decode: (i10) => (yf(i10), i10.map((o10) => {
      bf("alphabet.decode", o10);
      const s10 = n10.get(o10);
      if (s10 === void 0)
        throw new Error(`Unknown letter: "${o10}". Allowed: ${e10}`);
      return s10;
    }))
  };
}
function X6(e10 = "") {
  return bf("join", e10), {
    encode: (t10) => (cg("join.decode", t10), t10.join(e10)),
    decode: (t10) => (bf("join.decode", t10), t10.split(e10))
  };
}
function fh(e10, t10, r10) {
  if (t10 < 2)
    throw new Error(`convertRadix: invalid from=${t10}, base cannot be less than 2`);
  if (r10 < 2)
    throw new Error(`convertRadix: invalid to=${r10}, base cannot be less than 2`);
  if (yf(e10), !e10.length)
    return [];
  let n10 = 0;
  const i10 = [], o10 = Array.from(e10, (a10) => {
    if (ag(a10), a10 < 0 || a10 >= t10)
      throw new Error(`invalid integer: ${a10}`);
    return a10;
  }), s10 = o10.length;
  for (; ; ) {
    let a10 = 0, c = true;
    for (let l10 = n10; l10 < s10; l10++) {
      const u10 = o10[l10], d6 = t10 * a10, p = d6 + u10;
      if (!Number.isSafeInteger(p) || d6 / t10 !== a10 || p - u10 !== d6)
        throw new Error("convertRadix: carry overflow");
      const y = p / r10;
      a10 = p % r10;
      const x = Math.floor(y);
      if (o10[l10] = x, !Number.isSafeInteger(x) || x * r10 + a10 !== p)
        throw new Error("convertRadix: carry overflow");
      if (c)
        x ? c = false : n10 = l10;
      else
        continue;
    }
    if (i10.push(a10), c)
      break;
  }
  for (let a10 = 0; a10 < e10.length - 1 && e10[a10] === 0; a10++)
    i10.push(0);
  return i10.reverse();
}
function J6(e10) {
  ag(e10);
  const t10 = 2 ** 8;
  return {
    encode: (r10) => {
      if (!W6(r10))
        throw new Error("radix.encode input should be Uint8Array");
      return fh(Array.from(r10), t10, e10);
    },
    decode: (r10) => (G6("radix.decode", r10), Uint8Array.from(fh(r10, e10, t10)))
  };
}
var Z6 = (e10) => K6(J6(58), Y6(e10), X6(""));
var lg = Z6("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var Uo = (e10) => lg.encode(e10);
var Ai = (e10) => lg.decode(e10);
var Q6 = Uo;
var e4 = Ai;
function Cr(e10) {
  return Uint8Array.from(atob(e10), (t10) => t10.charCodeAt(0));
}
var pu = 8192;
function Sr(e10) {
  if (e10.length < pu)
    return btoa(String.fromCharCode(...e10));
  let t10 = "";
  for (var r10 = 0; r10 < e10.length; r10 += pu) {
    const n10 = e10.slice(r10, r10 + pu);
    t10 += String.fromCharCode(...n10);
  }
  return btoa(t10);
}
var ug = Sr;
var fg = Cr;
function As(e10) {
  var i10;
  const t10 = e10.startsWith("0x") ? e10.slice(2) : e10, r10 = t10.length % 2 === 0 ? t10 : `0${t10}`, n10 = ((i10 = r10.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : i10.map((o10) => parseInt(o10, 16))) ?? [];
  if (n10.length !== r10.length / 2)
    throw new Error(`Invalid hex string ${e10}`);
  return Uint8Array.from(n10);
}
function Mi(e10) {
  return e10.reduce((t10, r10) => t10 + r10.toString(16).padStart(2, "0"), "");
}
var dg = Mi;
var hg = As;
function Pc(e10) {
  let t10 = [], r10 = 0;
  if (e10 === 0)
    return [0];
  for (; e10 > 0; )
    t10[r10] = e10 & 127, (e10 >>= 7) && (t10[r10] |= 128), r10 += 1;
  return t10;
}
function t4(e10) {
  let t10 = 0, r10 = 0, n10 = 0;
  for (; ; ) {
    let i10 = e10[n10];
    if (n10 += 1, t10 |= (i10 & 127) << r10, !(i10 & 128))
      break;
    r10 += 7;
  }
  return {
    value: t10,
    length: n10
  };
}
var pg = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(t10) {
    this.bytePosition = 0, this.dataView = new DataView(t10.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(t10) {
    return this.bytePosition += t10, this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let t10 = this.dataView.getUint8(this.bytePosition);
    return this.shift(1), t10;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let t10 = this.dataView.getUint16(this.bytePosition, true);
    return this.shift(2), t10;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let t10 = this.dataView.getUint32(this.bytePosition, true);
    return this.shift(4), t10;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let t10 = this.read32(), n10 = this.read32().toString(16) + t10.toString(16).padStart(8, "0");
    return BigInt("0x" + n10).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let t10 = BigInt(this.read64()), n10 = BigInt(this.read64()).toString(16) + t10.toString(16).padStart(16, "0");
    return BigInt("0x" + n10).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let t10 = BigInt(this.read128()), n10 = BigInt(this.read128()).toString(16) + t10.toString(16).padStart(32, "0");
    return BigInt("0x" + n10).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(t10) {
    let r10 = this.bytePosition + this.dataView.byteOffset, n10 = new Uint8Array(this.dataView.buffer, r10, t10);
    return this.shift(t10), n10;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let t10 = this.bytePosition + this.dataView.byteOffset, r10 = new Uint8Array(this.dataView.buffer, t10), { value: n10, length: i10 } = t4(r10);
    return this.shift(i10), n10;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(t10) {
    let r10 = this.readULEB(), n10 = [];
    for (let i10 = 0; i10 < r10; i10++)
      n10.push(t10(this, i10, r10));
    return n10;
  }
};
function mg(e10, t10) {
  switch (t10) {
    case "base58":
      return Uo(e10);
    case "base64":
      return Sr(e10);
    case "hex":
      return Mi(e10);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function r4(e10, t10) {
  switch (t10) {
    case "base58":
      return Ai(e10);
    case "base64":
      return Cr(e10);
    case "hex":
      return As(e10);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function gd(e10, t10 = ["<", ">"]) {
  const [r10, n10] = t10, i10 = [];
  let o10 = "", s10 = 0;
  for (let a10 = 0; a10 < e10.length; a10++) {
    const c = e10[a10];
    if (c === r10 && s10++, c === n10 && s10--, s10 === 0 && c === ",") {
      i10.push(o10.trim()), o10 = "";
      continue;
    }
    o10 += c;
  }
  return i10.push(o10.trim()), i10;
}
var gg = class {
  constructor({
    initialSize: t10 = 1024,
    maxSize: r10 = 1 / 0,
    allocateSize: n10 = 1024
  } = {}) {
    this.bytePosition = 0, this.size = t10, this.maxSize = r10, this.allocateSize = n10, this.dataView = new DataView(new ArrayBuffer(t10));
  }
  ensureSizeOrGrow(t10) {
    const r10 = this.bytePosition + t10;
    if (r10 > this.size) {
      const n10 = Math.min(this.maxSize, this.size + this.allocateSize);
      if (r10 > n10)
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r10}`
        );
      this.size = n10;
      const i10 = new ArrayBuffer(this.size);
      new Uint8Array(i10).set(new Uint8Array(this.dataView.buffer)), this.dataView = new DataView(i10);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(t10) {
    return this.bytePosition += t10, this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(t10) {
    return this.ensureSizeOrGrow(1), this.dataView.setUint8(this.bytePosition, Number(t10)), this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(t10) {
    return this.ensureSizeOrGrow(2), this.dataView.setUint16(this.bytePosition, Number(t10), true), this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(t10) {
    return this.ensureSizeOrGrow(4), this.dataView.setUint32(this.bytePosition, Number(t10), true), this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(t10) {
    return mu(BigInt(t10), 8).forEach((r10) => this.write8(r10)), this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(t10) {
    return mu(BigInt(t10), 16).forEach((r10) => this.write8(r10)), this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(t10) {
    return mu(BigInt(t10), 32).forEach((r10) => this.write8(r10)), this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(t10) {
    return Pc(t10).forEach((r10) => this.write8(r10)), this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(t10, r10) {
    return this.writeULEB(t10.length), Array.from(t10).forEach((n10, i10) => r10(this, n10, i10, t10.length)), this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let t10 = 0; t10 < this.bytePosition; t10++)
      yield this.dataView.getUint8(t10);
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(t10) {
    return mg(this.toBytes(), t10);
  }
};
function mu(e10, t10) {
  let r10 = new Uint8Array(t10), n10 = 0;
  for (; e10 > 0; )
    r10[n10] = Number(e10 % BigInt(256)), e10 = e10 / BigInt(256), n10 += 1;
  return r10;
}
var vg = (e10) => {
  throw TypeError(e10);
};
var bg = (e10, t10, r10) => t10.has(e10) || vg("Cannot " + r10);
var Tn = (e10, t10, r10) => (bg(e10, t10, "read from private field"), r10 ? r10.call(e10) : t10.get(e10));
var Nc = (e10, t10, r10) => t10.has(e10) ? vg("Cannot add the same private member more than once") : t10 instanceof WeakSet ? t10.add(e10) : t10.set(e10, r10);
var jc = (e10, t10, r10, n10) => (bg(e10, t10, "write to private field"), n10 ? n10.call(e10, r10) : t10.set(e10, r10), r10);
var is2;
var Qs;
var dc;
var $i;
var n4 = class yg {
  constructor(t10) {
    Nc(this, is2), Nc(this, Qs), this.name = t10.name, this.read = t10.read, this.serializedSize = t10.serializedSize ?? (() => null), jc(this, is2, t10.write), jc(this, Qs, t10.serialize ?? ((r10, n10) => {
      const i10 = new gg({
        initialSize: this.serializedSize(r10) ?? void 0,
        ...n10
      });
      return Tn(this, is2).call(this, r10, i10), i10.toBytes();
    })), this.validate = t10.validate ?? (() => {
    });
  }
  write(t10, r10) {
    this.validate(t10), Tn(this, is2).call(this, t10, r10);
  }
  serialize(t10, r10) {
    return this.validate(t10), new xg(this, Tn(this, Qs).call(this, t10, r10));
  }
  parse(t10) {
    const r10 = new pg(t10);
    return this.read(r10);
  }
  fromHex(t10) {
    return this.parse(As(t10));
  }
  fromBase58(t10) {
    return this.parse(Ai(t10));
  }
  fromBase64(t10) {
    return this.parse(Cr(t10));
  }
  transform({
    name: t10,
    input: r10,
    output: n10,
    validate: i10
  }) {
    return new yg({
      name: t10 ?? this.name,
      read: (o10) => n10 ? n10(this.read(o10)) : this.read(o10),
      write: (o10, s10) => Tn(this, is2).call(this, r10 ? r10(o10) : o10, s10),
      serializedSize: (o10) => this.serializedSize(r10 ? r10(o10) : o10),
      serialize: (o10, s10) => Tn(this, Qs).call(this, r10 ? r10(o10) : o10, s10),
      validate: (o10) => {
        i10 == null || i10(o10), this.validate(r10 ? r10(o10) : o10);
      }
    });
  }
};
is2 = /* @__PURE__ */ new WeakMap();
Qs = /* @__PURE__ */ new WeakMap();
var An = n4;
var wg = Symbol.for("@mysten/serialized-bcs");
function ul(e10) {
  return !!e10 && typeof e10 == "object" && e10[wg] === true;
}
var xg = class {
  constructor(t10, r10) {
    Nc(this, dc), Nc(this, $i), jc(this, dc, t10), jc(this, $i, r10);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [wg]() {
    return true;
  }
  toBytes() {
    return Tn(this, $i);
  }
  toHex() {
    return Mi(Tn(this, $i));
  }
  toBase64() {
    return Sr(Tn(this, $i));
  }
  toBase58() {
    return Uo(Tn(this, $i));
  }
  parse() {
    return Tn(this, dc).parse(Tn(this, $i));
  }
};
dc = /* @__PURE__ */ new WeakMap();
$i = /* @__PURE__ */ new WeakMap();
function kc({
  size: e10,
  ...t10
}) {
  return new An({
    ...t10,
    serializedSize: () => e10
  });
}
function gu({
  readMethod: e10,
  writeMethod: t10,
  ...r10
}) {
  return kc({
    ...r10,
    read: (n10) => n10[e10](),
    write: (n10, i10) => i10[t10](n10),
    validate: (n10) => {
      var i10;
      if (n10 < 0 || n10 > r10.maxValue)
        throw new TypeError(
          `Invalid ${r10.name} value: ${n10}. Expected value in range 0-${r10.maxValue}`
        );
      (i10 = r10.validate) == null || i10.call(r10, n10);
    }
  });
}
function vu({
  readMethod: e10,
  writeMethod: t10,
  ...r10
}) {
  return kc({
    ...r10,
    read: (n10) => n10[e10](),
    write: (n10, i10) => i10[t10](BigInt(n10)),
    validate: (n10) => {
      var o10;
      const i10 = BigInt(n10);
      if (i10 < 0 || i10 > r10.maxValue)
        throw new TypeError(
          `Invalid ${r10.name} value: ${i10}. Expected value in range 0-${r10.maxValue}`
        );
      (o10 = r10.validate) == null || o10.call(r10, i10);
    }
  });
}
function i4({
  serialize: e10,
  ...t10
}) {
  const r10 = new An({
    ...t10,
    serialize: e10,
    write: (n10, i10) => {
      for (const o10 of r10.serialize(n10).toBytes())
        i10.write8(o10);
    }
  });
  return r10;
}
function o4({
  toBytes: e10,
  fromBytes: t10,
  ...r10
}) {
  return new An({
    ...r10,
    read: (n10) => {
      const i10 = n10.readULEB(), o10 = n10.readBytes(i10);
      return t10(o10);
    },
    write: (n10, i10) => {
      const o10 = e10(n10);
      i10.writeULEB(o10.length);
      for (let s10 = 0; s10 < o10.length; s10++)
        i10.write8(o10[s10]);
    },
    serialize: (n10) => {
      const i10 = e10(n10), o10 = Pc(i10.length), s10 = new Uint8Array(o10.length + i10.length);
      return s10.set(o10, 0), s10.set(i10, o10.length), s10;
    },
    validate: (n10) => {
      var i10;
      if (typeof n10 != "string")
        throw new TypeError(`Invalid ${r10.name} value: ${n10}. Expected string`);
      (i10 = r10.validate) == null || i10.call(r10, n10);
    }
  });
}
function s4(e10) {
  let t10 = null;
  function r10() {
    return t10 || (t10 = e10()), t10;
  }
  return new An({
    name: "lazy",
    read: (n10) => r10().read(n10),
    serializedSize: (n10) => r10().serializedSize(n10),
    write: (n10, i10) => r10().write(n10, i10),
    serialize: (n10, i10) => r10().serialize(n10, i10).toBytes()
  });
}
var H = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(e10) {
    return gu({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...e10
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(e10) {
    return gu({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...e10
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(e10) {
    return gu({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...e10
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(e10) {
    return vu({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...e10
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(e10) {
    return vu({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...e10
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(e10) {
    return vu({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...e10
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(e10) {
    return kc({
      name: "bool",
      size: 1,
      read: (t10) => t10.read8() === 1,
      write: (t10, r10) => r10.write8(t10 ? 1 : 0),
      ...e10,
      validate: (t10) => {
        var r10;
        if ((r10 = e10 == null ? void 0 : e10.validate) == null || r10.call(e10, t10), typeof t10 != "boolean")
          throw new TypeError(`Expected boolean, found ${typeof t10}`);
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(e10) {
    return i4({
      name: "uleb128",
      read: (t10) => t10.readULEB(),
      serialize: (t10) => Uint8Array.from(Pc(t10)),
      ...e10
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(e10, t10) {
    return kc({
      name: `bytes[${e10}]`,
      size: e10,
      read: (r10) => r10.readBytes(e10),
      write: (r10, n10) => {
        const i10 = new Uint8Array(r10);
        for (let o10 = 0; o10 < e10; o10++)
          n10.write8(i10[o10] ?? 0);
      },
      ...t10,
      validate: (r10) => {
        var n10;
        if ((n10 = t10 == null ? void 0 : t10.validate) == null || n10.call(t10, r10), !r10 || typeof r10 != "object" || !("length" in r10))
          throw new TypeError(`Expected array, found ${typeof r10}`);
        if (r10.length !== e10)
          throw new TypeError(`Expected array of length ${e10}, found ${r10.length}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(e10) {
    return new An({
      name: "bytesVector",
      read: (t10) => {
        const r10 = t10.readULEB();
        return t10.readBytes(r10);
      },
      write: (t10, r10) => {
        const n10 = new Uint8Array(t10);
        r10.writeULEB(n10.length);
        for (let i10 = 0; i10 < n10.length; i10++)
          r10.write8(n10[i10] ?? 0);
      },
      ...e10,
      serializedSize: (t10) => {
        const r10 = "length" in t10 ? t10.length : null;
        return r10 == null ? null : Pc(r10).length + r10;
      },
      validate: (t10) => {
        var r10;
        if ((r10 = e10 == null ? void 0 : e10.validate) == null || r10.call(e10, t10), !t10 || typeof t10 != "object" || !("length" in t10))
          throw new TypeError(`Expected array, found ${typeof t10}`);
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(e10) {
    return o4({
      name: "string",
      toBytes: (t10) => new TextEncoder().encode(t10),
      fromBytes: (t10) => new TextDecoder().decode(t10),
      ...e10
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(e10, t10, r10) {
    return new An({
      name: `${t10.name}[${e10}]`,
      read: (n10) => {
        const i10 = new Array(e10);
        for (let o10 = 0; o10 < e10; o10++)
          i10[o10] = t10.read(n10);
        return i10;
      },
      write: (n10, i10) => {
        for (const o10 of n10)
          t10.write(o10, i10);
      },
      ...r10,
      validate: (n10) => {
        var i10;
        if ((i10 = r10 == null ? void 0 : r10.validate) == null || i10.call(r10, n10), !n10 || typeof n10 != "object" || !("length" in n10))
          throw new TypeError(`Expected array, found ${typeof n10}`);
        if (n10.length !== e10)
          throw new TypeError(`Expected array of length ${e10}, found ${n10.length}`);
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(e10) {
    return H.enum(`Option<${e10.name}>`, {
      None: null,
      Some: e10
    }).transform({
      input: (t10) => t10 == null ? { None: true } : { Some: t10 },
      output: (t10) => t10.$kind === "Some" ? t10.Some : null
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(e10, t10) {
    return new An({
      name: `vector<${e10.name}>`,
      read: (r10) => {
        const n10 = r10.readULEB(), i10 = new Array(n10);
        for (let o10 = 0; o10 < n10; o10++)
          i10[o10] = e10.read(r10);
        return i10;
      },
      write: (r10, n10) => {
        n10.writeULEB(r10.length);
        for (const i10 of r10)
          e10.write(i10, n10);
      },
      ...t10,
      validate: (r10) => {
        var n10;
        if ((n10 = t10 == null ? void 0 : t10.validate) == null || n10.call(t10, r10), !r10 || typeof r10 != "object" || !("length" in r10))
          throw new TypeError(`Expected array, found ${typeof r10}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(e10, t10) {
    return new An({
      name: `(${e10.map((r10) => r10.name).join(", ")})`,
      serializedSize: (r10) => {
        let n10 = 0;
        for (let i10 = 0; i10 < e10.length; i10++) {
          const o10 = e10[i10].serializedSize(r10[i10]);
          if (o10 == null)
            return null;
          n10 += o10;
        }
        return n10;
      },
      read: (r10) => {
        const n10 = [];
        for (const i10 of e10)
          n10.push(i10.read(r10));
        return n10;
      },
      write: (r10, n10) => {
        for (let i10 = 0; i10 < e10.length; i10++)
          e10[i10].write(r10[i10], n10);
      },
      ...t10,
      validate: (r10) => {
        var n10;
        if ((n10 = t10 == null ? void 0 : t10.validate) == null || n10.call(t10, r10), !Array.isArray(r10))
          throw new TypeError(`Expected array, found ${typeof r10}`);
        if (r10.length !== e10.length)
          throw new TypeError(`Expected array of length ${e10.length}, found ${r10.length}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(e10, t10, r10) {
    const n10 = Object.entries(t10);
    return new An({
      name: e10,
      serializedSize: (i10) => {
        let o10 = 0;
        for (const [s10, a10] of n10) {
          const c = a10.serializedSize(i10[s10]);
          if (c == null)
            return null;
          o10 += c;
        }
        return o10;
      },
      read: (i10) => {
        const o10 = {};
        for (const [s10, a10] of n10)
          o10[s10] = a10.read(i10);
        return o10;
      },
      write: (i10, o10) => {
        for (const [s10, a10] of n10)
          a10.write(i10[s10], o10);
      },
      ...r10,
      validate: (i10) => {
        var o10;
        if ((o10 = r10 == null ? void 0 : r10.validate) == null || o10.call(r10, i10), typeof i10 != "object" || i10 == null)
          throw new TypeError(`Expected object, found ${typeof i10}`);
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(e10, t10, r10) {
    const n10 = Object.entries(t10);
    return new An({
      name: e10,
      read: (i10) => {
        const o10 = i10.readULEB(), s10 = n10[o10];
        if (!s10)
          throw new TypeError(`Unknown value ${o10} for enum ${e10}`);
        const [a10, c] = s10;
        return {
          [a10]: (c == null ? void 0 : c.read(i10)) ?? true,
          $kind: a10
        };
      },
      write: (i10, o10) => {
        const [s10, a10] = Object.entries(i10).filter(
          ([c]) => Object.hasOwn(t10, c)
        )[0];
        for (let c = 0; c < n10.length; c++) {
          const [l10, u10] = n10[c];
          if (l10 === s10) {
            o10.writeULEB(c), u10 == null || u10.write(a10, o10);
            return;
          }
        }
      },
      ...r10,
      validate: (i10) => {
        var a10;
        if ((a10 = r10 == null ? void 0 : r10.validate) == null || a10.call(r10, i10), typeof i10 != "object" || i10 == null)
          throw new TypeError(`Expected object, found ${typeof i10}`);
        const o10 = Object.keys(i10).filter(
          (c) => i10[c] !== void 0 && Object.hasOwn(t10, c)
        );
        if (o10.length !== 1)
          throw new TypeError(
            `Expected object with one key, but found ${o10.length} for type ${e10}}`
          );
        const [s10] = o10;
        if (!Object.hasOwn(t10, s10))
          throw new TypeError(`Invalid enum variant ${s10}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(e10, t10) {
    return H.vector(H.tuple([e10, t10])).transform({
      name: `Map<${e10.name}, ${t10.name}>`,
      input: (r10) => [...r10.entries()],
      output: (r10) => {
        const n10 = /* @__PURE__ */ new Map();
        for (const [i10, o10] of r10)
          n10.set(i10, o10);
        return n10;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(e10) {
    return s4(e10);
  }
};
var a4 = Object.freeze(Object.defineProperty({
  __proto__: null,
  BcsReader: pg,
  BcsType: An,
  BcsWriter: gg,
  SerializedBcs: xg,
  bcs: H,
  decodeStr: r4,
  encodeStr: mg,
  fromB58: e4,
  fromB64: fg,
  fromBase58: Ai,
  fromBase64: Cr,
  fromHEX: hg,
  fromHex: As,
  isSerializedBcs: ul,
  splitGenericParameters: gd,
  toB58: Q6,
  toB64: ug,
  toBase58: Uo,
  toBase64: Sr,
  toHEX: dg,
  toHex: Mi
}, Symbol.toStringTag, { value: "Module" }));
var Sg = class {
  constructor({ network: t10 }) {
    this.network = t10;
  }
  $extend(...t10) {
    return Object.create(
      this,
      Object.fromEntries(
        t10.map((r10) => {
          if ("experimental_asClientExtension" in r10) {
            const { name: n10, register: i10 } = r10.experimental_asClientExtension();
            return [n10, { value: i10(this) }];
          }
          return [r10.name, { value: r10.register(this) }];
        })
      )
    );
  }
};
var _g = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var Eg = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var c4 = 235;
function Cg(e10) {
  return e10.length > c4 ? false : e10.includes("@") ? _g.test(e10) : Eg.test(e10);
}
function Tg(e10, t10 = "at") {
  const r10 = e10.toLowerCase();
  let n10;
  if (r10.includes("@")) {
    if (!_g.test(r10))
      throw new Error(`Invalid SuiNS name ${e10}`);
    const [i10, o10] = r10.split("@");
    n10 = [...i10 ? i10.split(".") : [], o10];
  } else {
    if (!Eg.test(r10))
      throw new Error(`Invalid SuiNS name ${e10}`);
    n10 = r10.split(".").slice(0, -1);
  }
  return t10 === "dot" ? `${n10.join(".")}.sui` : `${n10.slice(0, -1).join(".")}@${n10[n10.length - 1]}`;
}
var l4 = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var u4 = /^\d+$/;
var f4 = 64;
var Ag = "/";
var vd = (e10) => {
  const t10 = e10.split(Ag);
  if (t10.length < 2 || t10.length > 3)
    return false;
  const [r10, n10, i10] = t10;
  return i10 !== void 0 && !u4.test(i10) || !Cg(r10) ? false : l4.test(n10) && n10.length < f4;
};
var d4 = (e10) => {
  const t10 = e10.split(/::|<|>|,/);
  for (const r10 of t10)
    if (r10.includes(Ag) && !vd(r10))
      return false;
  return true;
};
var h4 = 32;
function wf(e10) {
  try {
    return Ai(e10).length === h4;
  } catch {
    return false;
  }
}
var fl = 32;
function Xn(e10) {
  return m4(e10) && g4(e10) === fl;
}
function ea(e10) {
  return Xn(e10);
}
function p4(e10) {
  return e10.includes("::") ? bd(e10) : e10;
}
function bd(e10) {
  const [t10, r10] = e10.split("::"), n10 = vd(t10), i10 = e10.slice(t10.length + r10.length + 4), o10 = i10.includes("<") ? i10.slice(0, i10.indexOf("<")) : i10, s10 = i10.includes("<") ? gd(i10.slice(i10.indexOf("<") + 1, i10.lastIndexOf(">"))).map(
    (a10) => p4(a10.trim())
  ) : [];
  return {
    address: n10 ? t10 : Ft(t10),
    module: r10,
    name: o10,
    typeParams: s10
  };
}
function Mg(e10) {
  const { address: t10, module: r10, name: n10, typeParams: i10 } = typeof e10 == "string" ? bd(e10) : e10, o10 = (i10 == null ? void 0 : i10.length) > 0 ? `<${i10.map(
    (s10) => typeof s10 == "string" ? s10 : Mg(s10)
  ).join(",")}>` : "";
  return `${t10}::${r10}::${n10}${o10}`;
}
function Ft(e10, t10 = false) {
  let r10 = e10.toLowerCase();
  return !t10 && r10.startsWith("0x") && (r10 = r10.slice(2)), `0x${r10.padStart(fl * 2, "0")}`;
}
function en(e10, t10 = false) {
  return Ft(e10, t10);
}
function m4(e10) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e10) && e10.length % 2 === 0;
}
function g4(e10) {
  return /^(0x|0X)/.test(e10) ? (e10.length - 2) / 2 : e10.length / 2;
}
var v4 = /^vector<(.+)>$/;
var b4 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var Dc = class os {
  static parseFromStr(t10, r10 = false) {
    if (t10 === "address")
      return { address: null };
    if (t10 === "bool")
      return { bool: null };
    if (t10 === "u8")
      return { u8: null };
    if (t10 === "u16")
      return { u16: null };
    if (t10 === "u32")
      return { u32: null };
    if (t10 === "u64")
      return { u64: null };
    if (t10 === "u128")
      return { u128: null };
    if (t10 === "u256")
      return { u256: null };
    if (t10 === "signer")
      return { signer: null };
    const n10 = t10.match(v4);
    if (n10)
      return {
        vector: os.parseFromStr(n10[1], r10)
      };
    const i10 = t10.match(b4);
    if (i10)
      return {
        struct: {
          address: r10 ? Ft(i10[1]) : i10[1],
          module: i10[2],
          name: i10[3],
          typeParams: i10[5] === void 0 ? [] : os.parseStructTypeArgs(i10[5], r10)
        }
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t10}`);
  }
  static parseStructTypeArgs(t10, r10 = false) {
    return gd(t10).map(
      (n10) => os.parseFromStr(n10, r10)
    );
  }
  static tagToString(t10) {
    if ("bool" in t10)
      return "bool";
    if ("u8" in t10)
      return "u8";
    if ("u16" in t10)
      return "u16";
    if ("u32" in t10)
      return "u32";
    if ("u64" in t10)
      return "u64";
    if ("u128" in t10)
      return "u128";
    if ("u256" in t10)
      return "u256";
    if ("address" in t10)
      return "address";
    if ("signer" in t10)
      return "signer";
    if ("vector" in t10)
      return `vector<${os.tagToString(t10.vector)}>`;
    if ("struct" in t10) {
      const r10 = t10.struct, n10 = r10.typeParams.map(os.tagToString).join(", ");
      return `${r10.address}::${r10.module}::${r10.name}${n10 ? `<${n10}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};
function y4(e10) {
  return H.u64({
    name: "unsafe_u64",
    ...e10
  }).transform({
    input: (t10) => t10,
    output: (t10) => Number(t10)
  });
}
function w4(e10) {
  return H.enum("Option", {
    None: null,
    Some: e10
  });
}
var or = H.bytes(fl).transform({
  validate: (e10) => {
    const t10 = typeof e10 == "string" ? e10 : Mi(e10);
    if (!t10 || !Xn(Ft(t10)))
      throw new Error(`Invalid Sui address ${t10}`);
  },
  input: (e10) => typeof e10 == "string" ? As(Ft(e10)) : e10,
  output: (e10) => Ft(Mi(e10))
});
var In = H.vector(H.u8()).transform({
  name: "ObjectDigest",
  input: (e10) => Ai(e10),
  output: (e10) => Uo(new Uint8Array(e10)),
  validate: (e10) => {
    if (Ai(e10).length !== 32)
      throw new Error("ObjectDigest must be 32 bytes");
  }
});
var un = H.struct("SuiObjectRef", {
  objectId: or,
  version: H.u64(),
  digest: In
});
var Ig = H.struct("SharedObjectRef", {
  objectId: or,
  initialSharedVersion: H.u64(),
  mutable: H.bool()
});
var Og = H.enum("ObjectArg", {
  ImmOrOwnedObject: un,
  SharedObject: Ig,
  Receiving: un
});
var Io = H.enum("Owner", {
  AddressOwner: or,
  ObjectOwner: or,
  Shared: H.struct("Shared", {
    initialSharedVersion: H.u64()
  }),
  Immutable: null,
  ConsensusV2: H.struct("ConsensusV2", {
    authenticator: H.struct("Authenticator", {
      SingleOwner: H.string()
    }),
    startVersion: H.string()
  })
});
var Rg = H.enum("CallArg", {
  Pure: H.struct("Pure", {
    bytes: H.vector(H.u8()).transform({
      input: (e10) => typeof e10 == "string" ? Cr(e10) : e10,
      output: (e10) => Sr(new Uint8Array(e10))
    })
  }),
  Object: Og
});
var yd = H.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: H.lazy(() => yd),
  struct: H.lazy(() => Lg),
  u16: null,
  u32: null,
  u256: null
});
var wd = yd.transform({
  input: (e10) => typeof e10 == "string" ? Dc.parseFromStr(e10, true) : e10,
  output: (e10) => Dc.tagToString(e10)
});
var Hn = H.enum("Argument", {
  GasCoin: null,
  Input: H.u16(),
  Result: H.u16(),
  NestedResult: H.tuple([H.u16(), H.u16()])
});
var Pg = H.struct("ProgrammableMoveCall", {
  package: or,
  module: H.string(),
  function: H.string(),
  typeArguments: H.vector(wd),
  arguments: H.vector(Hn)
});
var Ng = H.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: Pg,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: H.struct("TransferObjects", {
    objects: H.vector(Hn),
    address: Hn
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: H.struct("SplitCoins", {
    coin: Hn,
    amounts: H.vector(Hn)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: H.struct("MergeCoins", {
    destination: Hn,
    sources: H.vector(Hn)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: H.struct("Publish", {
    modules: H.vector(
      H.vector(H.u8()).transform({
        input: (e10) => typeof e10 == "string" ? Cr(e10) : e10,
        output: (e10) => Sr(new Uint8Array(e10))
      })
    ),
    dependencies: H.vector(or)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: H.struct("MakeMoveVec", {
    type: w4(wd).transform({
      input: (e10) => e10 === null ? {
        None: true
      } : {
        Some: e10
      },
      output: (e10) => e10.Some ?? null
    }),
    elements: H.vector(Hn)
  }),
  Upgrade: H.struct("Upgrade", {
    modules: H.vector(
      H.vector(H.u8()).transform({
        input: (e10) => typeof e10 == "string" ? Cr(e10) : e10,
        output: (e10) => Sr(new Uint8Array(e10))
      })
    ),
    dependencies: H.vector(or),
    package: or,
    ticket: Hn
  })
});
var jg = H.struct("ProgrammableTransaction", {
  inputs: H.vector(Rg),
  commands: H.vector(Ng)
});
var kg = H.enum("TransactionKind", {
  ProgrammableTransaction: jg,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var Dg = H.enum("TransactionExpiration", {
  None: null,
  Epoch: y4()
});
var Lg = H.struct("StructTag", {
  address: or,
  module: H.string(),
  name: H.string(),
  typeParams: H.vector(yd)
});
var Bg = H.struct("GasData", {
  payment: H.vector(un),
  owner: or,
  price: H.u64(),
  budget: H.u64()
});
var Ug = H.struct("TransactionDataV1", {
  kind: kg,
  sender: or,
  gasData: Bg,
  expiration: Dg
});
var Fg = H.enum("TransactionData", {
  V1: Ug
});
var $g = H.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var Vg = H.enum("IntentVersion", {
  V0: null
});
var zg = H.enum("AppId", {
  Sui: null
});
var qg = H.struct("Intent", {
  scope: $g,
  version: Vg,
  appId: zg
});
function Hg(e10) {
  return H.struct(`IntentMessage<${e10.name}>`, {
    intent: qg,
    value: e10
  });
}
var Wg = H.enum("CompressedSignature", {
  ED25519: H.fixedArray(64, H.u8()),
  Secp256k1: H.fixedArray(64, H.u8()),
  Secp256r1: H.fixedArray(64, H.u8()),
  ZkLogin: H.vector(H.u8())
});
var Gg = H.enum("PublicKey", {
  ED25519: H.fixedArray(32, H.u8()),
  Secp256k1: H.fixedArray(33, H.u8()),
  Secp256r1: H.fixedArray(33, H.u8()),
  ZkLogin: H.vector(H.u8())
});
var Kg = H.struct("MultiSigPkMap", {
  pubKey: Gg,
  weight: H.u8()
});
var Yg = H.struct("MultiSigPublicKey", {
  pk_map: H.vector(Kg),
  threshold: H.u16()
});
var x4 = H.struct("MultiSig", {
  sigs: H.vector(Wg),
  bitmap: H.u16(),
  multisig_pk: Yg
});
var S4 = H.vector(H.u8()).transform({
  input: (e10) => typeof e10 == "string" ? Cr(e10) : e10,
  output: (e10) => Sr(new Uint8Array(e10))
});
var Xg = H.struct("SenderSignedTransaction", {
  intentMessage: Hg(Fg),
  txSignatures: H.vector(S4)
});
var _4 = H.vector(Xg, {
  name: "SenderSignedData"
});
var E4 = H.struct("PasskeyAuthenticator", {
  authenticatorData: H.vector(H.u8()),
  clientDataJson: H.string(),
  userSignature: H.vector(H.u8())
});
var C4 = H.enum("PackageUpgradeError", {
  UnableToFetchPackage: H.struct("UnableToFetchPackage", { packageId: or }),
  NotAPackage: H.struct("NotAPackage", { objectId: or }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: H.struct("DigestDoesNotMatch", { digest: H.vector(H.u8()) }),
  UnknownUpgradePolicy: H.struct("UnknownUpgradePolicy", { policy: H.u8() }),
  PackageIDDoesNotMatch: H.struct("PackageIDDoesNotMatch", {
    packageId: or,
    ticketId: or
  })
});
var T4 = H.struct("ModuleId", {
  address: or,
  name: H.string()
});
var dh = H.struct("MoveLocation", {
  module: T4,
  function: H.u16(),
  instruction: H.u16(),
  functionName: H.option(H.string())
});
var A4 = H.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: H.struct("IndexOutOfBounds", { idx: H.u16() }),
  SecondaryIndexOutOfBounds: H.struct("SecondaryIndexOutOfBounds", {
    resultIdx: H.u16(),
    secondaryIdx: H.u16()
  }),
  InvalidResultArity: H.struct("InvalidResultArity", { resultIdx: H.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var M4 = H.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var I4 = H.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: H.struct("MoveObjectTooBig", {
    objectSize: H.u64(),
    maxObjectSize: H.u64()
  }),
  MovePackageTooBig: H.struct("MovePackageTooBig", {
    objectSize: H.u64(),
    maxObjectSize: H.u64()
  }),
  CircularObjectOwnership: H.struct("CircularObjectOwnership", { object: or }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: H.option(dh),
  MoveAbort: H.tuple([dh, H.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: H.struct("CommandArgumentError", {
    argIdx: H.u16(),
    kind: A4
  }),
  TypeArgumentError: H.struct("TypeArgumentError", {
    argumentIdx: H.u16(),
    kind: M4
  }),
  UnusedValueWithoutDrop: H.struct("UnusedValueWithoutDrop", {
    resultIdx: H.u16(),
    secondaryIdx: H.u16()
  }),
  InvalidPublicFunctionReturnType: H.struct("InvalidPublicFunctionReturnType", {
    idx: H.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: H.struct("EffectsTooLarge", { currentSize: H.u64(), maxSize: H.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: H.struct("PackageUpgradeError", { upgradeError: C4 }),
  WrittenObjectsTooLarge: H.struct("WrittenObjectsTooLarge", {
    currentSize: H.u64(),
    maxSize: H.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: H.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: H.vector(or)
    }
  ),
  AddressDeniedForCoin: H.struct("AddressDeniedForCoin", {
    address: or,
    coinType: H.string()
  }),
  CoinTypeGlobalPause: H.struct("CoinTypeGlobalPause", { coinType: H.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var Jg = H.enum("ExecutionStatus", {
  Success: null,
  Failed: H.struct("ExecutionFailed", {
    error: I4,
    command: H.option(H.u64())
  })
});
var Zg = H.struct("GasCostSummary", {
  computationCost: H.u64(),
  storageCost: H.u64(),
  storageRebate: H.u64(),
  nonRefundableStorageFee: H.u64()
});
var O4 = H.struct("TransactionEffectsV1", {
  status: Jg,
  executedEpoch: H.u64(),
  gasUsed: Zg,
  modifiedAtVersions: H.vector(H.tuple([or, H.u64()])),
  sharedObjects: H.vector(un),
  transactionDigest: In,
  created: H.vector(H.tuple([un, Io])),
  mutated: H.vector(H.tuple([un, Io])),
  unwrapped: H.vector(H.tuple([un, Io])),
  deleted: H.vector(un),
  unwrappedThenDeleted: H.vector(un),
  wrapped: H.vector(un),
  gasObject: H.tuple([un, Io]),
  eventsDigest: H.option(In),
  dependencies: H.vector(In)
});
var xd = H.tuple([H.u64(), In]);
var R4 = H.enum("ObjectIn", {
  NotExist: null,
  Exist: H.tuple([xd, Io])
});
var P4 = H.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: H.tuple([In, Io]),
  PackageWrite: xd
});
var N4 = H.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var j4 = H.struct("EffectsObjectChange", {
  inputState: R4,
  outputState: P4,
  idOperation: N4
});
var k4 = H.enum("UnchangedSharedKind", {
  ReadOnlyRoot: xd,
  MutateDeleted: H.u64(),
  ReadDeleted: H.u64(),
  Cancelled: H.u64(),
  PerEpochConfig: null
});
var D4 = H.struct("TransactionEffectsV2", {
  status: Jg,
  executedEpoch: H.u64(),
  gasUsed: Zg,
  transactionDigest: In,
  gasObjectIndex: H.option(H.u32()),
  eventsDigest: H.option(In),
  dependencies: H.vector(In),
  lamportVersion: H.u64(),
  changedObjects: H.vector(H.tuple([or, j4])),
  unchangedSharedObjects: H.vector(H.tuple([or, k4])),
  auxDataDigest: H.option(In)
});
var L4 = H.enum("TransactionEffects", {
  V1: O4,
  V2: D4
});
function sa(e10) {
  switch (e10) {
    case "u8":
      return H.u8();
    case "u16":
      return H.u16();
    case "u32":
      return H.u32();
    case "u64":
      return H.u64();
    case "u128":
      return H.u128();
    case "u256":
      return H.u256();
    case "bool":
      return H.bool();
    case "string":
      return H.string();
    case "id":
    case "address":
      return or;
  }
  const t10 = e10.match(/^(vector|option)<(.+)>$/);
  if (t10) {
    const [r10, n10] = t10.slice(1);
    return r10 === "vector" ? H.vector(sa(n10)) : H.option(sa(n10));
  }
  throw new Error(`Invalid Pure type name: ${e10}`);
}
var gt = {
  ...H,
  U8: H.u8(),
  U16: H.u16(),
  U32: H.u32(),
  U64: H.u64(),
  U128: H.u128(),
  U256: H.u256(),
  ULEB128: H.uleb128(),
  Bool: H.bool(),
  String: H.string(),
  Address: or,
  AppId: zg,
  Argument: Hn,
  CallArg: Rg,
  CompressedSignature: Wg,
  GasData: Bg,
  Intent: qg,
  IntentMessage: Hg,
  IntentScope: $g,
  IntentVersion: Vg,
  MultiSig: x4,
  MultiSigPkMap: Kg,
  MultiSigPublicKey: Yg,
  ObjectArg: Og,
  ObjectDigest: In,
  Owner: Io,
  ProgrammableMoveCall: Pg,
  ProgrammableTransaction: jg,
  PublicKey: Gg,
  SenderSignedData: _4,
  SenderSignedTransaction: Xg,
  SharedObjectRef: Ig,
  StructTag: Lg,
  SuiObjectRef: un,
  Command: Ng,
  TransactionData: Fg,
  TransactionDataV1: Ug,
  TransactionExpiration: Dg,
  TransactionKind: kg,
  TypeTag: wd,
  TransactionEffects: L4,
  PasskeyAuthenticator: E4
};
function B4(e10, t10) {
  const r10 = [];
  for (let n10 = 0; n10 < e10.length; n10 += t10)
    r10.push(e10.slice(n10, n10 + t10));
  return r10;
}
var di;
function U4(e10) {
  return {
    lang: (e10 == null ? void 0 : e10.lang) ?? (di == null ? void 0 : di.lang),
    message: e10 == null ? void 0 : e10.message,
    abortEarly: (e10 == null ? void 0 : e10.abortEarly) ?? (di == null ? void 0 : di.abortEarly),
    abortPipeEarly: (e10 == null ? void 0 : e10.abortPipeEarly) ?? (di == null ? void 0 : di.abortPipeEarly)
  };
}
var bu;
function F4(e10) {
  return bu == null ? void 0 : bu.get(e10);
}
var yu;
function $4(e10) {
  return yu == null ? void 0 : yu.get(e10);
}
var wu;
function V4(e10, t10) {
  var r10;
  return (r10 = wu == null ? void 0 : wu.get(e10)) == null ? void 0 : r10.get(t10);
}
function Qg(e10) {
  var r10, n10;
  const t10 = typeof e10;
  return t10 === "string" ? `"${e10}"` : t10 === "number" || t10 === "bigint" || t10 === "boolean" ? `${e10}` : t10 === "object" || t10 === "function" ? (e10 && ((n10 = (r10 = Object.getPrototypeOf(e10)) == null ? void 0 : r10.constructor) == null ? void 0 : n10.name)) ?? "null" : t10;
}
function on(e10, t10, r10, n10, i10) {
  const o10 = i10 && "input" in i10 ? i10.input : r10.value, s10 = (i10 == null ? void 0 : i10.expected) ?? e10.expects ?? null, a10 = (i10 == null ? void 0 : i10.received) ?? Qg(o10), c = {
    kind: e10.kind,
    type: e10.type,
    input: o10,
    expected: s10,
    received: a10,
    message: `Invalid ${t10}: ${s10 ? `Expected ${s10} but r` : "R"}eceived ${a10}`,
    // @ts-expect-error
    requirement: e10.requirement,
    path: i10 == null ? void 0 : i10.path,
    issues: i10 == null ? void 0 : i10.issues,
    lang: n10.lang,
    abortEarly: n10.abortEarly,
    abortPipeEarly: n10.abortPipeEarly
  }, l10 = e10.kind === "schema", u10 = (i10 == null ? void 0 : i10.message) ?? // @ts-expect-error
  e10.message ?? V4(e10.reference, c.lang) ?? (l10 ? $4(c.lang) : null) ?? n10.message ?? F4(c.lang);
  u10 && (c.message = typeof u10 == "function" ? u10(c) : u10), l10 && (r10.typed = false), r10.issues ? r10.issues.push(c) : r10.issues = [c];
}
function z4(e10, t10) {
  return Object.hasOwn(e10, t10) && t10 !== "__proto__" && t10 !== "prototype" && t10 !== "constructor";
}
var q4 = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(t10) {
    super(t10[0].message);
    mt(this, "issues");
    this.name = "ValiError", this.issues = t10;
  }
};
function Ra(e10, t10) {
  return {
    kind: "validation",
    type: "check",
    reference: Ra,
    async: false,
    expects: null,
    requirement: e10,
    message: t10,
    _run(r10, n10) {
      return r10.typed && !this.requirement(r10.value) && on(this, "input", r10, n10), r10;
    }
  };
}
function fr(e10) {
  return {
    kind: "validation",
    type: "integer",
    reference: fr,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e10,
    _run(t10, r10) {
      return t10.typed && !this.requirement(t10.value) && on(this, "integer", t10, r10), t10;
    }
  };
}
function dl(e10) {
  return {
    kind: "transformation",
    type: "transform",
    reference: dl,
    async: false,
    operation: e10,
    _run(t10) {
      return t10.value = this.operation(t10.value), t10;
    }
  };
}
function Sd(e10, t10, r10) {
  return typeof e10.default == "function" ? (
    // @ts-expect-error
    e10.default(t10, r10)
  ) : (
    // @ts-expect-error
    e10.default
  );
}
function xf(e10, t10) {
  return !e10._run({ typed: false, value: t10 }, { abortEarly: true }).issues;
}
function tt(e10, t10) {
  return {
    kind: "schema",
    type: "array",
    reference: tt,
    expects: "Array",
    async: false,
    item: e10,
    message: t10,
    _run(r10, n10) {
      var o10;
      const i10 = r10.value;
      if (Array.isArray(i10)) {
        r10.typed = true, r10.value = [];
        for (let s10 = 0; s10 < i10.length; s10++) {
          const a10 = i10[s10], c = this.item._run({ typed: false, value: a10 }, n10);
          if (c.issues) {
            const l10 = {
              type: "array",
              origin: "value",
              input: i10,
              key: s10,
              value: a10
            };
            for (const u10 of c.issues)
              u10.path ? u10.path.unshift(l10) : u10.path = [l10], (o10 = r10.issues) == null || o10.push(u10);
            if (r10.issues || (r10.issues = c.issues), n10.abortEarly) {
              r10.typed = false;
              break;
            }
          }
          c.typed || (r10.typed = false), r10.value.push(c.value);
        }
      } else
        on(this, "type", r10, n10);
      return r10;
    }
  };
}
function _d(e10) {
  return {
    kind: "schema",
    type: "bigint",
    reference: _d,
    expects: "bigint",
    async: false,
    message: e10,
    _run(t10, r10) {
      return typeof t10.value == "bigint" ? t10.typed = true : on(this, "type", t10, r10), t10;
    }
  };
}
function hl(e10) {
  return {
    kind: "schema",
    type: "boolean",
    reference: hl,
    expects: "boolean",
    async: false,
    message: e10,
    _run(t10, r10) {
      return typeof t10.value == "boolean" ? t10.typed = true : on(this, "type", t10, r10), t10;
    }
  };
}
function ha(e10) {
  return {
    kind: "schema",
    type: "lazy",
    reference: ha,
    expects: "unknown",
    async: false,
    getter: e10,
    _run(t10, r10) {
      return this.getter(t10.value)._run(t10, r10);
    }
  };
}
function ct(e10, t10) {
  return {
    kind: "schema",
    type: "literal",
    reference: ct,
    expects: Qg(e10),
    async: false,
    literal: e10,
    message: t10,
    _run(r10, n10) {
      return r10.value === this.literal ? r10.typed = true : on(this, "type", r10, n10), r10;
    }
  };
}
function qt(e10, ...t10) {
  const r10 = {
    kind: "schema",
    type: "nullable",
    reference: qt,
    expects: `${e10.expects} | null`,
    async: false,
    wrapped: e10,
    _run(n10, i10) {
      return n10.value === null && ("default" in this && (n10.value = Sd(
        this,
        n10,
        i10
      )), n10.value === null) ? (n10.typed = true, n10) : this.wrapped._run(n10, i10);
    }
  };
  return 0 in t10 && (r10.default = t10[0]), r10;
}
function vs(e10, ...t10) {
  const r10 = {
    kind: "schema",
    type: "nullish",
    reference: vs,
    expects: `${e10.expects} | null | undefined`,
    async: false,
    wrapped: e10,
    _run(n10, i10) {
      return (n10.value === null || n10.value === void 0) && ("default" in this && (n10.value = Sd(
        this,
        n10,
        i10
      )), n10.value === null || n10.value === void 0) ? (n10.typed = true, n10) : this.wrapped._run(n10, i10);
    }
  };
  return 0 in t10 && (r10.default = t10[0]), r10;
}
function ar(e10) {
  return {
    kind: "schema",
    type: "number",
    reference: ar,
    expects: "number",
    async: false,
    message: e10,
    _run(t10, r10) {
      return typeof t10.value == "number" && !isNaN(t10.value) ? t10.typed = true : on(this, "type", t10, r10), t10;
    }
  };
}
function Me(e10, t10) {
  return {
    kind: "schema",
    type: "object",
    reference: Me,
    expects: "Object",
    async: false,
    entries: e10,
    message: t10,
    _run(r10, n10) {
      var o10;
      const i10 = r10.value;
      if (i10 && typeof i10 == "object") {
        r10.typed = true, r10.value = {};
        for (const s10 in this.entries) {
          const a10 = i10[s10], c = this.entries[s10]._run(
            { typed: false, value: a10 },
            n10
          );
          if (c.issues) {
            const l10 = {
              type: "object",
              origin: "value",
              input: i10,
              key: s10,
              value: a10
            };
            for (const u10 of c.issues)
              u10.path ? u10.path.unshift(l10) : u10.path = [l10], (o10 = r10.issues) == null || o10.push(u10);
            if (r10.issues || (r10.issues = c.issues), n10.abortEarly) {
              r10.typed = false;
              break;
            }
          }
          c.typed || (r10.typed = false), (c.value !== void 0 || s10 in i10) && (r10.value[s10] = c.value);
        }
      } else
        on(this, "type", r10, n10);
      return r10;
    }
  };
}
function Dr(e10, ...t10) {
  const r10 = {
    kind: "schema",
    type: "optional",
    reference: Dr,
    expects: `${e10.expects} | undefined`,
    async: false,
    wrapped: e10,
    _run(n10, i10) {
      return n10.value === void 0 && ("default" in this && (n10.value = Sd(
        this,
        n10,
        i10
      )), n10.value === void 0) ? (n10.typed = true, n10) : this.wrapped._run(n10, i10);
    }
  };
  return 0 in t10 && (r10.default = t10[0]), r10;
}
function pa(e10, t10, r10) {
  return {
    kind: "schema",
    type: "record",
    reference: pa,
    expects: "Object",
    async: false,
    key: e10,
    value: t10,
    message: r10,
    _run(n10, i10) {
      var s10, a10;
      const o10 = n10.value;
      if (o10 && typeof o10 == "object") {
        n10.typed = true, n10.value = {};
        for (const c in o10)
          if (z4(o10, c)) {
            const l10 = o10[c], u10 = this.key._run(
              { typed: false, value: c },
              i10
            );
            if (u10.issues) {
              const p = {
                type: "object",
                origin: "key",
                input: o10,
                key: c,
                value: l10
              };
              for (const y of u10.issues)
                y.path = [p], (s10 = n10.issues) == null || s10.push(y);
              if (n10.issues || (n10.issues = u10.issues), i10.abortEarly) {
                n10.typed = false;
                break;
              }
            }
            const d6 = this.value._run(
              { typed: false, value: l10 },
              i10
            );
            if (d6.issues) {
              const p = {
                type: "object",
                origin: "value",
                input: o10,
                key: c,
                value: l10
              };
              for (const y of d6.issues)
                y.path ? y.path.unshift(p) : y.path = [p], (a10 = n10.issues) == null || a10.push(y);
              if (n10.issues || (n10.issues = d6.issues), i10.abortEarly) {
                n10.typed = false;
                break;
              }
            }
            (!u10.typed || !d6.typed) && (n10.typed = false), u10.typed && (n10.value[u10.value] = d6.value);
          }
      } else
        on(this, "type", n10, i10);
      return n10;
    }
  };
}
function yt(e10) {
  return {
    kind: "schema",
    type: "string",
    reference: yt,
    expects: "string",
    async: false,
    message: e10,
    _run(t10, r10) {
      return typeof t10.value == "string" ? t10.typed = true : on(this, "type", t10, r10), t10;
    }
  };
}
function Ed(e10, t10) {
  return {
    kind: "schema",
    type: "tuple",
    reference: Ed,
    expects: "Array",
    async: false,
    items: e10,
    message: t10,
    _run(r10, n10) {
      var o10;
      const i10 = r10.value;
      if (Array.isArray(i10)) {
        r10.typed = true, r10.value = [];
        for (let s10 = 0; s10 < this.items.length; s10++) {
          const a10 = i10[s10], c = this.items[s10]._run(
            { typed: false, value: a10 },
            n10
          );
          if (c.issues) {
            const l10 = {
              type: "array",
              origin: "value",
              input: i10,
              key: s10,
              value: a10
            };
            for (const u10 of c.issues)
              u10.path ? u10.path.unshift(l10) : u10.path = [l10], (o10 = r10.issues) == null || o10.push(u10);
            if (r10.issues || (r10.issues = c.issues), n10.abortEarly) {
              r10.typed = false;
              break;
            }
          }
          c.typed || (r10.typed = false), r10.value.push(c.value);
        }
      } else
        on(this, "type", r10, n10);
      return r10;
    }
  };
}
function hh(e10) {
  let t10;
  if (e10)
    for (const r10 of e10)
      t10 ? t10.push(...r10.issues) : t10 = r10.issues;
  return t10;
}
function jr(e10, t10) {
  return {
    kind: "schema",
    type: "union",
    reference: jr,
    expects: [...new Set(e10.map((r10) => r10.expects))].join(" | ") || "never",
    async: false,
    options: e10,
    message: t10,
    _run(r10, n10) {
      let i10, o10, s10;
      for (const a10 of this.options) {
        const c = a10._run(
          { typed: false, value: r10.value },
          n10
        );
        if (c.typed)
          if (c.issues)
            o10 ? o10.push(c) : o10 = [c];
          else {
            i10 = c;
            break;
          }
        else
          s10 ? s10.push(c) : s10 = [c];
      }
      if (i10)
        return i10;
      if (o10) {
        if (o10.length === 1)
          return o10[0];
        on(this, "type", r10, n10, {
          issues: hh(o10)
        }), r10.typed = true;
      } else {
        if ((s10 == null ? void 0 : s10.length) === 1)
          return s10[0];
        on(this, "type", r10, n10, {
          issues: hh(s10)
        });
      }
      return r10;
    }
  };
}
function No() {
  return {
    kind: "schema",
    type: "unknown",
    reference: No,
    expects: "unknown",
    async: false,
    _run(e10) {
      return e10.typed = true, e10;
    }
  };
}
function ur(e10, t10, r10) {
  const n10 = e10._run(
    { typed: false, value: t10 },
    U4(r10)
  );
  if (n10.issues)
    throw new q4(n10.issues);
  return n10.value;
}
function Kt(...e10) {
  return {
    ...e10[0],
    pipe: e10,
    _run(t10, r10) {
      for (let n10 = 0; n10 < e10.length; n10++) {
        if (t10.issues && (e10[n10].kind === "schema" || e10[n10].kind === "transformation")) {
          t10.typed = false;
          break;
        }
        (!t10.issues || !r10.abortEarly && !r10.abortPipeEarly) && (t10 = e10[n10]._run(t10, r10));
      }
      return t10;
    }
  };
}
function Fo(e10) {
  const t10 = Object.entries(e10).map(([r10, n10]) => Me({ [r10]: n10 }));
  return Kt(
    jr(t10),
    dl((r10) => ({
      ...r10,
      $kind: Object.keys(r10)[0]
    }))
  );
}
var Ms = Kt(
  yt(),
  dl((e10) => Ft(e10)),
  Ra(Xn)
);
var tn = Ms;
var jo = yt();
var Gr = Kt(
  jr([yt(), Kt(ar(), fr())]),
  Ra((e10) => {
    try {
      return BigInt(e10), BigInt(e10) >= 0 && BigInt(e10) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var Zi = Me({
  objectId: Ms,
  version: Gr,
  digest: yt()
});
var ir = Kt(
  jr([
    Me({ GasCoin: ct(true) }),
    Me({ Input: Kt(ar(), fr()), type: Dr(ct("pure")) }),
    Me({ Input: Kt(ar(), fr()), type: Dr(ct("object")) }),
    Me({ Result: Kt(ar(), fr()) }),
    Me({ NestedResult: Ed([Kt(ar(), fr()), Kt(ar(), fr())]) })
  ]),
  dl((e10) => ({
    ...e10,
    $kind: Object.keys(e10)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var H4 = Me({
  budget: qt(Gr),
  price: qt(Gr),
  owner: qt(Ms),
  payment: qt(tt(Zi))
});
var Sf = jr([
  ct("address"),
  ct("bool"),
  ct("u8"),
  ct("u16"),
  ct("u32"),
  ct("u64"),
  ct("u128"),
  ct("u256"),
  Me({ vector: ha(() => Sf) }),
  Me({
    datatype: Me({
      package: yt(),
      module: yt(),
      type: yt(),
      typeParameters: tt(ha(() => Sf))
    })
  }),
  Me({ typeParameter: Kt(ar(), fr()) })
]);
var W4 = Me({
  ref: qt(jr([ct("&"), ct("&mut")])),
  body: Sf
});
var G4 = Me({
  package: tn,
  module: yt(),
  function: yt(),
  // snake case in rust
  typeArguments: tt(yt()),
  arguments: tt(ir),
  _argumentTypes: Dr(qt(tt(W4)))
});
var K4 = Me({
  name: yt(),
  inputs: pa(yt(), jr([ir, tt(ir)])),
  data: pa(yt(), No())
});
var Y4 = Fo({
  MoveCall: G4,
  TransferObjects: Me({
    objects: tt(ir),
    address: ir
  }),
  SplitCoins: Me({
    coin: ir,
    amounts: tt(ir)
  }),
  MergeCoins: Me({
    destination: ir,
    sources: tt(ir)
  }),
  Publish: Me({
    modules: tt(jo),
    dependencies: tt(tn)
  }),
  MakeMoveVec: Me({
    type: qt(yt()),
    elements: tt(ir)
  }),
  Upgrade: Me({
    modules: tt(jo),
    dependencies: tt(tn),
    package: tn,
    ticket: ir
  }),
  $Intent: K4
});
var e1 = Fo({
  ImmOrOwnedObject: Zi,
  SharedObject: Me({
    objectId: tn,
    // snake case in rust
    initialSharedVersion: Gr,
    mutable: hl()
  }),
  Receiving: Zi
});
var X4 = Fo({
  Object: e1,
  Pure: Me({
    bytes: jo
  }),
  UnresolvedPure: Me({
    value: No()
  }),
  UnresolvedObject: Me({
    objectId: tn,
    version: Dr(qt(Gr)),
    digest: Dr(qt(yt())),
    initialSharedVersion: Dr(qt(Gr))
  })
});
var ph = Fo({
  Object: e1,
  Pure: Me({
    bytes: jo
  })
});
var t1 = Fo({
  None: ct(true),
  Epoch: Gr
});
var hc = Me({
  version: ct(2),
  sender: vs(Ms),
  expiration: vs(t1),
  gasData: H4,
  inputs: tt(X4),
  commands: tt(Y4)
});
var po = {
  MoveCall(e10) {
    const [t10, r10 = "", n10 = ""] = "target" in e10 ? e10.target.split("::") : [e10.package, e10.module, e10.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: t10,
        module: r10,
        function: n10,
        typeArguments: e10.typeArguments ?? [],
        arguments: e10.arguments ?? []
      }
    };
  },
  TransferObjects(e10, t10) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: e10.map((r10) => ur(ir, r10)),
        address: ur(ir, t10)
      }
    };
  },
  SplitCoins(e10, t10) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: ur(ir, e10),
        amounts: t10.map((r10) => ur(ir, r10))
      }
    };
  },
  MergeCoins(e10, t10) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: ur(ir, e10),
        sources: t10.map((r10) => ur(ir, r10))
      }
    };
  },
  Publish({
    modules: e10,
    dependencies: t10
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: e10.map(
          (r10) => typeof r10 == "string" ? r10 : Sr(new Uint8Array(r10))
        ),
        dependencies: t10.map((r10) => en(r10))
      }
    };
  },
  Upgrade({
    modules: e10,
    dependencies: t10,
    package: r10,
    ticket: n10
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: e10.map(
          (i10) => typeof i10 == "string" ? i10 : Sr(new Uint8Array(i10))
        ),
        dependencies: t10.map((i10) => en(i10)),
        package: r10,
        ticket: ur(ir, n10)
      }
    };
  },
  MakeMoveVec({
    type: e10,
    elements: t10
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: e10 ?? null,
        elements: t10.map((r10) => ur(ir, r10))
      }
    };
  },
  Intent({
    name: e10,
    inputs: t10 = {},
    data: r10 = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name: e10,
        inputs: Object.fromEntries(
          Object.entries(t10).map(([n10, i10]) => [
            n10,
            Array.isArray(i10) ? i10.map((o10) => ur(ir, o10)) : ur(ir, i10)
          ])
        ),
        data: r10
      }
    };
  }
};
var _f = Me({
  digest: yt(),
  objectId: yt(),
  version: jr([Kt(ar(), fr()), yt(), _d()])
});
var J4 = Fo({
  ImmOrOwned: _f,
  Shared: Me({
    objectId: tn,
    initialSharedVersion: Gr,
    mutable: hl()
  }),
  Receiving: _f
});
var mh = Fo({
  Object: J4,
  Pure: tt(Kt(ar(), fr()))
});
var r1 = jr([
  Me({
    kind: ct("Input"),
    index: Kt(ar(), fr()),
    value: No(),
    type: Dr(ct("object"))
  }),
  Me({
    kind: ct("Input"),
    index: Kt(ar(), fr()),
    value: No(),
    type: ct("pure")
  })
]);
var Z4 = jr([
  Me({ Epoch: Kt(ar(), fr()) }),
  Me({ None: qt(ct(true)) })
]);
var gh = Kt(
  jr([ar(), yt(), _d()]),
  Ra((e10) => {
    if (!["string", "number", "bigint"].includes(typeof e10))
      return false;
    try {
      return BigInt(e10), true;
    } catch {
      return false;
    }
  })
);
var Cd = jr([
  Me({ bool: qt(ct(true)) }),
  Me({ u8: qt(ct(true)) }),
  Me({ u64: qt(ct(true)) }),
  Me({ u128: qt(ct(true)) }),
  Me({ address: qt(ct(true)) }),
  Me({ signer: qt(ct(true)) }),
  Me({ vector: ha(() => Cd) }),
  Me({ struct: ha(() => Q4) }),
  Me({ u16: qt(ct(true)) }),
  Me({ u32: qt(ct(true)) }),
  Me({ u256: qt(ct(true)) })
]);
var Q4 = Me({
  address: yt(),
  module: yt(),
  name: yt(),
  typeParams: tt(Cd)
});
var e8 = Me({
  budget: Dr(gh),
  price: Dr(gh),
  payment: Dr(tt(_f)),
  owner: Dr(yt())
});
var t8 = [
  r1,
  Me({ kind: ct("GasCoin") }),
  Me({ kind: ct("Result"), index: Kt(ar(), fr()) }),
  Me({
    kind: ct("NestedResult"),
    index: Kt(ar(), fr()),
    resultIndex: Kt(ar(), fr())
  })
];
var Ii = jr([...t8]);
var r8 = Me({
  kind: ct("MoveCall"),
  target: Kt(
    yt(),
    Ra((e10) => e10.split("::").length === 3)
  ),
  typeArguments: tt(yt()),
  arguments: tt(Ii)
});
var n8 = Me({
  kind: ct("TransferObjects"),
  objects: tt(Ii),
  address: Ii
});
var i8 = Me({
  kind: ct("SplitCoins"),
  coin: Ii,
  amounts: tt(Ii)
});
var o8 = Me({
  kind: ct("MergeCoins"),
  destination: Ii,
  sources: tt(Ii)
});
var s8 = Me({
  kind: ct("MakeMoveVec"),
  type: jr([Me({ Some: Cd }), Me({ None: qt(ct(true)) })]),
  objects: tt(Ii)
});
var a8 = Me({
  kind: ct("Publish"),
  modules: tt(tt(Kt(ar(), fr()))),
  dependencies: tt(yt())
});
var c8 = Me({
  kind: ct("Upgrade"),
  modules: tt(tt(Kt(ar(), fr()))),
  dependencies: tt(yt()),
  packageId: yt(),
  ticket: Ii
});
var l8 = [
  r8,
  n8,
  i8,
  o8,
  a8,
  c8,
  s8
];
var u8 = jr([...l8]);
Me({
  version: ct(1),
  sender: Dr(yt()),
  expiration: vs(Z4),
  gasConfig: e8,
  inputs: tt(r1),
  transactions: tt(u8)
});
function vh(e10) {
  var r10;
  const t10 = e10.inputs.map(
    (n10, i10) => {
      if (n10.Object)
        return {
          kind: "Input",
          index: i10,
          value: {
            Object: n10.Object.ImmOrOwnedObject ? {
              ImmOrOwned: n10.Object.ImmOrOwnedObject
            } : n10.Object.Receiving ? {
              Receiving: {
                digest: n10.Object.Receiving.digest,
                version: n10.Object.Receiving.version,
                objectId: n10.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: n10.Object.SharedObject.mutable,
                initialSharedVersion: n10.Object.SharedObject.initialSharedVersion,
                objectId: n10.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      if (n10.Pure)
        return {
          kind: "Input",
          index: i10,
          value: {
            Pure: Array.from(Cr(n10.Pure.bytes))
          },
          type: "pure"
        };
      if (n10.UnresolvedPure)
        return {
          kind: "Input",
          type: "pure",
          index: i10,
          value: n10.UnresolvedPure.value
        };
      if (n10.UnresolvedObject)
        return {
          kind: "Input",
          type: "object",
          index: i10,
          value: n10.UnresolvedObject.objectId
        };
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: e10.sender ?? void 0,
    expiration: ((r10 = e10.expiration) == null ? void 0 : r10.$kind) === "Epoch" ? { Epoch: Number(e10.expiration.Epoch) } : e10.expiration ? { None: true } : null,
    gasConfig: {
      owner: e10.gasData.owner ?? void 0,
      budget: e10.gasData.budget ?? void 0,
      price: e10.gasData.price ?? void 0,
      payment: e10.gasData.payment ?? void 0
    },
    inputs: t10,
    transactions: e10.commands.map((n10) => {
      if (n10.MakeMoveVec)
        return {
          kind: "MakeMoveVec",
          type: n10.MakeMoveVec.type === null ? { None: true } : { Some: Dc.parseFromStr(n10.MakeMoveVec.type) },
          objects: n10.MakeMoveVec.elements.map(
            (i10) => hi(i10, t10)
          )
        };
      if (n10.MergeCoins)
        return {
          kind: "MergeCoins",
          destination: hi(n10.MergeCoins.destination, t10),
          sources: n10.MergeCoins.sources.map((i10) => hi(i10, t10))
        };
      if (n10.MoveCall)
        return {
          kind: "MoveCall",
          target: `${n10.MoveCall.package}::${n10.MoveCall.module}::${n10.MoveCall.function}`,
          typeArguments: n10.MoveCall.typeArguments,
          arguments: n10.MoveCall.arguments.map(
            (i10) => hi(i10, t10)
          )
        };
      if (n10.Publish)
        return {
          kind: "Publish",
          modules: n10.Publish.modules.map((i10) => Array.from(Cr(i10))),
          dependencies: n10.Publish.dependencies
        };
      if (n10.SplitCoins)
        return {
          kind: "SplitCoins",
          coin: hi(n10.SplitCoins.coin, t10),
          amounts: n10.SplitCoins.amounts.map((i10) => hi(i10, t10))
        };
      if (n10.TransferObjects)
        return {
          kind: "TransferObjects",
          objects: n10.TransferObjects.objects.map(
            (i10) => hi(i10, t10)
          ),
          address: hi(n10.TransferObjects.address, t10)
        };
      if (n10.Upgrade)
        return {
          kind: "Upgrade",
          modules: n10.Upgrade.modules.map((i10) => Array.from(Cr(i10))),
          dependencies: n10.Upgrade.dependencies,
          packageId: n10.Upgrade.package,
          ticket: hi(n10.Upgrade.ticket, t10)
        };
      throw new Error(`Unknown transaction ${Object.keys(n10)}`);
    })
  };
}
function hi(e10, t10) {
  if (e10.$kind === "GasCoin")
    return { kind: "GasCoin" };
  if (e10.$kind === "Result")
    return { kind: "Result", index: e10.Result };
  if (e10.$kind === "NestedResult")
    return { kind: "NestedResult", index: e10.NestedResult[0], resultIndex: e10.NestedResult[1] };
  if (e10.$kind === "Input")
    return t10[e10.Input];
  throw new Error(`Invalid argument ${Object.keys(e10)}`);
}
function f8(e10) {
  var t10, r10, n10;
  return ur(hc, {
    version: 2,
    sender: e10.sender ?? null,
    expiration: e10.expiration ? "Epoch" in e10.expiration ? { Epoch: e10.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: e10.gasConfig.owner ?? null,
      budget: ((t10 = e10.gasConfig.budget) == null ? void 0 : t10.toString()) ?? null,
      price: ((r10 = e10.gasConfig.price) == null ? void 0 : r10.toString()) ?? null,
      payment: ((n10 = e10.gasConfig.payment) == null ? void 0 : n10.map((i10) => ({
        digest: i10.digest,
        objectId: i10.objectId,
        version: i10.version.toString()
      }))) ?? null
    },
    inputs: e10.inputs.map((i10) => {
      if (i10.kind === "Input") {
        if (xf(mh, i10.value)) {
          const o10 = ur(mh, i10.value);
          if (o10.Object) {
            if (o10.Object.ImmOrOwned)
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: o10.Object.ImmOrOwned.objectId,
                    version: String(o10.Object.ImmOrOwned.version),
                    digest: o10.Object.ImmOrOwned.digest
                  }
                }
              };
            if (o10.Object.Shared)
              return {
                Object: {
                  SharedObject: {
                    mutable: o10.Object.Shared.mutable ?? null,
                    initialSharedVersion: o10.Object.Shared.initialSharedVersion,
                    objectId: o10.Object.Shared.objectId
                  }
                }
              };
            if (o10.Object.Receiving)
              return {
                Object: {
                  Receiving: {
                    digest: o10.Object.Receiving.digest,
                    version: String(o10.Object.Receiving.version),
                    objectId: o10.Object.Receiving.objectId
                  }
                }
              };
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: Sr(new Uint8Array(o10.Pure))
            }
          };
        }
        return i10.type === "object" ? {
          UnresolvedObject: {
            objectId: i10.value
          }
        } : {
          UnresolvedPure: {
            value: i10.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: e10.transactions.map((i10) => {
      switch (i10.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in i10.type ? Dc.tagToString(i10.type.Some) : null,
              elements: i10.objects.map((o10) => pi(o10))
            }
          };
        case "MergeCoins":
          return {
            MergeCoins: {
              destination: pi(i10.destination),
              sources: i10.sources.map((o10) => pi(o10))
            }
          };
        case "MoveCall": {
          const [o10, s10, a10] = i10.target.split("::");
          return {
            MoveCall: {
              package: o10,
              module: s10,
              function: a10,
              typeArguments: i10.typeArguments,
              arguments: i10.arguments.map((c) => pi(c))
            }
          };
        }
        case "Publish":
          return {
            Publish: {
              modules: i10.modules.map((o10) => Sr(Uint8Array.from(o10))),
              dependencies: i10.dependencies
            }
          };
        case "SplitCoins":
          return {
            SplitCoins: {
              coin: pi(i10.coin),
              amounts: i10.amounts.map((o10) => pi(o10))
            }
          };
        case "TransferObjects":
          return {
            TransferObjects: {
              objects: i10.objects.map((o10) => pi(o10)),
              address: pi(i10.address)
            }
          };
        case "Upgrade":
          return {
            Upgrade: {
              modules: i10.modules.map((o10) => Sr(Uint8Array.from(o10))),
              dependencies: i10.dependencies,
              package: i10.packageId,
              ticket: pi(i10.ticket)
            }
          };
      }
      throw new Error(`Unknown transaction ${Object.keys(i10)}`);
    })
  });
}
function pi(e10) {
  switch (e10.kind) {
    case "GasCoin":
      return { GasCoin: true };
    case "Result":
      return { Result: e10.index };
    case "NestedResult":
      return { NestedResult: [e10.index, e10.resultIndex] };
    case "Input":
      return { Input: e10.index };
  }
}
function Pa(e10) {
  return jr(
    Object.entries(e10).map(([t10, r10]) => Me({ [t10]: r10 }))
  );
}
var _n = Pa({
  GasCoin: ct(true),
  Input: Kt(ar(), fr()),
  Result: Kt(ar(), fr()),
  NestedResult: Ed([Kt(ar(), fr()), Kt(ar(), fr())])
});
var d8 = Me({
  budget: qt(Gr),
  price: qt(Gr),
  owner: qt(Ms),
  payment: qt(tt(Zi))
});
var h8 = Me({
  package: tn,
  module: yt(),
  function: yt(),
  // snake case in rust
  typeArguments: tt(yt()),
  arguments: tt(_n)
});
var p8 = Me({
  name: yt(),
  inputs: pa(yt(), jr([_n, tt(_n)])),
  data: pa(yt(), No())
});
var m8 = Pa({
  MoveCall: h8,
  TransferObjects: Me({
    objects: tt(_n),
    address: _n
  }),
  SplitCoins: Me({
    coin: _n,
    amounts: tt(_n)
  }),
  MergeCoins: Me({
    destination: _n,
    sources: tt(_n)
  }),
  Publish: Me({
    modules: tt(jo),
    dependencies: tt(tn)
  }),
  MakeMoveVec: Me({
    type: qt(yt()),
    elements: tt(_n)
  }),
  Upgrade: Me({
    modules: tt(jo),
    dependencies: tt(tn),
    package: tn,
    ticket: _n
  }),
  $Intent: p8
});
var g8 = Pa({
  ImmOrOwnedObject: Zi,
  SharedObject: Me({
    objectId: tn,
    // snake case in rust
    initialSharedVersion: Gr,
    mutable: hl()
  }),
  Receiving: Zi
});
var v8 = Pa({
  Object: g8,
  Pure: Me({
    bytes: jo
  }),
  UnresolvedPure: Me({
    value: No()
  }),
  UnresolvedObject: Me({
    objectId: tn,
    version: Dr(qt(Gr)),
    digest: Dr(qt(yt())),
    initialSharedVersion: Dr(qt(Gr))
  })
});
var b8 = Pa({
  None: ct(true),
  Epoch: Gr
});
var y8 = Me({
  version: ct(2),
  sender: vs(Ms),
  expiration: vs(b8),
  gasData: d8,
  inputs: tt(v8),
  commands: tt(m8)
});
function w8(e10) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: e10 instanceof Uint8Array ? Sr(e10) : e10.toBase64()
    }
  };
}
var _i = {
  Pure: w8,
  ObjectRef({ objectId: e10, digest: t10, version: r10 }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest: t10,
          version: r10,
          objectId: Ft(e10)
        }
      }
    };
  },
  SharedObjectRef({
    objectId: e10,
    mutable: t10,
    initialSharedVersion: r10
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable: t10,
          initialSharedVersion: r10,
          objectId: Ft(e10)
        }
      }
    };
  },
  ReceivingRef({ objectId: e10, digest: t10, version: r10 }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest: t10,
          version: r10,
          objectId: Ft(e10)
        }
      }
    };
  }
};
var n1 = "…";
function x8(e10) {
  if (e10.length <= 6)
    return e10;
  const t10 = e10.startsWith("0x") ? 2 : 0;
  return `0x${e10.slice(t10, t10 + 4)}${n1}${e10.slice(-4)}`;
}
function S8(e10) {
  return `${e10.slice(0, 10)}${n1}`;
}
var _8 = 9;
var E8 = BigInt(1e9);
var i1 = "0x1";
var ma = "0x2";
var C8 = "0x3";
var o1 = en("0x6");
var T8 = "sui_system";
var pl = `${ma}::sui::SUI`;
var A8 = en("0x5");
function xu(e10) {
  if (!Number.isSafeInteger(e10) || e10 < 0)
    throw new Error("positive integer expected, got " + e10);
}
function M8(e10) {
  return e10 instanceof Uint8Array || ArrayBuffer.isView(e10) && e10.constructor.name === "Uint8Array";
}
function s1(e10, ...t10) {
  if (!M8(e10))
    throw new Error("Uint8Array expected");
  if (t10.length > 0 && !t10.includes(e10.length))
    throw new Error("Uint8Array expected of length " + t10 + ", got length=" + e10.length);
}
function bh(e10, t10 = true) {
  if (e10.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t10 && e10.finished)
    throw new Error("Hash#digest() has already been called");
}
function I8(e10, t10) {
  s1(e10);
  const r10 = t10.outputLen;
  if (e10.length < r10)
    throw new Error("digestInto() expects output buffer of length at least " + r10);
}
function Lc(e10) {
  return new Uint32Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 4));
}
var So = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function a1(e10) {
  return e10 << 24 & 4278190080 | e10 << 8 & 16711680 | e10 >>> 8 & 65280 | e10 >>> 24 & 255;
}
var vi = So ? (e10) => e10 : (e10) => a1(e10);
function Ko(e10) {
  for (let t10 = 0; t10 < e10.length; t10++)
    e10[t10] = a1(e10[t10]);
}
function O8(e10) {
  if (typeof e10 != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof e10);
  return new Uint8Array(new TextEncoder().encode(e10));
}
function aa(e10) {
  return typeof e10 == "string" && (e10 = O8(e10)), s1(e10), e10;
}
var R8 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function P8(e10) {
  const t10 = (n10, i10) => e10(i10).update(aa(n10)).digest(), r10 = e10({});
  return t10.outputLen = r10.outputLen, t10.blockLen = r10.blockLen, t10.create = (n10) => e10(n10), t10;
}
var N8 = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
var j8 = class extends R8 {
  constructor(t10, r10, n10 = {}, i10, o10, s10) {
    if (super(), this.blockLen = t10, this.outputLen = r10, this.length = 0, this.pos = 0, this.finished = false, this.destroyed = false, xu(t10), xu(r10), xu(i10), r10 < 0 || r10 > i10)
      throw new Error("outputLen bigger than keyLen");
    if (n10.key !== void 0 && (n10.key.length < 1 || n10.key.length > i10))
      throw new Error("key length must be undefined or 1.." + i10);
    if (n10.salt !== void 0 && n10.salt.length !== o10)
      throw new Error("salt must be undefined or " + o10);
    if (n10.personalization !== void 0 && n10.personalization.length !== s10)
      throw new Error("personalization must be undefined or " + s10);
    this.buffer = new Uint8Array(t10), this.buffer32 = Lc(this.buffer);
  }
  update(t10) {
    bh(this);
    const { blockLen: r10, buffer: n10, buffer32: i10 } = this;
    t10 = aa(t10);
    const o10 = t10.length, s10 = t10.byteOffset, a10 = t10.buffer;
    for (let c = 0; c < o10; ) {
      this.pos === r10 && (So || Ko(i10), this.compress(i10, 0, false), So || Ko(i10), this.pos = 0);
      const l10 = Math.min(r10 - this.pos, o10 - c), u10 = s10 + c;
      if (l10 === r10 && !(u10 % 4) && c + l10 < o10) {
        const d6 = new Uint32Array(a10, u10, Math.floor((o10 - c) / 4));
        So || Ko(d6);
        for (let p = 0; c + r10 < o10; p += i10.length, c += r10)
          this.length += r10, this.compress(d6, p, false);
        So || Ko(d6);
        continue;
      }
      n10.set(t10.subarray(c, c + l10), this.pos), this.pos += l10, this.length += l10, c += l10;
    }
    return this;
  }
  digestInto(t10) {
    bh(this), I8(t10, this);
    const { pos: r10, buffer32: n10 } = this;
    this.finished = true, this.buffer.subarray(r10).fill(0), So || Ko(n10), this.compress(n10, 0, true), So || Ko(n10);
    const i10 = Lc(t10);
    this.get().forEach((o10, s10) => i10[s10] = vi(o10));
  }
  digest() {
    const { buffer: t10, outputLen: r10 } = this;
    this.digestInto(t10);
    const n10 = t10.slice(0, r10);
    return this.destroy(), n10;
  }
  _cloneInto(t10) {
    const { buffer: r10, length: n10, finished: i10, destroyed: o10, outputLen: s10, pos: a10 } = this;
    return t10 || (t10 = new this.constructor({ dkLen: s10 })), t10.set(...this.get()), t10.length = n10, t10.finished = i10, t10.destroyed = o10, t10.outputLen = s10, t10.buffer.set(r10), t10.pos = a10, t10;
  }
};
var Xa = BigInt(2 ** 32 - 1);
var Ef = BigInt(32);
function c1(e10, t10 = false) {
  return t10 ? { h: Number(e10 & Xa), l: Number(e10 >> Ef & Xa) } : { h: Number(e10 >> Ef & Xa) | 0, l: Number(e10 & Xa) | 0 };
}
function k8(e10, t10 = false) {
  let r10 = new Uint32Array(e10.length), n10 = new Uint32Array(e10.length);
  for (let i10 = 0; i10 < e10.length; i10++) {
    const { h: o10, l: s10 } = c1(e10[i10], t10);
    [r10[i10], n10[i10]] = [o10, s10];
  }
  return [r10, n10];
}
var D8 = (e10, t10) => BigInt(e10 >>> 0) << Ef | BigInt(t10 >>> 0);
var L8 = (e10, t10, r10) => e10 >>> r10;
var B8 = (e10, t10, r10) => e10 << 32 - r10 | t10 >>> r10;
var U8 = (e10, t10, r10) => e10 >>> r10 | t10 << 32 - r10;
var F8 = (e10, t10, r10) => e10 << 32 - r10 | t10 >>> r10;
var $8 = (e10, t10, r10) => e10 << 64 - r10 | t10 >>> r10 - 32;
var V8 = (e10, t10, r10) => e10 >>> r10 - 32 | t10 << 64 - r10;
var z8 = (e10, t10) => t10;
var q8 = (e10, t10) => e10;
var H8 = (e10, t10, r10) => e10 << r10 | t10 >>> 32 - r10;
var W8 = (e10, t10, r10) => t10 << r10 | e10 >>> 32 - r10;
var G8 = (e10, t10, r10) => t10 << r10 - 32 | e10 >>> 64 - r10;
var K8 = (e10, t10, r10) => e10 << r10 - 32 | t10 >>> 64 - r10;
function Y8(e10, t10, r10, n10) {
  const i10 = (t10 >>> 0) + (n10 >>> 0);
  return { h: e10 + r10 + (i10 / 2 ** 32 | 0) | 0, l: i10 | 0 };
}
var X8 = (e10, t10, r10) => (e10 >>> 0) + (t10 >>> 0) + (r10 >>> 0);
var J8 = (e10, t10, r10, n10) => t10 + r10 + n10 + (e10 / 2 ** 32 | 0) | 0;
var Z8 = (e10, t10, r10, n10) => (e10 >>> 0) + (t10 >>> 0) + (r10 >>> 0) + (n10 >>> 0);
var Q8 = (e10, t10, r10, n10, i10) => t10 + r10 + n10 + i10 + (e10 / 2 ** 32 | 0) | 0;
var e3 = (e10, t10, r10, n10, i10) => (e10 >>> 0) + (t10 >>> 0) + (r10 >>> 0) + (n10 >>> 0) + (i10 >>> 0);
var t3 = (e10, t10, r10, n10, i10, o10) => t10 + r10 + n10 + i10 + o10 + (e10 / 2 ** 32 | 0) | 0;
var r3 = {
  fromBig: c1,
  split: k8,
  toBig: D8,
  shrSH: L8,
  shrSL: B8,
  rotrSH: U8,
  rotrSL: F8,
  rotrBH: $8,
  rotrBL: V8,
  rotr32H: z8,
  rotr32L: q8,
  rotlSH: H8,
  rotlSL: W8,
  rotlBH: G8,
  rotlBL: K8,
  add: Y8,
  add3L: X8,
  add3H: J8,
  add4L: Z8,
  add4H: Q8,
  add5H: t3,
  add5L: e3
};
var Vr = r3;
var vr = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var Ie = new Uint32Array(32);
function Ui(e10, t10, r10, n10, i10, o10) {
  const s10 = i10[o10], a10 = i10[o10 + 1];
  let c = Ie[2 * e10], l10 = Ie[2 * e10 + 1], u10 = Ie[2 * t10], d6 = Ie[2 * t10 + 1], p = Ie[2 * r10], y = Ie[2 * r10 + 1], x = Ie[2 * n10], b = Ie[2 * n10 + 1], M = Vr.add3L(c, u10, s10);
  l10 = Vr.add3H(M, l10, d6, a10), c = M | 0, { Dh: b, Dl: x } = { Dh: b ^ l10, Dl: x ^ c }, { Dh: b, Dl: x } = { Dh: Vr.rotr32H(b, x), Dl: Vr.rotr32L(b, x) }, { h: y, l: p } = Vr.add(y, p, b, x), { Bh: d6, Bl: u10 } = { Bh: d6 ^ y, Bl: u10 ^ p }, { Bh: d6, Bl: u10 } = { Bh: Vr.rotrSH(d6, u10, 24), Bl: Vr.rotrSL(d6, u10, 24) }, Ie[2 * e10] = c, Ie[2 * e10 + 1] = l10, Ie[2 * t10] = u10, Ie[2 * t10 + 1] = d6, Ie[2 * r10] = p, Ie[2 * r10 + 1] = y, Ie[2 * n10] = x, Ie[2 * n10 + 1] = b;
}
function Fi(e10, t10, r10, n10, i10, o10) {
  const s10 = i10[o10], a10 = i10[o10 + 1];
  let c = Ie[2 * e10], l10 = Ie[2 * e10 + 1], u10 = Ie[2 * t10], d6 = Ie[2 * t10 + 1], p = Ie[2 * r10], y = Ie[2 * r10 + 1], x = Ie[2 * n10], b = Ie[2 * n10 + 1], M = Vr.add3L(c, u10, s10);
  l10 = Vr.add3H(M, l10, d6, a10), c = M | 0, { Dh: b, Dl: x } = { Dh: b ^ l10, Dl: x ^ c }, { Dh: b, Dl: x } = { Dh: Vr.rotrSH(b, x, 16), Dl: Vr.rotrSL(b, x, 16) }, { h: y, l: p } = Vr.add(y, p, b, x), { Bh: d6, Bl: u10 } = { Bh: d6 ^ y, Bl: u10 ^ p }, { Bh: d6, Bl: u10 } = { Bh: Vr.rotrBH(d6, u10, 63), Bl: Vr.rotrBL(d6, u10, 63) }, Ie[2 * e10] = c, Ie[2 * e10 + 1] = l10, Ie[2 * t10] = u10, Ie[2 * t10 + 1] = d6, Ie[2 * r10] = p, Ie[2 * r10 + 1] = y, Ie[2 * n10] = x, Ie[2 * n10 + 1] = b;
}
var n3 = class extends j8 {
  constructor(t10 = {}) {
    super(128, t10.dkLen === void 0 ? 64 : t10.dkLen, t10, 64, 16, 16), this.v0l = vr[0] | 0, this.v0h = vr[1] | 0, this.v1l = vr[2] | 0, this.v1h = vr[3] | 0, this.v2l = vr[4] | 0, this.v2h = vr[5] | 0, this.v3l = vr[6] | 0, this.v3h = vr[7] | 0, this.v4l = vr[8] | 0, this.v4h = vr[9] | 0, this.v5l = vr[10] | 0, this.v5h = vr[11] | 0, this.v6l = vr[12] | 0, this.v6h = vr[13] | 0, this.v7l = vr[14] | 0, this.v7h = vr[15] | 0;
    const r10 = t10.key ? t10.key.length : 0;
    if (this.v0l ^= this.outputLen | r10 << 8 | 65536 | 1 << 24, t10.salt) {
      const n10 = Lc(aa(t10.salt));
      this.v4l ^= vi(n10[0]), this.v4h ^= vi(n10[1]), this.v5l ^= vi(n10[2]), this.v5h ^= vi(n10[3]);
    }
    if (t10.personalization) {
      const n10 = Lc(aa(t10.personalization));
      this.v6l ^= vi(n10[0]), this.v6h ^= vi(n10[1]), this.v7l ^= vi(n10[2]), this.v7h ^= vi(n10[3]);
    }
    if (t10.key) {
      const n10 = new Uint8Array(this.blockLen);
      n10.set(aa(t10.key)), this.update(n10);
    }
  }
  // prettier-ignore
  get() {
    let { v0l: t10, v0h: r10, v1l: n10, v1h: i10, v2l: o10, v2h: s10, v3l: a10, v3h: c, v4l: l10, v4h: u10, v5l: d6, v5h: p, v6l: y, v6h: x, v7l: b, v7h: M } = this;
    return [t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y, x, b, M];
  }
  // prettier-ignore
  set(t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y, x, b, M) {
    this.v0l = t10 | 0, this.v0h = r10 | 0, this.v1l = n10 | 0, this.v1h = i10 | 0, this.v2l = o10 | 0, this.v2h = s10 | 0, this.v3l = a10 | 0, this.v3h = c | 0, this.v4l = l10 | 0, this.v4h = u10 | 0, this.v5l = d6 | 0, this.v5h = p | 0, this.v6l = y | 0, this.v6h = x | 0, this.v7l = b | 0, this.v7h = M | 0;
  }
  compress(t10, r10, n10) {
    this.get().forEach((c, l10) => Ie[l10] = c), Ie.set(vr, 16);
    let { h: i10, l: o10 } = Vr.fromBig(BigInt(this.length));
    Ie[24] = vr[8] ^ o10, Ie[25] = vr[9] ^ i10, n10 && (Ie[28] = ~Ie[28], Ie[29] = ~Ie[29]);
    let s10 = 0;
    const a10 = N8;
    for (let c = 0; c < 12; c++)
      Ui(0, 4, 8, 12, t10, r10 + 2 * a10[s10++]), Fi(0, 4, 8, 12, t10, r10 + 2 * a10[s10++]), Ui(1, 5, 9, 13, t10, r10 + 2 * a10[s10++]), Fi(1, 5, 9, 13, t10, r10 + 2 * a10[s10++]), Ui(2, 6, 10, 14, t10, r10 + 2 * a10[s10++]), Fi(2, 6, 10, 14, t10, r10 + 2 * a10[s10++]), Ui(3, 7, 11, 15, t10, r10 + 2 * a10[s10++]), Fi(3, 7, 11, 15, t10, r10 + 2 * a10[s10++]), Ui(0, 5, 10, 15, t10, r10 + 2 * a10[s10++]), Fi(0, 5, 10, 15, t10, r10 + 2 * a10[s10++]), Ui(1, 6, 11, 12, t10, r10 + 2 * a10[s10++]), Fi(1, 6, 11, 12, t10, r10 + 2 * a10[s10++]), Ui(2, 7, 8, 13, t10, r10 + 2 * a10[s10++]), Fi(2, 7, 8, 13, t10, r10 + 2 * a10[s10++]), Ui(3, 4, 9, 14, t10, r10 + 2 * a10[s10++]), Fi(3, 4, 9, 14, t10, r10 + 2 * a10[s10++]);
    this.v0l ^= Ie[0] ^ Ie[16], this.v0h ^= Ie[1] ^ Ie[17], this.v1l ^= Ie[2] ^ Ie[18], this.v1h ^= Ie[3] ^ Ie[19], this.v2l ^= Ie[4] ^ Ie[20], this.v2h ^= Ie[5] ^ Ie[21], this.v3l ^= Ie[6] ^ Ie[22], this.v3h ^= Ie[7] ^ Ie[23], this.v4l ^= Ie[8] ^ Ie[24], this.v4h ^= Ie[9] ^ Ie[25], this.v5l ^= Ie[10] ^ Ie[26], this.v5h ^= Ie[11] ^ Ie[27], this.v6l ^= Ie[12] ^ Ie[28], this.v6h ^= Ie[13] ^ Ie[29], this.v7l ^= Ie[14] ^ Ie[30], this.v7h ^= Ie[15] ^ Ie[31], Ie.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer32.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var l1 = P8((e10) => new n3(e10));
function i3(e10, t10, r10) {
  const n10 = gt.Address.serialize(e10).toBytes(), i10 = gt.TypeTag.serialize(t10).toBytes(), o10 = gt.u64().serialize(r10.length).toBytes(), s10 = l1.create({
    dkLen: 32
  });
  return s10.update(new Uint8Array([240])), s10.update(n10), s10.update(o10), s10.update(r10), s10.update(i10), `0x${Mi(s10.digest().slice(0, 32))}`;
}
var o3 = Object.freeze(Object.defineProperty({
  __proto__: null,
  MIST_PER_SUI: E8,
  MOVE_STDLIB_ADDRESS: i1,
  SUI_ADDRESS_LENGTH: fl,
  SUI_CLOCK_OBJECT_ID: o1,
  SUI_DECIMALS: _8,
  SUI_FRAMEWORK_ADDRESS: ma,
  SUI_SYSTEM_ADDRESS: C8,
  SUI_SYSTEM_MODULE_NAME: T8,
  SUI_SYSTEM_STATE_OBJECT_ID: A8,
  SUI_TYPE_ARG: pl,
  deriveDynamicFieldID: i3,
  formatAddress: x8,
  formatDigest: S8,
  fromB64: fg,
  fromBase58: Ai,
  fromBase64: Cr,
  fromHEX: hg,
  fromHex: As,
  isValidNamedPackage: vd,
  isValidNamedType: d4,
  isValidSuiAddress: Xn,
  isValidSuiNSName: Cg,
  isValidSuiObjectId: ea,
  isValidTransactionDigest: wf,
  normalizeStructTag: Mg,
  normalizeSuiAddress: Ft,
  normalizeSuiNSName: Tg,
  normalizeSuiObjectId: en,
  parseStructTag: bd,
  toB64: ug,
  toBase58: Uo,
  toBase64: Sr,
  toHEX: dg,
  toHex: Mi
}, Symbol.toStringTag, { value: "Module" }));
var s3 = "object";
var a3 = "ID";
var c3 = "ascii";
var l3 = "String";
var u3 = "string";
var f3 = "String";
var d3 = "option";
var h3 = "Option";
function p3(e10) {
  const t10 = typeof e10.body == "object" && "datatype" in e10.body ? e10.body.datatype : null;
  return !!t10 && Ft(t10.package) === Ft("0x2") && t10.module === "tx_context" && t10.type === "TxContext";
}
function Cf(e10) {
  if (typeof e10 == "string")
    switch (e10) {
      case "address":
        return gt.Address;
      case "bool":
        return gt.Bool;
      case "u8":
        return gt.U8;
      case "u16":
        return gt.U16;
      case "u32":
        return gt.U32;
      case "u64":
        return gt.U64;
      case "u128":
        return gt.U128;
      case "u256":
        return gt.U256;
      default:
        throw new Error(`Unknown type signature ${e10}`);
    }
  if ("vector" in e10) {
    if (e10.vector === "u8")
      return gt.vector(gt.U8).transform({
        input: (r10) => typeof r10 == "string" ? new TextEncoder().encode(r10) : r10,
        output: (r10) => r10
      });
    const t10 = Cf(e10.vector);
    return t10 ? gt.vector(t10) : null;
  }
  if ("datatype" in e10) {
    const t10 = Ft(e10.datatype.package);
    if (t10 === Ft(i1)) {
      if (e10.datatype.module === c3 && e10.datatype.type === l3 || e10.datatype.module === u3 && e10.datatype.type === f3)
        return gt.String;
      if (e10.datatype.module === d3 && e10.datatype.type === h3) {
        const r10 = Cf(e10.datatype.typeParameters[0]);
        return r10 ? gt.vector(r10) : null;
      }
    }
    if (t10 === Ft(ma) && e10.datatype.module === s3 && e10.datatype.type === a3)
      return gt.Address;
  }
  return null;
}
function m3(e10) {
  return typeof e10 == "object" && "Reference" in e10 ? {
    ref: "&",
    body: ca(e10.Reference)
  } : typeof e10 == "object" && "MutableReference" in e10 ? {
    ref: "&mut",
    body: ca(e10.MutableReference)
  } : {
    ref: null,
    body: ca(e10)
  };
}
function ca(e10) {
  if (typeof e10 == "string")
    switch (e10) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${e10}`);
    }
  if ("Vector" in e10)
    return { vector: ca(e10.Vector) };
  if ("Struct" in e10)
    return {
      datatype: {
        package: e10.Struct.address,
        module: e10.Struct.module,
        type: e10.Struct.name,
        typeParameters: e10.Struct.typeArguments.map(ca)
      }
    };
  if ("TypeParameter" in e10)
    return { typeParameter: e10.TypeParameter };
  throw new Error(`Unexpected type ${JSON.stringify(e10)}`);
}
var g3 = 50;
var v3 = 1000n;
var b3 = 5e10;
async function y3(e10, t10, r10) {
  return await E3(e10, t10), await _3(e10, t10), t10.onlyTransactionKind || (await w3(e10, t10), await x3(e10, t10), await S3(e10, t10)), await C3(e10), await r10();
}
async function w3(e10, t10) {
  e10.gasConfig.price || (e10.gasConfig.price = String(await Na(t10).getReferenceGasPrice()));
}
async function x3(e10, t10) {
  if (e10.gasConfig.budget)
    return;
  const r10 = await Na(t10).dryRunTransactionBlock({
    transactionBlock: e10.build({
      overrides: {
        gasData: {
          budget: String(b3),
          payment: []
        }
      }
    })
  });
  if (r10.effects.status.status !== "success")
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${r10.effects.status.error}`,
      { cause: r10 }
    );
  const n10 = v3 * BigInt(e10.gasConfig.price || 1n), i10 = BigInt(r10.effects.gasUsed.computationCost) + n10, o10 = i10 + BigInt(r10.effects.gasUsed.storageCost) - BigInt(r10.effects.gasUsed.storageRebate);
  e10.gasConfig.budget = String(
    o10 > i10 ? o10 : i10
  );
}
async function S3(e10, t10) {
  if (!e10.gasConfig.payment) {
    const n10 = (await Na(t10).getCoins({
      owner: e10.gasConfig.owner || e10.sender,
      coinType: pl
    })).data.filter((i10) => !e10.inputs.find((s10) => {
      var a10;
      return (a10 = s10.Object) != null && a10.ImmOrOwnedObject ? i10.coinObjectId === s10.Object.ImmOrOwnedObject.objectId : false;
    })).map((i10) => ({
      objectId: i10.coinObjectId,
      digest: i10.digest,
      version: i10.version
    }));
    if (!n10.length)
      throw new Error("No valid gas coins found for the transaction.");
    e10.gasConfig.payment = n10.map((i10) => ur(Zi, i10));
  }
}
async function _3(e10, t10) {
  const r10 = e10.inputs.filter((u10) => {
    var d6;
    return u10.UnresolvedObject && !(u10.UnresolvedObject.version || (d6 = u10.UnresolvedObject) != null && d6.initialSharedVersion);
  }), n10 = [
    ...new Set(
      r10.map((u10) => en(u10.UnresolvedObject.objectId))
    )
  ], i10 = n10.length ? I3(n10, g3) : [], o10 = (await Promise.all(
    i10.map(
      (u10) => Na(t10).multiGetObjects({
        ids: u10,
        options: { showOwner: true }
      })
    )
  )).flat(), s10 = new Map(
    n10.map((u10, d6) => [u10, o10[d6]])
  ), a10 = Array.from(s10).filter(([u10, d6]) => d6.error).map(([u10, d6]) => JSON.stringify(d6.error));
  if (a10.length)
    throw new Error(`The following input objects are invalid: ${a10.join(", ")}`);
  const c = o10.map((u10) => {
    if (u10.error || !u10.data)
      throw new Error(`Failed to fetch object: ${u10.error}`);
    const d6 = u10.data.owner, p = d6 && typeof d6 == "object" && "Shared" in d6 ? d6.Shared.initial_shared_version : null;
    return {
      objectId: u10.data.objectId,
      digest: u10.data.digest,
      version: u10.data.version,
      initialSharedVersion: p
    };
  }), l10 = new Map(
    n10.map((u10, d6) => [u10, c[d6]])
  );
  for (const [u10, d6] of e10.inputs.entries()) {
    if (!d6.UnresolvedObject)
      continue;
    let p;
    const y = Ft(d6.UnresolvedObject.objectId), x = l10.get(y);
    d6.UnresolvedObject.initialSharedVersion ?? (x == null ? void 0 : x.initialSharedVersion) ? p = _i.SharedObjectRef({
      objectId: y,
      initialSharedVersion: d6.UnresolvedObject.initialSharedVersion || (x == null ? void 0 : x.initialSharedVersion),
      mutable: T3(e10, u10)
    }) : A3(e10, u10) && (p = _i.ReceivingRef(
      {
        objectId: y,
        digest: d6.UnresolvedObject.digest ?? (x == null ? void 0 : x.digest),
        version: d6.UnresolvedObject.version ?? (x == null ? void 0 : x.version)
      }
    )), e10.inputs[e10.inputs.indexOf(d6)] = p ?? _i.ObjectRef({
      objectId: y,
      digest: d6.UnresolvedObject.digest ?? (x == null ? void 0 : x.digest),
      version: d6.UnresolvedObject.version ?? (x == null ? void 0 : x.version)
    });
  }
}
async function E3(e10, t10) {
  const { inputs: r10, commands: n10 } = e10, i10 = [], o10 = /* @__PURE__ */ new Set();
  n10.forEach((a10) => {
    if (a10.MoveCall) {
      if (a10.MoveCall._argumentTypes)
        return;
      if (a10.MoveCall.arguments.map((u10) => u10.$kind === "Input" ? e10.inputs[u10.Input] : null).some(
        (u10) => (u10 == null ? void 0 : u10.UnresolvedPure) || (u10 == null ? void 0 : u10.UnresolvedObject)
      )) {
        const u10 = `${a10.MoveCall.package}::${a10.MoveCall.module}::${a10.MoveCall.function}`;
        o10.add(u10), i10.push(a10.MoveCall);
      }
    }
    switch (a10.$kind) {
      case "SplitCoins":
        a10.SplitCoins.amounts.forEach((c) => {
          yh(c, gt.U64, e10);
        });
        break;
      case "TransferObjects":
        yh(a10.TransferObjects.address, gt.Address, e10);
        break;
    }
  });
  const s10 = /* @__PURE__ */ new Map();
  if (o10.size > 0) {
    const a10 = Na(t10);
    await Promise.all(
      [...o10].map(async (c) => {
        const [l10, u10, d6] = c.split("::"), p = await a10.getNormalizedMoveFunction({
          package: l10,
          module: u10,
          function: d6
        });
        s10.set(
          c,
          p.parameters.map((y) => m3(y))
        );
      })
    );
  }
  i10.length && await Promise.all(
    i10.map(async (a10) => {
      const c = s10.get(
        `${a10.package}::${a10.module}::${a10.function}`
      );
      if (!c)
        return;
      const u10 = c.length > 0 && p3(c.at(-1)) ? c.slice(0, c.length - 1) : c;
      a10._argumentTypes = u10;
    })
  ), n10.forEach((a10) => {
    if (!a10.MoveCall)
      return;
    const c = a10.MoveCall, l10 = `${c.package}::${c.module}::${c.function}`, u10 = c._argumentTypes;
    if (u10) {
      if (u10.length !== a10.MoveCall.arguments.length)
        throw new Error(`Incorrect number of arguments for ${l10}`);
      u10.forEach((d6, p) => {
        var P, j;
        const y = c.arguments[p];
        if (y.$kind !== "Input")
          return;
        const x = r10[y.Input];
        if (!x.UnresolvedPure && !x.UnresolvedObject)
          return;
        const b = ((P = x.UnresolvedPure) == null ? void 0 : P.value) ?? ((j = x.UnresolvedObject) == null ? void 0 : j.objectId), M = Cf(d6.body);
        if (M) {
          y.type = "pure", r10[r10.indexOf(x)] = _i.Pure(M.serialize(b));
          return;
        }
        if (typeof b != "string")
          throw new Error(
            `Expect the argument to be an object id string, got ${JSON.stringify(
              b,
              null,
              2
            )}`
          );
        y.type = "object";
        const O = x.UnresolvedPure ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: {
            objectId: b
          }
        } : x;
        r10[y.Input] = O;
      });
    }
  });
}
function C3(e10) {
  e10.inputs.forEach((t10, r10) => {
    if (t10.$kind !== "Object" && t10.$kind !== "Pure")
      throw new Error(
        `Input at index ${r10} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          t10
        )}`
      );
  });
}
function yh(e10, t10, r10) {
  if (e10.$kind !== "Input")
    return;
  const n10 = r10.inputs[e10.Input];
  n10.$kind === "UnresolvedPure" && (r10.inputs[e10.Input] = _i.Pure(t10.serialize(n10.UnresolvedPure.value)));
}
function T3(e10, t10) {
  let r10 = false;
  return e10.getInputUses(t10, (n10, i10) => {
    if (i10.MoveCall && i10.MoveCall._argumentTypes) {
      const o10 = i10.MoveCall.arguments.indexOf(n10);
      r10 = i10.MoveCall._argumentTypes[o10].ref !== "&" || r10;
    }
    (i10.$kind === "MakeMoveVec" || i10.$kind === "MergeCoins" || i10.$kind === "SplitCoins") && (r10 = true);
  }), r10;
}
function A3(e10, t10) {
  let r10 = false;
  return e10.getInputUses(t10, (n10, i10) => {
    if (i10.MoveCall && i10.MoveCall._argumentTypes) {
      const o10 = i10.MoveCall.arguments.indexOf(n10);
      r10 = M3(i10.MoveCall._argumentTypes[o10]) || r10;
    }
  }), r10;
}
function M3(e10) {
  return typeof e10.body != "object" || !("datatype" in e10.body) ? false : e10.body.datatype.package === "0x2" && e10.body.datatype.module === "transfer" && e10.body.datatype.type === "Receiving";
}
function Na(e10) {
  if (!e10.client)
    throw new Error(
      "No sui client passed to Transaction#build, but transaction data was not sufficient to build offline."
    );
  return e10.client;
}
function I3(e10, t10) {
  return Array.from(
    { length: Math.ceil(e10.length / t10) },
    (r10, n10) => e10.slice(n10 * t10, n10 * t10 + t10)
  );
}
function O3(e10) {
  function t10(r10) {
    return e10(r10);
  }
  return t10.system = () => t10("0x5"), t10.clock = () => t10("0x6"), t10.random = () => t10("0x8"), t10.denyList = () => t10("0x403"), t10.option = ({ type: r10, value: n10 }) => (i10) => i10.moveCall({
    typeArguments: [r10],
    target: `0x1::option::${n10 === null ? "none" : "some"}`,
    arguments: n10 === null ? [] : [i10.object(n10)]
  }), t10;
}
function R3(e10) {
  function t10(r10, n10) {
    if (typeof r10 == "string")
      return e10(sa(r10).serialize(n10));
    if (r10 instanceof Uint8Array || ul(r10))
      return e10(r10);
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  return t10.u8 = (r10) => e10(gt.U8.serialize(r10)), t10.u16 = (r10) => e10(gt.U16.serialize(r10)), t10.u32 = (r10) => e10(gt.U32.serialize(r10)), t10.u64 = (r10) => e10(gt.U64.serialize(r10)), t10.u128 = (r10) => e10(gt.U128.serialize(r10)), t10.u256 = (r10) => e10(gt.U256.serialize(r10)), t10.bool = (r10) => e10(gt.Bool.serialize(r10)), t10.string = (r10) => e10(gt.String.serialize(r10)), t10.address = (r10) => e10(gt.Address.serialize(r10)), t10.id = t10.address, t10.vector = (r10, n10) => e10(
    gt.vector(sa(r10)).serialize(n10)
  ), t10.option = (r10, n10) => e10(gt.option(sa(r10)).serialize(n10)), t10;
}
function P3(e10, t10) {
  const r10 = Array.from(`${e10}::`).map((i10) => i10.charCodeAt(0)), n10 = new Uint8Array(r10.length + t10.length);
  return n10.set(r10), n10.set(t10, r10.length), l1(n10, { dkLen: 32 });
}
function wh(e10) {
  return Ft(e10).replace("0x", "");
}
var Mn = class _Mn {
  constructor(t10) {
    this.version = 2, this.sender = (t10 == null ? void 0 : t10.sender) ?? null, this.expiration = (t10 == null ? void 0 : t10.expiration) ?? null, this.inputs = (t10 == null ? void 0 : t10.inputs) ?? [], this.commands = (t10 == null ? void 0 : t10.commands) ?? [], this.gasData = (t10 == null ? void 0 : t10.gasData) ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(t10) {
    const n10 = gt.TransactionKind.parse(t10).ProgrammableTransaction;
    if (!n10)
      throw new Error("Unable to deserialize from bytes.");
    return _Mn.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: n10.inputs,
      commands: n10.commands
    });
  }
  static fromBytes(t10) {
    const r10 = gt.TransactionData.parse(t10), n10 = r10 == null ? void 0 : r10.V1, i10 = n10.kind.ProgrammableTransaction;
    if (!n10 || !i10)
      throw new Error("Unable to deserialize from bytes.");
    return _Mn.restore({
      version: 2,
      sender: n10.sender,
      expiration: n10.expiration,
      gasData: n10.gasData,
      inputs: i10.inputs,
      commands: i10.commands
    });
  }
  static restore(t10) {
    return t10.version === 2 ? new _Mn(ur(hc, t10)) : new _Mn(ur(hc, f8(t10)));
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(t10) {
    const r10 = P3("TransactionData", t10);
    return Uo(r10);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(t10) {
    this.gasData = t10;
  }
  build({
    maxSizeBytes: t10 = 1 / 0,
    overrides: r10,
    onlyTransactionKind: n10
  } = {}) {
    const i10 = this.inputs, o10 = this.commands, s10 = {
      ProgrammableTransaction: {
        inputs: i10,
        commands: o10
      }
    };
    if (n10)
      return gt.TransactionKind.serialize(s10, { maxSize: t10 }).toBytes();
    const a10 = (r10 == null ? void 0 : r10.expiration) ?? this.expiration, c = (r10 == null ? void 0 : r10.sender) ?? this.sender, l10 = { ...this.gasData, ...r10 == null ? void 0 : r10.gasConfig, ...r10 == null ? void 0 : r10.gasData };
    if (!c)
      throw new Error("Missing transaction sender");
    if (!l10.budget)
      throw new Error("Missing gas budget");
    if (!l10.payment)
      throw new Error("Missing gas payment");
    if (!l10.price)
      throw new Error("Missing gas price");
    const u10 = {
      sender: wh(c),
      expiration: a10 || { None: true },
      gasData: {
        payment: l10.payment,
        owner: wh(this.gasData.owner ?? c),
        price: BigInt(l10.price),
        budget: BigInt(l10.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs: i10,
          commands: o10
        }
      }
    };
    return gt.TransactionData.serialize(
      { V1: u10 },
      { maxSize: t10 }
    ).toBytes();
  }
  addInput(t10, r10) {
    const n10 = this.inputs.length;
    return this.inputs.push(r10), { Input: n10, type: t10, $kind: "Input" };
  }
  getInputUses(t10, r10) {
    this.mapArguments((n10, i10) => (n10.$kind === "Input" && n10.Input === t10 && r10(n10, i10), n10));
  }
  mapArguments(t10) {
    for (const r10 of this.commands)
      switch (r10.$kind) {
        case "MoveCall":
          r10.MoveCall.arguments = r10.MoveCall.arguments.map((i10) => t10(i10, r10));
          break;
        case "TransferObjects":
          r10.TransferObjects.objects = r10.TransferObjects.objects.map(
            (i10) => t10(i10, r10)
          ), r10.TransferObjects.address = t10(r10.TransferObjects.address, r10);
          break;
        case "SplitCoins":
          r10.SplitCoins.coin = t10(r10.SplitCoins.coin, r10), r10.SplitCoins.amounts = r10.SplitCoins.amounts.map((i10) => t10(i10, r10));
          break;
        case "MergeCoins":
          r10.MergeCoins.destination = t10(r10.MergeCoins.destination, r10), r10.MergeCoins.sources = r10.MergeCoins.sources.map((i10) => t10(i10, r10));
          break;
        case "MakeMoveVec":
          r10.MakeMoveVec.elements = r10.MakeMoveVec.elements.map(
            (i10) => t10(i10, r10)
          );
          break;
        case "Upgrade":
          r10.Upgrade.ticket = t10(r10.Upgrade.ticket, r10);
          break;
        case "$Intent":
          const n10 = r10.$Intent.inputs;
          r10.$Intent.inputs = {};
          for (const [i10, o10] of Object.entries(n10))
            r10.$Intent.inputs[i10] = Array.isArray(o10) ? o10.map((s10) => t10(s10, r10)) : t10(o10, r10);
          break;
        case "Publish":
          break;
        default:
          throw new Error(`Unexpected transaction kind: ${r10.$kind}`);
      }
  }
  replaceCommand(t10, r10) {
    if (!Array.isArray(r10)) {
      this.commands[t10] = r10;
      return;
    }
    const n10 = r10.length - 1;
    this.commands.splice(t10, 1, ...r10), n10 !== 0 && this.mapArguments((i10) => {
      switch (i10.$kind) {
        case "Result":
          i10.Result > t10 && (i10.Result += n10);
          break;
        case "NestedResult":
          i10.NestedResult[0] > t10 && (i10.NestedResult[0] += n10);
          break;
      }
      return i10;
    });
  }
  getDigest() {
    const t10 = this.build({ onlyTransactionKind: false });
    return _Mn.getDigestFromBytes(t10);
  }
  snapshot() {
    return ur(hc, this);
  }
};
function xh(e10) {
  if (typeof e10 == "string")
    return Ft(e10);
  if (e10.Object)
    return e10.Object.ImmOrOwnedObject ? Ft(e10.Object.ImmOrOwnedObject.objectId) : e10.Object.Receiving ? Ft(e10.Object.Receiving.objectId) : Ft(e10.Object.SharedObject.objectId);
  if (e10.UnresolvedObject)
    return Ft(e10.UnresolvedObject.objectId);
}
var u1 = (e10) => {
  throw TypeError(e10);
};
var Td = (e10, t10, r10) => t10.has(e10) || u1("Cannot " + r10);
var Tt = (e10, t10, r10) => (Td(e10, t10, "read from private field"), r10 ? r10.call(e10) : t10.get(e10));
var qs = (e10, t10, r10) => t10.has(e10) ? u1("Cannot add the same private member more than once") : t10 instanceof WeakSet ? t10.add(e10) : t10.set(e10, r10);
var mo = (e10, t10, r10, n10) => (Td(e10, t10, "write to private field"), n10 ? n10.call(e10, r10) : t10.set(e10, r10), r10);
var bi = (e10, t10, r10) => (Td(e10, t10, "access private method"), r10);
var ta;
var la;
var _o;
var Pt;
var En;
var pc2;
var Ad;
var Tf;
var Md;
function Sh(e10, t10 = 1 / 0) {
  const r10 = { $kind: "Result", Result: e10 }, n10 = [], i10 = (o10) => n10[o10] ?? (n10[o10] = {
    $kind: "NestedResult",
    NestedResult: [e10, o10]
  });
  return new Proxy(r10, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(o10, s10) {
      if (s10 in o10)
        return Reflect.get(o10, s10);
      if (s10 === Symbol.iterator)
        return function* () {
          let c = 0;
          for (; c < t10; )
            yield i10(c), c++;
        };
      if (typeof s10 == "symbol")
        return;
      const a10 = parseInt(s10, 10);
      if (!(Number.isNaN(a10) || a10 < 0))
        return i10(a10);
    }
  });
}
var f1 = Symbol.for("@mysten/transaction");
function d1(e10) {
  return !!e10 && typeof e10 == "object" && e10[f1] === true;
}
var _h = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var Su = Symbol.for("@mysten/transaction/registry");
function Hs() {
  try {
    const e10 = globalThis;
    return e10[Su] || (e10[Su] = _h), e10[Su];
  } catch {
    return _h;
  }
}
var N3 = class Af {
  constructor() {
    qs(this, En), qs(this, ta), qs(this, la), qs(this, _o, /* @__PURE__ */ new Map()), qs(this, Pt), this.object = O3(
      (r10) => {
        var o10, s10;
        if (typeof r10 == "function")
          return this.object(r10(this));
        if (typeof r10 == "object" && xf(ir, r10))
          return r10;
        const n10 = xh(r10), i10 = Tt(this, Pt).inputs.find((a10) => n10 === xh(a10));
        return (o10 = i10 == null ? void 0 : i10.Object) != null && o10.SharedObject && typeof r10 == "object" && ((s10 = r10.Object) != null && s10.SharedObject) && (i10.Object.SharedObject.mutable = i10.Object.SharedObject.mutable || r10.Object.SharedObject.mutable), i10 ? { $kind: "Input", Input: Tt(this, Pt).inputs.indexOf(i10), type: "object" } : Tt(this, Pt).addInput(
          "object",
          typeof r10 == "string" ? {
            $kind: "UnresolvedObject",
            UnresolvedObject: { objectId: Ft(r10) }
          } : r10
        );
      }
    );
    const t10 = Hs();
    mo(this, Pt, new Mn()), mo(this, la, [...t10.buildPlugins.values()]), mo(this, ta, [...t10.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(t10) {
    const r10 = new Af();
    return mo(r10, Pt, Mn.fromKindBytes(
      typeof t10 == "string" ? Cr(t10) : t10
    )), r10;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(t10) {
    const r10 = new Af();
    return d1(t10) ? mo(r10, Pt, new Mn(t10.getData())) : typeof t10 != "string" || !t10.startsWith("{") ? mo(r10, Pt, Mn.fromBytes(
      typeof t10 == "string" ? Cr(t10) : t10
    )) : mo(r10, Pt, Mn.restore(JSON.parse(t10))), r10;
  }
  static registerGlobalSerializationPlugin(t10, r10) {
    Hs().serializationPlugins.set(
      t10,
      r10 ?? t10
    );
  }
  static unregisterGlobalSerializationPlugin(t10) {
    Hs().serializationPlugins.delete(t10);
  }
  static registerGlobalBuildPlugin(t10, r10) {
    Hs().buildPlugins.set(
      t10,
      r10 ?? t10
    );
  }
  static unregisterGlobalBuildPlugin(t10) {
    Hs().buildPlugins.delete(t10);
  }
  addSerializationPlugin(t10) {
    Tt(this, ta).push(t10);
  }
  addBuildPlugin(t10) {
    Tt(this, la).push(t10);
  }
  addIntentResolver(t10, r10) {
    if (Tt(this, _o).has(t10) && Tt(this, _o).get(t10) !== r10)
      throw new Error(`Intent resolver for ${t10} already exists`);
    Tt(this, _o).set(t10, r10);
  }
  setSender(t10) {
    Tt(this, Pt).sender = t10;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(t10) {
    Tt(this, Pt).sender || (Tt(this, Pt).sender = t10);
  }
  setExpiration(t10) {
    Tt(this, Pt).expiration = t10 ? ur(t1, t10) : null;
  }
  setGasPrice(t10) {
    Tt(this, Pt).gasConfig.price = String(t10);
  }
  setGasBudget(t10) {
    Tt(this, Pt).gasConfig.budget = String(t10);
  }
  setGasBudgetIfNotSet(t10) {
    Tt(this, Pt).gasData.budget == null && (Tt(this, Pt).gasConfig.budget = String(t10));
  }
  setGasOwner(t10) {
    Tt(this, Pt).gasConfig.owner = t10;
  }
  setGasPayment(t10) {
    Tt(this, Pt).gasConfig.payment = t10.map((r10) => ur(Zi, r10));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return vh(Tt(this, Pt).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return Tt(this, Pt).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [f1]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    return Object.defineProperty(this, "pure", {
      enumerable: false,
      value: R3((t10) => ul(t10) ? Tt(this, Pt).addInput("pure", {
        $kind: "Pure",
        Pure: {
          bytes: t10.toBase64()
        }
      }) : Tt(this, Pt).addInput(
        "pure",
        xf(ph, t10) ? ur(ph, t10) : t10 instanceof Uint8Array ? _i.Pure(t10) : { $kind: "UnresolvedPure", UnresolvedPure: { value: t10 } }
      ))
    }), this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...t10) {
    return this.object(_i.ObjectRef(...t10));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...t10) {
    return this.object(_i.ReceivingRef(...t10));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...t10) {
    return this.object(_i.SharedObjectRef(...t10));
  }
  /** Add a transaction to the transaction */
  add(t10) {
    if (typeof t10 == "function")
      return t10(this);
    const r10 = Tt(this, Pt).commands.push(t10);
    return Sh(r10 - 1);
  }
  // Method shorthands:
  splitCoins(t10, r10) {
    const n10 = po.SplitCoins(
      typeof t10 == "string" ? this.object(t10) : bi(this, En, Ad).call(this, t10),
      r10.map(
        (o10) => typeof o10 == "number" || typeof o10 == "bigint" || typeof o10 == "string" ? this.pure.u64(o10) : bi(this, En, pc2).call(this, o10)
      )
    ), i10 = Tt(this, Pt).commands.push(n10);
    return Sh(i10 - 1, r10.length);
  }
  mergeCoins(t10, r10) {
    return this.add(
      po.MergeCoins(
        this.object(t10),
        r10.map((n10) => this.object(n10))
      )
    );
  }
  publish({ modules: t10, dependencies: r10 }) {
    return this.add(
      po.Publish({
        modules: t10,
        dependencies: r10
      })
    );
  }
  upgrade({
    modules: t10,
    dependencies: r10,
    package: n10,
    ticket: i10
  }) {
    return this.add(
      po.Upgrade({
        modules: t10,
        dependencies: r10,
        package: n10,
        ticket: this.object(i10)
      })
    );
  }
  moveCall({
    arguments: t10,
    ...r10
  }) {
    return this.add(
      po.MoveCall({
        ...r10,
        arguments: t10 == null ? void 0 : t10.map((n10) => bi(this, En, pc2).call(this, n10))
      })
    );
  }
  transferObjects(t10, r10) {
    return this.add(
      po.TransferObjects(
        t10.map((n10) => this.object(n10)),
        typeof r10 == "string" ? this.pure.address(r10) : bi(this, En, pc2).call(this, r10)
      )
    );
  }
  makeMoveVec({
    type: t10,
    elements: r10
  }) {
    return this.add(
      po.MakeMoveVec({
        type: t10,
        elements: r10.map((n10) => this.object(n10))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(vh(Tt(this, Pt).snapshot()));
  }
  async toJSON(t10 = {}) {
    return await this.prepareForSerialization(t10), JSON.stringify(
      ur(y8, Tt(this, Pt).snapshot()),
      (r10, n10) => typeof n10 == "bigint" ? n10.toString() : n10,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(t10) {
    const { signer: r10, ...n10 } = t10, i10 = await this.build(n10);
    return r10.signTransaction(i10);
  }
  /** Build the transaction to BCS bytes. */
  async build(t10 = {}) {
    return await this.prepareForSerialization(t10), await bi(this, En, Tf).call(this, t10), Tt(this, Pt).build({
      onlyTransactionKind: t10.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(t10 = {}) {
    return await bi(this, En, Tf).call(this, t10), Tt(this, Pt).getDigest();
  }
  async prepareForSerialization(t10) {
    var i10;
    const r10 = /* @__PURE__ */ new Set();
    for (const o10 of Tt(this, Pt).commands)
      o10.$Intent && r10.add(o10.$Intent.name);
    const n10 = [...Tt(this, ta)];
    for (const o10 of r10)
      if (!((i10 = t10.supportedIntents) != null && i10.includes(o10))) {
        if (!Tt(this, _o).has(o10))
          throw new Error(`Missing intent resolver for ${o10}`);
        n10.push(Tt(this, _o).get(o10));
      }
    await bi(this, En, Md).call(this, n10, t10);
  }
};
ta = /* @__PURE__ */ new WeakMap();
la = /* @__PURE__ */ new WeakMap();
_o = /* @__PURE__ */ new WeakMap();
Pt = /* @__PURE__ */ new WeakMap();
En = /* @__PURE__ */ new WeakSet();
pc2 = function(e10) {
  return ul(e10) ? this.pure(e10) : bi(this, En, Ad).call(this, e10);
};
Ad = function(e10) {
  return typeof e10 == "function" ? ur(ir, e10(this)) : ur(ir, e10);
};
Tf = async function(e10) {
  if (!e10.onlyTransactionKind && !Tt(this, Pt).sender)
    throw new Error("Missing transaction sender");
  await bi(this, En, Md).call(this, [...Tt(this, la), y3], e10);
};
Md = async function(e10, t10) {
  const r10 = (n10) => {
    if (n10 >= e10.length)
      return () => {
      };
    const i10 = e10[n10];
    return async () => {
      const o10 = r10(n10 + 1);
      let s10 = false, a10 = false;
      if (await i10(Tt(this, Pt), t10, async () => {
        if (s10)
          throw new Error(`next() was call multiple times in TransactionPlugin ${n10}`);
        s10 = true, await o10(), a10 = true;
      }), !s10)
        throw new Error(`next() was not called in TransactionPlugin ${n10}`);
      if (!a10)
        throw new Error(`next() was not awaited in TransactionPlugin ${n10}`);
    };
  };
  await r10(0)();
};
var Oo = N3;
var j3 = class extends Sg {
  constructor() {
    super(...arguments), this.core = this;
  }
};
var k3 = class extends Error {
};
var Wi = class _Wi extends k3 {
  constructor(t10, r10) {
    super(r10), this.code = t10;
  }
  static fromResponse(t10, r10) {
    switch (t10.code) {
      case "notExists":
        return new _Wi(t10.code, `Object ${t10.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new _Wi(
          t10.code,
          `Dynamic field not found for object ${t10.parent_object_id}`
        );
      case "deleted":
        return new _Wi(t10.code, `Object ${t10.object_id} has been deleted`);
      case "displayError":
        return new _Wi(t10.code, `Display error: ${t10.error}`);
      case "unknown":
      default:
        return new _Wi(
          t10.code,
          `Unknown error while loading object${r10 ? ` ${r10}` : ""}`
        );
    }
  }
};
var h1 = (e10) => {
  throw TypeError(e10);
};
var p1 = (e10, t10, r10) => t10.has(e10) || h1("Cannot " + r10);
var mi = (e10, t10, r10) => (p1(e10, t10, "read from private field"), r10 ? r10.call(e10) : t10.get(e10));
var D3 = (e10, t10, r10) => t10.has(e10) ? h1("Cannot add the same private member more than once") : t10 instanceof WeakSet ? t10.add(e10) : t10.set(e10, r10);
var L3 = (e10, t10, r10, n10) => (p1(e10, t10, "write to private field"), n10 ? n10.call(e10, r10) : t10.set(e10, r10), r10);
var ln;
var B3 = class extends j3 {
  constructor(t10) {
    super({ network: t10.network }), D3(this, ln), L3(this, ln, t10);
  }
  async getObjects(t10) {
    const r10 = B4(t10.objectIds, 50), n10 = [];
    for (const i10 of r10) {
      const o10 = await mi(this, ln).multiGetObjects({
        ids: i10,
        options: {
          showOwner: true,
          showType: true
        }
      });
      for (const [s10, a10] of o10.entries())
        a10.error ? n10.push(Wi.fromResponse(a10.error, i10[s10])) : n10.push(Eh(a10.data));
    }
    return {
      objects: n10
    };
  }
  async getOwnedObjects(t10) {
    const r10 = await mi(this, ln).getOwnedObjects({
      owner: t10.address,
      limit: t10.limit,
      cursor: t10.cursor
    });
    return {
      objects: r10.data.map((n10) => {
        if (n10.error)
          throw Wi.fromResponse(n10.error);
        return Eh(n10.data);
      }),
      hasNextPage: r10.hasNextPage,
      cursor: r10.nextCursor ?? null
    };
  }
  async getCoins(t10) {
    const r10 = await mi(this, ln).getCoins({
      owner: t10.address,
      coinType: t10.coinType
    });
    return {
      objects: r10.data.map((n10) => ({
        id: n10.coinObjectId,
        version: n10.version,
        digest: n10.digest,
        balance: BigInt(n10.balance),
        type: `0x2::coin::Coin<${n10.coinType}>`,
        content: $3.serialize({
          id: n10.coinObjectId,
          balance: {
            value: n10.balance
          }
        }).toBytes(),
        owner: {
          $kind: "ObjectOwner",
          ObjectOwner: t10.address
        }
      })),
      hasNextPage: r10.hasNextPage,
      cursor: r10.nextCursor ?? null
    };
  }
  async getBalance(t10) {
    const r10 = await mi(this, ln).getBalance({
      owner: t10.address,
      coinType: t10.coinType
    });
    return {
      balance: {
        coinType: r10.coinType,
        balance: BigInt(r10.totalBalance)
      }
    };
  }
  async getAllBalances(t10) {
    return {
      balances: (await mi(this, ln).getAllBalances({
        owner: t10.address
      })).map((n10) => ({
        coinType: n10.coinType,
        balance: BigInt(n10.totalBalance)
      })),
      hasNextPage: false,
      cursor: null
    };
  }
  async getTransaction(t10) {
    const r10 = await mi(this, ln).getTransactionBlock({
      digest: t10.digest,
      options: {
        showRawInput: true,
        showObjectChanges: true,
        showRawEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: Ch(r10)
    };
  }
  async executeTransaction(t10) {
    const r10 = await mi(this, ln).executeTransactionBlock({
      transactionBlock: t10.transaction,
      signature: t10.signatures,
      options: {
        showEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: Ch(r10)
    };
  }
  async dryRunTransaction(t10) {
    const r10 = Oo.from(t10.transaction), n10 = await mi(this, ln).dryRunTransactionBlock({
      transactionBlock: t10.transaction
    });
    return {
      transaction: {
        digest: await r10.getDigest(),
        // TODO: Effects aren't returned as bcs from dryRun, once we define structured effects we can return those instead
        effects: n10.effects,
        signatures: [],
        bcs: t10.transaction
      }
    };
  }
  async getReferenceGasPrice() {
    return {
      referenceGasPrice: await mi(this, ln).getReferenceGasPrice()
    };
  }
};
ln = /* @__PURE__ */ new WeakMap();
function Eh(e10) {
  var t10;
  return {
    id: e10.objectId,
    version: e10.version,
    digest: e10.digest,
    type: e10.type,
    content: ((t10 = e10.bcs) == null ? void 0 : t10.dataType) === "moveObject" ? Cr(e10.bcs.bcsBytes) : new Uint8Array(),
    owner: U3(e10.owner)
  };
}
function U3(e10) {
  if (e10 === "Immutable")
    return {
      $kind: "Immutable",
      Immutable: true
    };
  if ("ConsensusV2" in e10)
    return {
      $kind: "ConsensusV2",
      ConsensusV2Owner: {
        authenticator: {
          $kind: "SingleOwner",
          SingleOwner: e10.ConsensusV2.authenticator.SingleOwner
        },
        startVersion: e10.ConsensusV2.start_version
      }
    };
  if ("AddressOwner" in e10)
    return {
      $kind: "AddressOwner",
      AddressOwner: e10.AddressOwner
    };
  if ("ObjectOwner" in e10)
    return {
      $kind: "ObjectOwner",
      ObjectOwner: e10.ObjectOwner
    };
  if ("Shared" in e10)
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: e10.Shared.initial_shared_version
      }
    };
  throw new Error(`Unknown owner type: ${JSON.stringify(e10)}`);
}
function Ch(e10) {
  const t10 = gt.SenderSignedData.parse(Cr(e10.rawTransaction))[0];
  return {
    digest: e10.digest,
    effects: new Uint8Array(e10.rawEffects),
    bcs: gt.TransactionData.serialize(t10.intentMessage.value).toBytes(),
    signatures: t10.txSignatures
  };
}
var F3 = gt.struct("Balance", {
  value: gt.u64()
});
var $3 = gt.struct("Coin", {
  id: gt.Address,
  balance: F3
});
var V3 = Symbol.for("@mysten/SuiClient");
var bs = class extends Sg {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(t10) {
    super({ network: t10.network ?? "unknown" }), this.core = new B3(this), this.transport = t10.transport ?? new H6({ url: t10.url });
  }
  get [V3]() {
    return true;
  }
  async getRpcApiVersion() {
    return (await this.transport.request({
      method: "rpc.discover",
      params: []
    })).info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(t10) {
    if (!t10.owner || !Xn(Ft(t10.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getCoins",
      params: [t10.owner, t10.coinType, t10.cursor, t10.limit]
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(t10) {
    if (!t10.owner || !Xn(Ft(t10.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [t10.owner, t10.cursor, t10.limit]
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(t10) {
    if (!t10.owner || !Xn(Ft(t10.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getBalance",
      params: [t10.owner, t10.coinType]
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(t10) {
    if (!t10.owner || !Xn(Ft(t10.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({ method: "suix_getAllBalances", params: [t10.owner] });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(t10) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [t10.coinType]
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(t10) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [t10.coinType]
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(t10, r10) {
    return await this.transport.request({ method: t10, params: r10 });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(t10) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [t10.package, t10.module, t10.function]
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(t10) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [t10.package]
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(t10) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [t10.package, t10.module]
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(t10) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [t10.package, t10.module, t10.function]
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(t10) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [t10.package, t10.module, t10.struct]
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(t10) {
    if (!t10.owner || !Xn(Ft(t10.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        t10.owner,
        {
          filter: t10.filter,
          options: t10.options
        },
        t10.cursor,
        t10.limit
      ]
    });
  }
  /**
   * Get details about an object
   */
  async getObject(t10) {
    if (!t10.id || !ea(en(t10.id)))
      throw new Error("Invalid Sui Object id");
    return await this.transport.request({
      method: "sui_getObject",
      params: [t10.id, t10.options]
    });
  }
  async tryGetPastObject(t10) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [t10.id, t10.version, t10.options]
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(t10) {
    if (t10.ids.forEach((n10) => {
      if (!n10 || !ea(en(n10)))
        throw new Error(`Invalid Sui Object id ${n10}`);
    }), t10.ids.length !== new Set(t10.ids).size)
      throw new Error(`Duplicate object ids in batch call ${t10.ids}`);
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [t10.ids, t10.options]
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(t10) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: t10.filter,
          options: t10.options
        },
        t10.cursor,
        t10.limit,
        (t10.order || "descending") === "descending"
      ]
    });
  }
  async getTransactionBlock(t10) {
    if (!wf(t10.digest))
      throw new Error("Invalid Transaction digest");
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [t10.digest, t10.options]
    });
  }
  async multiGetTransactionBlocks(t10) {
    if (t10.digests.forEach((n10) => {
      if (!wf(n10))
        throw new Error(`Invalid Transaction digest ${n10}`);
    }), t10.digests.length !== new Set(t10.digests).size)
      throw new Error(`Duplicate digests in batch call ${t10.digests}`);
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [t10.digests, t10.options]
    });
  }
  async executeTransactionBlock({
    transactionBlock: t10,
    signature: r10,
    options: n10,
    requestType: i10
  }) {
    const o10 = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof t10 == "string" ? t10 : Sr(t10),
        Array.isArray(r10) ? r10 : [r10],
        n10
      ]
    });
    if (i10 === "WaitForLocalExecution")
      try {
        await this.waitForTransaction({
          digest: o10.digest
        });
      } catch {
      }
    return o10;
  }
  async signAndExecuteTransaction({
    transaction: t10,
    signer: r10,
    ...n10
  }) {
    let i10;
    t10 instanceof Uint8Array ? i10 = t10 : (t10.setSenderIfNotSet(r10.toSuiAddress()), i10 = await t10.build({ client: this }));
    const { signature: o10, bytes: s10 } = await r10.signTransaction(i10);
    return this.executeTransactionBlock({
      transactionBlock: s10,
      signature: o10,
      ...n10
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const t10 = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: []
    });
    return BigInt(t10);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const t10 = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: []
    });
    return BigInt(t10);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(t10) {
    if (!t10.owner || !Xn(Ft(t10.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({ method: "suix_getStakes", params: [t10.owner] });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(t10) {
    return t10.stakedSuiIds.forEach((r10) => {
      if (!r10 || !ea(en(r10)))
        throw new Error(`Invalid Sui Stake id ${r10}`);
    }), await this.transport.request({
      method: "suix_getStakesByIds",
      params: [t10.stakedSuiIds]
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.transport.request({ method: "suix_getLatestSuiSystemState", params: [] });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(t10) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        t10.query,
        t10.cursor,
        t10.limit,
        (t10.order || "descending") === "descending"
      ]
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(t10) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [t10.filter],
      onMessage: t10.onMessage
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(t10) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [t10.filter],
      onMessage: t10.onMessage
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(t10) {
    var n10;
    let r10;
    if (d1(t10.transactionBlock))
      t10.transactionBlock.setSenderIfNotSet(t10.sender), r10 = Sr(
        await t10.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    else if (typeof t10.transactionBlock == "string")
      r10 = t10.transactionBlock;
    else if (t10.transactionBlock instanceof Uint8Array)
      r10 = Sr(t10.transactionBlock);
    else
      throw new Error("Unknown transaction block format.");
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [t10.sender, r10, (n10 = t10.gasPrice) == null ? void 0 : n10.toString(), t10.epoch]
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(t10) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof t10.transactionBlock == "string" ? t10.transactionBlock : Sr(t10.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(t10) {
    if (!t10.parentId || !ea(en(t10.parentId)))
      throw new Error("Invalid Sui Object id");
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [t10.parentId, t10.cursor, t10.limit]
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(t10) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [t10.parentId, t10.name]
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const t10 = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: []
    });
    return String(t10);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(t10) {
    return await this.transport.request({ method: "sui_getCheckpoint", params: [t10.id] });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(t10) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [t10.cursor, t10 == null ? void 0 : t10.limit, t10.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(t10) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [t10 == null ? void 0 : t10.epoch]
    });
  }
  async getNetworkMetrics() {
    return await this.transport.request({ method: "suix_getNetworkMetrics", params: [] });
  }
  async getAddressMetrics() {
    return await this.transport.request({ method: "suix_getLatestAddressMetrics", params: [] });
  }
  async getEpochMetrics(t10) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [t10 == null ? void 0 : t10.cursor, t10 == null ? void 0 : t10.limit, t10 == null ? void 0 : t10.descendingOrder]
    });
  }
  async getAllEpochAddressMetrics(t10) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [t10 == null ? void 0 : t10.descendingOrder]
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(t10) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [t10 == null ? void 0 : t10.cursor, t10 == null ? void 0 : t10.limit, t10 == null ? void 0 : t10.descendingOrder]
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics() {
    return await this.transport.request({ method: "suix_getMoveCallMetrics", params: [] });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.transport.request({ method: "suix_getCurrentEpoch", params: [] });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy() {
    return await this.transport.request({ method: "suix_getValidatorsApy", params: [] });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier() {
    const t10 = await this.getCheckpoint({ id: "0" }), r10 = Ai(t10.digest);
    return Mi(r10.slice(0, 4));
  }
  async resolveNameServiceAddress(t10) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [t10.name]
    });
  }
  async resolveNameServiceNames({
    format: t10 = "dot",
    ...r10
  }) {
    const { nextCursor: n10, hasNextPage: i10, data: o10 } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [r10.address, r10.cursor, r10.limit]
    });
    return {
      hasNextPage: i10,
      nextCursor: n10,
      data: o10.map((s10) => Tg(s10, t10))
    };
  }
  async getProtocolConfig(t10) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [t10 == null ? void 0 : t10.version]
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction({
    signal: t10,
    timeout: r10 = 60 * 1e3,
    pollInterval: n10 = 2 * 1e3,
    ...i10
  }) {
    const o10 = AbortSignal.timeout(r10), s10 = new Promise((a10, c) => {
      o10.addEventListener("abort", () => c(o10.reason));
    });
    for (s10.catch(() => {
    }); !o10.aborted; ) {
      t10 == null || t10.throwIfAborted();
      try {
        return await this.getTransactionBlock(i10);
      } catch {
        await Promise.race([
          new Promise((c) => setTimeout(c, n10)),
          s10
        ]);
      }
    }
    throw o10.throwIfAborted(), new Error("Unexpected error while waiting for transaction block.");
  }
  experimental_asClientExtension() {
    return {
      name: "jsonRPC",
      register: () => this
    };
  }
};
var Mf = {};
var ml = {};
var Id = {};
var gl = {};
var Od = {};
var vl = {};
Object.defineProperty(vl, "__esModule", { value: true });
vl.Convert = void 0;
var z3 = class {
  static toPriceFeed(t10) {
    return _u(t10, wi("PriceFeed"));
  }
  static priceFeedToJson(t10) {
    return Eu(t10, wi("PriceFeed"));
  }
  static toPrice(t10) {
    return _u(t10, wi("Price"));
  }
  static priceToJson(t10) {
    return Eu(t10, wi("Price"));
  }
  static toPriceFeedMetadata(t10) {
    return _u(t10, wi("PriceFeedMetadata"));
  }
  static priceFeedMetadataToJson(t10) {
    return Eu(t10, wi("PriceFeedMetadata"));
  }
};
vl.Convert = z3;
function gi(e10, t10, r10 = "") {
  throw Error(r10 ? `Invalid value for key "${r10}". Expected type ${JSON.stringify(e10)} but got ${JSON.stringify(t10)}` : `Invalid value ${JSON.stringify(t10)} for type ${JSON.stringify(e10)}`);
}
function q3(e10) {
  if (e10.jsonToJS === void 0) {
    const t10 = {};
    e10.props.forEach((r10) => t10[r10.json] = { key: r10.js, typ: r10.typ }), e10.jsonToJS = t10;
  }
  return e10.jsonToJS;
}
function H3(e10) {
  if (e10.jsToJSON === void 0) {
    const t10 = {};
    e10.props.forEach((r10) => t10[r10.js] = { key: r10.json, typ: r10.typ }), e10.jsToJSON = t10;
  }
  return e10.jsToJSON;
}
function as(e10, t10, r10, n10 = "") {
  function i10(u10, d6) {
    return typeof u10 == typeof d6 ? d6 : gi(u10, d6, n10);
  }
  function o10(u10, d6) {
    const p = u10.length;
    for (let y = 0; y < p; y++) {
      const x = u10[y];
      try {
        return as(d6, x, r10);
      } catch {
      }
    }
    return gi(u10, d6);
  }
  function s10(u10, d6) {
    return u10.indexOf(d6) !== -1 ? d6 : gi(u10, d6);
  }
  function a10(u10, d6) {
    return Array.isArray(d6) ? d6.map((p) => as(p, u10, r10)) : gi("array", d6);
  }
  function c(u10) {
    if (u10 === null)
      return null;
    const d6 = new Date(u10);
    return isNaN(d6.valueOf()) ? gi("Date", u10) : d6;
  }
  function l10(u10, d6, p) {
    if (p === null || typeof p != "object" || Array.isArray(p))
      return gi("object", p);
    const y = {};
    return Object.getOwnPropertyNames(u10).forEach((x) => {
      const b = u10[x], M = Object.prototype.hasOwnProperty.call(p, x) ? p[x] : void 0;
      y[b.key] = as(M, b.typ, r10, b.key);
    }), Object.getOwnPropertyNames(p).forEach((x) => {
      Object.prototype.hasOwnProperty.call(u10, x) || (y[x] = as(p[x], d6, r10, x));
    }), y;
  }
  if (t10 === "any")
    return e10;
  if (t10 === null)
    return e10 === null ? e10 : gi(t10, e10);
  if (t10 === false)
    return gi(t10, e10);
  for (; typeof t10 == "object" && t10.ref !== void 0; )
    t10 = W3[t10.ref];
  return Array.isArray(t10) ? s10(t10, e10) : typeof t10 == "object" ? t10.hasOwnProperty("unionMembers") ? o10(t10.unionMembers, e10) : t10.hasOwnProperty("arrayItems") ? a10(t10.arrayItems, e10) : t10.hasOwnProperty("props") ? l10(r10(t10), t10.additional, e10) : gi(t10, e10) : t10 === Date && typeof e10 != "number" ? c(e10) : i10(t10, e10);
}
function _u(e10, t10) {
  return as(e10, t10, q3);
}
function Eu(e10, t10) {
  return as(e10, t10, H3);
}
function go(...e10) {
  return { unionMembers: e10 };
}
function Cu(e10, t10) {
  return { props: e10, additional: t10 };
}
function wi(e10) {
  return { ref: e10 };
}
var W3 = {
  PriceFeed: Cu([
    { json: "ema_price", js: "ema_price", typ: wi("Price") },
    { json: "id", js: "id", typ: "" },
    {
      json: "metadata",
      js: "metadata",
      typ: go(void 0, wi("PriceFeedMetadata"))
    },
    { json: "price", js: "price", typ: wi("Price") },
    { json: "vaa", js: "vaa", typ: go(void 0, "") }
  ], "any"),
  Price: Cu([
    { json: "conf", js: "conf", typ: "" },
    { json: "expo", js: "expo", typ: 0 },
    { json: "price", js: "price", typ: "" },
    { json: "publish_time", js: "publish_time", typ: 0 }
  ], "any"),
  PriceFeedMetadata: Cu([
    {
      json: "attestation_time",
      js: "attestation_time",
      typ: go(void 0, 0)
    },
    { json: "emitter_chain", js: "emitter_chain", typ: 0 },
    {
      json: "prev_publish_time",
      js: "prev_publish_time",
      typ: go(void 0, 0)
    },
    {
      json: "price_service_receive_time",
      js: "price_service_receive_time",
      typ: go(void 0, 0)
    },
    { json: "sequence_number", js: "sequence_number", typ: go(void 0, 0) },
    { json: "slot", js: "slot", typ: go(void 0, 0) }
  ], "any")
};
var ja = {};
(function(e10) {
  Object.defineProperties(e10, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
  var t10 = {}, r10 = {};
  r10.byteLength = u10, r10.toByteArray = p, r10.fromByteArray = b;
  for (var n10 = [], i10 = [], o10 = typeof Uint8Array < "u" ? Uint8Array : Array, s10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a10 = 0, c = s10.length; a10 < c; ++a10)
    n10[a10] = s10[a10], i10[s10.charCodeAt(a10)] = a10;
  i10["-".charCodeAt(0)] = 62, i10["_".charCodeAt(0)] = 63;
  function l10(P) {
    var j = P.length;
    if (j % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var F = P.indexOf("=");
    F === -1 && (F = j);
    var B = F === j ? 0 : 4 - F % 4;
    return [F, B];
  }
  function u10(P) {
    var j = l10(P), F = j[0], B = j[1];
    return (F + B) * 3 / 4 - B;
  }
  function d6(P, j, F) {
    return (j + F) * 3 / 4 - F;
  }
  function p(P) {
    var j, F = l10(P), B = F[0], W = F[1], z = new o10(d6(P, B, W)), G = 0, re = W > 0 ? B - 4 : B, ie;
    for (ie = 0; ie < re; ie += 4)
      j = i10[P.charCodeAt(ie)] << 18 | i10[P.charCodeAt(ie + 1)] << 12 | i10[P.charCodeAt(ie + 2)] << 6 | i10[P.charCodeAt(ie + 3)], z[G++] = j >> 16 & 255, z[G++] = j >> 8 & 255, z[G++] = j & 255;
    return W === 2 && (j = i10[P.charCodeAt(ie)] << 2 | i10[P.charCodeAt(ie + 1)] >> 4, z[G++] = j & 255), W === 1 && (j = i10[P.charCodeAt(ie)] << 10 | i10[P.charCodeAt(ie + 1)] << 4 | i10[P.charCodeAt(ie + 2)] >> 2, z[G++] = j >> 8 & 255, z[G++] = j & 255), z;
  }
  function y(P) {
    return n10[P >> 18 & 63] + n10[P >> 12 & 63] + n10[P >> 6 & 63] + n10[P & 63];
  }
  function x(P, j, F) {
    for (var B, W = [], z = j; z < F; z += 3)
      B = (P[z] << 16 & 16711680) + (P[z + 1] << 8 & 65280) + (P[z + 2] & 255), W.push(y(B));
    return W.join("");
  }
  function b(P) {
    for (var j, F = P.length, B = F % 3, W = [], z = 16383, G = 0, re = F - B; G < re; G += z)
      W.push(x(P, G, G + z > re ? re : G + z));
    return B === 1 ? (j = P[F - 1], W.push(
      n10[j >> 2] + n10[j << 4 & 63] + "=="
    )) : B === 2 && (j = (P[F - 2] << 8) + P[F - 1], W.push(
      n10[j >> 10] + n10[j >> 4 & 63] + n10[j << 2 & 63] + "="
    )), W.join("");
  }
  var M = {};
  M.read = function(P, j, F, B, W) {
    var z, G, re = W * 8 - B - 1, ie = (1 << re) - 1, oe = ie >> 1, q = -7, L = F ? W - 1 : 0, h = F ? -1 : 1, f = P[j + L];
    for (L += h, z = f & (1 << -q) - 1, f >>= -q, q += re; q > 0; z = z * 256 + P[j + L], L += h, q -= 8)
      ;
    for (G = z & (1 << -q) - 1, z >>= -q, q += B; q > 0; G = G * 256 + P[j + L], L += h, q -= 8)
      ;
    if (z === 0)
      z = 1 - oe;
    else {
      if (z === ie)
        return G ? NaN : (f ? -1 : 1) * (1 / 0);
      G = G + Math.pow(2, B), z = z - oe;
    }
    return (f ? -1 : 1) * G * Math.pow(2, z - B);
  }, M.write = function(P, j, F, B, W, z) {
    var G, re, ie, oe = z * 8 - W - 1, q = (1 << oe) - 1, L = q >> 1, h = W === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = B ? 0 : z - 1, m = B ? 1 : -1, S = j < 0 || j === 0 && 1 / j < 0 ? 1 : 0;
    for (j = Math.abs(j), isNaN(j) || j === 1 / 0 ? (re = isNaN(j) ? 1 : 0, G = q) : (G = Math.floor(Math.log(j) / Math.LN2), j * (ie = Math.pow(2, -G)) < 1 && (G--, ie *= 2), G + L >= 1 ? j += h / ie : j += h * Math.pow(2, 1 - L), j * ie >= 2 && (G++, ie /= 2), G + L >= q ? (re = 0, G = q) : G + L >= 1 ? (re = (j * ie - 1) * Math.pow(2, W), G = G + L) : (re = j * Math.pow(2, L - 1) * Math.pow(2, W), G = 0)); W >= 8; P[F + f] = re & 255, f += m, re /= 256, W -= 8)
      ;
    for (G = G << W | re, oe += W; oe > 0; P[F + f] = G & 255, f += m, G /= 256, oe -= 8)
      ;
    P[F + f - m] |= S * 128;
  };
  (function(P) {
    const j = r10, F = M, B = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    P.Buffer = q, P.SlowBuffer = v10, P.INSPECT_MAX_BYTES = 50;
    const W = 2147483647;
    P.kMaxLength = W;
    const { Uint8Array: z, ArrayBuffer: G, SharedArrayBuffer: re } = globalThis;
    q.TYPED_ARRAY_SUPPORT = ie(), !q.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function ie() {
      try {
        const N = new z(1), _ = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(_, z.prototype), Object.setPrototypeOf(N, _), N.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(q.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (q.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(q.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (q.isBuffer(this))
          return this.byteOffset;
      }
    });
    function oe(N) {
      if (N > W)
        throw new RangeError('The value "' + N + '" is invalid for option "size"');
      const _ = new z(N);
      return Object.setPrototypeOf(_, q.prototype), _;
    }
    function q(N, _, A) {
      if (typeof N == "number") {
        if (typeof _ == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return m(N);
      }
      return L(N, _, A);
    }
    q.poolSize = 8192;
    function L(N, _, A) {
      if (typeof N == "string")
        return S(N, _);
      if (G.isView(N))
        return E(N);
      if (N == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
        );
      if (pt(N, G) || N && pt(N.buffer, G) || typeof re < "u" && (pt(N, re) || N && pt(N.buffer, re)))
        return I(N, _, A);
      if (typeof N == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const U = N.valueOf && N.valueOf();
      if (U != null && U !== N)
        return q.from(U, _, A);
      const Y = C(N);
      if (Y)
        return Y;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof N[Symbol.toPrimitive] == "function")
        return q.from(N[Symbol.toPrimitive]("string"), _, A);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
      );
    }
    q.from = function(N, _, A) {
      return L(N, _, A);
    }, Object.setPrototypeOf(q.prototype, z.prototype), Object.setPrototypeOf(q, z);
    function h(N) {
      if (typeof N != "number")
        throw new TypeError('"size" argument must be of type number');
      if (N < 0)
        throw new RangeError('The value "' + N + '" is invalid for option "size"');
    }
    function f(N, _, A) {
      return h(N), N <= 0 ? oe(N) : _ !== void 0 ? typeof A == "string" ? oe(N).fill(_, A) : oe(N).fill(_) : oe(N);
    }
    q.alloc = function(N, _, A) {
      return f(N, _, A);
    };
    function m(N) {
      return h(N), oe(N < 0 ? 0 : g(N) | 0);
    }
    q.allocUnsafe = function(N) {
      return m(N);
    }, q.allocUnsafeSlow = function(N) {
      return m(N);
    };
    function S(N, _) {
      if ((typeof _ != "string" || _ === "") && (_ = "utf8"), !q.isEncoding(_))
        throw new TypeError("Unknown encoding: " + _);
      const A = k(N, _) | 0;
      let U = oe(A);
      const Y = U.write(N, _);
      return Y !== A && (U = U.slice(0, Y)), U;
    }
    function T(N) {
      const _ = N.length < 0 ? 0 : g(N.length) | 0, A = oe(_);
      for (let U = 0; U < _; U += 1)
        A[U] = N[U] & 255;
      return A;
    }
    function E(N) {
      if (pt(N, z)) {
        const _ = new z(N);
        return I(_.buffer, _.byteOffset, _.byteLength);
      }
      return T(N);
    }
    function I(N, _, A) {
      if (_ < 0 || N.byteLength < _)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (N.byteLength < _ + (A || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let U;
      return _ === void 0 && A === void 0 ? U = new z(N) : A === void 0 ? U = new z(N, _) : U = new z(N, _, A), Object.setPrototypeOf(U, q.prototype), U;
    }
    function C(N) {
      if (q.isBuffer(N)) {
        const _ = g(N.length) | 0, A = oe(_);
        return A.length === 0 || N.copy(A, 0, 0, _), A;
      }
      if (N.length !== void 0)
        return typeof N.length != "number" || jt(N.length) ? oe(0) : T(N);
      if (N.type === "Buffer" && Array.isArray(N.data))
        return T(N.data);
    }
    function g(N) {
      if (N >= W)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + W.toString(16) + " bytes");
      return N | 0;
    }
    function v10(N) {
      return +N != N && (N = 0), q.alloc(+N);
    }
    q.isBuffer = function(_) {
      return _ != null && _._isBuffer === true && _ !== q.prototype;
    }, q.compare = function(_, A) {
      if (pt(_, z) && (_ = q.from(_, _.offset, _.byteLength)), pt(A, z) && (A = q.from(A, A.offset, A.byteLength)), !q.isBuffer(_) || !q.isBuffer(A))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (_ === A)
        return 0;
      let U = _.length, Y = A.length;
      for (let ee = 0, ne = Math.min(U, Y); ee < ne; ++ee)
        if (_[ee] !== A[ee]) {
          U = _[ee], Y = A[ee];
          break;
        }
      return U < Y ? -1 : Y < U ? 1 : 0;
    }, q.isEncoding = function(_) {
      switch (String(_).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, q.concat = function(_, A) {
      if (!Array.isArray(_))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (_.length === 0)
        return q.alloc(0);
      let U;
      if (A === void 0)
        for (A = 0, U = 0; U < _.length; ++U)
          A += _[U].length;
      const Y = q.allocUnsafe(A);
      let ee = 0;
      for (U = 0; U < _.length; ++U) {
        let ne = _[U];
        if (pt(ne, z))
          ee + ne.length > Y.length ? (q.isBuffer(ne) || (ne = q.from(ne)), ne.copy(Y, ee)) : z.prototype.set.call(
            Y,
            ne,
            ee
          );
        else if (q.isBuffer(ne))
          ne.copy(Y, ee);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        ee += ne.length;
      }
      return Y;
    };
    function k(N, _) {
      if (q.isBuffer(N))
        return N.length;
      if (G.isView(N) || pt(N, G))
        return N.byteLength;
      if (typeof N != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof N
        );
      const A = N.length, U = arguments.length > 2 && arguments[2] === true;
      if (!U && A === 0)
        return 0;
      let Y = false;
      for (; ; )
        switch (_) {
          case "ascii":
          case "latin1":
          case "binary":
            return A;
          case "utf8":
          case "utf-8":
            return Nt(N).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return A * 2;
          case "hex":
            return A >>> 1;
          case "base64":
            return Ct(N).length;
          default:
            if (Y)
              return U ? -1 : Nt(N).length;
            _ = ("" + _).toLowerCase(), Y = true;
        }
    }
    q.byteLength = k;
    function Q(N, _, A) {
      let U = false;
      if ((_ === void 0 || _ < 0) && (_ = 0), _ > this.length || ((A === void 0 || A > this.length) && (A = this.length), A <= 0) || (A >>>= 0, _ >>>= 0, A <= _))
        return "";
      for (N || (N = "utf8"); ; )
        switch (N) {
          case "hex":
            return $e(this, _, A);
          case "utf8":
          case "utf-8":
            return je(this, _, A);
          case "ascii":
            return de(this, _, A);
          case "latin1":
          case "binary":
            return Ee(this, _, A);
          case "base64":
            return ft(this, _, A);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ne(this, _, A);
          default:
            if (U)
              throw new TypeError("Unknown encoding: " + N);
            N = (N + "").toLowerCase(), U = true;
        }
    }
    q.prototype._isBuffer = true;
    function Z(N, _, A) {
      const U = N[_];
      N[_] = N[A], N[A] = U;
    }
    q.prototype.swap16 = function() {
      const _ = this.length;
      if (_ % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let A = 0; A < _; A += 2)
        Z(this, A, A + 1);
      return this;
    }, q.prototype.swap32 = function() {
      const _ = this.length;
      if (_ % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let A = 0; A < _; A += 4)
        Z(this, A, A + 3), Z(this, A + 1, A + 2);
      return this;
    }, q.prototype.swap64 = function() {
      const _ = this.length;
      if (_ % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let A = 0; A < _; A += 8)
        Z(this, A, A + 7), Z(this, A + 1, A + 6), Z(this, A + 2, A + 5), Z(this, A + 3, A + 4);
      return this;
    }, q.prototype.toString = function() {
      const _ = this.length;
      return _ === 0 ? "" : arguments.length === 0 ? je(this, 0, _) : Q.apply(this, arguments);
    }, q.prototype.toLocaleString = q.prototype.toString, q.prototype.equals = function(_) {
      if (!q.isBuffer(_))
        throw new TypeError("Argument must be a Buffer");
      return this === _ ? true : q.compare(this, _) === 0;
    }, q.prototype.inspect = function() {
      let _ = "";
      const A = P.INSPECT_MAX_BYTES;
      return _ = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (_ += " ... "), "<Buffer " + _ + ">";
    }, B && (q.prototype[B] = q.prototype.inspect), q.prototype.compare = function(_, A, U, Y, ee) {
      if (pt(_, z) && (_ = q.from(_, _.offset, _.byteLength)), !q.isBuffer(_))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof _
        );
      if (A === void 0 && (A = 0), U === void 0 && (U = _ ? _.length : 0), Y === void 0 && (Y = 0), ee === void 0 && (ee = this.length), A < 0 || U > _.length || Y < 0 || ee > this.length)
        throw new RangeError("out of range index");
      if (Y >= ee && A >= U)
        return 0;
      if (Y >= ee)
        return -1;
      if (A >= U)
        return 1;
      if (A >>>= 0, U >>>= 0, Y >>>= 0, ee >>>= 0, this === _)
        return 0;
      let ne = ee - Y, ke = U - A;
      const Je = Math.min(ne, ke), Pe = this.slice(Y, ee), V = _.slice(A, U);
      for (let se = 0; se < Je; ++se)
        if (Pe[se] !== V[se]) {
          ne = Pe[se], ke = V[se];
          break;
        }
      return ne < ke ? -1 : ke < ne ? 1 : 0;
    };
    function ae(N, _, A, U, Y) {
      if (N.length === 0)
        return -1;
      if (typeof A == "string" ? (U = A, A = 0) : A > 2147483647 ? A = 2147483647 : A < -2147483648 && (A = -2147483648), A = +A, jt(A) && (A = Y ? 0 : N.length - 1), A < 0 && (A = N.length + A), A >= N.length) {
        if (Y)
          return -1;
        A = N.length - 1;
      } else if (A < 0)
        if (Y)
          A = 0;
        else
          return -1;
      if (typeof _ == "string" && (_ = q.from(_, U)), q.isBuffer(_))
        return _.length === 0 ? -1 : ve(N, _, A, U, Y);
      if (typeof _ == "number")
        return _ = _ & 255, typeof z.prototype.indexOf == "function" ? Y ? z.prototype.indexOf.call(N, _, A) : z.prototype.lastIndexOf.call(N, _, A) : ve(N, [_], A, U, Y);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ve(N, _, A, U, Y) {
      let ee = 1, ne = N.length, ke = _.length;
      if (U !== void 0 && (U = String(U).toLowerCase(), U === "ucs2" || U === "ucs-2" || U === "utf16le" || U === "utf-16le")) {
        if (N.length < 2 || _.length < 2)
          return -1;
        ee = 2, ne /= 2, ke /= 2, A /= 2;
      }
      function Je(V, se) {
        return ee === 1 ? V[se] : V.readUInt16BE(se * ee);
      }
      let Pe;
      if (Y) {
        let V = -1;
        for (Pe = A; Pe < ne; Pe++)
          if (Je(N, Pe) === Je(_, V === -1 ? 0 : Pe - V)) {
            if (V === -1 && (V = Pe), Pe - V + 1 === ke)
              return V * ee;
          } else
            V !== -1 && (Pe -= Pe - V), V = -1;
      } else
        for (A + ke > ne && (A = ne - ke), Pe = A; Pe >= 0; Pe--) {
          let V = true;
          for (let se = 0; se < ke; se++)
            if (Je(N, Pe + se) !== Je(_, se)) {
              V = false;
              break;
            }
          if (V)
            return Pe;
        }
      return -1;
    }
    q.prototype.includes = function(_, A, U) {
      return this.indexOf(_, A, U) !== -1;
    }, q.prototype.indexOf = function(_, A, U) {
      return ae(this, _, A, U, true);
    }, q.prototype.lastIndexOf = function(_, A, U) {
      return ae(this, _, A, U, false);
    };
    function we(N, _, A, U) {
      A = Number(A) || 0;
      const Y = N.length - A;
      U ? (U = Number(U), U > Y && (U = Y)) : U = Y;
      const ee = _.length;
      U > ee / 2 && (U = ee / 2);
      let ne;
      for (ne = 0; ne < U; ++ne) {
        const ke = parseInt(_.substr(ne * 2, 2), 16);
        if (jt(ke))
          return ne;
        N[A + ne] = ke;
      }
      return ne;
    }
    function he(N, _, A, U) {
      return We(Nt(_, N.length - A), N, A, U);
    }
    function De(N, _, A, U) {
      return We(et(_), N, A, U);
    }
    function Te(N, _, A, U) {
      return We(Ct(_), N, A, U);
    }
    function Xe(N, _, A, U) {
      return We(wt(_, N.length - A), N, A, U);
    }
    q.prototype.write = function(_, A, U, Y) {
      if (A === void 0)
        Y = "utf8", U = this.length, A = 0;
      else if (U === void 0 && typeof A == "string")
        Y = A, U = this.length, A = 0;
      else if (isFinite(A))
        A = A >>> 0, isFinite(U) ? (U = U >>> 0, Y === void 0 && (Y = "utf8")) : (Y = U, U = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const ee = this.length - A;
      if ((U === void 0 || U > ee) && (U = ee), _.length > 0 && (U < 0 || A < 0) || A > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      Y || (Y = "utf8");
      let ne = false;
      for (; ; )
        switch (Y) {
          case "hex":
            return we(this, _, A, U);
          case "utf8":
          case "utf-8":
            return he(this, _, A, U);
          case "ascii":
          case "latin1":
          case "binary":
            return De(this, _, A, U);
          case "base64":
            return Te(this, _, A, U);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Xe(this, _, A, U);
          default:
            if (ne)
              throw new TypeError("Unknown encoding: " + Y);
            Y = ("" + Y).toLowerCase(), ne = true;
        }
    }, q.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function ft(N, _, A) {
      return _ === 0 && A === N.length ? j.fromByteArray(N) : j.fromByteArray(N.slice(_, A));
    }
    function je(N, _, A) {
      A = Math.min(N.length, A);
      const U = [];
      let Y = _;
      for (; Y < A; ) {
        const ee = N[Y];
        let ne = null, ke = ee > 239 ? 4 : ee > 223 ? 3 : ee > 191 ? 2 : 1;
        if (Y + ke <= A) {
          let Je, Pe, V, se;
          switch (ke) {
            case 1:
              ee < 128 && (ne = ee);
              break;
            case 2:
              Je = N[Y + 1], (Je & 192) === 128 && (se = (ee & 31) << 6 | Je & 63, se > 127 && (ne = se));
              break;
            case 3:
              Je = N[Y + 1], Pe = N[Y + 2], (Je & 192) === 128 && (Pe & 192) === 128 && (se = (ee & 15) << 12 | (Je & 63) << 6 | Pe & 63, se > 2047 && (se < 55296 || se > 57343) && (ne = se));
              break;
            case 4:
              Je = N[Y + 1], Pe = N[Y + 2], V = N[Y + 3], (Je & 192) === 128 && (Pe & 192) === 128 && (V & 192) === 128 && (se = (ee & 15) << 18 | (Je & 63) << 12 | (Pe & 63) << 6 | V & 63, se > 65535 && se < 1114112 && (ne = se));
          }
        }
        ne === null ? (ne = 65533, ke = 1) : ne > 65535 && (ne -= 65536, U.push(ne >>> 10 & 1023 | 55296), ne = 56320 | ne & 1023), U.push(ne), Y += ke;
      }
      return ye(U);
    }
    const ht = 4096;
    function ye(N) {
      const _ = N.length;
      if (_ <= ht)
        return String.fromCharCode.apply(String, N);
      let A = "", U = 0;
      for (; U < _; )
        A += String.fromCharCode.apply(
          String,
          N.slice(U, U += ht)
        );
      return A;
    }
    function de(N, _, A) {
      let U = "";
      A = Math.min(N.length, A);
      for (let Y = _; Y < A; ++Y)
        U += String.fromCharCode(N[Y] & 127);
      return U;
    }
    function Ee(N, _, A) {
      let U = "";
      A = Math.min(N.length, A);
      for (let Y = _; Y < A; ++Y)
        U += String.fromCharCode(N[Y]);
      return U;
    }
    function $e(N, _, A) {
      const U = N.length;
      (!_ || _ < 0) && (_ = 0), (!A || A < 0 || A > U) && (A = U);
      let Y = "";
      for (let ee = _; ee < A; ++ee)
        Y += nt[N[ee]];
      return Y;
    }
    function Ne(N, _, A) {
      const U = N.slice(_, A);
      let Y = "";
      for (let ee = 0; ee < U.length - 1; ee += 2)
        Y += String.fromCharCode(U[ee] + U[ee + 1] * 256);
      return Y;
    }
    q.prototype.slice = function(_, A) {
      const U = this.length;
      _ = ~~_, A = A === void 0 ? U : ~~A, _ < 0 ? (_ += U, _ < 0 && (_ = 0)) : _ > U && (_ = U), A < 0 ? (A += U, A < 0 && (A = 0)) : A > U && (A = U), A < _ && (A = _);
      const Y = this.subarray(_, A);
      return Object.setPrototypeOf(Y, q.prototype), Y;
    };
    function Ce(N, _, A) {
      if (N % 1 !== 0 || N < 0)
        throw new RangeError("offset is not uint");
      if (N + _ > A)
        throw new RangeError("Trying to access beyond buffer length");
    }
    q.prototype.readUintLE = q.prototype.readUIntLE = function(_, A, U) {
      _ = _ >>> 0, A = A >>> 0, U || Ce(_, A, this.length);
      let Y = this[_], ee = 1, ne = 0;
      for (; ++ne < A && (ee *= 256); )
        Y += this[_ + ne] * ee;
      return Y;
    }, q.prototype.readUintBE = q.prototype.readUIntBE = function(_, A, U) {
      _ = _ >>> 0, A = A >>> 0, U || Ce(_, A, this.length);
      let Y = this[_ + --A], ee = 1;
      for (; A > 0 && (ee *= 256); )
        Y += this[_ + --A] * ee;
      return Y;
    }, q.prototype.readUint8 = q.prototype.readUInt8 = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 1, this.length), this[_];
    }, q.prototype.readUint16LE = q.prototype.readUInt16LE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 2, this.length), this[_] | this[_ + 1] << 8;
    }, q.prototype.readUint16BE = q.prototype.readUInt16BE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 2, this.length), this[_] << 8 | this[_ + 1];
    }, q.prototype.readUint32LE = q.prototype.readUInt32LE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 4, this.length), (this[_] | this[_ + 1] << 8 | this[_ + 2] << 16) + this[_ + 3] * 16777216;
    }, q.prototype.readUint32BE = q.prototype.readUInt32BE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 4, this.length), this[_] * 16777216 + (this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3]);
    }, q.prototype.readBigUInt64LE = xt(function(_) {
      _ = _ >>> 0, Et(_, "offset");
      const A = this[_], U = this[_ + 7];
      (A === void 0 || U === void 0) && Rt(_, this.length - 8);
      const Y = A + this[++_] * 2 ** 8 + this[++_] * 2 ** 16 + this[++_] * 2 ** 24, ee = this[++_] + this[++_] * 2 ** 8 + this[++_] * 2 ** 16 + U * 2 ** 24;
      return BigInt(Y) + (BigInt(ee) << BigInt(32));
    }), q.prototype.readBigUInt64BE = xt(function(_) {
      _ = _ >>> 0, Et(_, "offset");
      const A = this[_], U = this[_ + 7];
      (A === void 0 || U === void 0) && Rt(_, this.length - 8);
      const Y = A * 2 ** 24 + this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + this[++_], ee = this[++_] * 2 ** 24 + this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + U;
      return (BigInt(Y) << BigInt(32)) + BigInt(ee);
    }), q.prototype.readIntLE = function(_, A, U) {
      _ = _ >>> 0, A = A >>> 0, U || Ce(_, A, this.length);
      let Y = this[_], ee = 1, ne = 0;
      for (; ++ne < A && (ee *= 256); )
        Y += this[_ + ne] * ee;
      return ee *= 128, Y >= ee && (Y -= Math.pow(2, 8 * A)), Y;
    }, q.prototype.readIntBE = function(_, A, U) {
      _ = _ >>> 0, A = A >>> 0, U || Ce(_, A, this.length);
      let Y = A, ee = 1, ne = this[_ + --Y];
      for (; Y > 0 && (ee *= 256); )
        ne += this[_ + --Y] * ee;
      return ee *= 128, ne >= ee && (ne -= Math.pow(2, 8 * A)), ne;
    }, q.prototype.readInt8 = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 1, this.length), this[_] & 128 ? (255 - this[_] + 1) * -1 : this[_];
    }, q.prototype.readInt16LE = function(_, A) {
      _ = _ >>> 0, A || Ce(_, 2, this.length);
      const U = this[_] | this[_ + 1] << 8;
      return U & 32768 ? U | 4294901760 : U;
    }, q.prototype.readInt16BE = function(_, A) {
      _ = _ >>> 0, A || Ce(_, 2, this.length);
      const U = this[_ + 1] | this[_] << 8;
      return U & 32768 ? U | 4294901760 : U;
    }, q.prototype.readInt32LE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 4, this.length), this[_] | this[_ + 1] << 8 | this[_ + 2] << 16 | this[_ + 3] << 24;
    }, q.prototype.readInt32BE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 4, this.length), this[_] << 24 | this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3];
    }, q.prototype.readBigInt64LE = xt(function(_) {
      _ = _ >>> 0, Et(_, "offset");
      const A = this[_], U = this[_ + 7];
      (A === void 0 || U === void 0) && Rt(_, this.length - 8);
      const Y = this[_ + 4] + this[_ + 5] * 2 ** 8 + this[_ + 6] * 2 ** 16 + (U << 24);
      return (BigInt(Y) << BigInt(32)) + BigInt(A + this[++_] * 2 ** 8 + this[++_] * 2 ** 16 + this[++_] * 2 ** 24);
    }), q.prototype.readBigInt64BE = xt(function(_) {
      _ = _ >>> 0, Et(_, "offset");
      const A = this[_], U = this[_ + 7];
      (A === void 0 || U === void 0) && Rt(_, this.length - 8);
      const Y = (A << 24) + // Overflow
      this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + this[++_];
      return (BigInt(Y) << BigInt(32)) + BigInt(this[++_] * 2 ** 24 + this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + U);
    }), q.prototype.readFloatLE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 4, this.length), F.read(this, _, true, 23, 4);
    }, q.prototype.readFloatBE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 4, this.length), F.read(this, _, false, 23, 4);
    }, q.prototype.readDoubleLE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 8, this.length), F.read(this, _, true, 52, 8);
    }, q.prototype.readDoubleBE = function(_, A) {
      return _ = _ >>> 0, A || Ce(_, 8, this.length), F.read(this, _, false, 52, 8);
    };
    function Ae(N, _, A, U, Y, ee) {
      if (!q.isBuffer(N))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (_ > Y || _ < ee)
        throw new RangeError('"value" argument is out of bounds');
      if (A + U > N.length)
        throw new RangeError("Index out of range");
    }
    q.prototype.writeUintLE = q.prototype.writeUIntLE = function(_, A, U, Y) {
      if (_ = +_, A = A >>> 0, U = U >>> 0, !Y) {
        const ke = Math.pow(2, 8 * U) - 1;
        Ae(this, _, A, U, ke, 0);
      }
      let ee = 1, ne = 0;
      for (this[A] = _ & 255; ++ne < U && (ee *= 256); )
        this[A + ne] = _ / ee & 255;
      return A + U;
    }, q.prototype.writeUintBE = q.prototype.writeUIntBE = function(_, A, U, Y) {
      if (_ = +_, A = A >>> 0, U = U >>> 0, !Y) {
        const ke = Math.pow(2, 8 * U) - 1;
        Ae(this, _, A, U, ke, 0);
      }
      let ee = U - 1, ne = 1;
      for (this[A + ee] = _ & 255; --ee >= 0 && (ne *= 256); )
        this[A + ee] = _ / ne & 255;
      return A + U;
    }, q.prototype.writeUint8 = q.prototype.writeUInt8 = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 1, 255, 0), this[A] = _ & 255, A + 1;
    }, q.prototype.writeUint16LE = q.prototype.writeUInt16LE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 2, 65535, 0), this[A] = _ & 255, this[A + 1] = _ >>> 8, A + 2;
    }, q.prototype.writeUint16BE = q.prototype.writeUInt16BE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 2, 65535, 0), this[A] = _ >>> 8, this[A + 1] = _ & 255, A + 2;
    }, q.prototype.writeUint32LE = q.prototype.writeUInt32LE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 4, 4294967295, 0), this[A + 3] = _ >>> 24, this[A + 2] = _ >>> 16, this[A + 1] = _ >>> 8, this[A] = _ & 255, A + 4;
    }, q.prototype.writeUint32BE = q.prototype.writeUInt32BE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 4, 4294967295, 0), this[A] = _ >>> 24, this[A + 1] = _ >>> 16, this[A + 2] = _ >>> 8, this[A + 3] = _ & 255, A + 4;
    };
    function Be(N, _, A, U, Y) {
      Qe(_, U, Y, N, A, 7);
      let ee = Number(_ & BigInt(4294967295));
      N[A++] = ee, ee = ee >> 8, N[A++] = ee, ee = ee >> 8, N[A++] = ee, ee = ee >> 8, N[A++] = ee;
      let ne = Number(_ >> BigInt(32) & BigInt(4294967295));
      return N[A++] = ne, ne = ne >> 8, N[A++] = ne, ne = ne >> 8, N[A++] = ne, ne = ne >> 8, N[A++] = ne, A;
    }
    function lt(N, _, A, U, Y) {
      Qe(_, U, Y, N, A, 7);
      let ee = Number(_ & BigInt(4294967295));
      N[A + 7] = ee, ee = ee >> 8, N[A + 6] = ee, ee = ee >> 8, N[A + 5] = ee, ee = ee >> 8, N[A + 4] = ee;
      let ne = Number(_ >> BigInt(32) & BigInt(4294967295));
      return N[A + 3] = ne, ne = ne >> 8, N[A + 2] = ne, ne = ne >> 8, N[A + 1] = ne, ne = ne >> 8, N[A] = ne, A + 8;
    }
    q.prototype.writeBigUInt64LE = xt(function(_, A = 0) {
      return Be(this, _, A, BigInt(0), BigInt("0xffffffffffffffff"));
    }), q.prototype.writeBigUInt64BE = xt(function(_, A = 0) {
      return lt(this, _, A, BigInt(0), BigInt("0xffffffffffffffff"));
    }), q.prototype.writeIntLE = function(_, A, U, Y) {
      if (_ = +_, A = A >>> 0, !Y) {
        const Je = Math.pow(2, 8 * U - 1);
        Ae(this, _, A, U, Je - 1, -Je);
      }
      let ee = 0, ne = 1, ke = 0;
      for (this[A] = _ & 255; ++ee < U && (ne *= 256); )
        _ < 0 && ke === 0 && this[A + ee - 1] !== 0 && (ke = 1), this[A + ee] = (_ / ne >> 0) - ke & 255;
      return A + U;
    }, q.prototype.writeIntBE = function(_, A, U, Y) {
      if (_ = +_, A = A >>> 0, !Y) {
        const Je = Math.pow(2, 8 * U - 1);
        Ae(this, _, A, U, Je - 1, -Je);
      }
      let ee = U - 1, ne = 1, ke = 0;
      for (this[A + ee] = _ & 255; --ee >= 0 && (ne *= 256); )
        _ < 0 && ke === 0 && this[A + ee + 1] !== 0 && (ke = 1), this[A + ee] = (_ / ne >> 0) - ke & 255;
      return A + U;
    }, q.prototype.writeInt8 = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 1, 127, -128), _ < 0 && (_ = 255 + _ + 1), this[A] = _ & 255, A + 1;
    }, q.prototype.writeInt16LE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 2, 32767, -32768), this[A] = _ & 255, this[A + 1] = _ >>> 8, A + 2;
    }, q.prototype.writeInt16BE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 2, 32767, -32768), this[A] = _ >>> 8, this[A + 1] = _ & 255, A + 2;
    }, q.prototype.writeInt32LE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 4, 2147483647, -2147483648), this[A] = _ & 255, this[A + 1] = _ >>> 8, this[A + 2] = _ >>> 16, this[A + 3] = _ >>> 24, A + 4;
    }, q.prototype.writeInt32BE = function(_, A, U) {
      return _ = +_, A = A >>> 0, U || Ae(this, _, A, 4, 2147483647, -2147483648), _ < 0 && (_ = 4294967295 + _ + 1), this[A] = _ >>> 24, this[A + 1] = _ >>> 16, this[A + 2] = _ >>> 8, this[A + 3] = _ & 255, A + 4;
    }, q.prototype.writeBigInt64LE = xt(function(_, A = 0) {
      return Be(this, _, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), q.prototype.writeBigInt64BE = xt(function(_, A = 0) {
      return lt(this, _, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ut(N, _, A, U, Y, ee) {
      if (A + U > N.length)
        throw new RangeError("Index out of range");
      if (A < 0)
        throw new RangeError("Index out of range");
    }
    function Ve(N, _, A, U, Y) {
      return _ = +_, A = A >>> 0, Y || ut(N, _, A, 4), F.write(N, _, A, U, 23, 4), A + 4;
    }
    q.prototype.writeFloatLE = function(_, A, U) {
      return Ve(this, _, A, true, U);
    }, q.prototype.writeFloatBE = function(_, A, U) {
      return Ve(this, _, A, false, U);
    };
    function kt(N, _, A, U, Y) {
      return _ = +_, A = A >>> 0, Y || ut(N, _, A, 8), F.write(N, _, A, U, 52, 8), A + 8;
    }
    q.prototype.writeDoubleLE = function(_, A, U) {
      return kt(this, _, A, true, U);
    }, q.prototype.writeDoubleBE = function(_, A, U) {
      return kt(this, _, A, false, U);
    }, q.prototype.copy = function(_, A, U, Y) {
      if (!q.isBuffer(_))
        throw new TypeError("argument should be a Buffer");
      if (U || (U = 0), !Y && Y !== 0 && (Y = this.length), A >= _.length && (A = _.length), A || (A = 0), Y > 0 && Y < U && (Y = U), Y === U || _.length === 0 || this.length === 0)
        return 0;
      if (A < 0)
        throw new RangeError("targetStart out of bounds");
      if (U < 0 || U >= this.length)
        throw new RangeError("Index out of range");
      if (Y < 0)
        throw new RangeError("sourceEnd out of bounds");
      Y > this.length && (Y = this.length), _.length - A < Y - U && (Y = _.length - A + U);
      const ee = Y - U;
      return this === _ && typeof z.prototype.copyWithin == "function" ? this.copyWithin(A, U, Y) : z.prototype.set.call(
        _,
        this.subarray(U, Y),
        A
      ), ee;
    }, q.prototype.fill = function(_, A, U, Y) {
      if (typeof _ == "string") {
        if (typeof A == "string" ? (Y = A, A = 0, U = this.length) : typeof U == "string" && (Y = U, U = this.length), Y !== void 0 && typeof Y != "string")
          throw new TypeError("encoding must be a string");
        if (typeof Y == "string" && !q.isEncoding(Y))
          throw new TypeError("Unknown encoding: " + Y);
        if (_.length === 1) {
          const ne = _.charCodeAt(0);
          (Y === "utf8" && ne < 128 || Y === "latin1") && (_ = ne);
        }
      } else
        typeof _ == "number" ? _ = _ & 255 : typeof _ == "boolean" && (_ = Number(_));
      if (A < 0 || this.length < A || this.length < U)
        throw new RangeError("Out of range index");
      if (U <= A)
        return this;
      A = A >>> 0, U = U === void 0 ? this.length : U >>> 0, _ || (_ = 0);
      let ee;
      if (typeof _ == "number")
        for (ee = A; ee < U; ++ee)
          this[ee] = _;
      else {
        const ne = q.isBuffer(_) ? _ : q.from(_, Y), ke = ne.length;
        if (ke === 0)
          throw new TypeError('The value "' + _ + '" is invalid for argument "value"');
        for (ee = 0; ee < U - A; ++ee)
          this[ee + A] = ne[ee % ke];
      }
      return this;
    };
    const _t = {};
    function Ge(N, _, A) {
      _t[N] = class extends A {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: _.apply(this, arguments),
            writable: true,
            configurable: true
          }), this.name = `${this.name} [${N}]`, this.stack, delete this.name;
        }
        get code() {
          return N;
        }
        set code(Y) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: Y,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${N}]: ${this.message}`;
        }
      };
    }
    Ge(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(N) {
        return N ? `${N} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Ge(
      "ERR_INVALID_ARG_TYPE",
      function(N, _) {
        return `The "${N}" argument must be of type number. Received type ${typeof _}`;
      },
      TypeError
    ), Ge(
      "ERR_OUT_OF_RANGE",
      function(N, _, A) {
        let U = `The value of "${N}" is out of range.`, Y = A;
        return Number.isInteger(A) && Math.abs(A) > 2 ** 32 ? Y = Ot(String(A)) : typeof A == "bigint" && (Y = String(A), (A > BigInt(2) ** BigInt(32) || A < -(BigInt(2) ** BigInt(32))) && (Y = Ot(Y)), Y += "n"), U += ` It must be ${_}. Received ${Y}`, U;
      },
      RangeError
    );
    function Ot(N) {
      let _ = "", A = N.length;
      const U = N[0] === "-" ? 1 : 0;
      for (; A >= U + 4; A -= 3)
        _ = `_${N.slice(A - 3, A)}${_}`;
      return `${N.slice(0, A)}${_}`;
    }
    function $t(N, _, A) {
      Et(_, "offset"), (N[_] === void 0 || N[_ + A] === void 0) && Rt(_, N.length - (A + 1));
    }
    function Qe(N, _, A, U, Y, ee) {
      if (N > A || N < _) {
        const ne = typeof _ == "bigint" ? "n" : "";
        let ke;
        throw ee > 3 ? _ === 0 || _ === BigInt(0) ? ke = `>= 0${ne} and < 2${ne} ** ${(ee + 1) * 8}${ne}` : ke = `>= -(2${ne} ** ${(ee + 1) * 8 - 1}${ne}) and < 2 ** ${(ee + 1) * 8 - 1}${ne}` : ke = `>= ${_}${ne} and <= ${A}${ne}`, new _t.ERR_OUT_OF_RANGE("value", ke, N);
      }
      $t(U, Y, ee);
    }
    function Et(N, _) {
      if (typeof N != "number")
        throw new _t.ERR_INVALID_ARG_TYPE(_, "number", N);
    }
    function Rt(N, _, A) {
      throw Math.floor(N) !== N ? (Et(N, A), new _t.ERR_OUT_OF_RANGE(A || "offset", "an integer", N)) : _ < 0 ? new _t.ERR_BUFFER_OUT_OF_BOUNDS() : new _t.ERR_OUT_OF_RANGE(
        A || "offset",
        `>= ${A ? 1 : 0} and <= ${_}`,
        N
      );
    }
    const rt = /[^+/0-9A-Za-z-_]/g;
    function Dt(N) {
      if (N = N.split("=")[0], N = N.trim().replace(rt, ""), N.length < 2)
        return "";
      for (; N.length % 4 !== 0; )
        N = N + "=";
      return N;
    }
    function Nt(N, _) {
      _ = _ || 1 / 0;
      let A;
      const U = N.length;
      let Y = null;
      const ee = [];
      for (let ne = 0; ne < U; ++ne) {
        if (A = N.charCodeAt(ne), A > 55295 && A < 57344) {
          if (!Y) {
            if (A > 56319) {
              (_ -= 3) > -1 && ee.push(239, 191, 189);
              continue;
            } else if (ne + 1 === U) {
              (_ -= 3) > -1 && ee.push(239, 191, 189);
              continue;
            }
            Y = A;
            continue;
          }
          if (A < 56320) {
            (_ -= 3) > -1 && ee.push(239, 191, 189), Y = A;
            continue;
          }
          A = (Y - 55296 << 10 | A - 56320) + 65536;
        } else
          Y && (_ -= 3) > -1 && ee.push(239, 191, 189);
        if (Y = null, A < 128) {
          if ((_ -= 1) < 0)
            break;
          ee.push(A);
        } else if (A < 2048) {
          if ((_ -= 2) < 0)
            break;
          ee.push(
            A >> 6 | 192,
            A & 63 | 128
          );
        } else if (A < 65536) {
          if ((_ -= 3) < 0)
            break;
          ee.push(
            A >> 12 | 224,
            A >> 6 & 63 | 128,
            A & 63 | 128
          );
        } else if (A < 1114112) {
          if ((_ -= 4) < 0)
            break;
          ee.push(
            A >> 18 | 240,
            A >> 12 & 63 | 128,
            A >> 6 & 63 | 128,
            A & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return ee;
    }
    function et(N) {
      const _ = [];
      for (let A = 0; A < N.length; ++A)
        _.push(N.charCodeAt(A) & 255);
      return _;
    }
    function wt(N, _) {
      let A, U, Y;
      const ee = [];
      for (let ne = 0; ne < N.length && !((_ -= 2) < 0); ++ne)
        A = N.charCodeAt(ne), U = A >> 8, Y = A % 256, ee.push(Y), ee.push(U);
      return ee;
    }
    function Ct(N) {
      return j.toByteArray(Dt(N));
    }
    function We(N, _, A, U) {
      let Y;
      for (Y = 0; Y < U && !(Y + A >= _.length || Y >= N.length); ++Y)
        _[Y + A] = N[Y];
      return Y;
    }
    function pt(N, _) {
      return N instanceof _ || N != null && N.constructor != null && N.constructor.name != null && N.constructor.name === _.name;
    }
    function jt(N) {
      return N !== N;
    }
    const nt = function() {
      const N = "0123456789abcdef", _ = new Array(256);
      for (let A = 0; A < 16; ++A) {
        const U = A * 16;
        for (let Y = 0; Y < 16; ++Y)
          _[U + Y] = N[A] + N[Y];
      }
      return _;
    }();
    function xt(N) {
      return typeof BigInt > "u" ? Ht : N;
    }
    function Ht() {
      throw new Error("BigInt not supported");
    }
  })(t10);
  const O = t10.Buffer;
  e10.Blob = t10.Blob, e10.BlobOptions = t10.BlobOptions, e10.Buffer = t10.Buffer, e10.File = t10.File, e10.FileOptions = t10.FileOptions, e10.INSPECT_MAX_BYTES = t10.INSPECT_MAX_BYTES, e10.SlowBuffer = t10.SlowBuffer, e10.TranscodeEncoding = t10.TranscodeEncoding, e10.atob = t10.atob, e10.btoa = t10.btoa, e10.constants = t10.constants, e10.default = O, e10.isAscii = t10.isAscii, e10.isUtf8 = t10.isUtf8, e10.kMaxLength = t10.kMaxLength, e10.kStringMaxLength = t10.kStringMaxLength, e10.resolveObjectURL = t10.resolveObjectURL, e10.transcode = t10.transcode;
})(ja);
var If = Oa(ja);
var pn = {};
var Rd = { exports: {} };
Rd.exports;
(function(e10) {
  (function(t10, r10) {
    function n10(L, h) {
      if (!L)
        throw new Error(h || "Assertion failed");
    }
    function i10(L, h) {
      L.super_ = h;
      var f = function() {
      };
      f.prototype = h.prototype, L.prototype = new f(), L.prototype.constructor = L;
    }
    function o10(L, h, f) {
      if (o10.isBN(L))
        return L;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, L !== null && ((h === "le" || h === "be") && (f = h, h = 10), this._init(L || 0, h || 10, f || "be"));
    }
    typeof t10 == "object" ? t10.exports = o10 : r10.BN = o10, o10.BN = o10, o10.wordSize = 26;
    var s10;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s10 = window.Buffer : s10 = ja.Buffer;
    } catch {
    }
    o10.isBN = function(h) {
      return h instanceof o10 ? true : h !== null && typeof h == "object" && h.constructor.wordSize === o10.wordSize && Array.isArray(h.words);
    }, o10.max = function(h, f) {
      return h.cmp(f) > 0 ? h : f;
    }, o10.min = function(h, f) {
      return h.cmp(f) < 0 ? h : f;
    }, o10.prototype._init = function(h, f, m) {
      if (typeof h == "number")
        return this._initNumber(h, f, m);
      if (typeof h == "object")
        return this._initArray(h, f, m);
      f === "hex" && (f = 16), n10(f === (f | 0) && f >= 2 && f <= 36), h = h.toString().replace(/\s+/g, "");
      var S = 0;
      h[0] === "-" && (S++, this.negative = 1), S < h.length && (f === 16 ? this._parseHex(h, S, m) : (this._parseBase(h, f, S), m === "le" && this._initArray(this.toArray(), f, m)));
    }, o10.prototype._initNumber = function(h, f, m) {
      h < 0 && (this.negative = 1, h = -h), h < 67108864 ? (this.words = [h & 67108863], this.length = 1) : h < 4503599627370496 ? (this.words = [
        h & 67108863,
        h / 67108864 & 67108863
      ], this.length = 2) : (n10(h < 9007199254740992), this.words = [
        h & 67108863,
        h / 67108864 & 67108863,
        1
      ], this.length = 3), m === "le" && this._initArray(this.toArray(), f, m);
    }, o10.prototype._initArray = function(h, f, m) {
      if (n10(typeof h.length == "number"), h.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(h.length / 3), this.words = new Array(this.length);
      for (var S = 0; S < this.length; S++)
        this.words[S] = 0;
      var T, E, I = 0;
      if (m === "be")
        for (S = h.length - 1, T = 0; S >= 0; S -= 3)
          E = h[S] | h[S - 1] << 8 | h[S - 2] << 16, this.words[T] |= E << I & 67108863, this.words[T + 1] = E >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, T++);
      else if (m === "le")
        for (S = 0, T = 0; S < h.length; S += 3)
          E = h[S] | h[S + 1] << 8 | h[S + 2] << 16, this.words[T] |= E << I & 67108863, this.words[T + 1] = E >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, T++);
      return this._strip();
    };
    function a10(L, h) {
      var f = L.charCodeAt(h);
      if (f >= 48 && f <= 57)
        return f - 48;
      if (f >= 65 && f <= 70)
        return f - 55;
      if (f >= 97 && f <= 102)
        return f - 87;
      n10(false, "Invalid character in " + L);
    }
    function c(L, h, f) {
      var m = a10(L, f);
      return f - 1 >= h && (m |= a10(L, f - 1) << 4), m;
    }
    o10.prototype._parseHex = function(h, f, m) {
      this.length = Math.ceil((h.length - f) / 6), this.words = new Array(this.length);
      for (var S = 0; S < this.length; S++)
        this.words[S] = 0;
      var T = 0, E = 0, I;
      if (m === "be")
        for (S = h.length - 1; S >= f; S -= 2)
          I = c(h, f, S) << T, this.words[E] |= I & 67108863, T >= 18 ? (T -= 18, E += 1, this.words[E] |= I >>> 26) : T += 8;
      else {
        var C = h.length - f;
        for (S = C % 2 === 0 ? f + 1 : f; S < h.length; S += 2)
          I = c(h, f, S) << T, this.words[E] |= I & 67108863, T >= 18 ? (T -= 18, E += 1, this.words[E] |= I >>> 26) : T += 8;
      }
      this._strip();
    };
    function l10(L, h, f, m) {
      for (var S = 0, T = 0, E = Math.min(L.length, f), I = h; I < E; I++) {
        var C = L.charCodeAt(I) - 48;
        S *= m, C >= 49 ? T = C - 49 + 10 : C >= 17 ? T = C - 17 + 10 : T = C, n10(C >= 0 && T < m, "Invalid character"), S += T;
      }
      return S;
    }
    o10.prototype._parseBase = function(h, f, m) {
      this.words = [0], this.length = 1;
      for (var S = 0, T = 1; T <= 67108863; T *= f)
        S++;
      S--, T = T / f | 0;
      for (var E = h.length - m, I = E % S, C = Math.min(E, E - I) + m, g = 0, v10 = m; v10 < C; v10 += S)
        g = l10(h, v10, v10 + S, f), this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (I !== 0) {
        var k = 1;
        for (g = l10(h, v10, h.length, f), v10 = 0; v10 < I; v10++)
          k *= f;
        this.imuln(k), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this._strip();
    }, o10.prototype.copy = function(h) {
      h.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        h.words[f] = this.words[f];
      h.length = this.length, h.negative = this.negative, h.red = this.red;
    };
    function u10(L, h) {
      L.words = h.words, L.length = h.length, L.negative = h.negative, L.red = h.red;
    }
    if (o10.prototype._move = function(h) {
      u10(h, this);
    }, o10.prototype.clone = function() {
      var h = new o10(null);
      return this.copy(h), h;
    }, o10.prototype._expand = function(h) {
      for (; this.length < h; )
        this.words[this.length++] = 0;
      return this;
    }, o10.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o10.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        o10.prototype[Symbol.for("nodejs.util.inspect.custom")] = d6;
      } catch {
        o10.prototype.inspect = d6;
      }
    else
      o10.prototype.inspect = d6;
    function d6() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var p = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], y = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], x = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o10.prototype.toString = function(h, f) {
      h = h || 10, f = f | 0 || 1;
      var m;
      if (h === 16 || h === "hex") {
        m = "";
        for (var S = 0, T = 0, E = 0; E < this.length; E++) {
          var I = this.words[E], C = ((I << S | T) & 16777215).toString(16);
          T = I >>> 24 - S & 16777215, S += 2, S >= 26 && (S -= 26, E--), T !== 0 || E !== this.length - 1 ? m = p[6 - C.length] + C + m : m = C + m;
        }
        for (T !== 0 && (m = T.toString(16) + m); m.length % f !== 0; )
          m = "0" + m;
        return this.negative !== 0 && (m = "-" + m), m;
      }
      if (h === (h | 0) && h >= 2 && h <= 36) {
        var g = y[h], v10 = x[h];
        m = "";
        var k = this.clone();
        for (k.negative = 0; !k.isZero(); ) {
          var Q = k.modrn(v10).toString(h);
          k = k.idivn(v10), k.isZero() ? m = Q + m : m = p[g - Q.length] + Q + m;
        }
        for (this.isZero() && (m = "0" + m); m.length % f !== 0; )
          m = "0" + m;
        return this.negative !== 0 && (m = "-" + m), m;
      }
      n10(false, "Base should be between 2 and 36");
    }, o10.prototype.toNumber = function() {
      var h = this.words[0];
      return this.length === 2 ? h += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? h += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n10(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -h : h;
    }, o10.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, s10 && (o10.prototype.toBuffer = function(h, f) {
      return this.toArrayLike(s10, h, f);
    }), o10.prototype.toArray = function(h, f) {
      return this.toArrayLike(Array, h, f);
    };
    var b = function(h, f) {
      return h.allocUnsafe ? h.allocUnsafe(f) : new h(f);
    };
    o10.prototype.toArrayLike = function(h, f, m) {
      this._strip();
      var S = this.byteLength(), T = m || Math.max(1, S);
      n10(S <= T, "byte array longer than desired length"), n10(T > 0, "Requested array length <= 0");
      var E = b(h, T), I = f === "le" ? "LE" : "BE";
      return this["_toArrayLike" + I](E, S), E;
    }, o10.prototype._toArrayLikeLE = function(h, f) {
      for (var m = 0, S = 0, T = 0, E = 0; T < this.length; T++) {
        var I = this.words[T] << E | S;
        h[m++] = I & 255, m < h.length && (h[m++] = I >> 8 & 255), m < h.length && (h[m++] = I >> 16 & 255), E === 6 ? (m < h.length && (h[m++] = I >> 24 & 255), S = 0, E = 0) : (S = I >>> 24, E += 2);
      }
      if (m < h.length)
        for (h[m++] = S; m < h.length; )
          h[m++] = 0;
    }, o10.prototype._toArrayLikeBE = function(h, f) {
      for (var m = h.length - 1, S = 0, T = 0, E = 0; T < this.length; T++) {
        var I = this.words[T] << E | S;
        h[m--] = I & 255, m >= 0 && (h[m--] = I >> 8 & 255), m >= 0 && (h[m--] = I >> 16 & 255), E === 6 ? (m >= 0 && (h[m--] = I >> 24 & 255), S = 0, E = 0) : (S = I >>> 24, E += 2);
      }
      if (m >= 0)
        for (h[m--] = S; m >= 0; )
          h[m--] = 0;
    }, Math.clz32 ? o10.prototype._countBits = function(h) {
      return 32 - Math.clz32(h);
    } : o10.prototype._countBits = function(h) {
      var f = h, m = 0;
      return f >= 4096 && (m += 13, f >>>= 13), f >= 64 && (m += 7, f >>>= 7), f >= 8 && (m += 4, f >>>= 4), f >= 2 && (m += 2, f >>>= 2), m + f;
    }, o10.prototype._zeroBits = function(h) {
      if (h === 0)
        return 26;
      var f = h, m = 0;
      return f & 8191 || (m += 13, f >>>= 13), f & 127 || (m += 7, f >>>= 7), f & 15 || (m += 4, f >>>= 4), f & 3 || (m += 2, f >>>= 2), f & 1 || m++, m;
    }, o10.prototype.bitLength = function() {
      var h = this.words[this.length - 1], f = this._countBits(h);
      return (this.length - 1) * 26 + f;
    };
    function M(L) {
      for (var h = new Array(L.bitLength()), f = 0; f < h.length; f++) {
        var m = f / 26 | 0, S = f % 26;
        h[f] = L.words[m] >>> S & 1;
      }
      return h;
    }
    o10.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var h = 0, f = 0; f < this.length; f++) {
        var m = this._zeroBits(this.words[f]);
        if (h += m, m !== 26)
          break;
      }
      return h;
    }, o10.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o10.prototype.toTwos = function(h) {
      return this.negative !== 0 ? this.abs().inotn(h).iaddn(1) : this.clone();
    }, o10.prototype.fromTwos = function(h) {
      return this.testn(h - 1) ? this.notn(h).iaddn(1).ineg() : this.clone();
    }, o10.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o10.prototype.neg = function() {
      return this.clone().ineg();
    }, o10.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o10.prototype.iuor = function(h) {
      for (; this.length < h.length; )
        this.words[this.length++] = 0;
      for (var f = 0; f < h.length; f++)
        this.words[f] = this.words[f] | h.words[f];
      return this._strip();
    }, o10.prototype.ior = function(h) {
      return n10((this.negative | h.negative) === 0), this.iuor(h);
    }, o10.prototype.or = function(h) {
      return this.length > h.length ? this.clone().ior(h) : h.clone().ior(this);
    }, o10.prototype.uor = function(h) {
      return this.length > h.length ? this.clone().iuor(h) : h.clone().iuor(this);
    }, o10.prototype.iuand = function(h) {
      var f;
      this.length > h.length ? f = h : f = this;
      for (var m = 0; m < f.length; m++)
        this.words[m] = this.words[m] & h.words[m];
      return this.length = f.length, this._strip();
    }, o10.prototype.iand = function(h) {
      return n10((this.negative | h.negative) === 0), this.iuand(h);
    }, o10.prototype.and = function(h) {
      return this.length > h.length ? this.clone().iand(h) : h.clone().iand(this);
    }, o10.prototype.uand = function(h) {
      return this.length > h.length ? this.clone().iuand(h) : h.clone().iuand(this);
    }, o10.prototype.iuxor = function(h) {
      var f, m;
      this.length > h.length ? (f = this, m = h) : (f = h, m = this);
      for (var S = 0; S < m.length; S++)
        this.words[S] = f.words[S] ^ m.words[S];
      if (this !== f)
        for (; S < f.length; S++)
          this.words[S] = f.words[S];
      return this.length = f.length, this._strip();
    }, o10.prototype.ixor = function(h) {
      return n10((this.negative | h.negative) === 0), this.iuxor(h);
    }, o10.prototype.xor = function(h) {
      return this.length > h.length ? this.clone().ixor(h) : h.clone().ixor(this);
    }, o10.prototype.uxor = function(h) {
      return this.length > h.length ? this.clone().iuxor(h) : h.clone().iuxor(this);
    }, o10.prototype.inotn = function(h) {
      n10(typeof h == "number" && h >= 0);
      var f = Math.ceil(h / 26) | 0, m = h % 26;
      this._expand(f), m > 0 && f--;
      for (var S = 0; S < f; S++)
        this.words[S] = ~this.words[S] & 67108863;
      return m > 0 && (this.words[S] = ~this.words[S] & 67108863 >> 26 - m), this._strip();
    }, o10.prototype.notn = function(h) {
      return this.clone().inotn(h);
    }, o10.prototype.setn = function(h, f) {
      n10(typeof h == "number" && h >= 0);
      var m = h / 26 | 0, S = h % 26;
      return this._expand(m + 1), f ? this.words[m] = this.words[m] | 1 << S : this.words[m] = this.words[m] & ~(1 << S), this._strip();
    }, o10.prototype.iadd = function(h) {
      var f;
      if (this.negative !== 0 && h.negative === 0)
        return this.negative = 0, f = this.isub(h), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && h.negative !== 0)
        return h.negative = 0, f = this.isub(h), h.negative = 1, f._normSign();
      var m, S;
      this.length > h.length ? (m = this, S = h) : (m = h, S = this);
      for (var T = 0, E = 0; E < S.length; E++)
        f = (m.words[E] | 0) + (S.words[E] | 0) + T, this.words[E] = f & 67108863, T = f >>> 26;
      for (; T !== 0 && E < m.length; E++)
        f = (m.words[E] | 0) + T, this.words[E] = f & 67108863, T = f >>> 26;
      if (this.length = m.length, T !== 0)
        this.words[this.length] = T, this.length++;
      else if (m !== this)
        for (; E < m.length; E++)
          this.words[E] = m.words[E];
      return this;
    }, o10.prototype.add = function(h) {
      var f;
      return h.negative !== 0 && this.negative === 0 ? (h.negative = 0, f = this.sub(h), h.negative ^= 1, f) : h.negative === 0 && this.negative !== 0 ? (this.negative = 0, f = h.sub(this), this.negative = 1, f) : this.length > h.length ? this.clone().iadd(h) : h.clone().iadd(this);
    }, o10.prototype.isub = function(h) {
      if (h.negative !== 0) {
        h.negative = 0;
        var f = this.iadd(h);
        return h.negative = 1, f._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(h), this.negative = 1, this._normSign();
      var m = this.cmp(h);
      if (m === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var S, T;
      m > 0 ? (S = this, T = h) : (S = h, T = this);
      for (var E = 0, I = 0; I < T.length; I++)
        f = (S.words[I] | 0) - (T.words[I] | 0) + E, E = f >> 26, this.words[I] = f & 67108863;
      for (; E !== 0 && I < S.length; I++)
        f = (S.words[I] | 0) + E, E = f >> 26, this.words[I] = f & 67108863;
      if (E === 0 && I < S.length && S !== this)
        for (; I < S.length; I++)
          this.words[I] = S.words[I];
      return this.length = Math.max(this.length, I), S !== this && (this.negative = 1), this._strip();
    }, o10.prototype.sub = function(h) {
      return this.clone().isub(h);
    };
    function O(L, h, f) {
      f.negative = h.negative ^ L.negative;
      var m = L.length + h.length | 0;
      f.length = m, m = m - 1 | 0;
      var S = L.words[0] | 0, T = h.words[0] | 0, E = S * T, I = E & 67108863, C = E / 67108864 | 0;
      f.words[0] = I;
      for (var g = 1; g < m; g++) {
        for (var v10 = C >>> 26, k = C & 67108863, Q = Math.min(g, h.length - 1), Z = Math.max(0, g - L.length + 1); Z <= Q; Z++) {
          var ae = g - Z | 0;
          S = L.words[ae] | 0, T = h.words[Z] | 0, E = S * T + k, v10 += E / 67108864 | 0, k = E & 67108863;
        }
        f.words[g] = k | 0, C = v10 | 0;
      }
      return C !== 0 ? f.words[g] = C | 0 : f.length--, f._strip();
    }
    var P = function(h, f, m) {
      var S = h.words, T = f.words, E = m.words, I = 0, C, g, v10, k = S[0] | 0, Q = k & 8191, Z = k >>> 13, ae = S[1] | 0, ve = ae & 8191, we = ae >>> 13, he = S[2] | 0, De = he & 8191, Te = he >>> 13, Xe = S[3] | 0, ft = Xe & 8191, je = Xe >>> 13, ht = S[4] | 0, ye = ht & 8191, de = ht >>> 13, Ee = S[5] | 0, $e = Ee & 8191, Ne = Ee >>> 13, Ce = S[6] | 0, Ae = Ce & 8191, Be = Ce >>> 13, lt = S[7] | 0, ut = lt & 8191, Ve = lt >>> 13, kt = S[8] | 0, _t = kt & 8191, Ge = kt >>> 13, Ot = S[9] | 0, $t = Ot & 8191, Qe = Ot >>> 13, Et = T[0] | 0, Rt = Et & 8191, rt = Et >>> 13, Dt = T[1] | 0, Nt = Dt & 8191, et = Dt >>> 13, wt = T[2] | 0, Ct = wt & 8191, We = wt >>> 13, pt = T[3] | 0, jt = pt & 8191, nt = pt >>> 13, xt = T[4] | 0, Ht = xt & 8191, N = xt >>> 13, _ = T[5] | 0, A = _ & 8191, U = _ >>> 13, Y = T[6] | 0, ee = Y & 8191, ne = Y >>> 13, ke = T[7] | 0, Je = ke & 8191, Pe = ke >>> 13, V = T[8] | 0, se = V & 8191, ue = V >>> 13, Oe = T[9] | 0, ze = Oe & 8191, Re = Oe >>> 13;
      m.negative = h.negative ^ f.negative, m.length = 19, C = Math.imul(Q, Rt), g = Math.imul(Q, rt), g = g + Math.imul(Z, Rt) | 0, v10 = Math.imul(Z, rt);
      var Ue = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, C = Math.imul(ve, Rt), g = Math.imul(ve, rt), g = g + Math.imul(we, Rt) | 0, v10 = Math.imul(we, rt), C = C + Math.imul(Q, Nt) | 0, g = g + Math.imul(Q, et) | 0, g = g + Math.imul(Z, Nt) | 0, v10 = v10 + Math.imul(Z, et) | 0;
      var it = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, C = Math.imul(De, Rt), g = Math.imul(De, rt), g = g + Math.imul(Te, Rt) | 0, v10 = Math.imul(Te, rt), C = C + Math.imul(ve, Nt) | 0, g = g + Math.imul(ve, et) | 0, g = g + Math.imul(we, Nt) | 0, v10 = v10 + Math.imul(we, et) | 0, C = C + Math.imul(Q, Ct) | 0, g = g + Math.imul(Q, We) | 0, g = g + Math.imul(Z, Ct) | 0, v10 = v10 + Math.imul(Z, We) | 0;
      var Qt = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, C = Math.imul(ft, Rt), g = Math.imul(ft, rt), g = g + Math.imul(je, Rt) | 0, v10 = Math.imul(je, rt), C = C + Math.imul(De, Nt) | 0, g = g + Math.imul(De, et) | 0, g = g + Math.imul(Te, Nt) | 0, v10 = v10 + Math.imul(Te, et) | 0, C = C + Math.imul(ve, Ct) | 0, g = g + Math.imul(ve, We) | 0, g = g + Math.imul(we, Ct) | 0, v10 = v10 + Math.imul(we, We) | 0, C = C + Math.imul(Q, jt) | 0, g = g + Math.imul(Q, nt) | 0, g = g + Math.imul(Z, jt) | 0, v10 = v10 + Math.imul(Z, nt) | 0;
      var Lt = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, C = Math.imul(ye, Rt), g = Math.imul(ye, rt), g = g + Math.imul(de, Rt) | 0, v10 = Math.imul(de, rt), C = C + Math.imul(ft, Nt) | 0, g = g + Math.imul(ft, et) | 0, g = g + Math.imul(je, Nt) | 0, v10 = v10 + Math.imul(je, et) | 0, C = C + Math.imul(De, Ct) | 0, g = g + Math.imul(De, We) | 0, g = g + Math.imul(Te, Ct) | 0, v10 = v10 + Math.imul(Te, We) | 0, C = C + Math.imul(ve, jt) | 0, g = g + Math.imul(ve, nt) | 0, g = g + Math.imul(we, jt) | 0, v10 = v10 + Math.imul(we, nt) | 0, C = C + Math.imul(Q, Ht) | 0, g = g + Math.imul(Q, N) | 0, g = g + Math.imul(Z, Ht) | 0, v10 = v10 + Math.imul(Z, N) | 0;
      var Vt = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, C = Math.imul($e, Rt), g = Math.imul($e, rt), g = g + Math.imul(Ne, Rt) | 0, v10 = Math.imul(Ne, rt), C = C + Math.imul(ye, Nt) | 0, g = g + Math.imul(ye, et) | 0, g = g + Math.imul(de, Nt) | 0, v10 = v10 + Math.imul(de, et) | 0, C = C + Math.imul(ft, Ct) | 0, g = g + Math.imul(ft, We) | 0, g = g + Math.imul(je, Ct) | 0, v10 = v10 + Math.imul(je, We) | 0, C = C + Math.imul(De, jt) | 0, g = g + Math.imul(De, nt) | 0, g = g + Math.imul(Te, jt) | 0, v10 = v10 + Math.imul(Te, nt) | 0, C = C + Math.imul(ve, Ht) | 0, g = g + Math.imul(ve, N) | 0, g = g + Math.imul(we, Ht) | 0, v10 = v10 + Math.imul(we, N) | 0, C = C + Math.imul(Q, A) | 0, g = g + Math.imul(Q, U) | 0, g = g + Math.imul(Z, A) | 0, v10 = v10 + Math.imul(Z, U) | 0;
      var cr = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, C = Math.imul(Ae, Rt), g = Math.imul(Ae, rt), g = g + Math.imul(Be, Rt) | 0, v10 = Math.imul(Be, rt), C = C + Math.imul($e, Nt) | 0, g = g + Math.imul($e, et) | 0, g = g + Math.imul(Ne, Nt) | 0, v10 = v10 + Math.imul(Ne, et) | 0, C = C + Math.imul(ye, Ct) | 0, g = g + Math.imul(ye, We) | 0, g = g + Math.imul(de, Ct) | 0, v10 = v10 + Math.imul(de, We) | 0, C = C + Math.imul(ft, jt) | 0, g = g + Math.imul(ft, nt) | 0, g = g + Math.imul(je, jt) | 0, v10 = v10 + Math.imul(je, nt) | 0, C = C + Math.imul(De, Ht) | 0, g = g + Math.imul(De, N) | 0, g = g + Math.imul(Te, Ht) | 0, v10 = v10 + Math.imul(Te, N) | 0, C = C + Math.imul(ve, A) | 0, g = g + Math.imul(ve, U) | 0, g = g + Math.imul(we, A) | 0, v10 = v10 + Math.imul(we, U) | 0, C = C + Math.imul(Q, ee) | 0, g = g + Math.imul(Q, ne) | 0, g = g + Math.imul(Z, ee) | 0, v10 = v10 + Math.imul(Z, ne) | 0;
      var Ar = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Ar >>> 26) | 0, Ar &= 67108863, C = Math.imul(ut, Rt), g = Math.imul(ut, rt), g = g + Math.imul(Ve, Rt) | 0, v10 = Math.imul(Ve, rt), C = C + Math.imul(Ae, Nt) | 0, g = g + Math.imul(Ae, et) | 0, g = g + Math.imul(Be, Nt) | 0, v10 = v10 + Math.imul(Be, et) | 0, C = C + Math.imul($e, Ct) | 0, g = g + Math.imul($e, We) | 0, g = g + Math.imul(Ne, Ct) | 0, v10 = v10 + Math.imul(Ne, We) | 0, C = C + Math.imul(ye, jt) | 0, g = g + Math.imul(ye, nt) | 0, g = g + Math.imul(de, jt) | 0, v10 = v10 + Math.imul(de, nt) | 0, C = C + Math.imul(ft, Ht) | 0, g = g + Math.imul(ft, N) | 0, g = g + Math.imul(je, Ht) | 0, v10 = v10 + Math.imul(je, N) | 0, C = C + Math.imul(De, A) | 0, g = g + Math.imul(De, U) | 0, g = g + Math.imul(Te, A) | 0, v10 = v10 + Math.imul(Te, U) | 0, C = C + Math.imul(ve, ee) | 0, g = g + Math.imul(ve, ne) | 0, g = g + Math.imul(we, ee) | 0, v10 = v10 + Math.imul(we, ne) | 0, C = C + Math.imul(Q, Je) | 0, g = g + Math.imul(Q, Pe) | 0, g = g + Math.imul(Z, Je) | 0, v10 = v10 + Math.imul(Z, Pe) | 0;
      var dr = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, C = Math.imul(_t, Rt), g = Math.imul(_t, rt), g = g + Math.imul(Ge, Rt) | 0, v10 = Math.imul(Ge, rt), C = C + Math.imul(ut, Nt) | 0, g = g + Math.imul(ut, et) | 0, g = g + Math.imul(Ve, Nt) | 0, v10 = v10 + Math.imul(Ve, et) | 0, C = C + Math.imul(Ae, Ct) | 0, g = g + Math.imul(Ae, We) | 0, g = g + Math.imul(Be, Ct) | 0, v10 = v10 + Math.imul(Be, We) | 0, C = C + Math.imul($e, jt) | 0, g = g + Math.imul($e, nt) | 0, g = g + Math.imul(Ne, jt) | 0, v10 = v10 + Math.imul(Ne, nt) | 0, C = C + Math.imul(ye, Ht) | 0, g = g + Math.imul(ye, N) | 0, g = g + Math.imul(de, Ht) | 0, v10 = v10 + Math.imul(de, N) | 0, C = C + Math.imul(ft, A) | 0, g = g + Math.imul(ft, U) | 0, g = g + Math.imul(je, A) | 0, v10 = v10 + Math.imul(je, U) | 0, C = C + Math.imul(De, ee) | 0, g = g + Math.imul(De, ne) | 0, g = g + Math.imul(Te, ee) | 0, v10 = v10 + Math.imul(Te, ne) | 0, C = C + Math.imul(ve, Je) | 0, g = g + Math.imul(ve, Pe) | 0, g = g + Math.imul(we, Je) | 0, v10 = v10 + Math.imul(we, Pe) | 0, C = C + Math.imul(Q, se) | 0, g = g + Math.imul(Q, ue) | 0, g = g + Math.imul(Z, se) | 0, v10 = v10 + Math.imul(Z, ue) | 0;
      var er = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, C = Math.imul($t, Rt), g = Math.imul($t, rt), g = g + Math.imul(Qe, Rt) | 0, v10 = Math.imul(Qe, rt), C = C + Math.imul(_t, Nt) | 0, g = g + Math.imul(_t, et) | 0, g = g + Math.imul(Ge, Nt) | 0, v10 = v10 + Math.imul(Ge, et) | 0, C = C + Math.imul(ut, Ct) | 0, g = g + Math.imul(ut, We) | 0, g = g + Math.imul(Ve, Ct) | 0, v10 = v10 + Math.imul(Ve, We) | 0, C = C + Math.imul(Ae, jt) | 0, g = g + Math.imul(Ae, nt) | 0, g = g + Math.imul(Be, jt) | 0, v10 = v10 + Math.imul(Be, nt) | 0, C = C + Math.imul($e, Ht) | 0, g = g + Math.imul($e, N) | 0, g = g + Math.imul(Ne, Ht) | 0, v10 = v10 + Math.imul(Ne, N) | 0, C = C + Math.imul(ye, A) | 0, g = g + Math.imul(ye, U) | 0, g = g + Math.imul(de, A) | 0, v10 = v10 + Math.imul(de, U) | 0, C = C + Math.imul(ft, ee) | 0, g = g + Math.imul(ft, ne) | 0, g = g + Math.imul(je, ee) | 0, v10 = v10 + Math.imul(je, ne) | 0, C = C + Math.imul(De, Je) | 0, g = g + Math.imul(De, Pe) | 0, g = g + Math.imul(Te, Je) | 0, v10 = v10 + Math.imul(Te, Pe) | 0, C = C + Math.imul(ve, se) | 0, g = g + Math.imul(ve, ue) | 0, g = g + Math.imul(we, se) | 0, v10 = v10 + Math.imul(we, ue) | 0, C = C + Math.imul(Q, ze) | 0, g = g + Math.imul(Q, Re) | 0, g = g + Math.imul(Z, ze) | 0, v10 = v10 + Math.imul(Z, Re) | 0;
      var _r = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, C = Math.imul($t, Nt), g = Math.imul($t, et), g = g + Math.imul(Qe, Nt) | 0, v10 = Math.imul(Qe, et), C = C + Math.imul(_t, Ct) | 0, g = g + Math.imul(_t, We) | 0, g = g + Math.imul(Ge, Ct) | 0, v10 = v10 + Math.imul(Ge, We) | 0, C = C + Math.imul(ut, jt) | 0, g = g + Math.imul(ut, nt) | 0, g = g + Math.imul(Ve, jt) | 0, v10 = v10 + Math.imul(Ve, nt) | 0, C = C + Math.imul(Ae, Ht) | 0, g = g + Math.imul(Ae, N) | 0, g = g + Math.imul(Be, Ht) | 0, v10 = v10 + Math.imul(Be, N) | 0, C = C + Math.imul($e, A) | 0, g = g + Math.imul($e, U) | 0, g = g + Math.imul(Ne, A) | 0, v10 = v10 + Math.imul(Ne, U) | 0, C = C + Math.imul(ye, ee) | 0, g = g + Math.imul(ye, ne) | 0, g = g + Math.imul(de, ee) | 0, v10 = v10 + Math.imul(de, ne) | 0, C = C + Math.imul(ft, Je) | 0, g = g + Math.imul(ft, Pe) | 0, g = g + Math.imul(je, Je) | 0, v10 = v10 + Math.imul(je, Pe) | 0, C = C + Math.imul(De, se) | 0, g = g + Math.imul(De, ue) | 0, g = g + Math.imul(Te, se) | 0, v10 = v10 + Math.imul(Te, ue) | 0, C = C + Math.imul(ve, ze) | 0, g = g + Math.imul(ve, Re) | 0, g = g + Math.imul(we, ze) | 0, v10 = v10 + Math.imul(we, Re) | 0;
      var wn = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (wn >>> 26) | 0, wn &= 67108863, C = Math.imul($t, Ct), g = Math.imul($t, We), g = g + Math.imul(Qe, Ct) | 0, v10 = Math.imul(Qe, We), C = C + Math.imul(_t, jt) | 0, g = g + Math.imul(_t, nt) | 0, g = g + Math.imul(Ge, jt) | 0, v10 = v10 + Math.imul(Ge, nt) | 0, C = C + Math.imul(ut, Ht) | 0, g = g + Math.imul(ut, N) | 0, g = g + Math.imul(Ve, Ht) | 0, v10 = v10 + Math.imul(Ve, N) | 0, C = C + Math.imul(Ae, A) | 0, g = g + Math.imul(Ae, U) | 0, g = g + Math.imul(Be, A) | 0, v10 = v10 + Math.imul(Be, U) | 0, C = C + Math.imul($e, ee) | 0, g = g + Math.imul($e, ne) | 0, g = g + Math.imul(Ne, ee) | 0, v10 = v10 + Math.imul(Ne, ne) | 0, C = C + Math.imul(ye, Je) | 0, g = g + Math.imul(ye, Pe) | 0, g = g + Math.imul(de, Je) | 0, v10 = v10 + Math.imul(de, Pe) | 0, C = C + Math.imul(ft, se) | 0, g = g + Math.imul(ft, ue) | 0, g = g + Math.imul(je, se) | 0, v10 = v10 + Math.imul(je, ue) | 0, C = C + Math.imul(De, ze) | 0, g = g + Math.imul(De, Re) | 0, g = g + Math.imul(Te, ze) | 0, v10 = v10 + Math.imul(Te, Re) | 0;
      var Wr = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, C = Math.imul($t, jt), g = Math.imul($t, nt), g = g + Math.imul(Qe, jt) | 0, v10 = Math.imul(Qe, nt), C = C + Math.imul(_t, Ht) | 0, g = g + Math.imul(_t, N) | 0, g = g + Math.imul(Ge, Ht) | 0, v10 = v10 + Math.imul(Ge, N) | 0, C = C + Math.imul(ut, A) | 0, g = g + Math.imul(ut, U) | 0, g = g + Math.imul(Ve, A) | 0, v10 = v10 + Math.imul(Ve, U) | 0, C = C + Math.imul(Ae, ee) | 0, g = g + Math.imul(Ae, ne) | 0, g = g + Math.imul(Be, ee) | 0, v10 = v10 + Math.imul(Be, ne) | 0, C = C + Math.imul($e, Je) | 0, g = g + Math.imul($e, Pe) | 0, g = g + Math.imul(Ne, Je) | 0, v10 = v10 + Math.imul(Ne, Pe) | 0, C = C + Math.imul(ye, se) | 0, g = g + Math.imul(ye, ue) | 0, g = g + Math.imul(de, se) | 0, v10 = v10 + Math.imul(de, ue) | 0, C = C + Math.imul(ft, ze) | 0, g = g + Math.imul(ft, Re) | 0, g = g + Math.imul(je, ze) | 0, v10 = v10 + Math.imul(je, Re) | 0;
      var xn = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, C = Math.imul($t, Ht), g = Math.imul($t, N), g = g + Math.imul(Qe, Ht) | 0, v10 = Math.imul(Qe, N), C = C + Math.imul(_t, A) | 0, g = g + Math.imul(_t, U) | 0, g = g + Math.imul(Ge, A) | 0, v10 = v10 + Math.imul(Ge, U) | 0, C = C + Math.imul(ut, ee) | 0, g = g + Math.imul(ut, ne) | 0, g = g + Math.imul(Ve, ee) | 0, v10 = v10 + Math.imul(Ve, ne) | 0, C = C + Math.imul(Ae, Je) | 0, g = g + Math.imul(Ae, Pe) | 0, g = g + Math.imul(Be, Je) | 0, v10 = v10 + Math.imul(Be, Pe) | 0, C = C + Math.imul($e, se) | 0, g = g + Math.imul($e, ue) | 0, g = g + Math.imul(Ne, se) | 0, v10 = v10 + Math.imul(Ne, ue) | 0, C = C + Math.imul(ye, ze) | 0, g = g + Math.imul(ye, Re) | 0, g = g + Math.imul(de, ze) | 0, v10 = v10 + Math.imul(de, Re) | 0;
      var ci = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, C = Math.imul($t, A), g = Math.imul($t, U), g = g + Math.imul(Qe, A) | 0, v10 = Math.imul(Qe, U), C = C + Math.imul(_t, ee) | 0, g = g + Math.imul(_t, ne) | 0, g = g + Math.imul(Ge, ee) | 0, v10 = v10 + Math.imul(Ge, ne) | 0, C = C + Math.imul(ut, Je) | 0, g = g + Math.imul(ut, Pe) | 0, g = g + Math.imul(Ve, Je) | 0, v10 = v10 + Math.imul(Ve, Pe) | 0, C = C + Math.imul(Ae, se) | 0, g = g + Math.imul(Ae, ue) | 0, g = g + Math.imul(Be, se) | 0, v10 = v10 + Math.imul(Be, ue) | 0, C = C + Math.imul($e, ze) | 0, g = g + Math.imul($e, Re) | 0, g = g + Math.imul(Ne, ze) | 0, v10 = v10 + Math.imul(Ne, Re) | 0;
      var li = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, C = Math.imul($t, ee), g = Math.imul($t, ne), g = g + Math.imul(Qe, ee) | 0, v10 = Math.imul(Qe, ne), C = C + Math.imul(_t, Je) | 0, g = g + Math.imul(_t, Pe) | 0, g = g + Math.imul(Ge, Je) | 0, v10 = v10 + Math.imul(Ge, Pe) | 0, C = C + Math.imul(ut, se) | 0, g = g + Math.imul(ut, ue) | 0, g = g + Math.imul(Ve, se) | 0, v10 = v10 + Math.imul(Ve, ue) | 0, C = C + Math.imul(Ae, ze) | 0, g = g + Math.imul(Ae, Re) | 0, g = g + Math.imul(Be, ze) | 0, v10 = v10 + Math.imul(Be, Re) | 0;
      var Sn = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, C = Math.imul($t, Je), g = Math.imul($t, Pe), g = g + Math.imul(Qe, Je) | 0, v10 = Math.imul(Qe, Pe), C = C + Math.imul(_t, se) | 0, g = g + Math.imul(_t, ue) | 0, g = g + Math.imul(Ge, se) | 0, v10 = v10 + Math.imul(Ge, ue) | 0, C = C + Math.imul(ut, ze) | 0, g = g + Math.imul(ut, Re) | 0, g = g + Math.imul(Ve, ze) | 0, v10 = v10 + Math.imul(Ve, Re) | 0;
      var ui = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, C = Math.imul($t, se), g = Math.imul($t, ue), g = g + Math.imul(Qe, se) | 0, v10 = Math.imul(Qe, ue), C = C + Math.imul(_t, ze) | 0, g = g + Math.imul(_t, Re) | 0, g = g + Math.imul(Ge, ze) | 0, v10 = v10 + Math.imul(Ge, Re) | 0;
      var fi = (I + C | 0) + ((g & 8191) << 13) | 0;
      I = (v10 + (g >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, C = Math.imul($t, ze), g = Math.imul($t, Re), g = g + Math.imul(Qe, ze) | 0, v10 = Math.imul(Qe, Re);
      var D = (I + C | 0) + ((g & 8191) << 13) | 0;
      return I = (v10 + (g >>> 13) | 0) + (D >>> 26) | 0, D &= 67108863, E[0] = Ue, E[1] = it, E[2] = Qt, E[3] = Lt, E[4] = Vt, E[5] = cr, E[6] = Ar, E[7] = dr, E[8] = er, E[9] = _r, E[10] = wn, E[11] = Wr, E[12] = xn, E[13] = ci, E[14] = li, E[15] = Sn, E[16] = ui, E[17] = fi, E[18] = D, I !== 0 && (E[19] = I, m.length++), m;
    };
    Math.imul || (P = O);
    function j(L, h, f) {
      f.negative = h.negative ^ L.negative, f.length = L.length + h.length;
      for (var m = 0, S = 0, T = 0; T < f.length - 1; T++) {
        var E = S;
        S = 0;
        for (var I = m & 67108863, C = Math.min(T, h.length - 1), g = Math.max(0, T - L.length + 1); g <= C; g++) {
          var v10 = T - g, k = L.words[v10] | 0, Q = h.words[g] | 0, Z = k * Q, ae = Z & 67108863;
          E = E + (Z / 67108864 | 0) | 0, ae = ae + I | 0, I = ae & 67108863, E = E + (ae >>> 26) | 0, S += E >>> 26, E &= 67108863;
        }
        f.words[T] = I, m = E, E = S;
      }
      return m !== 0 ? f.words[T] = m : f.length--, f._strip();
    }
    function F(L, h, f) {
      return j(L, h, f);
    }
    o10.prototype.mulTo = function(h, f) {
      var m, S = this.length + h.length;
      return this.length === 10 && h.length === 10 ? m = P(this, h, f) : S < 63 ? m = O(this, h, f) : S < 1024 ? m = j(this, h, f) : m = F(this, h, f), m;
    }, o10.prototype.mul = function(h) {
      var f = new o10(null);
      return f.words = new Array(this.length + h.length), this.mulTo(h, f);
    }, o10.prototype.mulf = function(h) {
      var f = new o10(null);
      return f.words = new Array(this.length + h.length), F(this, h, f);
    }, o10.prototype.imul = function(h) {
      return this.clone().mulTo(h, this);
    }, o10.prototype.imuln = function(h) {
      var f = h < 0;
      f && (h = -h), n10(typeof h == "number"), n10(h < 67108864);
      for (var m = 0, S = 0; S < this.length; S++) {
        var T = (this.words[S] | 0) * h, E = (T & 67108863) + (m & 67108863);
        m >>= 26, m += T / 67108864 | 0, m += E >>> 26, this.words[S] = E & 67108863;
      }
      return m !== 0 && (this.words[S] = m, this.length++), f ? this.ineg() : this;
    }, o10.prototype.muln = function(h) {
      return this.clone().imuln(h);
    }, o10.prototype.sqr = function() {
      return this.mul(this);
    }, o10.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o10.prototype.pow = function(h) {
      var f = M(h);
      if (f.length === 0)
        return new o10(1);
      for (var m = this, S = 0; S < f.length && f[S] === 0; S++, m = m.sqr())
        ;
      if (++S < f.length)
        for (var T = m.sqr(); S < f.length; S++, T = T.sqr())
          f[S] !== 0 && (m = m.mul(T));
      return m;
    }, o10.prototype.iushln = function(h) {
      n10(typeof h == "number" && h >= 0);
      var f = h % 26, m = (h - f) / 26, S = 67108863 >>> 26 - f << 26 - f, T;
      if (f !== 0) {
        var E = 0;
        for (T = 0; T < this.length; T++) {
          var I = this.words[T] & S, C = (this.words[T] | 0) - I << f;
          this.words[T] = C | E, E = I >>> 26 - f;
        }
        E && (this.words[T] = E, this.length++);
      }
      if (m !== 0) {
        for (T = this.length - 1; T >= 0; T--)
          this.words[T + m] = this.words[T];
        for (T = 0; T < m; T++)
          this.words[T] = 0;
        this.length += m;
      }
      return this._strip();
    }, o10.prototype.ishln = function(h) {
      return n10(this.negative === 0), this.iushln(h);
    }, o10.prototype.iushrn = function(h, f, m) {
      n10(typeof h == "number" && h >= 0);
      var S;
      f ? S = (f - f % 26) / 26 : S = 0;
      var T = h % 26, E = Math.min((h - T) / 26, this.length), I = 67108863 ^ 67108863 >>> T << T, C = m;
      if (S -= E, S = Math.max(0, S), C) {
        for (var g = 0; g < E; g++)
          C.words[g] = this.words[g];
        C.length = E;
      }
      if (E !== 0)
        if (this.length > E)
          for (this.length -= E, g = 0; g < this.length; g++)
            this.words[g] = this.words[g + E];
        else
          this.words[0] = 0, this.length = 1;
      var v10 = 0;
      for (g = this.length - 1; g >= 0 && (v10 !== 0 || g >= S); g--) {
        var k = this.words[g] | 0;
        this.words[g] = v10 << 26 - T | k >>> T, v10 = k & I;
      }
      return C && v10 !== 0 && (C.words[C.length++] = v10), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o10.prototype.ishrn = function(h, f, m) {
      return n10(this.negative === 0), this.iushrn(h, f, m);
    }, o10.prototype.shln = function(h) {
      return this.clone().ishln(h);
    }, o10.prototype.ushln = function(h) {
      return this.clone().iushln(h);
    }, o10.prototype.shrn = function(h) {
      return this.clone().ishrn(h);
    }, o10.prototype.ushrn = function(h) {
      return this.clone().iushrn(h);
    }, o10.prototype.testn = function(h) {
      n10(typeof h == "number" && h >= 0);
      var f = h % 26, m = (h - f) / 26, S = 1 << f;
      if (this.length <= m)
        return false;
      var T = this.words[m];
      return !!(T & S);
    }, o10.prototype.imaskn = function(h) {
      n10(typeof h == "number" && h >= 0);
      var f = h % 26, m = (h - f) / 26;
      if (n10(this.negative === 0, "imaskn works only with positive numbers"), this.length <= m)
        return this;
      if (f !== 0 && m++, this.length = Math.min(m, this.length), f !== 0) {
        var S = 67108863 ^ 67108863 >>> f << f;
        this.words[this.length - 1] &= S;
      }
      return this._strip();
    }, o10.prototype.maskn = function(h) {
      return this.clone().imaskn(h);
    }, o10.prototype.iaddn = function(h) {
      return n10(typeof h == "number"), n10(h < 67108864), h < 0 ? this.isubn(-h) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= h ? (this.words[0] = h - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(h), this.negative = 1, this) : this._iaddn(h);
    }, o10.prototype._iaddn = function(h) {
      this.words[0] += h;
      for (var f = 0; f < this.length && this.words[f] >= 67108864; f++)
        this.words[f] -= 67108864, f === this.length - 1 ? this.words[f + 1] = 1 : this.words[f + 1]++;
      return this.length = Math.max(this.length, f + 1), this;
    }, o10.prototype.isubn = function(h) {
      if (n10(typeof h == "number"), n10(h < 67108864), h < 0)
        return this.iaddn(-h);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(h), this.negative = 1, this;
      if (this.words[0] -= h, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var f = 0; f < this.length && this.words[f] < 0; f++)
          this.words[f] += 67108864, this.words[f + 1] -= 1;
      return this._strip();
    }, o10.prototype.addn = function(h) {
      return this.clone().iaddn(h);
    }, o10.prototype.subn = function(h) {
      return this.clone().isubn(h);
    }, o10.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o10.prototype.abs = function() {
      return this.clone().iabs();
    }, o10.prototype._ishlnsubmul = function(h, f, m) {
      var S = h.length + m, T;
      this._expand(S);
      var E, I = 0;
      for (T = 0; T < h.length; T++) {
        E = (this.words[T + m] | 0) + I;
        var C = (h.words[T] | 0) * f;
        E -= C & 67108863, I = (E >> 26) - (C / 67108864 | 0), this.words[T + m] = E & 67108863;
      }
      for (; T < this.length - m; T++)
        E = (this.words[T + m] | 0) + I, I = E >> 26, this.words[T + m] = E & 67108863;
      if (I === 0)
        return this._strip();
      for (n10(I === -1), I = 0, T = 0; T < this.length; T++)
        E = -(this.words[T] | 0) + I, I = E >> 26, this.words[T] = E & 67108863;
      return this.negative = 1, this._strip();
    }, o10.prototype._wordDiv = function(h, f) {
      var m = this.length - h.length, S = this.clone(), T = h, E = T.words[T.length - 1] | 0, I = this._countBits(E);
      m = 26 - I, m !== 0 && (T = T.ushln(m), S.iushln(m), E = T.words[T.length - 1] | 0);
      var C = S.length - T.length, g;
      if (f !== "mod") {
        g = new o10(null), g.length = C + 1, g.words = new Array(g.length);
        for (var v10 = 0; v10 < g.length; v10++)
          g.words[v10] = 0;
      }
      var k = S.clone()._ishlnsubmul(T, 1, C);
      k.negative === 0 && (S = k, g && (g.words[C] = 1));
      for (var Q = C - 1; Q >= 0; Q--) {
        var Z = (S.words[T.length + Q] | 0) * 67108864 + (S.words[T.length + Q - 1] | 0);
        for (Z = Math.min(Z / E | 0, 67108863), S._ishlnsubmul(T, Z, Q); S.negative !== 0; )
          Z--, S.negative = 0, S._ishlnsubmul(T, 1, Q), S.isZero() || (S.negative ^= 1);
        g && (g.words[Q] = Z);
      }
      return g && g._strip(), S._strip(), f !== "div" && m !== 0 && S.iushrn(m), {
        div: g || null,
        mod: S
      };
    }, o10.prototype.divmod = function(h, f, m) {
      if (n10(!h.isZero()), this.isZero())
        return {
          div: new o10(0),
          mod: new o10(0)
        };
      var S, T, E;
      return this.negative !== 0 && h.negative === 0 ? (E = this.neg().divmod(h, f), f !== "mod" && (S = E.div.neg()), f !== "div" && (T = E.mod.neg(), m && T.negative !== 0 && T.iadd(h)), {
        div: S,
        mod: T
      }) : this.negative === 0 && h.negative !== 0 ? (E = this.divmod(h.neg(), f), f !== "mod" && (S = E.div.neg()), {
        div: S,
        mod: E.mod
      }) : this.negative & h.negative ? (E = this.neg().divmod(h.neg(), f), f !== "div" && (T = E.mod.neg(), m && T.negative !== 0 && T.isub(h)), {
        div: E.div,
        mod: T
      }) : h.length > this.length || this.cmp(h) < 0 ? {
        div: new o10(0),
        mod: this
      } : h.length === 1 ? f === "div" ? {
        div: this.divn(h.words[0]),
        mod: null
      } : f === "mod" ? {
        div: null,
        mod: new o10(this.modrn(h.words[0]))
      } : {
        div: this.divn(h.words[0]),
        mod: new o10(this.modrn(h.words[0]))
      } : this._wordDiv(h, f);
    }, o10.prototype.div = function(h) {
      return this.divmod(h, "div", false).div;
    }, o10.prototype.mod = function(h) {
      return this.divmod(h, "mod", false).mod;
    }, o10.prototype.umod = function(h) {
      return this.divmod(h, "mod", true).mod;
    }, o10.prototype.divRound = function(h) {
      var f = this.divmod(h);
      if (f.mod.isZero())
        return f.div;
      var m = f.div.negative !== 0 ? f.mod.isub(h) : f.mod, S = h.ushrn(1), T = h.andln(1), E = m.cmp(S);
      return E < 0 || T === 1 && E === 0 ? f.div : f.div.negative !== 0 ? f.div.isubn(1) : f.div.iaddn(1);
    }, o10.prototype.modrn = function(h) {
      var f = h < 0;
      f && (h = -h), n10(h <= 67108863);
      for (var m = (1 << 26) % h, S = 0, T = this.length - 1; T >= 0; T--)
        S = (m * S + (this.words[T] | 0)) % h;
      return f ? -S : S;
    }, o10.prototype.modn = function(h) {
      return this.modrn(h);
    }, o10.prototype.idivn = function(h) {
      var f = h < 0;
      f && (h = -h), n10(h <= 67108863);
      for (var m = 0, S = this.length - 1; S >= 0; S--) {
        var T = (this.words[S] | 0) + m * 67108864;
        this.words[S] = T / h | 0, m = T % h;
      }
      return this._strip(), f ? this.ineg() : this;
    }, o10.prototype.divn = function(h) {
      return this.clone().idivn(h);
    }, o10.prototype.egcd = function(h) {
      n10(h.negative === 0), n10(!h.isZero());
      var f = this, m = h.clone();
      f.negative !== 0 ? f = f.umod(h) : f = f.clone();
      for (var S = new o10(1), T = new o10(0), E = new o10(0), I = new o10(1), C = 0; f.isEven() && m.isEven(); )
        f.iushrn(1), m.iushrn(1), ++C;
      for (var g = m.clone(), v10 = f.clone(); !f.isZero(); ) {
        for (var k = 0, Q = 1; !(f.words[0] & Q) && k < 26; ++k, Q <<= 1)
          ;
        if (k > 0)
          for (f.iushrn(k); k-- > 0; )
            (S.isOdd() || T.isOdd()) && (S.iadd(g), T.isub(v10)), S.iushrn(1), T.iushrn(1);
        for (var Z = 0, ae = 1; !(m.words[0] & ae) && Z < 26; ++Z, ae <<= 1)
          ;
        if (Z > 0)
          for (m.iushrn(Z); Z-- > 0; )
            (E.isOdd() || I.isOdd()) && (E.iadd(g), I.isub(v10)), E.iushrn(1), I.iushrn(1);
        f.cmp(m) >= 0 ? (f.isub(m), S.isub(E), T.isub(I)) : (m.isub(f), E.isub(S), I.isub(T));
      }
      return {
        a: E,
        b: I,
        gcd: m.iushln(C)
      };
    }, o10.prototype._invmp = function(h) {
      n10(h.negative === 0), n10(!h.isZero());
      var f = this, m = h.clone();
      f.negative !== 0 ? f = f.umod(h) : f = f.clone();
      for (var S = new o10(1), T = new o10(0), E = m.clone(); f.cmpn(1) > 0 && m.cmpn(1) > 0; ) {
        for (var I = 0, C = 1; !(f.words[0] & C) && I < 26; ++I, C <<= 1)
          ;
        if (I > 0)
          for (f.iushrn(I); I-- > 0; )
            S.isOdd() && S.iadd(E), S.iushrn(1);
        for (var g = 0, v10 = 1; !(m.words[0] & v10) && g < 26; ++g, v10 <<= 1)
          ;
        if (g > 0)
          for (m.iushrn(g); g-- > 0; )
            T.isOdd() && T.iadd(E), T.iushrn(1);
        f.cmp(m) >= 0 ? (f.isub(m), S.isub(T)) : (m.isub(f), T.isub(S));
      }
      var k;
      return f.cmpn(1) === 0 ? k = S : k = T, k.cmpn(0) < 0 && k.iadd(h), k;
    }, o10.prototype.gcd = function(h) {
      if (this.isZero())
        return h.abs();
      if (h.isZero())
        return this.abs();
      var f = this.clone(), m = h.clone();
      f.negative = 0, m.negative = 0;
      for (var S = 0; f.isEven() && m.isEven(); S++)
        f.iushrn(1), m.iushrn(1);
      do {
        for (; f.isEven(); )
          f.iushrn(1);
        for (; m.isEven(); )
          m.iushrn(1);
        var T = f.cmp(m);
        if (T < 0) {
          var E = f;
          f = m, m = E;
        } else if (T === 0 || m.cmpn(1) === 0)
          break;
        f.isub(m);
      } while (true);
      return m.iushln(S);
    }, o10.prototype.invm = function(h) {
      return this.egcd(h).a.umod(h);
    }, o10.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o10.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o10.prototype.andln = function(h) {
      return this.words[0] & h;
    }, o10.prototype.bincn = function(h) {
      n10(typeof h == "number");
      var f = h % 26, m = (h - f) / 26, S = 1 << f;
      if (this.length <= m)
        return this._expand(m + 1), this.words[m] |= S, this;
      for (var T = S, E = m; T !== 0 && E < this.length; E++) {
        var I = this.words[E] | 0;
        I += T, T = I >>> 26, I &= 67108863, this.words[E] = I;
      }
      return T !== 0 && (this.words[E] = T, this.length++), this;
    }, o10.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o10.prototype.cmpn = function(h) {
      var f = h < 0;
      if (this.negative !== 0 && !f)
        return -1;
      if (this.negative === 0 && f)
        return 1;
      this._strip();
      var m;
      if (this.length > 1)
        m = 1;
      else {
        f && (h = -h), n10(h <= 67108863, "Number is too big");
        var S = this.words[0] | 0;
        m = S === h ? 0 : S < h ? -1 : 1;
      }
      return this.negative !== 0 ? -m | 0 : m;
    }, o10.prototype.cmp = function(h) {
      if (this.negative !== 0 && h.negative === 0)
        return -1;
      if (this.negative === 0 && h.negative !== 0)
        return 1;
      var f = this.ucmp(h);
      return this.negative !== 0 ? -f | 0 : f;
    }, o10.prototype.ucmp = function(h) {
      if (this.length > h.length)
        return 1;
      if (this.length < h.length)
        return -1;
      for (var f = 0, m = this.length - 1; m >= 0; m--) {
        var S = this.words[m] | 0, T = h.words[m] | 0;
        if (S !== T) {
          S < T ? f = -1 : S > T && (f = 1);
          break;
        }
      }
      return f;
    }, o10.prototype.gtn = function(h) {
      return this.cmpn(h) === 1;
    }, o10.prototype.gt = function(h) {
      return this.cmp(h) === 1;
    }, o10.prototype.gten = function(h) {
      return this.cmpn(h) >= 0;
    }, o10.prototype.gte = function(h) {
      return this.cmp(h) >= 0;
    }, o10.prototype.ltn = function(h) {
      return this.cmpn(h) === -1;
    }, o10.prototype.lt = function(h) {
      return this.cmp(h) === -1;
    }, o10.prototype.lten = function(h) {
      return this.cmpn(h) <= 0;
    }, o10.prototype.lte = function(h) {
      return this.cmp(h) <= 0;
    }, o10.prototype.eqn = function(h) {
      return this.cmpn(h) === 0;
    }, o10.prototype.eq = function(h) {
      return this.cmp(h) === 0;
    }, o10.red = function(h) {
      return new oe(h);
    }, o10.prototype.toRed = function(h) {
      return n10(!this.red, "Already a number in reduction context"), n10(this.negative === 0, "red works only with positives"), h.convertTo(this)._forceRed(h);
    }, o10.prototype.fromRed = function() {
      return n10(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o10.prototype._forceRed = function(h) {
      return this.red = h, this;
    }, o10.prototype.forceRed = function(h) {
      return n10(!this.red, "Already a number in reduction context"), this._forceRed(h);
    }, o10.prototype.redAdd = function(h) {
      return n10(this.red, "redAdd works only with red numbers"), this.red.add(this, h);
    }, o10.prototype.redIAdd = function(h) {
      return n10(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, h);
    }, o10.prototype.redSub = function(h) {
      return n10(this.red, "redSub works only with red numbers"), this.red.sub(this, h);
    }, o10.prototype.redISub = function(h) {
      return n10(this.red, "redISub works only with red numbers"), this.red.isub(this, h);
    }, o10.prototype.redShl = function(h) {
      return n10(this.red, "redShl works only with red numbers"), this.red.shl(this, h);
    }, o10.prototype.redMul = function(h) {
      return n10(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.mul(this, h);
    }, o10.prototype.redIMul = function(h) {
      return n10(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.imul(this, h);
    }, o10.prototype.redSqr = function() {
      return n10(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o10.prototype.redISqr = function() {
      return n10(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o10.prototype.redSqrt = function() {
      return n10(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o10.prototype.redInvm = function() {
      return n10(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o10.prototype.redNeg = function() {
      return n10(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o10.prototype.redPow = function(h) {
      return n10(this.red && !h.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, h);
    };
    var B = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function W(L, h) {
      this.name = L, this.p = new o10(h, 16), this.n = this.p.bitLength(), this.k = new o10(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    W.prototype._tmp = function() {
      var h = new o10(null);
      return h.words = new Array(Math.ceil(this.n / 13)), h;
    }, W.prototype.ireduce = function(h) {
      var f = h, m;
      do
        this.split(f, this.tmp), f = this.imulK(f), f = f.iadd(this.tmp), m = f.bitLength();
      while (m > this.n);
      var S = m < this.n ? -1 : f.ucmp(this.p);
      return S === 0 ? (f.words[0] = 0, f.length = 1) : S > 0 ? f.isub(this.p) : f.strip !== void 0 ? f.strip() : f._strip(), f;
    }, W.prototype.split = function(h, f) {
      h.iushrn(this.n, 0, f);
    }, W.prototype.imulK = function(h) {
      return h.imul(this.k);
    };
    function z() {
      W.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i10(z, W), z.prototype.split = function(h, f) {
      for (var m = 4194303, S = Math.min(h.length, 9), T = 0; T < S; T++)
        f.words[T] = h.words[T];
      if (f.length = S, h.length <= 9) {
        h.words[0] = 0, h.length = 1;
        return;
      }
      var E = h.words[9];
      for (f.words[f.length++] = E & m, T = 10; T < h.length; T++) {
        var I = h.words[T] | 0;
        h.words[T - 10] = (I & m) << 4 | E >>> 22, E = I;
      }
      E >>>= 22, h.words[T - 10] = E, E === 0 && h.length > 10 ? h.length -= 10 : h.length -= 9;
    }, z.prototype.imulK = function(h) {
      h.words[h.length] = 0, h.words[h.length + 1] = 0, h.length += 2;
      for (var f = 0, m = 0; m < h.length; m++) {
        var S = h.words[m] | 0;
        f += S * 977, h.words[m] = f & 67108863, f = S * 64 + (f / 67108864 | 0);
      }
      return h.words[h.length - 1] === 0 && (h.length--, h.words[h.length - 1] === 0 && h.length--), h;
    };
    function G() {
      W.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i10(G, W);
    function re() {
      W.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i10(re, W);
    function ie() {
      W.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i10(ie, W), ie.prototype.imulK = function(h) {
      for (var f = 0, m = 0; m < h.length; m++) {
        var S = (h.words[m] | 0) * 19 + f, T = S & 67108863;
        S >>>= 26, h.words[m] = T, f = S;
      }
      return f !== 0 && (h.words[h.length++] = f), h;
    }, o10._prime = function(h) {
      if (B[h])
        return B[h];
      var f;
      if (h === "k256")
        f = new z();
      else if (h === "p224")
        f = new G();
      else if (h === "p192")
        f = new re();
      else if (h === "p25519")
        f = new ie();
      else
        throw new Error("Unknown prime " + h);
      return B[h] = f, f;
    };
    function oe(L) {
      if (typeof L == "string") {
        var h = o10._prime(L);
        this.m = h.p, this.prime = h;
      } else
        n10(L.gtn(1), "modulus must be greater than 1"), this.m = L, this.prime = null;
    }
    oe.prototype._verify1 = function(h) {
      n10(h.negative === 0, "red works only with positives"), n10(h.red, "red works only with red numbers");
    }, oe.prototype._verify2 = function(h, f) {
      n10((h.negative | f.negative) === 0, "red works only with positives"), n10(
        h.red && h.red === f.red,
        "red works only with red numbers"
      );
    }, oe.prototype.imod = function(h) {
      return this.prime ? this.prime.ireduce(h)._forceRed(this) : (u10(h, h.umod(this.m)._forceRed(this)), h);
    }, oe.prototype.neg = function(h) {
      return h.isZero() ? h.clone() : this.m.sub(h)._forceRed(this);
    }, oe.prototype.add = function(h, f) {
      this._verify2(h, f);
      var m = h.add(f);
      return m.cmp(this.m) >= 0 && m.isub(this.m), m._forceRed(this);
    }, oe.prototype.iadd = function(h, f) {
      this._verify2(h, f);
      var m = h.iadd(f);
      return m.cmp(this.m) >= 0 && m.isub(this.m), m;
    }, oe.prototype.sub = function(h, f) {
      this._verify2(h, f);
      var m = h.sub(f);
      return m.cmpn(0) < 0 && m.iadd(this.m), m._forceRed(this);
    }, oe.prototype.isub = function(h, f) {
      this._verify2(h, f);
      var m = h.isub(f);
      return m.cmpn(0) < 0 && m.iadd(this.m), m;
    }, oe.prototype.shl = function(h, f) {
      return this._verify1(h), this.imod(h.ushln(f));
    }, oe.prototype.imul = function(h, f) {
      return this._verify2(h, f), this.imod(h.imul(f));
    }, oe.prototype.mul = function(h, f) {
      return this._verify2(h, f), this.imod(h.mul(f));
    }, oe.prototype.isqr = function(h) {
      return this.imul(h, h.clone());
    }, oe.prototype.sqr = function(h) {
      return this.mul(h, h);
    }, oe.prototype.sqrt = function(h) {
      if (h.isZero())
        return h.clone();
      var f = this.m.andln(3);
      if (n10(f % 2 === 1), f === 3) {
        var m = this.m.add(new o10(1)).iushrn(2);
        return this.pow(h, m);
      }
      for (var S = this.m.subn(1), T = 0; !S.isZero() && S.andln(1) === 0; )
        T++, S.iushrn(1);
      n10(!S.isZero());
      var E = new o10(1).toRed(this), I = E.redNeg(), C = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new o10(2 * g * g).toRed(this); this.pow(g, C).cmp(I) !== 0; )
        g.redIAdd(I);
      for (var v10 = this.pow(g, S), k = this.pow(h, S.addn(1).iushrn(1)), Q = this.pow(h, S), Z = T; Q.cmp(E) !== 0; ) {
        for (var ae = Q, ve = 0; ae.cmp(E) !== 0; ve++)
          ae = ae.redSqr();
        n10(ve < Z);
        var we = this.pow(v10, new o10(1).iushln(Z - ve - 1));
        k = k.redMul(we), v10 = we.redSqr(), Q = Q.redMul(v10), Z = ve;
      }
      return k;
    }, oe.prototype.invm = function(h) {
      var f = h._invmp(this.m);
      return f.negative !== 0 ? (f.negative = 0, this.imod(f).redNeg()) : this.imod(f);
    }, oe.prototype.pow = function(h, f) {
      if (f.isZero())
        return new o10(1).toRed(this);
      if (f.cmpn(1) === 0)
        return h.clone();
      var m = 4, S = new Array(1 << m);
      S[0] = new o10(1).toRed(this), S[1] = h;
      for (var T = 2; T < S.length; T++)
        S[T] = this.mul(S[T - 1], h);
      var E = S[0], I = 0, C = 0, g = f.bitLength() % 26;
      for (g === 0 && (g = 26), T = f.length - 1; T >= 0; T--) {
        for (var v10 = f.words[T], k = g - 1; k >= 0; k--) {
          var Q = v10 >> k & 1;
          if (E !== S[0] && (E = this.sqr(E)), Q === 0 && I === 0) {
            C = 0;
            continue;
          }
          I <<= 1, I |= Q, C++, !(C !== m && (T !== 0 || k !== 0)) && (E = this.mul(E, S[I]), C = 0, I = 0);
        }
        g = 26;
      }
      return E;
    }, oe.prototype.convertTo = function(h) {
      var f = h.umod(this.m);
      return f === h ? f.clone() : f;
    }, oe.prototype.convertFrom = function(h) {
      var f = h.clone();
      return f.red = null, f;
    }, o10.mont = function(h) {
      return new q(h);
    };
    function q(L) {
      oe.call(this, L), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o10(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i10(q, oe), q.prototype.convertTo = function(h) {
      return this.imod(h.ushln(this.shift));
    }, q.prototype.convertFrom = function(h) {
      var f = this.imod(h.mul(this.rinv));
      return f.red = null, f;
    }, q.prototype.imul = function(h, f) {
      if (h.isZero() || f.isZero())
        return h.words[0] = 0, h.length = 1, h;
      var m = h.imul(f), S = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), T = m.isub(S).iushrn(this.shift), E = T;
      return T.cmp(this.m) >= 0 ? E = T.isub(this.m) : T.cmpn(0) < 0 && (E = T.iadd(this.m)), E._forceRed(this);
    }, q.prototype.mul = function(h, f) {
      if (h.isZero() || f.isZero())
        return new o10(0)._forceRed(this);
      var m = h.mul(f), S = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), T = m.isub(S).iushrn(this.shift), E = T;
      return T.cmp(this.m) >= 0 ? E = T.isub(this.m) : T.cmpn(0) < 0 && (E = T.iadd(this.m)), E._forceRed(this);
    }, q.prototype.invm = function(h) {
      var f = this.imod(h._invmp(this.m).mul(this.r2));
      return f._forceRed(this);
    };
  })(e10, Rr);
})(Rd);
var m1 = Rd.exports;
var Th = Oa(m1);
var G3 = Rr && Rr.__importDefault || function(e10) {
  return e10 && e10.__esModule ? e10 : { default: e10 };
};
Object.defineProperty(pn, "__esModule", { value: true });
pn.parseAccumulatorUpdateData = pn.sliceAccumulatorUpdateData = pn.parseTwapMessage = pn.parsePriceFeedMessage = pn.isAccumulatorUpdateData = void 0;
var dn = G3(m1);
var K3 = "504e4155";
var Y3 = 1;
var X3 = 0;
var Of = 20;
var J3 = 0;
var Z3 = 1;
function Pd(e10) {
  return e10.toString("hex").slice(0, 8) === K3 && e10[4] === Y3 && e10[5] === X3;
}
pn.isAccumulatorUpdateData = Pd;
function Q3(e10) {
  let t10 = 0;
  if (e10.readUInt8(t10) !== J3)
    throw new Error("Not a price feed message");
  t10 += 1;
  const n10 = e10.subarray(t10, t10 + 32);
  t10 += 32;
  const i10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const o10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const s10 = e10.readInt32BE(t10);
  t10 += 4;
  const a10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const c = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const l10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const u10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  return t10 += 8, {
    feedId: n10,
    price: i10,
    confidence: o10,
    exponent: s10,
    publishTime: a10,
    prevPublishTime: c,
    emaPrice: l10,
    emaConf: u10
  };
}
pn.parsePriceFeedMessage = Q3;
function ex(e10) {
  let t10 = 0;
  if (e10.readUInt8(t10) !== Z3)
    throw new Error("Not a twap message");
  t10 += 1;
  const n10 = e10.subarray(t10, t10 + 32);
  t10 += 32;
  const i10 = new dn.default(e10.subarray(t10, t10 + 16), "be");
  t10 += 16;
  const o10 = new dn.default(e10.subarray(t10, t10 + 16), "be");
  t10 += 16;
  const s10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const a10 = e10.readInt32BE(t10);
  t10 += 4;
  const c = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const l10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  t10 += 8;
  const u10 = new dn.default(e10.subarray(t10, t10 + 8), "be");
  return t10 += 8, {
    feedId: n10,
    cumulativePrice: i10,
    cumulativeConf: o10,
    numDownSlots: s10,
    exponent: a10,
    publishTime: c,
    prevPublishTime: l10,
    publishSlot: u10
  };
}
pn.parseTwapMessage = ex;
function tx(e10, t10, r10) {
  if (!Pd(e10))
    throw new Error("Invalid accumulator message");
  let n10 = 6;
  const i10 = e10.readUint8(n10);
  n10 += 1 + i10, n10 += 1;
  const o10 = e10.readUint16BE(n10);
  n10 += 2, n10 += o10;
  const s10 = n10, a10 = [], c = e10.readUInt8(n10);
  n10 += 1;
  for (let u10 = 0; u10 < c; u10++) {
    const d6 = n10, p = e10.readUint16BE(n10);
    n10 += 2, n10 += p;
    const y = e10.readUInt8(n10);
    n10 += 1, n10 += Of * y, a10.push(e10.subarray(d6, n10));
  }
  if (n10 !== e10.length)
    throw new Error("Didn't reach the end of the message");
  const l10 = a10.slice(t10, r10);
  return If.concat([
    e10.subarray(0, s10),
    If.from([l10.length]),
    ...a10.slice(t10, r10)
  ]);
}
pn.sliceAccumulatorUpdateData = tx;
function rx(e10) {
  if (!Pd(e10))
    throw new Error("Invalid accumulator message");
  let t10 = 6;
  const r10 = e10.readUint8(t10);
  t10 += 1 + r10, t10 += 1;
  const n10 = e10.readUint16BE(t10);
  t10 += 2;
  const i10 = e10.subarray(t10, t10 + n10);
  t10 += n10;
  const o10 = e10.readUInt8(t10), s10 = [];
  t10 += 1;
  for (let a10 = 0; a10 < o10; a10++) {
    const c = e10.readUint16BE(t10);
    t10 += 2;
    const l10 = e10.subarray(t10, t10 + c);
    t10 += c;
    const u10 = e10.readUInt8(t10);
    t10 += 1;
    const d6 = [];
    for (let p = 0; p < u10; p++)
      d6.push(Array.from(e10.subarray(t10, t10 + Of))), t10 += Of;
    s10.push({ message: l10, proof: d6 });
  }
  if (t10 !== e10.length)
    throw new Error("Didn't reach the end of the message");
  return { vaa: i10, updates: s10 };
}
pn.parseAccumulatorUpdateData = rx;
(function(e10) {
  Object.defineProperty(e10, "__esModule", { value: true }), e10.PriceFeed = e10.PriceFeedMetadata = e10.Price = e10.parseTwapMessage = e10.parsePriceFeedMessage = e10.parseAccumulatorUpdateData = e10.sliceAccumulatorUpdateData = e10.isAccumulatorUpdateData = void 0;
  const t10 = vl;
  var r10 = pn;
  Object.defineProperty(e10, "isAccumulatorUpdateData", { enumerable: true, get: function() {
    return r10.isAccumulatorUpdateData;
  } }), Object.defineProperty(e10, "sliceAccumulatorUpdateData", { enumerable: true, get: function() {
    return r10.sliceAccumulatorUpdateData;
  } }), Object.defineProperty(e10, "parseAccumulatorUpdateData", { enumerable: true, get: function() {
    return r10.parseAccumulatorUpdateData;
  } }), Object.defineProperty(e10, "parsePriceFeedMessage", { enumerable: true, get: function() {
    return r10.parsePriceFeedMessage;
  } }), Object.defineProperty(e10, "parseTwapMessage", { enumerable: true, get: function() {
    return r10.parseTwapMessage;
  } });
  class n10 {
    constructor(a10) {
      mt(this, "conf");
      mt(this, "expo");
      mt(this, "price");
      mt(this, "publishTime");
      this.conf = a10.conf, this.expo = a10.expo, this.price = a10.price, this.publishTime = a10.publishTime;
    }
    /**
     * Get price as number. Warning: this conversion might result in an inaccurate number.
     * We store price and confidence values in our Oracle at 64-bit precision, but the JavaScript
     * number type can only represent numbers with 52-bit precision. So if a price or confidence
     * is larger than 52-bits, the conversion will lose the most insignificant bits.
     *
     * @returns a floating point number representing the price
     */
    getPriceAsNumberUnchecked() {
      return Number(this.price) * 10 ** this.expo;
    }
    /**
     * Get price as number. Warning: this conversion might result in an inaccurate number.
     * Explanation is the same as `priceAsNumberUnchecked()` documentation.
     *
     * @returns a floating point number representing the price
     */
    getConfAsNumberUnchecked() {
      return Number(this.conf) * 10 ** this.expo;
    }
    static fromJson(a10) {
      const c = t10.Convert.toPrice(a10);
      return new n10({
        conf: c.conf,
        expo: c.expo,
        price: c.price,
        publishTime: c.publish_time
      });
    }
    toJson() {
      const a10 = {
        conf: this.conf,
        expo: this.expo,
        price: this.price,
        publish_time: this.publishTime
      };
      return t10.Convert.priceToJson(a10);
    }
  }
  e10.Price = n10;
  class i10 {
    constructor(a10) {
      mt(this, "attestationTime");
      mt(this, "emitterChain");
      mt(this, "priceServiceReceiveTime");
      mt(this, "sequenceNumber");
      mt(this, "slot");
      mt(this, "prevPublishTime");
      this.attestationTime = a10.attestationTime, this.emitterChain = a10.emitterChain, this.priceServiceReceiveTime = a10.receiveTime, this.sequenceNumber = a10.sequenceNumber, this.slot = a10.slot, this.prevPublishTime = a10.prevPublishTime;
    }
    static fromJson(a10) {
      if (a10 === void 0)
        return;
      const c = t10.Convert.toPriceFeedMetadata(a10);
      return new i10({
        attestationTime: c.attestation_time,
        emitterChain: c.emitter_chain,
        receiveTime: c.price_service_receive_time,
        sequenceNumber: c.sequence_number,
        slot: c.slot,
        prevPublishTime: c.prev_publish_time
      });
    }
    toJson() {
      const a10 = {
        attestation_time: this.attestationTime,
        emitter_chain: this.emitterChain,
        price_service_receive_time: this.priceServiceReceiveTime,
        sequence_number: this.sequenceNumber,
        slot: this.slot,
        prev_publish_time: this.prevPublishTime
      };
      return t10.Convert.priceFeedMetadataToJson(a10);
    }
  }
  e10.PriceFeedMetadata = i10;
  let o10 = class g1 {
    constructor(a10) {
      mt(this, "emaPrice");
      mt(this, "id");
      mt(this, "metadata");
      mt(this, "vaa");
      mt(this, "price");
      this.emaPrice = a10.emaPrice, this.id = a10.id, this.metadata = a10.metadata, this.vaa = a10.vaa, this.price = a10.price;
    }
    static fromJson(a10) {
      const c = t10.Convert.toPriceFeed(a10);
      return new g1({
        emaPrice: n10.fromJson(c.ema_price),
        id: c.id,
        metadata: i10.fromJson(c.metadata),
        vaa: c.vaa,
        price: n10.fromJson(c.price)
      });
    }
    toJson() {
      var c;
      const a10 = {
        ema_price: this.emaPrice.toJson(),
        id: this.id,
        metadata: (c = this.metadata) == null ? void 0 : c.toJson(),
        price: this.price.toJson()
      };
      return t10.Convert.priceFeedToJson(a10);
    }
    /**
     * Get the price and confidence interval as fixed-point numbers of the form a * 10^e.
     * This function returns the current best estimate of the price at the time that this `PriceFeed` was
     * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function
     * makes no guarantees that the returned price is recent or useful for any particular application.
     *
     * Users of this function should check the returned `publishTime` to ensure that the returned price is
     * sufficiently recent for their application. If you are considering using this function, it may be
     * safer / easier to use `getPriceNoOlderThan` method.
     *
     * @returns a Price that contains the price and confidence interval along with
     * the exponent for them, and publish time of the price.
     */
    getPriceUnchecked() {
      return this.price;
    }
    /**
     * Get the exponentially-weighted moving average (EMA) price and confidence interval.
     *
     * This function returns the current best estimate of the price at the time that this `PriceFeed` was
     * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function
     * makes no guarantees that the returned price is recent or useful for any particular application.
     *
     * Users of this function should check the returned `publishTime` to ensure that the returned price is
     * sufficiently recent for their application. If you are considering using this function, it may be
     * safer / easier to use `getEmaPriceNoOlderThan` method.
     *
     * At the moment, the confidence interval returned by this method is computed in
     * a somewhat questionable way, so we do not recommend using it for high-value applications.
     *
     * @returns a Price that contains the EMA price and confidence interval along with
     * the exponent for them, and publish time of the price.
     */
    getEmaPriceUnchecked() {
      return this.emaPrice;
    }
    /**
     * Get the price if it was updated no older than `age` seconds of the current time.
     *
     * This function is a sanity-checked version of `getPriceUnchecked` which is useful in
     * applications that require a sufficiently-recent price. Returns `undefined` if the price
     * is not recent enough.
     *
     * @param age return a price as long as it has been updated within this number of seconds
     * @returns a Price struct containing the price, confidence interval along with the exponent for
     * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.
     */
    getPriceNoOlderThan(a10) {
      const c = this.getPriceUnchecked(), l10 = Math.floor(Date.now() / 1e3);
      if (!(Math.abs(l10 - c.publishTime) > a10))
        return c;
    }
    /**
     * Get the exponentially-weighted moving average (EMA) price if it was updated no older than
     * `age` seconds of the current time.
     *
     * This function is a sanity-checked version of `getEmaPriceUnchecked` which is useful in
     * applications that require a sufficiently-recent price. Returns `undefined` if the price
     * is not recent enough.
     *
     * At the moment, the confidence interval returned by this method is computed in
     * a somewhat questionable way, so we do not recommend using it for high-value applications.
     *
     * @param age return a price as long as it has been updated within this number of seconds
     * @returns a Price struct containing the EMA price, confidence interval along with the exponent for
     * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.
     */
    getEmaPriceNoOlderThan(a10) {
      const c = this.getEmaPriceUnchecked(), l10 = Math.floor(Date.now() / 1e3);
      if (!(Math.abs(l10 - c.publishTime) > a10))
        return c;
    }
    /**
     * Get the price feed metadata.
     *
     * @returns a struct containing the attestation time, emitter chain, and the sequence number.
     * Returns `undefined` if metadata is currently unavailable.
     */
    getMetadata() {
      return this.metadata;
    }
    /**
     * Get the price feed vaa.
     *
     * @returns vaa in base64.
     * Returns `undefined` if vaa is unavailable.
     */
    getVAA() {
      return this.vaa;
    }
  };
  e10.PriceFeed = o10;
})(Od);
function v1(e10, t10) {
  return function() {
    return e10.apply(t10, arguments);
  };
}
var { toString: nx } = Object.prototype;
var { getPrototypeOf: Nd } = Object;
var bl = /* @__PURE__ */ ((e10) => (t10) => {
  const r10 = nx.call(t10);
  return e10[r10] || (e10[r10] = r10.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var Fn = (e10) => (e10 = e10.toLowerCase(), (t10) => bl(t10) === e10);
var yl = (e10) => (t10) => typeof t10 === e10;
var { isArray: Is } = Array;
var ga = yl("undefined");
function ix(e10) {
  return e10 !== null && !ga(e10) && e10.constructor !== null && !ga(e10.constructor) && rn(e10.constructor.isBuffer) && e10.constructor.isBuffer(e10);
}
var b1 = Fn("ArrayBuffer");
function ox(e10) {
  let t10;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t10 = ArrayBuffer.isView(e10) : t10 = e10 && e10.buffer && b1(e10.buffer), t10;
}
var sx = yl("string");
var rn = yl("function");
var y1 = yl("number");
var wl = (e10) => e10 !== null && typeof e10 == "object";
var ax = (e10) => e10 === true || e10 === false;
var mc = (e10) => {
  if (bl(e10) !== "object")
    return false;
  const t10 = Nd(e10);
  return (t10 === null || t10 === Object.prototype || Object.getPrototypeOf(t10) === null) && !(Symbol.toStringTag in e10) && !(Symbol.iterator in e10);
};
var cx = Fn("Date");
var lx = Fn("File");
var ux = Fn("Blob");
var fx = Fn("FileList");
var dx = (e10) => wl(e10) && rn(e10.pipe);
var hx = (e10) => {
  let t10;
  return e10 && (typeof FormData == "function" && e10 instanceof FormData || rn(e10.append) && ((t10 = bl(e10)) === "formdata" || // detect form-data instance
  t10 === "object" && rn(e10.toString) && e10.toString() === "[object FormData]"));
};
var px = Fn("URLSearchParams");
var [mx, gx, vx, bx] = ["ReadableStream", "Request", "Response", "Headers"].map(Fn);
var yx = (e10) => e10.trim ? e10.trim() : e10.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ka(e10, t10, { allOwnKeys: r10 = false } = {}) {
  if (e10 === null || typeof e10 > "u")
    return;
  let n10, i10;
  if (typeof e10 != "object" && (e10 = [e10]), Is(e10))
    for (n10 = 0, i10 = e10.length; n10 < i10; n10++)
      t10.call(null, e10[n10], n10, e10);
  else {
    const o10 = r10 ? Object.getOwnPropertyNames(e10) : Object.keys(e10), s10 = o10.length;
    let a10;
    for (n10 = 0; n10 < s10; n10++)
      a10 = o10[n10], t10.call(null, e10[a10], a10, e10);
  }
}
function w1(e10, t10) {
  t10 = t10.toLowerCase();
  const r10 = Object.keys(e10);
  let n10 = r10.length, i10;
  for (; n10-- > 0; )
    if (i10 = r10[n10], t10 === i10.toLowerCase())
      return i10;
  return null;
}
var Ro = /* @__PURE__ */ (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Rr)();
var x1 = (e10) => !ga(e10) && e10 !== Ro;
function Rf() {
  const { caseless: e10 } = x1(this) && this || {}, t10 = {}, r10 = (n10, i10) => {
    const o10 = e10 && w1(t10, i10) || i10;
    mc(t10[o10]) && mc(n10) ? t10[o10] = Rf(t10[o10], n10) : mc(n10) ? t10[o10] = Rf({}, n10) : Is(n10) ? t10[o10] = n10.slice() : t10[o10] = n10;
  };
  for (let n10 = 0, i10 = arguments.length; n10 < i10; n10++)
    arguments[n10] && ka(arguments[n10], r10);
  return t10;
}
var wx = (e10, t10, r10, { allOwnKeys: n10 } = {}) => (ka(t10, (i10, o10) => {
  r10 && rn(i10) ? e10[o10] = v1(i10, r10) : e10[o10] = i10;
}, { allOwnKeys: n10 }), e10);
var xx = (e10) => (e10.charCodeAt(0) === 65279 && (e10 = e10.slice(1)), e10);
var Sx = (e10, t10, r10, n10) => {
  e10.prototype = Object.create(t10.prototype, n10), e10.prototype.constructor = e10, Object.defineProperty(e10, "super", {
    value: t10.prototype
  }), r10 && Object.assign(e10.prototype, r10);
};
var _x = (e10, t10, r10, n10) => {
  let i10, o10, s10;
  const a10 = {};
  if (t10 = t10 || {}, e10 == null)
    return t10;
  do {
    for (i10 = Object.getOwnPropertyNames(e10), o10 = i10.length; o10-- > 0; )
      s10 = i10[o10], (!n10 || n10(s10, e10, t10)) && !a10[s10] && (t10[s10] = e10[s10], a10[s10] = true);
    e10 = r10 !== false && Nd(e10);
  } while (e10 && (!r10 || r10(e10, t10)) && e10 !== Object.prototype);
  return t10;
};
var Ex = (e10, t10, r10) => {
  e10 = String(e10), (r10 === void 0 || r10 > e10.length) && (r10 = e10.length), r10 -= t10.length;
  const n10 = e10.indexOf(t10, r10);
  return n10 !== -1 && n10 === r10;
};
var Cx = (e10) => {
  if (!e10)
    return null;
  if (Is(e10))
    return e10;
  let t10 = e10.length;
  if (!y1(t10))
    return null;
  const r10 = new Array(t10);
  for (; t10-- > 0; )
    r10[t10] = e10[t10];
  return r10;
};
var Tx = /* @__PURE__ */ ((e10) => (t10) => e10 && t10 instanceof e10)(typeof Uint8Array < "u" && Nd(Uint8Array));
var Ax = (e10, t10) => {
  const n10 = (e10 && e10[Symbol.iterator]).call(e10);
  let i10;
  for (; (i10 = n10.next()) && !i10.done; ) {
    const o10 = i10.value;
    t10.call(e10, o10[0], o10[1]);
  }
};
var Mx = (e10, t10) => {
  let r10;
  const n10 = [];
  for (; (r10 = e10.exec(t10)) !== null; )
    n10.push(r10);
  return n10;
};
var Ix = Fn("HTMLFormElement");
var Ox = (e10) => e10.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r10, n10, i10) {
    return n10.toUpperCase() + i10;
  }
);
var Ah = (({ hasOwnProperty: e10 }) => (t10, r10) => e10.call(t10, r10))(Object.prototype);
var Rx = Fn("RegExp");
var S1 = (e10, t10) => {
  const r10 = Object.getOwnPropertyDescriptors(e10), n10 = {};
  ka(r10, (i10, o10) => {
    let s10;
    (s10 = t10(i10, o10, e10)) !== false && (n10[o10] = s10 || i10);
  }), Object.defineProperties(e10, n10);
};
var Px = (e10) => {
  S1(e10, (t10, r10) => {
    if (rn(e10) && ["arguments", "caller", "callee"].indexOf(r10) !== -1)
      return false;
    const n10 = e10[r10];
    if (rn(n10)) {
      if (t10.enumerable = false, "writable" in t10) {
        t10.writable = false;
        return;
      }
      t10.set || (t10.set = () => {
        throw Error("Can not rewrite read-only method '" + r10 + "'");
      });
    }
  });
};
var Nx = (e10, t10) => {
  const r10 = {}, n10 = (i10) => {
    i10.forEach((o10) => {
      r10[o10] = true;
    });
  };
  return Is(e10) ? n10(e10) : n10(String(e10).split(t10)), r10;
};
var jx = () => {
};
var kx = (e10, t10) => e10 != null && Number.isFinite(e10 = +e10) ? e10 : t10;
function Dx(e10) {
  return !!(e10 && rn(e10.append) && e10[Symbol.toStringTag] === "FormData" && e10[Symbol.iterator]);
}
var Lx = (e10) => {
  const t10 = new Array(10), r10 = (n10, i10) => {
    if (wl(n10)) {
      if (t10.indexOf(n10) >= 0)
        return;
      if (!("toJSON" in n10)) {
        t10[i10] = n10;
        const o10 = Is(n10) ? [] : {};
        return ka(n10, (s10, a10) => {
          const c = r10(s10, i10 + 1);
          !ga(c) && (o10[a10] = c);
        }), t10[i10] = void 0, o10;
      }
    }
    return n10;
  };
  return r10(e10, 0);
};
var Bx = Fn("AsyncFunction");
var Ux = (e10) => e10 && (wl(e10) || rn(e10)) && rn(e10.then) && rn(e10.catch);
var _1 = ((e10, t10) => e10 ? setImmediate : t10 ? ((r10, n10) => (Ro.addEventListener("message", ({ source: i10, data: o10 }) => {
  i10 === Ro && o10 === r10 && n10.length && n10.shift()();
}, false), (i10) => {
  n10.push(i10), Ro.postMessage(r10, "*");
}))(`axios@${Math.random()}`, []) : (r10) => setTimeout(r10))(
  typeof setImmediate == "function",
  rn(Ro.postMessage)
);
var Fx = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ro) : typeof Rn < "u" && Rn.nextTick || _1;
var ce = {
  isArray: Is,
  isArrayBuffer: b1,
  isBuffer: ix,
  isFormData: hx,
  isArrayBufferView: ox,
  isString: sx,
  isNumber: y1,
  isBoolean: ax,
  isObject: wl,
  isPlainObject: mc,
  isReadableStream: mx,
  isRequest: gx,
  isResponse: vx,
  isHeaders: bx,
  isUndefined: ga,
  isDate: cx,
  isFile: lx,
  isBlob: ux,
  isRegExp: Rx,
  isFunction: rn,
  isStream: dx,
  isURLSearchParams: px,
  isTypedArray: Tx,
  isFileList: fx,
  forEach: ka,
  merge: Rf,
  extend: wx,
  trim: yx,
  stripBOM: xx,
  inherits: Sx,
  toFlatObject: _x,
  kindOf: bl,
  kindOfTest: Fn,
  endsWith: Ex,
  toArray: Cx,
  forEachEntry: Ax,
  matchAll: Mx,
  isHTMLForm: Ix,
  hasOwnProperty: Ah,
  hasOwnProp: Ah,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: S1,
  freezeMethods: Px,
  toObjectSet: Nx,
  toCamelCase: Ox,
  noop: jx,
  toFiniteNumber: kx,
  findKey: w1,
  global: Ro,
  isContextDefined: x1,
  isSpecCompliantForm: Dx,
  toJSONObject: Lx,
  isAsyncFn: Bx,
  isThenable: Ux,
  setImmediate: _1,
  asap: Fx
};
function dt(e10, t10, r10, n10, i10) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e10, this.name = "AxiosError", t10 && (this.code = t10), r10 && (this.config = r10), n10 && (this.request = n10), i10 && (this.response = i10, this.status = i10.status ? i10.status : null);
}
ce.inherits(dt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ce.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var E1 = dt.prototype;
var C1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e10) => {
  C1[e10] = { value: e10 };
});
Object.defineProperties(dt, C1);
Object.defineProperty(E1, "isAxiosError", { value: true });
dt.from = (e10, t10, r10, n10, i10, o10) => {
  const s10 = Object.create(E1);
  return ce.toFlatObject(e10, s10, function(c) {
    return c !== Error.prototype;
  }, (a10) => a10 !== "isAxiosError"), dt.call(s10, e10.message, t10, r10, n10, i10), s10.cause = e10, s10.name = e10.name, o10 && Object.assign(s10, o10), s10;
};
var $x = null;
function Pf(e10) {
  return ce.isPlainObject(e10) || ce.isArray(e10);
}
function T1(e10) {
  return ce.endsWith(e10, "[]") ? e10.slice(0, -2) : e10;
}
function Mh(e10, t10, r10) {
  return e10 ? e10.concat(t10).map(function(i10, o10) {
    return i10 = T1(i10), !r10 && o10 ? "[" + i10 + "]" : i10;
  }).join(r10 ? "." : "") : t10;
}
function Vx(e10) {
  return ce.isArray(e10) && !e10.some(Pf);
}
var zx = ce.toFlatObject(ce, {}, null, function(t10) {
  return /^is[A-Z]/.test(t10);
});
function xl(e10, t10, r10) {
  if (!ce.isObject(e10))
    throw new TypeError("target must be an object");
  t10 = t10 || new FormData(), r10 = ce.toFlatObject(r10, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(b, M) {
    return !ce.isUndefined(M[b]);
  });
  const n10 = r10.metaTokens, i10 = r10.visitor || u10, o10 = r10.dots, s10 = r10.indexes, c = (r10.Blob || typeof Blob < "u" && Blob) && ce.isSpecCompliantForm(t10);
  if (!ce.isFunction(i10))
    throw new TypeError("visitor must be a function");
  function l10(x) {
    if (x === null)
      return "";
    if (ce.isDate(x))
      return x.toISOString();
    if (!c && ce.isBlob(x))
      throw new dt("Blob is not supported. Use a Buffer instead.");
    return ce.isArrayBuffer(x) || ce.isTypedArray(x) ? c && typeof Blob == "function" ? new Blob([x]) : If.from(x) : x;
  }
  function u10(x, b, M) {
    let O = x;
    if (x && !M && typeof x == "object") {
      if (ce.endsWith(b, "{}"))
        b = n10 ? b : b.slice(0, -2), x = JSON.stringify(x);
      else if (ce.isArray(x) && Vx(x) || (ce.isFileList(x) || ce.endsWith(b, "[]")) && (O = ce.toArray(x)))
        return b = T1(b), O.forEach(function(j, F) {
          !(ce.isUndefined(j) || j === null) && t10.append(
            // eslint-disable-next-line no-nested-ternary
            s10 === true ? Mh([b], F, o10) : s10 === null ? b : b + "[]",
            l10(j)
          );
        }), false;
    }
    return Pf(x) ? true : (t10.append(Mh(M, b, o10), l10(x)), false);
  }
  const d6 = [], p = Object.assign(zx, {
    defaultVisitor: u10,
    convertValue: l10,
    isVisitable: Pf
  });
  function y(x, b) {
    if (!ce.isUndefined(x)) {
      if (d6.indexOf(x) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      d6.push(x), ce.forEach(x, function(O, P) {
        (!(ce.isUndefined(O) || O === null) && i10.call(
          t10,
          O,
          ce.isString(P) ? P.trim() : P,
          b,
          p
        )) === true && y(O, b ? b.concat(P) : [P]);
      }), d6.pop();
    }
  }
  if (!ce.isObject(e10))
    throw new TypeError("data must be an object");
  return y(e10), t10;
}
function Ih(e10) {
  const t10 = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e10).replace(/[!'()~]|%20|%00/g, function(n10) {
    return t10[n10];
  });
}
function jd(e10, t10) {
  this._pairs = [], e10 && xl(e10, this, t10);
}
var A1 = jd.prototype;
A1.append = function(t10, r10) {
  this._pairs.push([t10, r10]);
};
A1.toString = function(t10) {
  const r10 = t10 ? function(n10) {
    return t10.call(this, n10, Ih);
  } : Ih;
  return this._pairs.map(function(i10) {
    return r10(i10[0]) + "=" + r10(i10[1]);
  }, "").join("&");
};
function qx(e10) {
  return encodeURIComponent(e10).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function M1(e10, t10, r10) {
  if (!t10)
    return e10;
  const n10 = r10 && r10.encode || qx;
  ce.isFunction(r10) && (r10 = {
    serialize: r10
  });
  const i10 = r10 && r10.serialize;
  let o10;
  if (i10 ? o10 = i10(t10, r10) : o10 = ce.isURLSearchParams(t10) ? t10.toString() : new jd(t10, r10).toString(n10), o10) {
    const s10 = e10.indexOf("#");
    s10 !== -1 && (e10 = e10.slice(0, s10)), e10 += (e10.indexOf("?") === -1 ? "?" : "&") + o10;
  }
  return e10;
}
var Hx = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t10, r10, n10) {
    return this.handlers.push({
      fulfilled: t10,
      rejected: r10,
      synchronous: n10 ? n10.synchronous : false,
      runWhen: n10 ? n10.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t10) {
    this.handlers[t10] && (this.handlers[t10] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t10) {
    ce.forEach(this.handlers, function(n10) {
      n10 !== null && t10(n10);
    });
  }
};
var Oh = Hx;
var I1 = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var Wx = typeof URLSearchParams < "u" ? URLSearchParams : jd;
var Gx = typeof FormData < "u" ? FormData : null;
var Kx = typeof Blob < "u" ? Blob : null;
var Yx = {
  isBrowser: true,
  classes: {
    URLSearchParams: Wx,
    FormData: Gx,
    Blob: Kx
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var kd = typeof window < "u" && typeof document < "u";
var Nf = typeof navigator == "object" && navigator || void 0;
var Xx = kd && (!Nf || ["ReactNative", "NativeScript", "NS"].indexOf(Nf.product) < 0);
var Jx = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")();
var Zx = kd && window.location.href || "http://localhost";
var Qx = Object.freeze({
  __proto__: null,
  hasBrowserEnv: kd,
  hasStandardBrowserWebWorkerEnv: Jx,
  hasStandardBrowserEnv: Xx,
  navigator: Nf,
  origin: Zx
});
var kr = {
  ...Qx,
  ...Yx
};
function e5(e10, t10) {
  return xl(e10, new kr.classes.URLSearchParams(), Object.assign({
    visitor: function(r10, n10, i10, o10) {
      return kr.isNode && ce.isBuffer(r10) ? (this.append(n10, r10.toString("base64")), false) : o10.defaultVisitor.apply(this, arguments);
    }
  }, t10));
}
function t5(e10) {
  return ce.matchAll(/\w+|\[(\w*)]/g, e10).map((t10) => t10[0] === "[]" ? "" : t10[1] || t10[0]);
}
function r5(e10) {
  const t10 = {}, r10 = Object.keys(e10);
  let n10;
  const i10 = r10.length;
  let o10;
  for (n10 = 0; n10 < i10; n10++)
    o10 = r10[n10], t10[o10] = e10[o10];
  return t10;
}
function O1(e10) {
  function t10(r10, n10, i10, o10) {
    let s10 = r10[o10++];
    if (s10 === "__proto__")
      return true;
    const a10 = Number.isFinite(+s10), c = o10 >= r10.length;
    return s10 = !s10 && ce.isArray(i10) ? i10.length : s10, c ? (ce.hasOwnProp(i10, s10) ? i10[s10] = [i10[s10], n10] : i10[s10] = n10, !a10) : ((!i10[s10] || !ce.isObject(i10[s10])) && (i10[s10] = []), t10(r10, n10, i10[s10], o10) && ce.isArray(i10[s10]) && (i10[s10] = r5(i10[s10])), !a10);
  }
  if (ce.isFormData(e10) && ce.isFunction(e10.entries)) {
    const r10 = {};
    return ce.forEachEntry(e10, (n10, i10) => {
      t10(t5(n10), i10, r10, 0);
    }), r10;
  }
  return null;
}
function n5(e10, t10, r10) {
  if (ce.isString(e10))
    try {
      return (t10 || JSON.parse)(e10), ce.trim(e10);
    } catch (n10) {
      if (n10.name !== "SyntaxError")
        throw n10;
    }
  return (r10 || JSON.stringify)(e10);
}
var Dd = {
  transitional: I1,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t10, r10) {
    const n10 = r10.getContentType() || "", i10 = n10.indexOf("application/json") > -1, o10 = ce.isObject(t10);
    if (o10 && ce.isHTMLForm(t10) && (t10 = new FormData(t10)), ce.isFormData(t10))
      return i10 ? JSON.stringify(O1(t10)) : t10;
    if (ce.isArrayBuffer(t10) || ce.isBuffer(t10) || ce.isStream(t10) || ce.isFile(t10) || ce.isBlob(t10) || ce.isReadableStream(t10))
      return t10;
    if (ce.isArrayBufferView(t10))
      return t10.buffer;
    if (ce.isURLSearchParams(t10))
      return r10.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), t10.toString();
    let a10;
    if (o10) {
      if (n10.indexOf("application/x-www-form-urlencoded") > -1)
        return e5(t10, this.formSerializer).toString();
      if ((a10 = ce.isFileList(t10)) || n10.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return xl(
          a10 ? { "files[]": t10 } : t10,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return o10 || i10 ? (r10.setContentType("application/json", false), n5(t10)) : t10;
  }],
  transformResponse: [function(t10) {
    const r10 = this.transitional || Dd.transitional, n10 = r10 && r10.forcedJSONParsing, i10 = this.responseType === "json";
    if (ce.isResponse(t10) || ce.isReadableStream(t10))
      return t10;
    if (t10 && ce.isString(t10) && (n10 && !this.responseType || i10)) {
      const s10 = !(r10 && r10.silentJSONParsing) && i10;
      try {
        return JSON.parse(t10);
      } catch (a10) {
        if (s10)
          throw a10.name === "SyntaxError" ? dt.from(a10, dt.ERR_BAD_RESPONSE, this, null, this.response) : a10;
      }
    }
    return t10;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: kr.classes.FormData,
    Blob: kr.classes.Blob
  },
  validateStatus: function(t10) {
    return t10 >= 200 && t10 < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ce.forEach(["delete", "get", "head", "post", "put", "patch"], (e10) => {
  Dd.headers[e10] = {};
});
var Ld = Dd;
var i5 = ce.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var o5 = (e10) => {
  const t10 = {};
  let r10, n10, i10;
  return e10 && e10.split(`
`).forEach(function(s10) {
    i10 = s10.indexOf(":"), r10 = s10.substring(0, i10).trim().toLowerCase(), n10 = s10.substring(i10 + 1).trim(), !(!r10 || t10[r10] && i5[r10]) && (r10 === "set-cookie" ? t10[r10] ? t10[r10].push(n10) : t10[r10] = [n10] : t10[r10] = t10[r10] ? t10[r10] + ", " + n10 : n10);
  }), t10;
};
var Rh = Symbol("internals");
function Ws(e10) {
  return e10 && String(e10).trim().toLowerCase();
}
function gc(e10) {
  return e10 === false || e10 == null ? e10 : ce.isArray(e10) ? e10.map(gc) : String(e10);
}
function s5(e10) {
  const t10 = /* @__PURE__ */ Object.create(null), r10 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n10;
  for (; n10 = r10.exec(e10); )
    t10[n10[1]] = n10[2];
  return t10;
}
var a5 = (e10) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e10.trim());
function Tu(e10, t10, r10, n10, i10) {
  if (ce.isFunction(n10))
    return n10.call(this, t10, r10);
  if (i10 && (t10 = r10), !!ce.isString(t10)) {
    if (ce.isString(n10))
      return t10.indexOf(n10) !== -1;
    if (ce.isRegExp(n10))
      return n10.test(t10);
  }
}
function c5(e10) {
  return e10.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t10, r10, n10) => r10.toUpperCase() + n10);
}
function l5(e10, t10) {
  const r10 = ce.toCamelCase(" " + t10);
  ["get", "set", "has"].forEach((n10) => {
    Object.defineProperty(e10, n10 + r10, {
      value: function(i10, o10, s10) {
        return this[n10].call(this, t10, i10, o10, s10);
      },
      configurable: true
    });
  });
}
var Sl = class {
  constructor(t10) {
    t10 && this.set(t10);
  }
  set(t10, r10, n10) {
    const i10 = this;
    function o10(a10, c, l10) {
      const u10 = Ws(c);
      if (!u10)
        throw new Error("header name must be a non-empty string");
      const d6 = ce.findKey(i10, u10);
      (!d6 || i10[d6] === void 0 || l10 === true || l10 === void 0 && i10[d6] !== false) && (i10[d6 || c] = gc(a10));
    }
    const s10 = (a10, c) => ce.forEach(a10, (l10, u10) => o10(l10, u10, c));
    if (ce.isPlainObject(t10) || t10 instanceof this.constructor)
      s10(t10, r10);
    else if (ce.isString(t10) && (t10 = t10.trim()) && !a5(t10))
      s10(o5(t10), r10);
    else if (ce.isHeaders(t10))
      for (const [a10, c] of t10.entries())
        o10(c, a10, n10);
    else
      t10 != null && o10(r10, t10, n10);
    return this;
  }
  get(t10, r10) {
    if (t10 = Ws(t10), t10) {
      const n10 = ce.findKey(this, t10);
      if (n10) {
        const i10 = this[n10];
        if (!r10)
          return i10;
        if (r10 === true)
          return s5(i10);
        if (ce.isFunction(r10))
          return r10.call(this, i10, n10);
        if (ce.isRegExp(r10))
          return r10.exec(i10);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t10, r10) {
    if (t10 = Ws(t10), t10) {
      const n10 = ce.findKey(this, t10);
      return !!(n10 && this[n10] !== void 0 && (!r10 || Tu(this, this[n10], n10, r10)));
    }
    return false;
  }
  delete(t10, r10) {
    const n10 = this;
    let i10 = false;
    function o10(s10) {
      if (s10 = Ws(s10), s10) {
        const a10 = ce.findKey(n10, s10);
        a10 && (!r10 || Tu(n10, n10[a10], a10, r10)) && (delete n10[a10], i10 = true);
      }
    }
    return ce.isArray(t10) ? t10.forEach(o10) : o10(t10), i10;
  }
  clear(t10) {
    const r10 = Object.keys(this);
    let n10 = r10.length, i10 = false;
    for (; n10--; ) {
      const o10 = r10[n10];
      (!t10 || Tu(this, this[o10], o10, t10, true)) && (delete this[o10], i10 = true);
    }
    return i10;
  }
  normalize(t10) {
    const r10 = this, n10 = {};
    return ce.forEach(this, (i10, o10) => {
      const s10 = ce.findKey(n10, o10);
      if (s10) {
        r10[s10] = gc(i10), delete r10[o10];
        return;
      }
      const a10 = t10 ? c5(o10) : String(o10).trim();
      a10 !== o10 && delete r10[o10], r10[a10] = gc(i10), n10[a10] = true;
    }), this;
  }
  concat(...t10) {
    return this.constructor.concat(this, ...t10);
  }
  toJSON(t10) {
    const r10 = /* @__PURE__ */ Object.create(null);
    return ce.forEach(this, (n10, i10) => {
      n10 != null && n10 !== false && (r10[i10] = t10 && ce.isArray(n10) ? n10.join(", ") : n10);
    }), r10;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t10, r10]) => t10 + ": " + r10).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t10) {
    return t10 instanceof this ? t10 : new this(t10);
  }
  static concat(t10, ...r10) {
    const n10 = new this(t10);
    return r10.forEach((i10) => n10.set(i10)), n10;
  }
  static accessor(t10) {
    const n10 = (this[Rh] = this[Rh] = {
      accessors: {}
    }).accessors, i10 = this.prototype;
    function o10(s10) {
      const a10 = Ws(s10);
      n10[a10] || (l5(i10, s10), n10[a10] = true);
    }
    return ce.isArray(t10) ? t10.forEach(o10) : o10(t10), this;
  }
};
Sl.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ce.reduceDescriptors(Sl.prototype, ({ value: e10 }, t10) => {
  let r10 = t10[0].toUpperCase() + t10.slice(1);
  return {
    get: () => e10,
    set(n10) {
      this[r10] = n10;
    }
  };
});
ce.freezeMethods(Sl);
var Pn = Sl;
function Au(e10, t10) {
  const r10 = this || Ld, n10 = t10 || r10, i10 = Pn.from(n10.headers);
  let o10 = n10.data;
  return ce.forEach(e10, function(a10) {
    o10 = a10.call(r10, o10, i10.normalize(), t10 ? t10.status : void 0);
  }), i10.normalize(), o10;
}
function R1(e10) {
  return !!(e10 && e10.__CANCEL__);
}
function Os(e10, t10, r10) {
  dt.call(this, e10 ?? "canceled", dt.ERR_CANCELED, t10, r10), this.name = "CanceledError";
}
ce.inherits(Os, dt, {
  __CANCEL__: true
});
function P1(e10, t10, r10) {
  const n10 = r10.config.validateStatus;
  !r10.status || !n10 || n10(r10.status) ? e10(r10) : t10(new dt(
    "Request failed with status code " + r10.status,
    [dt.ERR_BAD_REQUEST, dt.ERR_BAD_RESPONSE][Math.floor(r10.status / 100) - 4],
    r10.config,
    r10.request,
    r10
  ));
}
function u5(e10) {
  const t10 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e10);
  return t10 && t10[1] || "";
}
function f5(e10, t10) {
  e10 = e10 || 10;
  const r10 = new Array(e10), n10 = new Array(e10);
  let i10 = 0, o10 = 0, s10;
  return t10 = t10 !== void 0 ? t10 : 1e3, function(c) {
    const l10 = Date.now(), u10 = n10[o10];
    s10 || (s10 = l10), r10[i10] = c, n10[i10] = l10;
    let d6 = o10, p = 0;
    for (; d6 !== i10; )
      p += r10[d6++], d6 = d6 % e10;
    if (i10 = (i10 + 1) % e10, i10 === o10 && (o10 = (o10 + 1) % e10), l10 - s10 < t10)
      return;
    const y = u10 && l10 - u10;
    return y ? Math.round(p * 1e3 / y) : void 0;
  };
}
function d5(e10, t10) {
  let r10 = 0, n10 = 1e3 / t10, i10, o10;
  const s10 = (l10, u10 = Date.now()) => {
    r10 = u10, i10 = null, o10 && (clearTimeout(o10), o10 = null), e10.apply(null, l10);
  };
  return [(...l10) => {
    const u10 = Date.now(), d6 = u10 - r10;
    d6 >= n10 ? s10(l10, u10) : (i10 = l10, o10 || (o10 = setTimeout(() => {
      o10 = null, s10(i10);
    }, n10 - d6)));
  }, () => i10 && s10(i10)];
}
var Bc = (e10, t10, r10 = 3) => {
  let n10 = 0;
  const i10 = f5(50, 250);
  return d5((o10) => {
    const s10 = o10.loaded, a10 = o10.lengthComputable ? o10.total : void 0, c = s10 - n10, l10 = i10(c), u10 = s10 <= a10;
    n10 = s10;
    const d6 = {
      loaded: s10,
      total: a10,
      progress: a10 ? s10 / a10 : void 0,
      bytes: c,
      rate: l10 || void 0,
      estimated: l10 && a10 && u10 ? (a10 - s10) / l10 : void 0,
      event: o10,
      lengthComputable: a10 != null,
      [t10 ? "download" : "upload"]: true
    };
    e10(d6);
  }, r10);
};
var Ph = (e10, t10) => {
  const r10 = e10 != null;
  return [(n10) => t10[0]({
    lengthComputable: r10,
    total: e10,
    loaded: n10
  }), t10[1]];
};
var Nh = (e10) => (...t10) => ce.asap(() => e10(...t10));
var h5 = kr.hasStandardBrowserEnv ? /* @__PURE__ */ ((e10, t10) => (r10) => (r10 = new URL(r10, kr.origin), e10.protocol === r10.protocol && e10.host === r10.host && (t10 || e10.port === r10.port)))(
  new URL(kr.origin),
  kr.navigator && /(msie|trident)/i.test(kr.navigator.userAgent)
) : () => true;
var p5 = kr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e10, t10, r10, n10, i10, o10) {
      const s10 = [e10 + "=" + encodeURIComponent(t10)];
      ce.isNumber(r10) && s10.push("expires=" + new Date(r10).toGMTString()), ce.isString(n10) && s10.push("path=" + n10), ce.isString(i10) && s10.push("domain=" + i10), o10 === true && s10.push("secure"), document.cookie = s10.join("; ");
    },
    read(e10) {
      const t10 = document.cookie.match(new RegExp("(^|;\\s*)(" + e10 + ")=([^;]*)"));
      return t10 ? decodeURIComponent(t10[3]) : null;
    },
    remove(e10) {
      this.write(e10, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function m5(e10) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e10);
}
function g5(e10, t10) {
  return t10 ? e10.replace(/\/?\/$/, "") + "/" + t10.replace(/^\/+/, "") : e10;
}
function N1(e10, t10, r10) {
  let n10 = !m5(t10);
  return e10 && (n10 || r10 == false) ? g5(e10, t10) : t10;
}
var jh = (e10) => e10 instanceof Pn ? { ...e10 } : e10;
function ko(e10, t10) {
  t10 = t10 || {};
  const r10 = {};
  function n10(l10, u10, d6, p) {
    return ce.isPlainObject(l10) && ce.isPlainObject(u10) ? ce.merge.call({ caseless: p }, l10, u10) : ce.isPlainObject(u10) ? ce.merge({}, u10) : ce.isArray(u10) ? u10.slice() : u10;
  }
  function i10(l10, u10, d6, p) {
    if (ce.isUndefined(u10)) {
      if (!ce.isUndefined(l10))
        return n10(void 0, l10, d6, p);
    } else
      return n10(l10, u10, d6, p);
  }
  function o10(l10, u10) {
    if (!ce.isUndefined(u10))
      return n10(void 0, u10);
  }
  function s10(l10, u10) {
    if (ce.isUndefined(u10)) {
      if (!ce.isUndefined(l10))
        return n10(void 0, l10);
    } else
      return n10(void 0, u10);
  }
  function a10(l10, u10, d6) {
    if (d6 in t10)
      return n10(l10, u10);
    if (d6 in e10)
      return n10(void 0, l10);
  }
  const c = {
    url: o10,
    method: o10,
    data: o10,
    baseURL: s10,
    transformRequest: s10,
    transformResponse: s10,
    paramsSerializer: s10,
    timeout: s10,
    timeoutMessage: s10,
    withCredentials: s10,
    withXSRFToken: s10,
    adapter: s10,
    responseType: s10,
    xsrfCookieName: s10,
    xsrfHeaderName: s10,
    onUploadProgress: s10,
    onDownloadProgress: s10,
    decompress: s10,
    maxContentLength: s10,
    maxBodyLength: s10,
    beforeRedirect: s10,
    transport: s10,
    httpAgent: s10,
    httpsAgent: s10,
    cancelToken: s10,
    socketPath: s10,
    responseEncoding: s10,
    validateStatus: a10,
    headers: (l10, u10, d6) => i10(jh(l10), jh(u10), d6, true)
  };
  return ce.forEach(Object.keys(Object.assign({}, e10, t10)), function(u10) {
    const d6 = c[u10] || i10, p = d6(e10[u10], t10[u10], u10);
    ce.isUndefined(p) && d6 !== a10 || (r10[u10] = p);
  }), r10;
}
var j1 = (e10) => {
  const t10 = ko({}, e10);
  let { data: r10, withXSRFToken: n10, xsrfHeaderName: i10, xsrfCookieName: o10, headers: s10, auth: a10 } = t10;
  t10.headers = s10 = Pn.from(s10), t10.url = M1(N1(t10.baseURL, t10.url, t10.allowAbsoluteUrls), e10.params, e10.paramsSerializer), a10 && s10.set(
    "Authorization",
    "Basic " + btoa((a10.username || "") + ":" + (a10.password ? unescape(encodeURIComponent(a10.password)) : ""))
  );
  let c;
  if (ce.isFormData(r10)) {
    if (kr.hasStandardBrowserEnv || kr.hasStandardBrowserWebWorkerEnv)
      s10.setContentType(void 0);
    else if ((c = s10.getContentType()) !== false) {
      const [l10, ...u10] = c ? c.split(";").map((d6) => d6.trim()).filter(Boolean) : [];
      s10.setContentType([l10 || "multipart/form-data", ...u10].join("; "));
    }
  }
  if (kr.hasStandardBrowserEnv && (n10 && ce.isFunction(n10) && (n10 = n10(t10)), n10 || n10 !== false && h5(t10.url))) {
    const l10 = i10 && o10 && p5.read(o10);
    l10 && s10.set(i10, l10);
  }
  return t10;
};
var v5 = typeof XMLHttpRequest < "u";
var b5 = v5 && function(e10) {
  return new Promise(function(r10, n10) {
    const i10 = j1(e10);
    let o10 = i10.data;
    const s10 = Pn.from(i10.headers).normalize();
    let { responseType: a10, onUploadProgress: c, onDownloadProgress: l10 } = i10, u10, d6, p, y, x;
    function b() {
      y && y(), x && x(), i10.cancelToken && i10.cancelToken.unsubscribe(u10), i10.signal && i10.signal.removeEventListener("abort", u10);
    }
    let M = new XMLHttpRequest();
    M.open(i10.method.toUpperCase(), i10.url, true), M.timeout = i10.timeout;
    function O() {
      if (!M)
        return;
      const j = Pn.from(
        "getAllResponseHeaders" in M && M.getAllResponseHeaders()
      ), B = {
        data: !a10 || a10 === "text" || a10 === "json" ? M.responseText : M.response,
        status: M.status,
        statusText: M.statusText,
        headers: j,
        config: e10,
        request: M
      };
      P1(function(z) {
        r10(z), b();
      }, function(z) {
        n10(z), b();
      }, B), M = null;
    }
    "onloadend" in M ? M.onloadend = O : M.onreadystatechange = function() {
      !M || M.readyState !== 4 || M.status === 0 && !(M.responseURL && M.responseURL.indexOf("file:") === 0) || setTimeout(O);
    }, M.onabort = function() {
      M && (n10(new dt("Request aborted", dt.ECONNABORTED, e10, M)), M = null);
    }, M.onerror = function() {
      n10(new dt("Network Error", dt.ERR_NETWORK, e10, M)), M = null;
    }, M.ontimeout = function() {
      let F = i10.timeout ? "timeout of " + i10.timeout + "ms exceeded" : "timeout exceeded";
      const B = i10.transitional || I1;
      i10.timeoutErrorMessage && (F = i10.timeoutErrorMessage), n10(new dt(
        F,
        B.clarifyTimeoutError ? dt.ETIMEDOUT : dt.ECONNABORTED,
        e10,
        M
      )), M = null;
    }, o10 === void 0 && s10.setContentType(null), "setRequestHeader" in M && ce.forEach(s10.toJSON(), function(F, B) {
      M.setRequestHeader(B, F);
    }), ce.isUndefined(i10.withCredentials) || (M.withCredentials = !!i10.withCredentials), a10 && a10 !== "json" && (M.responseType = i10.responseType), l10 && ([p, x] = Bc(l10, true), M.addEventListener("progress", p)), c && M.upload && ([d6, y] = Bc(c), M.upload.addEventListener("progress", d6), M.upload.addEventListener("loadend", y)), (i10.cancelToken || i10.signal) && (u10 = (j) => {
      M && (n10(!j || j.type ? new Os(null, e10, M) : j), M.abort(), M = null);
    }, i10.cancelToken && i10.cancelToken.subscribe(u10), i10.signal && (i10.signal.aborted ? u10() : i10.signal.addEventListener("abort", u10)));
    const P = u5(i10.url);
    if (P && kr.protocols.indexOf(P) === -1) {
      n10(new dt("Unsupported protocol " + P + ":", dt.ERR_BAD_REQUEST, e10));
      return;
    }
    M.send(o10 || null);
  });
};
var y5 = (e10, t10) => {
  const { length: r10 } = e10 = e10 ? e10.filter(Boolean) : [];
  if (t10 || r10) {
    let n10 = new AbortController(), i10;
    const o10 = function(l10) {
      if (!i10) {
        i10 = true, a10();
        const u10 = l10 instanceof Error ? l10 : this.reason;
        n10.abort(u10 instanceof dt ? u10 : new Os(u10 instanceof Error ? u10.message : u10));
      }
    };
    let s10 = t10 && setTimeout(() => {
      s10 = null, o10(new dt(`timeout ${t10} of ms exceeded`, dt.ETIMEDOUT));
    }, t10);
    const a10 = () => {
      e10 && (s10 && clearTimeout(s10), s10 = null, e10.forEach((l10) => {
        l10.unsubscribe ? l10.unsubscribe(o10) : l10.removeEventListener("abort", o10);
      }), e10 = null);
    };
    e10.forEach((l10) => l10.addEventListener("abort", o10));
    const { signal: c } = n10;
    return c.unsubscribe = () => ce.asap(a10), c;
  }
};
var w5 = y5;
var x5 = function* (e10, t10) {
  let r10 = e10.byteLength;
  if (!t10 || r10 < t10) {
    yield e10;
    return;
  }
  let n10 = 0, i10;
  for (; n10 < r10; )
    i10 = n10 + t10, yield e10.slice(n10, i10), n10 = i10;
};
var S5 = async function* (e10, t10) {
  for await (const r10 of _5(e10))
    yield* x5(r10, t10);
};
var _5 = async function* (e10) {
  if (e10[Symbol.asyncIterator]) {
    yield* e10;
    return;
  }
  const t10 = e10.getReader();
  try {
    for (; ; ) {
      const { done: r10, value: n10 } = await t10.read();
      if (r10)
        break;
      yield n10;
    }
  } finally {
    await t10.cancel();
  }
};
var kh = (e10, t10, r10, n10) => {
  const i10 = S5(e10, t10);
  let o10 = 0, s10, a10 = (c) => {
    s10 || (s10 = true, n10 && n10(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: l10, value: u10 } = await i10.next();
        if (l10) {
          a10(), c.close();
          return;
        }
        let d6 = u10.byteLength;
        if (r10) {
          let p = o10 += d6;
          r10(p);
        }
        c.enqueue(new Uint8Array(u10));
      } catch (l10) {
        throw a10(l10), l10;
      }
    },
    cancel(c) {
      return a10(c), i10.return();
    }
  }, {
    highWaterMark: 2
  });
};
var _l = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function";
var k1 = _l && typeof ReadableStream == "function";
var E5 = _l && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e10) => (t10) => e10.encode(t10))(new TextEncoder()) : async (e10) => new Uint8Array(await new Response(e10).arrayBuffer()));
var D1 = (e10, ...t10) => {
  try {
    return !!e10(...t10);
  } catch {
    return false;
  }
};
var C5 = k1 && D1(() => {
  let e10 = false;
  const t10 = new Request(kr.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e10 = true, "half";
    }
  }).headers.has("Content-Type");
  return e10 && !t10;
});
var Dh = 64 * 1024;
var jf = k1 && D1(() => ce.isReadableStream(new Response("").body));
var Uc = {
  stream: jf && ((e10) => e10.body)
};
_l && ((e10) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t10) => {
    !Uc[t10] && (Uc[t10] = ce.isFunction(e10[t10]) ? (r10) => r10[t10]() : (r10, n10) => {
      throw new dt(`Response type '${t10}' is not supported`, dt.ERR_NOT_SUPPORT, n10);
    });
  });
})(new Response());
var T5 = async (e10) => {
  if (e10 == null)
    return 0;
  if (ce.isBlob(e10))
    return e10.size;
  if (ce.isSpecCompliantForm(e10))
    return (await new Request(kr.origin, {
      method: "POST",
      body: e10
    }).arrayBuffer()).byteLength;
  if (ce.isArrayBufferView(e10) || ce.isArrayBuffer(e10))
    return e10.byteLength;
  if (ce.isURLSearchParams(e10) && (e10 = e10 + ""), ce.isString(e10))
    return (await E5(e10)).byteLength;
};
var A5 = async (e10, t10) => {
  const r10 = ce.toFiniteNumber(e10.getContentLength());
  return r10 ?? T5(t10);
};
var M5 = _l && (async (e10) => {
  let {
    url: t10,
    method: r10,
    data: n10,
    signal: i10,
    cancelToken: o10,
    timeout: s10,
    onDownloadProgress: a10,
    onUploadProgress: c,
    responseType: l10,
    headers: u10,
    withCredentials: d6 = "same-origin",
    fetchOptions: p
  } = j1(e10);
  l10 = l10 ? (l10 + "").toLowerCase() : "text";
  let y = w5([i10, o10 && o10.toAbortSignal()], s10), x;
  const b = y && y.unsubscribe && (() => {
    y.unsubscribe();
  });
  let M;
  try {
    if (c && C5 && r10 !== "get" && r10 !== "head" && (M = await A5(u10, n10)) !== 0) {
      let B = new Request(t10, {
        method: "POST",
        body: n10,
        duplex: "half"
      }), W;
      if (ce.isFormData(n10) && (W = B.headers.get("content-type")) && u10.setContentType(W), B.body) {
        const [z, G] = Ph(
          M,
          Bc(Nh(c))
        );
        n10 = kh(B.body, Dh, z, G);
      }
    }
    ce.isString(d6) || (d6 = d6 ? "include" : "omit");
    const O = "credentials" in Request.prototype;
    x = new Request(t10, {
      ...p,
      signal: y,
      method: r10.toUpperCase(),
      headers: u10.normalize().toJSON(),
      body: n10,
      duplex: "half",
      credentials: O ? d6 : void 0
    });
    let P = await fetch(x);
    const j = jf && (l10 === "stream" || l10 === "response");
    if (jf && (a10 || j && b)) {
      const B = {};
      ["status", "statusText", "headers"].forEach((re) => {
        B[re] = P[re];
      });
      const W = ce.toFiniteNumber(P.headers.get("content-length")), [z, G] = a10 && Ph(
        W,
        Bc(Nh(a10), true)
      ) || [];
      P = new Response(
        kh(P.body, Dh, z, () => {
          G && G(), b && b();
        }),
        B
      );
    }
    l10 = l10 || "text";
    let F = await Uc[ce.findKey(Uc, l10) || "text"](P, e10);
    return !j && b && b(), await new Promise((B, W) => {
      P1(B, W, {
        data: F,
        headers: Pn.from(P.headers),
        status: P.status,
        statusText: P.statusText,
        config: e10,
        request: x
      });
    });
  } catch (O) {
    throw b && b(), O && O.name === "TypeError" && /fetch/i.test(O.message) ? Object.assign(
      new dt("Network Error", dt.ERR_NETWORK, e10, x),
      {
        cause: O.cause || O
      }
    ) : dt.from(O, O && O.code, e10, x);
  }
});
var kf = {
  http: $x,
  xhr: b5,
  fetch: M5
};
ce.forEach(kf, (e10, t10) => {
  if (e10) {
    try {
      Object.defineProperty(e10, "name", { value: t10 });
    } catch {
    }
    Object.defineProperty(e10, "adapterName", { value: t10 });
  }
});
var Lh = (e10) => `- ${e10}`;
var I5 = (e10) => ce.isFunction(e10) || e10 === null || e10 === false;
var L1 = {
  getAdapter: (e10) => {
    e10 = ce.isArray(e10) ? e10 : [e10];
    const { length: t10 } = e10;
    let r10, n10;
    const i10 = {};
    for (let o10 = 0; o10 < t10; o10++) {
      r10 = e10[o10];
      let s10;
      if (n10 = r10, !I5(r10) && (n10 = kf[(s10 = String(r10)).toLowerCase()], n10 === void 0))
        throw new dt(`Unknown adapter '${s10}'`);
      if (n10)
        break;
      i10[s10 || "#" + o10] = n10;
    }
    if (!n10) {
      const o10 = Object.entries(i10).map(
        ([a10, c]) => `adapter ${a10} ` + (c === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s10 = t10 ? o10.length > 1 ? `since :
` + o10.map(Lh).join(`
`) : " " + Lh(o10[0]) : "as no adapter specified";
      throw new dt(
        "There is no suitable adapter to dispatch the request " + s10,
        "ERR_NOT_SUPPORT"
      );
    }
    return n10;
  },
  adapters: kf
};
function Mu(e10) {
  if (e10.cancelToken && e10.cancelToken.throwIfRequested(), e10.signal && e10.signal.aborted)
    throw new Os(null, e10);
}
function Bh(e10) {
  return Mu(e10), e10.headers = Pn.from(e10.headers), e10.data = Au.call(
    e10,
    e10.transformRequest
  ), ["post", "put", "patch"].indexOf(e10.method) !== -1 && e10.headers.setContentType("application/x-www-form-urlencoded", false), L1.getAdapter(e10.adapter || Ld.adapter)(e10).then(function(n10) {
    return Mu(e10), n10.data = Au.call(
      e10,
      e10.transformResponse,
      n10
    ), n10.headers = Pn.from(n10.headers), n10;
  }, function(n10) {
    return R1(n10) || (Mu(e10), n10 && n10.response && (n10.response.data = Au.call(
      e10,
      e10.transformResponse,
      n10.response
    ), n10.response.headers = Pn.from(n10.response.headers))), Promise.reject(n10);
  });
}
var B1 = "1.8.4";
var El = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e10, t10) => {
  El[e10] = function(n10) {
    return typeof n10 === e10 || "a" + (t10 < 1 ? "n " : " ") + e10;
  };
});
var Uh = {};
El.transitional = function(t10, r10, n10) {
  function i10(o10, s10) {
    return "[Axios v" + B1 + "] Transitional option '" + o10 + "'" + s10 + (n10 ? ". " + n10 : "");
  }
  return (o10, s10, a10) => {
    if (t10 === false)
      throw new dt(
        i10(s10, " has been removed" + (r10 ? " in " + r10 : "")),
        dt.ERR_DEPRECATED
      );
    return r10 && !Uh[s10] && (Uh[s10] = true, console.warn(
      i10(
        s10,
        " has been deprecated since v" + r10 + " and will be removed in the near future"
      )
    )), t10 ? t10(o10, s10, a10) : true;
  };
};
El.spelling = function(t10) {
  return (r10, n10) => (console.warn(`${n10} is likely a misspelling of ${t10}`), true);
};
function O5(e10, t10, r10) {
  if (typeof e10 != "object")
    throw new dt("options must be an object", dt.ERR_BAD_OPTION_VALUE);
  const n10 = Object.keys(e10);
  let i10 = n10.length;
  for (; i10-- > 0; ) {
    const o10 = n10[i10], s10 = t10[o10];
    if (s10) {
      const a10 = e10[o10], c = a10 === void 0 || s10(a10, o10, e10);
      if (c !== true)
        throw new dt("option " + o10 + " must be " + c, dt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r10 !== true)
      throw new dt("Unknown option " + o10, dt.ERR_BAD_OPTION);
  }
}
var vc = {
  assertOptions: O5,
  validators: El
};
var Vn = vc.validators;
var Fc = class {
  constructor(t10) {
    this.defaults = t10, this.interceptors = {
      request: new Oh(),
      response: new Oh()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t10, r10) {
    try {
      return await this._request(t10, r10);
    } catch (n10) {
      if (n10 instanceof Error) {
        let i10 = {};
        Error.captureStackTrace ? Error.captureStackTrace(i10) : i10 = new Error();
        const o10 = i10.stack ? i10.stack.replace(/^.+\n/, "") : "";
        try {
          n10.stack ? o10 && !String(n10.stack).endsWith(o10.replace(/^.+\n.+\n/, "")) && (n10.stack += `
` + o10) : n10.stack = o10;
        } catch {
        }
      }
      throw n10;
    }
  }
  _request(t10, r10) {
    typeof t10 == "string" ? (r10 = r10 || {}, r10.url = t10) : r10 = t10 || {}, r10 = ko(this.defaults, r10);
    const { transitional: n10, paramsSerializer: i10, headers: o10 } = r10;
    n10 !== void 0 && vc.assertOptions(n10, {
      silentJSONParsing: Vn.transitional(Vn.boolean),
      forcedJSONParsing: Vn.transitional(Vn.boolean),
      clarifyTimeoutError: Vn.transitional(Vn.boolean)
    }, false), i10 != null && (ce.isFunction(i10) ? r10.paramsSerializer = {
      serialize: i10
    } : vc.assertOptions(i10, {
      encode: Vn.function,
      serialize: Vn.function
    }, true)), r10.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r10.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r10.allowAbsoluteUrls = true), vc.assertOptions(r10, {
      baseUrl: Vn.spelling("baseURL"),
      withXsrfToken: Vn.spelling("withXSRFToken")
    }, true), r10.method = (r10.method || this.defaults.method || "get").toLowerCase();
    let s10 = o10 && ce.merge(
      o10.common,
      o10[r10.method]
    );
    o10 && ce.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (x) => {
        delete o10[x];
      }
    ), r10.headers = Pn.concat(s10, o10);
    const a10 = [];
    let c = true;
    this.interceptors.request.forEach(function(b) {
      typeof b.runWhen == "function" && b.runWhen(r10) === false || (c = c && b.synchronous, a10.unshift(b.fulfilled, b.rejected));
    });
    const l10 = [];
    this.interceptors.response.forEach(function(b) {
      l10.push(b.fulfilled, b.rejected);
    });
    let u10, d6 = 0, p;
    if (!c) {
      const x = [Bh.bind(this), void 0];
      for (x.unshift.apply(x, a10), x.push.apply(x, l10), p = x.length, u10 = Promise.resolve(r10); d6 < p; )
        u10 = u10.then(x[d6++], x[d6++]);
      return u10;
    }
    p = a10.length;
    let y = r10;
    for (d6 = 0; d6 < p; ) {
      const x = a10[d6++], b = a10[d6++];
      try {
        y = x(y);
      } catch (M) {
        b.call(this, M);
        break;
      }
    }
    try {
      u10 = Bh.call(this, y);
    } catch (x) {
      return Promise.reject(x);
    }
    for (d6 = 0, p = l10.length; d6 < p; )
      u10 = u10.then(l10[d6++], l10[d6++]);
    return u10;
  }
  getUri(t10) {
    t10 = ko(this.defaults, t10);
    const r10 = N1(t10.baseURL, t10.url, t10.allowAbsoluteUrls);
    return M1(r10, t10.params, t10.paramsSerializer);
  }
};
ce.forEach(["delete", "get", "head", "options"], function(t10) {
  Fc.prototype[t10] = function(r10, n10) {
    return this.request(ko(n10 || {}, {
      method: t10,
      url: r10,
      data: (n10 || {}).data
    }));
  };
});
ce.forEach(["post", "put", "patch"], function(t10) {
  function r10(n10) {
    return function(o10, s10, a10) {
      return this.request(ko(a10 || {}, {
        method: t10,
        headers: n10 ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o10,
        data: s10
      }));
    };
  }
  Fc.prototype[t10] = r10(), Fc.prototype[t10 + "Form"] = r10(true);
});
var bc = Fc;
var Bd = class _Bd {
  constructor(t10) {
    if (typeof t10 != "function")
      throw new TypeError("executor must be a function.");
    let r10;
    this.promise = new Promise(function(o10) {
      r10 = o10;
    });
    const n10 = this;
    this.promise.then((i10) => {
      if (!n10._listeners)
        return;
      let o10 = n10._listeners.length;
      for (; o10-- > 0; )
        n10._listeners[o10](i10);
      n10._listeners = null;
    }), this.promise.then = (i10) => {
      let o10;
      const s10 = new Promise((a10) => {
        n10.subscribe(a10), o10 = a10;
      }).then(i10);
      return s10.cancel = function() {
        n10.unsubscribe(o10);
      }, s10;
    }, t10(function(o10, s10, a10) {
      n10.reason || (n10.reason = new Os(o10, s10, a10), r10(n10.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t10) {
    if (this.reason) {
      t10(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t10) : this._listeners = [t10];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t10) {
    if (!this._listeners)
      return;
    const r10 = this._listeners.indexOf(t10);
    r10 !== -1 && this._listeners.splice(r10, 1);
  }
  toAbortSignal() {
    const t10 = new AbortController(), r10 = (n10) => {
      t10.abort(n10);
    };
    return this.subscribe(r10), t10.signal.unsubscribe = () => this.unsubscribe(r10), t10.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t10;
    return {
      token: new _Bd(function(i10) {
        t10 = i10;
      }),
      cancel: t10
    };
  }
};
var R5 = Bd;
function P5(e10) {
  return function(r10) {
    return e10.apply(null, r10);
  };
}
function N5(e10) {
  return ce.isObject(e10) && e10.isAxiosError === true;
}
var Df = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Df).forEach(([e10, t10]) => {
  Df[t10] = e10;
});
var j5 = Df;
function U1(e10) {
  const t10 = new bc(e10), r10 = v1(bc.prototype.request, t10);
  return ce.extend(r10, bc.prototype, t10, { allOwnKeys: true }), ce.extend(r10, t10, null, { allOwnKeys: true }), r10.create = function(i10) {
    return U1(ko(e10, i10));
  }, r10;
}
var gr = U1(Ld);
gr.Axios = bc;
gr.CanceledError = Os;
gr.CancelToken = R5;
gr.isCancel = R1;
gr.VERSION = B1;
gr.toFormData = xl;
gr.AxiosError = dt;
gr.Cancel = gr.CanceledError;
gr.all = function(t10) {
  return Promise.all(t10);
};
gr.spread = P5;
gr.isAxiosError = N5;
gr.mergeConfig = ko;
gr.AxiosHeaders = Pn;
gr.formToJSON = (e10) => O1(ce.isHTMLForm(e10) ? new FormData(e10) : e10);
gr.getAdapter = L1.getAdapter;
gr.HttpStatusCode = j5;
gr.default = gr;
var F1 = gr;
var Ud = { exports: {} };
var sn = {};
var $1 = { exports: {} };
(function(e10) {
  function t10(r10) {
    return r10 && r10.__esModule ? r10 : {
      default: r10
    };
  }
  e10.exports = t10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
})($1);
var k5 = $1.exports;
var Iu = { exports: {} };
var Ou = { exports: {} };
var Fh;
function Cl() {
  return Fh || (Fh = 1, function(e10) {
    function t10(r10) {
      "@babel/helpers - typeof";
      return e10.exports = t10 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n10) {
        return typeof n10;
      } : function(n10) {
        return n10 && typeof Symbol == "function" && n10.constructor === Symbol && n10 !== Symbol.prototype ? "symbol" : typeof n10;
      }, e10.exports.__esModule = true, e10.exports.default = e10.exports, t10(r10);
    }
    e10.exports = t10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
  }(Ou)), Ou.exports;
}
var $h;
function D5() {
  return $h || ($h = 1, function(e10) {
    var t10 = Cl().default;
    function r10() {
      e10.exports = r10 = function() {
        return i10;
      }, e10.exports.__esModule = true, e10.exports.default = e10.exports;
      var n10, i10 = {}, o10 = Object.prototype, s10 = o10.hasOwnProperty, a10 = Object.defineProperty || function(E, I, C) {
        E[I] = C.value;
      }, c = typeof Symbol == "function" ? Symbol : {}, l10 = c.iterator || "@@iterator", u10 = c.asyncIterator || "@@asyncIterator", d6 = c.toStringTag || "@@toStringTag";
      function p(E, I, C) {
        return Object.defineProperty(E, I, {
          value: C,
          enumerable: true,
          configurable: true,
          writable: true
        }), E[I];
      }
      try {
        p({}, "");
      } catch {
        p = function(C, g, v10) {
          return C[g] = v10;
        };
      }
      function y(E, I, C, g) {
        var v10 = I && I.prototype instanceof F ? I : F, k = Object.create(v10.prototype), Q = new S(g || []);
        return a10(k, "_invoke", {
          value: L(E, C, Q)
        }), k;
      }
      function x(E, I, C) {
        try {
          return {
            type: "normal",
            arg: E.call(I, C)
          };
        } catch (g) {
          return {
            type: "throw",
            arg: g
          };
        }
      }
      i10.wrap = y;
      var b = "suspendedStart", M = "suspendedYield", O = "executing", P = "completed", j = {};
      function F() {
      }
      function B() {
      }
      function W() {
      }
      var z = {};
      p(z, l10, function() {
        return this;
      });
      var G = Object.getPrototypeOf, re = G && G(G(T([])));
      re && re !== o10 && s10.call(re, l10) && (z = re);
      var ie = W.prototype = F.prototype = Object.create(z);
      function oe(E) {
        ["next", "throw", "return"].forEach(function(I) {
          p(E, I, function(C) {
            return this._invoke(I, C);
          });
        });
      }
      function q(E, I) {
        function C(v10, k, Q, Z) {
          var ae = x(E[v10], E, k);
          if (ae.type !== "throw") {
            var ve = ae.arg, we = ve.value;
            return we && t10(we) == "object" && s10.call(we, "__await") ? I.resolve(we.__await).then(function(he) {
              C("next", he, Q, Z);
            }, function(he) {
              C("throw", he, Q, Z);
            }) : I.resolve(we).then(function(he) {
              ve.value = he, Q(ve);
            }, function(he) {
              return C("throw", he, Q, Z);
            });
          }
          Z(ae.arg);
        }
        var g;
        a10(this, "_invoke", {
          value: function(k, Q) {
            function Z() {
              return new I(function(ae, ve) {
                C(k, Q, ae, ve);
              });
            }
            return g = g ? g.then(Z, Z) : Z();
          }
        });
      }
      function L(E, I, C) {
        var g = b;
        return function(v10, k) {
          if (g === O)
            throw Error("Generator is already running");
          if (g === P) {
            if (v10 === "throw")
              throw k;
            return {
              value: n10,
              done: true
            };
          }
          for (C.method = v10, C.arg = k; ; ) {
            var Q = C.delegate;
            if (Q) {
              var Z = h(Q, C);
              if (Z) {
                if (Z === j)
                  continue;
                return Z;
              }
            }
            if (C.method === "next")
              C.sent = C._sent = C.arg;
            else if (C.method === "throw") {
              if (g === b)
                throw g = P, C.arg;
              C.dispatchException(C.arg);
            } else
              C.method === "return" && C.abrupt("return", C.arg);
            g = O;
            var ae = x(E, I, C);
            if (ae.type === "normal") {
              if (g = C.done ? P : M, ae.arg === j)
                continue;
              return {
                value: ae.arg,
                done: C.done
              };
            }
            ae.type === "throw" && (g = P, C.method = "throw", C.arg = ae.arg);
          }
        };
      }
      function h(E, I) {
        var C = I.method, g = E.iterator[C];
        if (g === n10)
          return I.delegate = null, C === "throw" && E.iterator.return && (I.method = "return", I.arg = n10, h(E, I), I.method === "throw") || C !== "return" && (I.method = "throw", I.arg = new TypeError("The iterator does not provide a '" + C + "' method")), j;
        var v10 = x(g, E.iterator, I.arg);
        if (v10.type === "throw")
          return I.method = "throw", I.arg = v10.arg, I.delegate = null, j;
        var k = v10.arg;
        return k ? k.done ? (I[E.resultName] = k.value, I.next = E.nextLoc, I.method !== "return" && (I.method = "next", I.arg = n10), I.delegate = null, j) : k : (I.method = "throw", I.arg = new TypeError("iterator result is not an object"), I.delegate = null, j);
      }
      function f(E) {
        var I = {
          tryLoc: E[0]
        };
        1 in E && (I.catchLoc = E[1]), 2 in E && (I.finallyLoc = E[2], I.afterLoc = E[3]), this.tryEntries.push(I);
      }
      function m(E) {
        var I = E.completion || {};
        I.type = "normal", delete I.arg, E.completion = I;
      }
      function S(E) {
        this.tryEntries = [{
          tryLoc: "root"
        }], E.forEach(f, this), this.reset(true);
      }
      function T(E) {
        if (E || E === "") {
          var I = E[l10];
          if (I)
            return I.call(E);
          if (typeof E.next == "function")
            return E;
          if (!isNaN(E.length)) {
            var C = -1, g = function v10() {
              for (; ++C < E.length; )
                if (s10.call(E, C))
                  return v10.value = E[C], v10.done = false, v10;
              return v10.value = n10, v10.done = true, v10;
            };
            return g.next = g;
          }
        }
        throw new TypeError(t10(E) + " is not iterable");
      }
      return B.prototype = W, a10(ie, "constructor", {
        value: W,
        configurable: true
      }), a10(W, "constructor", {
        value: B,
        configurable: true
      }), B.displayName = p(W, d6, "GeneratorFunction"), i10.isGeneratorFunction = function(E) {
        var I = typeof E == "function" && E.constructor;
        return !!I && (I === B || (I.displayName || I.name) === "GeneratorFunction");
      }, i10.mark = function(E) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(E, W) : (E.__proto__ = W, p(E, d6, "GeneratorFunction")), E.prototype = Object.create(ie), E;
      }, i10.awrap = function(E) {
        return {
          __await: E
        };
      }, oe(q.prototype), p(q.prototype, u10, function() {
        return this;
      }), i10.AsyncIterator = q, i10.async = function(E, I, C, g, v10) {
        v10 === void 0 && (v10 = Promise);
        var k = new q(y(E, I, C, g), v10);
        return i10.isGeneratorFunction(I) ? k : k.next().then(function(Q) {
          return Q.done ? Q.value : k.next();
        });
      }, oe(ie), p(ie, d6, "Generator"), p(ie, l10, function() {
        return this;
      }), p(ie, "toString", function() {
        return "[object Generator]";
      }), i10.keys = function(E) {
        var I = Object(E), C = [];
        for (var g in I)
          C.push(g);
        return C.reverse(), function v10() {
          for (; C.length; ) {
            var k = C.pop();
            if (k in I)
              return v10.value = k, v10.done = false, v10;
          }
          return v10.done = true, v10;
        };
      }, i10.values = T, S.prototype = {
        constructor: S,
        reset: function(I) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = n10, this.done = false, this.delegate = null, this.method = "next", this.arg = n10, this.tryEntries.forEach(m), !I)
            for (var C in this)
              C.charAt(0) === "t" && s10.call(this, C) && !isNaN(+C.slice(1)) && (this[C] = n10);
        },
        stop: function() {
          this.done = true;
          var I = this.tryEntries[0].completion;
          if (I.type === "throw")
            throw I.arg;
          return this.rval;
        },
        dispatchException: function(I) {
          if (this.done)
            throw I;
          var C = this;
          function g(ve, we) {
            return Q.type = "throw", Q.arg = I, C.next = ve, we && (C.method = "next", C.arg = n10), !!we;
          }
          for (var v10 = this.tryEntries.length - 1; v10 >= 0; --v10) {
            var k = this.tryEntries[v10], Q = k.completion;
            if (k.tryLoc === "root")
              return g("end");
            if (k.tryLoc <= this.prev) {
              var Z = s10.call(k, "catchLoc"), ae = s10.call(k, "finallyLoc");
              if (Z && ae) {
                if (this.prev < k.catchLoc)
                  return g(k.catchLoc, true);
                if (this.prev < k.finallyLoc)
                  return g(k.finallyLoc);
              } else if (Z) {
                if (this.prev < k.catchLoc)
                  return g(k.catchLoc, true);
              } else {
                if (!ae)
                  throw Error("try statement without catch or finally");
                if (this.prev < k.finallyLoc)
                  return g(k.finallyLoc);
              }
            }
          }
        },
        abrupt: function(I, C) {
          for (var g = this.tryEntries.length - 1; g >= 0; --g) {
            var v10 = this.tryEntries[g];
            if (v10.tryLoc <= this.prev && s10.call(v10, "finallyLoc") && this.prev < v10.finallyLoc) {
              var k = v10;
              break;
            }
          }
          k && (I === "break" || I === "continue") && k.tryLoc <= C && C <= k.finallyLoc && (k = null);
          var Q = k ? k.completion : {};
          return Q.type = I, Q.arg = C, k ? (this.method = "next", this.next = k.finallyLoc, j) : this.complete(Q);
        },
        complete: function(I, C) {
          if (I.type === "throw")
            throw I.arg;
          return I.type === "break" || I.type === "continue" ? this.next = I.arg : I.type === "return" ? (this.rval = this.arg = I.arg, this.method = "return", this.next = "end") : I.type === "normal" && C && (this.next = C), j;
        },
        finish: function(I) {
          for (var C = this.tryEntries.length - 1; C >= 0; --C) {
            var g = this.tryEntries[C];
            if (g.finallyLoc === I)
              return this.complete(g.completion, g.afterLoc), m(g), j;
          }
        },
        catch: function(I) {
          for (var C = this.tryEntries.length - 1; C >= 0; --C) {
            var g = this.tryEntries[C];
            if (g.tryLoc === I) {
              var v10 = g.completion;
              if (v10.type === "throw") {
                var k = v10.arg;
                m(g);
              }
              return k;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function(I, C, g) {
          return this.delegate = {
            iterator: T(I),
            resultName: C,
            nextLoc: g
          }, this.method === "next" && (this.arg = n10), j;
        }
      }, i10;
    }
    e10.exports = r10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
  }(Iu)), Iu.exports;
}
var Ru;
var Vh;
function L5() {
  if (Vh)
    return Ru;
  Vh = 1;
  var e10 = D5()();
  Ru = e10;
  try {
    regeneratorRuntime = e10;
  } catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = e10 : Function("r", "regeneratorRuntime = r")(e10);
  }
  return Ru;
}
var Pu = { exports: {} };
var zh;
function B5() {
  return zh || (zh = 1, function(e10) {
    function t10(n10, i10, o10, s10, a10, c, l10) {
      try {
        var u10 = n10[c](l10), d6 = u10.value;
      } catch (p) {
        return void o10(p);
      }
      u10.done ? i10(d6) : Promise.resolve(d6).then(s10, a10);
    }
    function r10(n10) {
      return function() {
        var i10 = this, o10 = arguments;
        return new Promise(function(s10, a10) {
          var c = n10.apply(i10, o10);
          function l10(d6) {
            t10(c, s10, a10, l10, u10, "next", d6);
          }
          function u10(d6) {
            t10(c, s10, a10, l10, u10, "throw", d6);
          }
          l10(void 0);
        });
      };
    }
    e10.exports = r10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
  }(Pu)), Pu.exports;
}
var Nu = { exports: {} };
var ju = { exports: {} };
var ku = { exports: {} };
var qh;
function U5() {
  return qh || (qh = 1, function(e10) {
    var t10 = Cl().default;
    function r10(n10, i10) {
      if (t10(n10) != "object" || !n10)
        return n10;
      var o10 = n10[Symbol.toPrimitive];
      if (o10 !== void 0) {
        var s10 = o10.call(n10, i10 || "default");
        if (t10(s10) != "object")
          return s10;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (i10 === "string" ? String : Number)(n10);
    }
    e10.exports = r10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
  }(ku)), ku.exports;
}
var Hh;
function F5() {
  return Hh || (Hh = 1, function(e10) {
    var t10 = Cl().default, r10 = U5();
    function n10(i10) {
      var o10 = r10(i10, "string");
      return t10(o10) == "symbol" ? o10 : o10 + "";
    }
    e10.exports = n10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
  }(ju)), ju.exports;
}
var Wh;
function $5() {
  return Wh || (Wh = 1, function(e10) {
    var t10 = F5();
    function r10(n10, i10, o10) {
      return (i10 = t10(i10)) in n10 ? Object.defineProperty(n10, i10, {
        value: o10,
        enumerable: true,
        configurable: true,
        writable: true
      }) : n10[i10] = o10, n10;
    }
    e10.exports = r10, e10.exports.__esModule = true, e10.exports.default = e10.exports;
  }(Nu)), Nu.exports;
}
var Du;
var Gh;
function V5() {
  if (Gh)
    return Du;
  Gh = 1;
  const e10 = /* @__PURE__ */ new Set([
    "ENOTFOUND",
    "ENETUNREACH",
    // SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328
    "UNABLE_TO_GET_ISSUER_CERT",
    "UNABLE_TO_GET_CRL",
    "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
    "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
    "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
    "CERT_SIGNATURE_FAILURE",
    "CRL_SIGNATURE_FAILURE",
    "CERT_NOT_YET_VALID",
    "CERT_HAS_EXPIRED",
    "CRL_NOT_YET_VALID",
    "CRL_HAS_EXPIRED",
    "ERROR_IN_CERT_NOT_BEFORE_FIELD",
    "ERROR_IN_CERT_NOT_AFTER_FIELD",
    "ERROR_IN_CRL_LAST_UPDATE_FIELD",
    "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
    "OUT_OF_MEM",
    "DEPTH_ZERO_SELF_SIGNED_CERT",
    "SELF_SIGNED_CERT_IN_CHAIN",
    "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
    "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
    "CERT_CHAIN_TOO_LONG",
    "CERT_REVOKED",
    "INVALID_CA",
    "PATH_LENGTH_EXCEEDED",
    "INVALID_PURPOSE",
    "CERT_UNTRUSTED",
    "CERT_REJECTED",
    "HOSTNAME_MISMATCH"
  ]);
  return Du = (t10) => !e10.has(t10 && t10.code), Du;
}
var Da = k5;
Object.defineProperty(sn, "__esModule", {
  value: true
});
sn.isNetworkError = $d;
sn.isRetryableError = Tl;
sn.isSafeRequestError = q1;
sn.isIdempotentRequestError = Vd;
sn.isNetworkOrIdempotentRequestError = zd;
sn.exponentialDelay = H1;
sn.default = $o;
sn.DEFAULT_OPTIONS = sn.namespace = void 0;
var $c = Da(L5());
var z5 = Da(Cl());
var V1 = Da(B5());
var q5 = Da($5());
var H5 = Da(V5());
function Kh(e10, t10) {
  var r10 = Object.keys(e10);
  if (Object.getOwnPropertySymbols) {
    var n10 = Object.getOwnPropertySymbols(e10);
    t10 && (n10 = n10.filter(function(i10) {
      return Object.getOwnPropertyDescriptor(e10, i10).enumerable;
    })), r10.push.apply(r10, n10);
  }
  return r10;
}
function Lu(e10) {
  for (var t10 = 1; t10 < arguments.length; t10++) {
    var r10 = arguments[t10] != null ? arguments[t10] : {};
    t10 % 2 ? Kh(Object(r10), true).forEach(function(n10) {
      (0, q5.default)(e10, n10, r10[n10]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(r10)) : Kh(Object(r10)).forEach(function(n10) {
      Object.defineProperty(e10, n10, Object.getOwnPropertyDescriptor(r10, n10));
    });
  }
  return e10;
}
var Fd = "axios-retry";
sn.namespace = Fd;
function $d(e10) {
  var t10 = ["ERR_CANCELED", "ECONNABORTED"];
  return !e10.response && !!e10.code && // Prevents retrying cancelled requests
  !t10.includes(e10.code) && // Prevents retrying timed out & cancelled requests
  (0, H5.default)(e10);
}
var z1 = ["get", "head", "options"];
var W5 = z1.concat(["put", "delete"]);
function Tl(e10) {
  return e10.code !== "ECONNABORTED" && (!e10.response || e10.response.status >= 500 && e10.response.status <= 599);
}
function q1(e10) {
  return e10.config ? Tl(e10) && z1.indexOf(e10.config.method) !== -1 : false;
}
function Vd(e10) {
  return e10.config ? Tl(e10) && W5.indexOf(e10.config.method) !== -1 : false;
}
function zd(e10) {
  return $d(e10) || Vd(e10);
}
function G5() {
  return 0;
}
function H1() {
  var e10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t10 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100, r10 = Math.pow(2, e10) * t10, n10 = r10 * 0.2 * Math.random();
  return r10 + n10;
}
var W1 = {
  retries: 3,
  retryCondition: zd,
  retryDelay: G5,
  shouldResetTimeout: false,
  onRetry: function() {
  }
};
sn.DEFAULT_OPTIONS = W1;
function K5(e10, t10) {
  return Lu(Lu(Lu({}, W1), t10), e10[Fd]);
}
function Yh(e10, t10) {
  var r10 = K5(e10, t10);
  return r10.retryCount = r10.retryCount || 0, e10[Fd] = r10, r10;
}
function Y5(e10, t10) {
  e10.defaults.agent === t10.agent && delete t10.agent, e10.defaults.httpAgent === t10.httpAgent && delete t10.httpAgent, e10.defaults.httpsAgent === t10.httpsAgent && delete t10.httpsAgent;
}
function X5(e10, t10) {
  return Lf.apply(this, arguments);
}
function Lf() {
  return Lf = (0, V1.default)($c.default.mark(function e10(t10, r10) {
    var n10, i10, o10, s10;
    return $c.default.wrap(function(c) {
      for (; ; )
        switch (c.prev = c.next) {
          case 0:
            if (n10 = t10.retries, i10 = t10.retryCondition, o10 = t10.retryCount < n10 && i10(r10), (0, z5.default)(o10) !== "object") {
              c.next = 13;
              break;
            }
            return c.prev = 3, c.next = 6, o10;
          case 6:
            return s10 = c.sent, c.abrupt("return", s10 !== false);
          case 10:
            return c.prev = 10, c.t0 = c.catch(3), c.abrupt("return", false);
          case 13:
            return c.abrupt("return", o10);
          case 14:
          case "end":
            return c.stop();
        }
    }, e10, null, [[3, 10]]);
  })), Lf.apply(this, arguments);
}
function $o(e10, t10) {
  var r10 = e10.interceptors.request.use(function(i10) {
    var o10 = Yh(i10, t10);
    return o10.lastRequestTime = Date.now(), i10;
  }), n10 = e10.interceptors.response.use(null, function() {
    var i10 = (0, V1.default)($c.default.mark(function o10(s10) {
      var a10, c, l10, u10, d6, p, y, x;
      return $c.default.wrap(function(M) {
        for (; ; )
          switch (M.prev = M.next) {
            case 0:
              if (a10 = s10.config, a10) {
                M.next = 3;
                break;
              }
              return M.abrupt("return", Promise.reject(s10));
            case 3:
              return c = Yh(a10, t10), M.next = 6, X5(c, s10);
            case 6:
              if (!M.sent) {
                M.next = 21;
                break;
              }
              if (c.retryCount += 1, l10 = c.retryDelay, u10 = c.shouldResetTimeout, d6 = c.onRetry, p = l10(c.retryCount, s10), Y5(e10, a10), !(!u10 && a10.timeout && c.lastRequestTime)) {
                M.next = 17;
                break;
              }
              if (y = Date.now() - c.lastRequestTime, x = a10.timeout - y - p, !(x <= 0)) {
                M.next = 16;
                break;
              }
              return M.abrupt("return", Promise.reject(s10));
            case 16:
              a10.timeout = x;
            case 17:
              return a10.transformRequest = [function(O) {
                return O;
              }], M.next = 20, d6(c.retryCount, s10, a10);
            case 20:
              return M.abrupt("return", new Promise(function(O) {
                return setTimeout(function() {
                  return O(e10(a10));
                }, p);
              }));
            case 21:
              return M.abrupt("return", Promise.reject(s10));
            case 22:
            case "end":
              return M.stop();
          }
      }, o10);
    }));
    return function(o10) {
      return i10.apply(this, arguments);
    };
  }());
  return {
    requestInterceptorId: r10,
    responseInterceptorId: n10
  };
}
$o.isNetworkError = $d;
$o.isSafeRequestError = q1;
$o.isIdempotentRequestError = Vd;
$o.isNetworkOrIdempotentRequestError = zd;
$o.exponentialDelay = H1;
$o.isRetryableError = Tl;
var G1 = sn.default;
Ud.exports = G1;
Ud.exports.default = G1;
var J5 = Ud.exports;
var Al = {};
var ss = null;
typeof WebSocket < "u" ? ss = WebSocket : typeof MozWebSocket < "u" ? ss = MozWebSocket : typeof Rr < "u" ? ss = Rr.WebSocket || Rr.MozWebSocket : typeof window < "u" ? ss = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ss = self.WebSocket || self.MozWebSocket);
var Z5 = ss;
var Q5 = Rr && Rr.__importDefault || function(e10) {
  return e10 && e10.__esModule ? e10 : { default: e10 };
};
Object.defineProperty(Al, "__esModule", { value: true });
Al.ResilientWebSocket = void 0;
var eS = Q5(Z5);
var tS = 3e4 + 3e3;
var rS = class {
  constructor(t10, r10) {
    mt(this, "endpoint");
    mt(this, "wsClient");
    mt(this, "wsUserClosed");
    mt(this, "wsFailedAttempts");
    mt(this, "pingTimeout");
    mt(this, "logger");
    mt(this, "onError");
    mt(this, "onMessage");
    mt(this, "onReconnect");
    this.endpoint = t10, this.logger = r10, this.wsFailedAttempts = 0, this.onError = (n10) => {
      var i10;
      (i10 = this.logger) == null || i10.error(n10);
    }, this.wsUserClosed = true, this.onMessage = () => {
    }, this.onReconnect = () => {
    };
  }
  async send(t10) {
    var r10, n10, i10;
    (r10 = this.logger) == null || r10.info(`Sending ${t10}`), await this.waitForMaybeReadyWebSocket(), this.wsClient === void 0 ? (n10 = this.logger) == null || n10.error("Couldn't connect to the websocket server. Error callback is called.") : (i10 = this.wsClient) == null || i10.send(t10);
  }
  async startWebSocket() {
    var t10;
    this.wsClient === void 0 && ((t10 = this.logger) == null || t10.info("Creating Web Socket client"), this.wsClient = new eS.default(this.endpoint), this.wsUserClosed = false, this.wsClient.onopen = () => {
      this.wsFailedAttempts = 0, this.wsClient.on !== void 0 && this.heartbeat();
    }, this.wsClient.onerror = (r10) => {
      this.onError(r10.error);
    }, this.wsClient.onmessage = (r10) => {
      this.onMessage(r10.data);
    }, this.wsClient.onclose = async () => {
      var r10, n10;
      if (this.pingTimeout !== void 0 && clearInterval(this.pingTimeout), this.wsUserClosed === false) {
        this.wsFailedAttempts += 1, this.wsClient = void 0;
        const i10 = nS(this.wsFailedAttempts);
        (r10 = this.logger) == null || r10.error(`Connection closed unexpectedly or because of timeout. Reconnecting after ${i10}ms.`), await Xh(i10), this.restartUnexpectedClosedWebsocket();
      } else
        (n10 = this.logger) == null || n10.info("The connection has been closed successfully.");
    }, this.wsClient.on !== void 0 && this.wsClient.on("ping", this.heartbeat.bind(this)));
  }
  /**
   * Heartbeat is only enabled in node clients because they support handling
   * ping-pong events.
   *
   * This approach only works when server constantly pings the clients which.
   * Otherwise you might consider sending ping and acting on pong responses
   * yourself.
   */
  heartbeat() {
    var t10;
    (t10 = this.logger) == null || t10.info("Heartbeat"), this.pingTimeout !== void 0 && clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      var r10, n10;
      (r10 = this.logger) == null || r10.warn("Connection timed out. Reconnecting..."), (n10 = this.wsClient) == null || n10.terminate(), this.restartUnexpectedClosedWebsocket();
    }, tS);
  }
  async waitForMaybeReadyWebSocket() {
    let t10 = 0;
    for (; this.wsClient !== void 0 && this.wsClient.readyState !== this.wsClient.OPEN; )
      if (t10 > 5e3) {
        this.wsClient.close();
        return;
      } else
        t10 += 10, await Xh(10);
  }
  async restartUnexpectedClosedWebsocket() {
    var t10;
    if (this.wsUserClosed !== true) {
      if (await this.startWebSocket(), await this.waitForMaybeReadyWebSocket(), this.wsClient === void 0) {
        (t10 = this.logger) == null || t10.error("Couldn't reconnect to websocket. Error callback is called.");
        return;
      }
      this.onReconnect();
    }
  }
  closeWebSocket() {
    if (this.wsClient !== void 0) {
      const t10 = this.wsClient;
      this.wsClient = void 0, t10.close();
    }
    this.wsUserClosed = true;
  }
};
Al.ResilientWebSocket = rS;
async function Xh(e10) {
  return new Promise((t10) => setTimeout(t10, e10));
}
function nS(e10) {
  return 2 ** e10 * 100;
}
var ys = {};
Object.defineProperty(ys, "__esModule", { value: true });
ys.removeLeading0xIfExists = ys.makeWebsocketUrl = void 0;
function iS(e10) {
  const t10 = new URL("ws", e10), r10 = t10.protocol === "https:";
  return t10.protocol = r10 ? "wss:" : "ws:", t10.toString();
}
ys.makeWebsocketUrl = iS;
function oS(e10) {
  return e10.startsWith("0x") ? e10.substring(2) : e10;
}
ys.removeLeading0xIfExists = oS;
var K1 = Rr && Rr.__importDefault || function(e10) {
  return e10 && e10.__esModule ? e10 : { default: e10 };
};
Object.defineProperty(gl, "__esModule", { value: true });
gl.PriceServiceConnection = void 0;
var Bu = Od;
var sS = K1(F1);
var Jh = K1(J5);
var aS = Al;
var Uu = ys;
var cS = class {
  /**
   * Constructs a new Connection.
   *
   * @param endpoint endpoint URL to the price service. Example: https://website/example/
   * @param config Optional PriceServiceConnectionConfig for custom configurations.
   */
  constructor(t10, r10) {
    mt(this, "httpClient");
    mt(this, "priceFeedCallbacks");
    mt(this, "wsClient");
    mt(this, "wsEndpoint");
    mt(this, "logger");
    mt(this, "priceFeedRequestConfig");
    mt(this, "onWsError");
    var n10, i10, o10;
    this.httpClient = sS.default.create({
      baseURL: t10,
      timeout: (r10 == null ? void 0 : r10.timeout) || 5e3
    }), (0, Jh.default)(this.httpClient, {
      retries: (r10 == null ? void 0 : r10.httpRetries) || 3,
      retryDelay: Jh.default.exponentialDelay
    }), this.priceFeedRequestConfig = {
      binary: (n10 = r10 == null ? void 0 : r10.priceFeedRequestConfig) == null ? void 0 : n10.binary,
      verbose: ((i10 = r10 == null ? void 0 : r10.priceFeedRequestConfig) == null ? void 0 : i10.verbose) ?? (r10 == null ? void 0 : r10.verbose),
      allowOutOfOrder: (o10 = r10 == null ? void 0 : r10.priceFeedRequestConfig) == null ? void 0 : o10.allowOutOfOrder
    }, this.priceFeedCallbacks = /* @__PURE__ */ new Map(), this.logger = (r10 == null ? void 0 : r10.logger) || {
      trace: () => {
      },
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn,
      error: console.error
    }, this.onWsError = (s10) => {
      this.logger.error(s10), typeof Rn < "u" && typeof Rn.exit == "function" ? (this.logger.error("Halting the process due to the websocket error"), Rn.exit(1)) : this.logger.error("Cannot halt process. Please handle the websocket error.");
    }, this.wsEndpoint = (0, Uu.makeWebsocketUrl)(t10);
  }
  /**
   * Fetch Latest PriceFeeds of given price ids.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
   *
   * @param priceIds Array of hex-encoded price ids.
   * @returns Array of PriceFeeds
   */
  async getLatestPriceFeeds(t10) {
    return t10.length === 0 ? [] : (await this.httpClient.get("/api/latest_price_feeds", {
      params: {
        ids: t10,
        verbose: this.priceFeedRequestConfig.verbose,
        binary: this.priceFeedRequestConfig.binary
      }
    })).data.map((i10) => Bu.PriceFeed.fromJson(i10));
  }
  /**
   * Fetch latest VAA of given price ids.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
   *
   * This function is coupled to wormhole implemntation.
   *
   * @param priceIds Array of hex-encoded price ids.
   * @returns Array of base64 encoded VAAs.
   */
  async getLatestVaas(t10) {
    return (await this.httpClient.get("/api/latest_vaas", {
      params: {
        ids: t10
      }
    })).data;
  }
  /**
   * Fetch the earliest VAA of the given price id that is published since the given publish time.
   * This will throw an error if the given publish time is in the future, or if the publish time
   * is old and the price service endpoint does not have a db backend for historical requests.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
   *
   * This function is coupled to wormhole implemntation.
   *
   * @param priceId Hex-encoded price id.
   * @param publishTime Epoch timestamp in seconds.
   * @returns Tuple of VAA and publishTime.
   */
  async getVaa(t10, r10) {
    const n10 = await this.httpClient.get("/api/get_vaa", {
      params: {
        id: t10,
        publish_time: r10
      }
    });
    return [n10.data.vaa, n10.data.publishTime];
  }
  /**
   * Fetch the PriceFeed of the given price id that is published since the given publish time.
   * This will throw an error if the given publish time is in the future, or if the publish time
   * is old and the price service endpoint does not have a db backend for historical requests.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
   *
   * @param priceId Hex-encoded price id.
   * @param publishTime Epoch timestamp in seconds.
   * @returns PriceFeed
   */
  async getPriceFeed(t10, r10) {
    const n10 = await this.httpClient.get("/api/get_price_feed", {
      params: {
        id: t10,
        publish_time: r10,
        verbose: this.priceFeedRequestConfig.verbose,
        binary: this.priceFeedRequestConfig.binary
      }
    });
    return Bu.PriceFeed.fromJson(n10.data);
  }
  /**
   * Fetch the list of available price feed ids.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response.
   *
   * @returns Array of hex-encoded price ids.
   */
  async getPriceFeedIds() {
    return (await this.httpClient.get("/api/price_feed_ids")).data;
  }
  /**
   * Subscribe to updates for given price ids.
   *
   * It will start a websocket connection if it's not started yet.
   * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
   * it calls `connection.onWsError`. If you want to handle the errors you should set the
   * `onWsError` function to your custom error handler.
   *
   * @param priceIds Array of hex-encoded price ids.
   * @param cb Callback function that is called with a PriceFeed upon updates to given price ids.
   */
  async subscribePriceFeedUpdates(t10, r10) {
    var o10;
    this.wsClient === void 0 && await this.startWebSocket(), t10 = t10.map((s10) => (0, Uu.removeLeading0xIfExists)(s10));
    const n10 = [];
    for (const s10 of t10)
      this.priceFeedCallbacks.has(s10) || (this.priceFeedCallbacks.set(s10, /* @__PURE__ */ new Set()), n10.push(s10)), this.priceFeedCallbacks.get(s10).add(r10);
    const i10 = {
      ids: n10,
      type: "subscribe",
      verbose: this.priceFeedRequestConfig.verbose,
      binary: this.priceFeedRequestConfig.binary,
      allow_out_of_order: this.priceFeedRequestConfig.allowOutOfOrder
    };
    await ((o10 = this.wsClient) == null ? void 0 : o10.send(JSON.stringify(i10)));
  }
  /**
   * Unsubscribe from updates for given price ids.
   *
   * It will close the websocket connection if it's not subscribed to any price feed updates anymore.
   * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
   * it calls `connection.onWsError`. If you want to handle the errors you should set the
   * `onWsError` function to your custom error handler.
   *
   * @param priceIds Array of hex-encoded price ids.
   * @param cb Optional callback, if set it will only unsubscribe this callback from updates for given price ids.
   */
  async unsubscribePriceFeedUpdates(t10, r10) {
    var o10;
    this.wsClient === void 0 && await this.startWebSocket(), t10 = t10.map((s10) => (0, Uu.removeLeading0xIfExists)(s10));
    const n10 = [];
    for (const s10 of t10)
      if (this.priceFeedCallbacks.has(s10)) {
        let a10 = false;
        r10 === void 0 ? (this.priceFeedCallbacks.delete(s10), a10 = true) : (this.priceFeedCallbacks.get(s10).delete(r10), this.priceFeedCallbacks.get(s10).size === 0 && (this.priceFeedCallbacks.delete(s10), a10 = true)), a10 && n10.push(s10);
      }
    const i10 = {
      ids: n10,
      type: "unsubscribe"
    };
    await ((o10 = this.wsClient) == null ? void 0 : o10.send(JSON.stringify(i10))), this.priceFeedCallbacks.size === 0 && this.closeWebSocket();
  }
  /**
   * Starts connection websocket.
   *
   * This function is called automatically upon subscribing to price feed updates.
   */
  async startWebSocket() {
    if (this.wsEndpoint === void 0)
      throw new Error("Websocket endpoint is undefined.");
    this.wsClient = new aS.ResilientWebSocket(this.wsEndpoint, this.logger), this.wsClient.onError = this.onWsError, this.wsClient.onReconnect = () => {
      var t10;
      if (this.priceFeedCallbacks.size > 0) {
        const r10 = {
          ids: Array.from(this.priceFeedCallbacks.keys()),
          type: "subscribe",
          verbose: this.priceFeedRequestConfig.verbose,
          binary: this.priceFeedRequestConfig.binary,
          allow_out_of_order: this.priceFeedRequestConfig.allowOutOfOrder
        };
        this.logger.info("Resubscribing to existing price feeds."), (t10 = this.wsClient) == null || t10.send(JSON.stringify(r10));
      }
    }, this.wsClient.onMessage = (t10) => {
      this.logger.info(`Received message ${t10.toString()}`);
      let r10;
      try {
        r10 = JSON.parse(t10.toString());
      } catch (n10) {
        this.logger.error(`Error parsing message ${t10.toString()} as JSON.`), this.logger.error(n10), this.onWsError(n10);
        return;
      }
      if (r10.type === "response")
        r10.status === "error" && (this.logger.error(`Error response from the websocket server ${r10.error}.`), this.onWsError(new Error(r10.error)));
      else if (r10.type === "price_update") {
        let n10;
        try {
          n10 = Bu.PriceFeed.fromJson(r10.price_feed);
        } catch (i10) {
          this.logger.error(`Error parsing price feeds from message ${t10.toString()}.`), this.logger.error(i10), this.onWsError(i10);
          return;
        }
        if (this.priceFeedCallbacks.has(n10.id))
          for (const i10 of this.priceFeedCallbacks.get(n10.id))
            i10(n10);
      } else
        this.logger.warn(`Ignoring unsupported server response ${t10.toString()}.`);
    }, await this.wsClient.startWebSocket();
  }
  /**
   * Closes connection websocket.
   *
   * At termination, the websocket should be closed to finish the
   * process elegantly. It will automatically close when the connection
   * is subscribed to no price feeds.
   */
  closeWebSocket() {
    var t10;
    (t10 = this.wsClient) == null || t10.closeWebSocket(), this.wsClient = void 0, this.priceFeedCallbacks.clear();
  }
};
gl.PriceServiceConnection = cS;
(function(e10) {
  Object.defineProperty(e10, "__esModule", { value: true }), e10.parseAccumulatorUpdateData = e10.isAccumulatorUpdateData = e10.Price = e10.PriceFeed = e10.PriceFeedMetadata = e10.PriceServiceConnection = void 0;
  var t10 = gl;
  Object.defineProperty(e10, "PriceServiceConnection", { enumerable: true, get: function() {
    return t10.PriceServiceConnection;
  } });
  var r10 = Od;
  Object.defineProperty(e10, "PriceFeedMetadata", { enumerable: true, get: function() {
    return r10.PriceFeedMetadata;
  } }), Object.defineProperty(e10, "PriceFeed", { enumerable: true, get: function() {
    return r10.PriceFeed;
  } }), Object.defineProperty(e10, "Price", { enumerable: true, get: function() {
    return r10.Price;
  } }), Object.defineProperty(e10, "isAccumulatorUpdateData", { enumerable: true, get: function() {
    return r10.isAccumulatorUpdateData;
  } }), Object.defineProperty(e10, "parseAccumulatorUpdateData", { enumerable: true, get: function() {
    return r10.parseAccumulatorUpdateData;
  } });
})(Id);
Object.defineProperty(ml, "__esModule", { value: true });
ml.SuiPriceServiceConnection = void 0;
var lS = Id;
var uS = ja;
var fS = class extends lS.PriceServiceConnection {
  /**
   * Gets price update data (either batch price attestation VAAs or accumulator messages, depending on the chosen endpoint), which then
   * can be submitted to the Pyth contract to update the prices. This will throw an axios error if there is a network problem or
   * the price service returns a non-ok response (e.g: Invalid price ids)
   *
   * @param priceIds Array of hex-encoded price ids.
   * @returns Array of buffers containing the price update data.
   */
  async getPriceFeedsUpdateData(t10) {
    return (await this.getLatestVaas(t10)).map((n10) => uS.Buffer.from(n10, "base64"));
  }
};
ml.SuiPriceServiceConnection = fS;
var Ml = {};
var dS = Xm(o3);
var Vo = Xm(a4);
var qd = Object.defineProperty;
var hS = Object.getOwnPropertyDescriptor;
var pS = Object.getOwnPropertyNames;
var mS = Object.prototype.hasOwnProperty;
var gS = (e10, t10) => {
  for (var r10 in t10)
    qd(e10, r10, { get: t10[r10], enumerable: true });
};
var vS = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of pS(t10))
      !mS.call(e10, i10) && i10 !== r10 && qd(e10, i10, { get: () => t10[i10], enumerable: !(n10 = hS(t10, i10)) || n10.enumerable });
  return e10;
};
var bS = (e10) => vS(qd({}, "__esModule", { value: true }), e10);
var Y1 = {};
gS(Y1, {
  isValidSuiNSName: () => xS,
  normalizeSuiNSName: () => SS
});
var yS = bS(Y1);
var X1 = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var J1 = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var wS = 235;
function xS(e10) {
  return e10.length > wS ? false : e10.includes("@") ? X1.test(e10) : J1.test(e10);
}
function SS(e10, t10 = "at") {
  const r10 = e10.toLowerCase();
  let n10;
  if (r10.includes("@")) {
    if (!X1.test(r10))
      throw new Error(`Invalid SuiNS name ${e10}`);
    const [i10, o10] = r10.split("@");
    n10 = [...i10 ? i10.split(".") : [], o10];
  } else {
    if (!J1.test(r10))
      throw new Error(`Invalid SuiNS name ${e10}`);
    n10 = r10.split(".").slice(0, -1);
  }
  return t10 === "dot" ? `${n10.join(".")}.sui` : `${n10.slice(0, -1).join(".")}@${n10[n10.length - 1]}`;
}
var Hd = Object.defineProperty;
var _S = Object.getOwnPropertyDescriptor;
var ES = Object.getOwnPropertyNames;
var CS = Object.prototype.hasOwnProperty;
var TS = (e10, t10) => {
  for (var r10 in t10)
    Hd(e10, r10, { get: t10[r10], enumerable: true });
};
var AS2 = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of ES(t10))
      !CS.call(e10, i10) && i10 !== r10 && Hd(e10, i10, { get: () => t10[i10], enumerable: !(n10 = _S(t10, i10)) || n10.enumerable });
  return e10;
};
var MS = (e10) => AS2(Hd({}, "__esModule", { value: true }), e10);
var Z1 = {};
TS(Z1, {
  isValidNamedPackage: () => ev,
  isValidNamedType: () => jS
});
var IS = MS(Z1);
var OS = yS;
var RS = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var PS = /^\d+$/;
var NS = 64;
var Q1 = "/";
var ev = (e10) => {
  const t10 = e10.split(Q1);
  if (t10.length < 2 || t10.length > 3)
    return false;
  const [r10, n10, i10] = t10;
  return i10 !== void 0 && !PS.test(i10) || !(0, OS.isValidSuiNSName)(r10) ? false : RS.test(n10) && n10.length < NS;
};
var jS = (e10) => {
  const t10 = e10.split(/::|<|>|,/);
  for (const r10 of t10)
    if (r10.includes(Q1) && !ev(r10))
      return false;
  return true;
};
var Wd = Object.defineProperty;
var kS = Object.getOwnPropertyDescriptor;
var DS = Object.getOwnPropertyNames;
var LS = Object.prototype.hasOwnProperty;
var BS = (e10, t10) => {
  for (var r10 in t10)
    Wd(e10, r10, { get: t10[r10], enumerable: true });
};
var US = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of DS(t10))
      !LS.call(e10, i10) && i10 !== r10 && Wd(e10, i10, { get: () => t10[i10], enumerable: !(n10 = kS(t10, i10)) || n10.enumerable });
  return e10;
};
var FS = (e10) => US(Wd({}, "__esModule", { value: true }), e10);
var tv = {};
BS(tv, {
  SUI_ADDRESS_LENGTH: () => Gd,
  isValidSuiAddress: () => iv,
  isValidSuiObjectId: () => qS,
  isValidTransactionDigest: () => zS,
  normalizeStructTag: () => ov,
  normalizeSuiAddress: () => Yd,
  normalizeSuiObjectId: () => WS,
  parseStructTag: () => Kd
});
var rv = FS(tv);
var nv = Vo;
var $S = IS;
var VS = 32;
function zS(e10) {
  try {
    return (0, nv.fromBase58)(e10).length === VS;
  } catch {
    return false;
  }
}
var Gd = 32;
function iv(e10) {
  return GS(e10) && KS(e10) === Gd;
}
function qS(e10) {
  return iv(e10);
}
function HS(e10) {
  return e10.includes("::") ? Kd(e10) : e10;
}
function Kd(e10) {
  const [t10, r10] = e10.split("::"), n10 = (0, $S.isValidNamedPackage)(t10), i10 = e10.slice(t10.length + r10.length + 4), o10 = i10.includes("<") ? i10.slice(0, i10.indexOf("<")) : i10, s10 = i10.includes("<") ? (0, nv.splitGenericParameters)(i10.slice(i10.indexOf("<") + 1, i10.lastIndexOf(">"))).map(
    (a10) => HS(a10.trim())
  ) : [];
  return {
    address: n10 ? t10 : Yd(t10),
    module: r10,
    name: o10,
    typeParams: s10
  };
}
function ov(e10) {
  const { address: t10, module: r10, name: n10, typeParams: i10 } = typeof e10 == "string" ? Kd(e10) : e10, o10 = (i10 == null ? void 0 : i10.length) > 0 ? `<${i10.map(
    (s10) => typeof s10 == "string" ? s10 : ov(s10)
  ).join(",")}>` : "";
  return `${t10}::${r10}::${n10}${o10}`;
}
function Yd(e10, t10 = false) {
  let r10 = e10.toLowerCase();
  return !t10 && r10.startsWith("0x") && (r10 = r10.slice(2)), `0x${r10.padStart(Gd * 2, "0")}`;
}
function WS(e10, t10 = false) {
  return Yd(e10, t10);
}
function GS(e10) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e10) && e10.length % 2 === 0;
}
function KS(e10) {
  return /^(0x|0X)/.test(e10) ? (e10.length - 2) / 2 : e10.length / 2;
}
var Xd = Object.defineProperty;
var YS = Object.getOwnPropertyDescriptor;
var XS = Object.getOwnPropertyNames;
var JS = Object.prototype.hasOwnProperty;
var ZS = (e10, t10) => {
  for (var r10 in t10)
    Xd(e10, r10, { get: t10[r10], enumerable: true });
};
var QS = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of XS(t10))
      !JS.call(e10, i10) && i10 !== r10 && Xd(e10, i10, { get: () => t10[i10], enumerable: !(n10 = YS(t10, i10)) || n10.enumerable });
  return e10;
};
var e7 = (e10) => QS(Xd({}, "__esModule", { value: true }), e10);
var sv = {};
ZS(sv, {
  TypeTagSerializer: () => Co
});
var av = e7(sv);
var t7 = Vo;
var r7 = rv;
var n7 = /^vector<(.+)>$/;
var i7 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var Co = class _Co {
  static parseFromStr(t10, r10 = false) {
    if (t10 === "address")
      return { address: null };
    if (t10 === "bool")
      return { bool: null };
    if (t10 === "u8")
      return { u8: null };
    if (t10 === "u16")
      return { u16: null };
    if (t10 === "u32")
      return { u32: null };
    if (t10 === "u64")
      return { u64: null };
    if (t10 === "u128")
      return { u128: null };
    if (t10 === "u256")
      return { u256: null };
    if (t10 === "signer")
      return { signer: null };
    const n10 = t10.match(n7);
    if (n10)
      return {
        vector: _Co.parseFromStr(n10[1], r10)
      };
    const i10 = t10.match(i7);
    if (i10)
      return {
        struct: {
          address: r10 ? (0, r7.normalizeSuiAddress)(i10[1]) : i10[1],
          module: i10[2],
          name: i10[3],
          typeParams: i10[5] === void 0 ? [] : _Co.parseStructTypeArgs(i10[5], r10)
        }
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t10}`);
  }
  static parseStructTypeArgs(t10, r10 = false) {
    return (0, t7.splitGenericParameters)(t10).map(
      (n10) => _Co.parseFromStr(n10, r10)
    );
  }
  static tagToString(t10) {
    if ("bool" in t10)
      return "bool";
    if ("u8" in t10)
      return "u8";
    if ("u16" in t10)
      return "u16";
    if ("u32" in t10)
      return "u32";
    if ("u64" in t10)
      return "u64";
    if ("u128" in t10)
      return "u128";
    if ("u256" in t10)
      return "u256";
    if ("address" in t10)
      return "address";
    if ("signer" in t10)
      return "signer";
    if ("vector" in t10)
      return `vector<${_Co.tagToString(t10.vector)}>`;
    if ("struct" in t10) {
      const r10 = t10.struct, n10 = r10.typeParams.map(_Co.tagToString).join(", ");
      return `${r10.address}::${r10.module}::${r10.name}${n10 ? `<${n10}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};
var Jd = Object.defineProperty;
var o7 = Object.getOwnPropertyDescriptor;
var s7 = Object.getOwnPropertyNames;
var a7 = Object.prototype.hasOwnProperty;
var c7 = (e10, t10) => {
  for (var r10 in t10)
    Jd(e10, r10, { get: t10[r10], enumerable: true });
};
var l7 = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of s7(t10))
      !a7.call(e10, i10) && i10 !== r10 && Jd(e10, i10, { get: () => t10[i10], enumerable: !(n10 = o7(t10, i10)) || n10.enumerable });
  return e10;
};
var u7 = (e10) => l7(Jd({}, "__esModule", { value: true }), e10);
var cv = {};
c7(cv, {
  Address: () => gn,
  AppId: () => Ev,
  Argument: () => Wn,
  CallArg: () => dv,
  Command: () => pv,
  CompressedSignature: () => Av,
  GasData: () => yv,
  Intent: () => Cv,
  IntentMessage: () => Tv,
  IntentScope: () => Sv,
  IntentVersion: () => _v,
  MultiSig: () => p7,
  MultiSigPkMap: () => Iv,
  MultiSigPublicKey: () => Ov,
  ObjectArg: () => fv,
  ObjectDigest: () => lv,
  Owner: () => h7,
  PasskeyAuthenticator: () => g7,
  ProgrammableMoveCall: () => hv,
  ProgrammableTransaction: () => mv,
  PublicKey: () => Mv,
  SenderSignedData: () => m7,
  SenderSignedTransaction: () => Pv,
  SharedObjectRef: () => uv,
  StructTag: () => bv,
  SuiObjectRef: () => Vc,
  TransactionData: () => xv,
  TransactionDataV1: () => wv,
  TransactionExpiration: () => vv,
  TransactionKind: () => gv,
  TypeTag: () => e0,
  base64String: () => Rv
});
var Zd = u7(cv);
var le = Vo;
var Gs = rv;
var Zh = av;
function f7(e10) {
  return le.bcs.u64({
    name: "unsafe_u64",
    ...e10
  }).transform({
    input: (t10) => t10,
    output: (t10) => Number(t10)
  });
}
function d7(e10) {
  return le.bcs.enum("Option", {
    None: null,
    Some: e10
  });
}
var gn = le.bcs.bytes(Gs.SUI_ADDRESS_LENGTH).transform({
  validate: (e10) => {
    const t10 = typeof e10 == "string" ? e10 : (0, le.toHex)(e10);
    if (!t10 || !(0, Gs.isValidSuiAddress)((0, Gs.normalizeSuiAddress)(t10)))
      throw new Error(`Invalid Sui address ${t10}`);
  },
  input: (e10) => typeof e10 == "string" ? (0, le.fromHex)((0, Gs.normalizeSuiAddress)(e10)) : e10,
  output: (e10) => (0, Gs.normalizeSuiAddress)((0, le.toHex)(e10))
});
var lv = le.bcs.vector(le.bcs.u8()).transform({
  name: "ObjectDigest",
  input: (e10) => (0, le.fromBase58)(e10),
  output: (e10) => (0, le.toBase58)(new Uint8Array(e10)),
  validate: (e10) => {
    if ((0, le.fromBase58)(e10).length !== 32)
      throw new Error("ObjectDigest must be 32 bytes");
  }
});
var Vc = le.bcs.struct("SuiObjectRef", {
  objectId: gn,
  version: le.bcs.u64(),
  digest: lv
});
var uv = le.bcs.struct("SharedObjectRef", {
  objectId: gn,
  initialSharedVersion: le.bcs.u64(),
  mutable: le.bcs.bool()
});
var fv = le.bcs.enum("ObjectArg", {
  ImmOrOwnedObject: Vc,
  SharedObject: uv,
  Receiving: Vc
});
var h7 = le.bcs.enum("Owner", {
  AddressOwner: gn,
  ObjectOwner: gn,
  Shared: le.bcs.struct("Shared", {
    initialSharedVersion: le.bcs.u64()
  }),
  Immutable: null,
  ConsensusV2: le.bcs.struct("ConsensusV2", {
    authenticator: le.bcs.struct("Authenticator", {
      SingleOwner: le.bcs.string()
    }),
    startVersion: le.bcs.string()
  })
});
var dv = le.bcs.enum("CallArg", {
  Pure: le.bcs.struct("Pure", {
    bytes: le.bcs.vector(le.bcs.u8()).transform({
      input: (e10) => typeof e10 == "string" ? (0, le.fromBase64)(e10) : e10,
      output: (e10) => (0, le.toBase64)(new Uint8Array(e10))
    })
  }),
  Object: fv
});
var Qd = le.bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: le.bcs.lazy(() => Qd),
  struct: le.bcs.lazy(() => bv),
  u16: null,
  u32: null,
  u256: null
});
var e0 = Qd.transform({
  input: (e10) => typeof e10 == "string" ? Zh.TypeTagSerializer.parseFromStr(e10, true) : e10,
  output: (e10) => Zh.TypeTagSerializer.tagToString(e10)
});
var Wn = le.bcs.enum("Argument", {
  GasCoin: null,
  Input: le.bcs.u16(),
  Result: le.bcs.u16(),
  NestedResult: le.bcs.tuple([le.bcs.u16(), le.bcs.u16()])
});
var hv = le.bcs.struct("ProgrammableMoveCall", {
  package: gn,
  module: le.bcs.string(),
  function: le.bcs.string(),
  typeArguments: le.bcs.vector(e0),
  arguments: le.bcs.vector(Wn)
});
var pv = le.bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: hv,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: le.bcs.struct("TransferObjects", {
    objects: le.bcs.vector(Wn),
    address: Wn
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: le.bcs.struct("SplitCoins", {
    coin: Wn,
    amounts: le.bcs.vector(Wn)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: le.bcs.struct("MergeCoins", {
    destination: Wn,
    sources: le.bcs.vector(Wn)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: le.bcs.struct("Publish", {
    modules: le.bcs.vector(
      le.bcs.vector(le.bcs.u8()).transform({
        input: (e10) => typeof e10 == "string" ? (0, le.fromBase64)(e10) : e10,
        output: (e10) => (0, le.toBase64)(new Uint8Array(e10))
      })
    ),
    dependencies: le.bcs.vector(gn)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: le.bcs.struct("MakeMoveVec", {
    type: d7(e0).transform({
      input: (e10) => e10 === null ? {
        None: true
      } : {
        Some: e10
      },
      output: (e10) => e10.Some ?? null
    }),
    elements: le.bcs.vector(Wn)
  }),
  Upgrade: le.bcs.struct("Upgrade", {
    modules: le.bcs.vector(
      le.bcs.vector(le.bcs.u8()).transform({
        input: (e10) => typeof e10 == "string" ? (0, le.fromBase64)(e10) : e10,
        output: (e10) => (0, le.toBase64)(new Uint8Array(e10))
      })
    ),
    dependencies: le.bcs.vector(gn),
    package: gn,
    ticket: Wn
  })
});
var mv = le.bcs.struct("ProgrammableTransaction", {
  inputs: le.bcs.vector(dv),
  commands: le.bcs.vector(pv)
});
var gv = le.bcs.enum("TransactionKind", {
  ProgrammableTransaction: mv,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var vv = le.bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: f7()
});
var bv = le.bcs.struct("StructTag", {
  address: gn,
  module: le.bcs.string(),
  name: le.bcs.string(),
  typeParams: le.bcs.vector(Qd)
});
var yv = le.bcs.struct("GasData", {
  payment: le.bcs.vector(Vc),
  owner: gn,
  price: le.bcs.u64(),
  budget: le.bcs.u64()
});
var wv = le.bcs.struct("TransactionDataV1", {
  kind: gv,
  sender: gn,
  gasData: yv,
  expiration: vv
});
var xv = le.bcs.enum("TransactionData", {
  V1: wv
});
var Sv = le.bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var _v = le.bcs.enum("IntentVersion", {
  V0: null
});
var Ev = le.bcs.enum("AppId", {
  Sui: null
});
var Cv = le.bcs.struct("Intent", {
  scope: Sv,
  version: _v,
  appId: Ev
});
function Tv(e10) {
  return le.bcs.struct(`IntentMessage<${e10.name}>`, {
    intent: Cv,
    value: e10
  });
}
var Av = le.bcs.enum("CompressedSignature", {
  ED25519: le.bcs.fixedArray(64, le.bcs.u8()),
  Secp256k1: le.bcs.fixedArray(64, le.bcs.u8()),
  Secp256r1: le.bcs.fixedArray(64, le.bcs.u8()),
  ZkLogin: le.bcs.vector(le.bcs.u8())
});
var Mv = le.bcs.enum("PublicKey", {
  ED25519: le.bcs.fixedArray(32, le.bcs.u8()),
  Secp256k1: le.bcs.fixedArray(33, le.bcs.u8()),
  Secp256r1: le.bcs.fixedArray(33, le.bcs.u8()),
  ZkLogin: le.bcs.vector(le.bcs.u8())
});
var Iv = le.bcs.struct("MultiSigPkMap", {
  pubKey: Mv,
  weight: le.bcs.u8()
});
var Ov = le.bcs.struct("MultiSigPublicKey", {
  pk_map: le.bcs.vector(Iv),
  threshold: le.bcs.u16()
});
var p7 = le.bcs.struct("MultiSig", {
  sigs: le.bcs.vector(Av),
  bitmap: le.bcs.u16(),
  multisig_pk: Ov
});
var Rv = le.bcs.vector(le.bcs.u8()).transform({
  input: (e10) => typeof e10 == "string" ? (0, le.fromBase64)(e10) : e10,
  output: (e10) => (0, le.toBase64)(new Uint8Array(e10))
});
var Pv = le.bcs.struct("SenderSignedTransaction", {
  intentMessage: Tv(xv),
  txSignatures: le.bcs.vector(Rv)
});
var m7 = le.bcs.vector(Pv, {
  name: "SenderSignedData"
});
var g7 = le.bcs.struct("PasskeyAuthenticator", {
  authenticatorData: le.bcs.vector(le.bcs.u8()),
  clientDataJson: le.bcs.string(),
  userSignature: le.bcs.vector(le.bcs.u8())
});
var t0 = Object.defineProperty;
var v7 = Object.getOwnPropertyDescriptor;
var b7 = Object.getOwnPropertyNames;
var y7 = Object.prototype.hasOwnProperty;
var w7 = (e10, t10) => {
  for (var r10 in t10)
    t0(e10, r10, { get: t10[r10], enumerable: true });
};
var x7 = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of b7(t10))
      !y7.call(e10, i10) && i10 !== r10 && t0(e10, i10, { get: () => t10[i10], enumerable: !(n10 = v7(t10, i10)) || n10.enumerable });
  return e10;
};
var S7 = (e10) => x7(t0({}, "__esModule", { value: true }), e10);
var Nv = {};
w7(Nv, {
  TransactionEffects: () => D7
});
var _7 = S7(Nv);
var pe = Vo;
var It = Zd;
var E7 = pe.bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: pe.bcs.struct("UnableToFetchPackage", { packageId: It.Address }),
  NotAPackage: pe.bcs.struct("NotAPackage", { objectId: It.Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: pe.bcs.struct("DigestDoesNotMatch", { digest: pe.bcs.vector(pe.bcs.u8()) }),
  UnknownUpgradePolicy: pe.bcs.struct("UnknownUpgradePolicy", { policy: pe.bcs.u8() }),
  PackageIDDoesNotMatch: pe.bcs.struct("PackageIDDoesNotMatch", {
    packageId: It.Address,
    ticketId: It.Address
  })
});
var C7 = pe.bcs.struct("ModuleId", {
  address: It.Address,
  name: pe.bcs.string()
});
var Qh = pe.bcs.struct("MoveLocation", {
  module: C7,
  function: pe.bcs.u16(),
  instruction: pe.bcs.u16(),
  functionName: pe.bcs.option(pe.bcs.string())
});
var T7 = pe.bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: pe.bcs.struct("IndexOutOfBounds", { idx: pe.bcs.u16() }),
  SecondaryIndexOutOfBounds: pe.bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: pe.bcs.u16(),
    secondaryIdx: pe.bcs.u16()
  }),
  InvalidResultArity: pe.bcs.struct("InvalidResultArity", { resultIdx: pe.bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var A7 = pe.bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var M7 = pe.bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: pe.bcs.struct("MoveObjectTooBig", {
    objectSize: pe.bcs.u64(),
    maxObjectSize: pe.bcs.u64()
  }),
  MovePackageTooBig: pe.bcs.struct("MovePackageTooBig", {
    objectSize: pe.bcs.u64(),
    maxObjectSize: pe.bcs.u64()
  }),
  CircularObjectOwnership: pe.bcs.struct("CircularObjectOwnership", { object: It.Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: pe.bcs.option(Qh),
  MoveAbort: pe.bcs.tuple([Qh, pe.bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: pe.bcs.struct("CommandArgumentError", {
    argIdx: pe.bcs.u16(),
    kind: T7
  }),
  TypeArgumentError: pe.bcs.struct("TypeArgumentError", {
    argumentIdx: pe.bcs.u16(),
    kind: A7
  }),
  UnusedValueWithoutDrop: pe.bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: pe.bcs.u16(),
    secondaryIdx: pe.bcs.u16()
  }),
  InvalidPublicFunctionReturnType: pe.bcs.struct("InvalidPublicFunctionReturnType", {
    idx: pe.bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: pe.bcs.struct("EffectsTooLarge", { currentSize: pe.bcs.u64(), maxSize: pe.bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: pe.bcs.struct("PackageUpgradeError", { upgradeError: E7 }),
  WrittenObjectsTooLarge: pe.bcs.struct("WrittenObjectsTooLarge", {
    currentSize: pe.bcs.u64(),
    maxSize: pe.bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: pe.bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: pe.bcs.vector(It.Address)
    }
  ),
  AddressDeniedForCoin: pe.bcs.struct("AddressDeniedForCoin", {
    address: It.Address,
    coinType: pe.bcs.string()
  }),
  CoinTypeGlobalPause: pe.bcs.struct("CoinTypeGlobalPause", { coinType: pe.bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var jv = pe.bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: pe.bcs.struct("ExecutionFailed", {
    error: M7,
    command: pe.bcs.option(pe.bcs.u64())
  })
});
var kv = pe.bcs.struct("GasCostSummary", {
  computationCost: pe.bcs.u64(),
  storageCost: pe.bcs.u64(),
  storageRebate: pe.bcs.u64(),
  nonRefundableStorageFee: pe.bcs.u64()
});
var I7 = pe.bcs.struct("TransactionEffectsV1", {
  status: jv,
  executedEpoch: pe.bcs.u64(),
  gasUsed: kv,
  modifiedAtVersions: pe.bcs.vector(pe.bcs.tuple([It.Address, pe.bcs.u64()])),
  sharedObjects: pe.bcs.vector(It.SuiObjectRef),
  transactionDigest: It.ObjectDigest,
  created: pe.bcs.vector(pe.bcs.tuple([It.SuiObjectRef, It.Owner])),
  mutated: pe.bcs.vector(pe.bcs.tuple([It.SuiObjectRef, It.Owner])),
  unwrapped: pe.bcs.vector(pe.bcs.tuple([It.SuiObjectRef, It.Owner])),
  deleted: pe.bcs.vector(It.SuiObjectRef),
  unwrappedThenDeleted: pe.bcs.vector(It.SuiObjectRef),
  wrapped: pe.bcs.vector(It.SuiObjectRef),
  gasObject: pe.bcs.tuple([It.SuiObjectRef, It.Owner]),
  eventsDigest: pe.bcs.option(It.ObjectDigest),
  dependencies: pe.bcs.vector(It.ObjectDigest)
});
var r0 = pe.bcs.tuple([pe.bcs.u64(), It.ObjectDigest]);
var O7 = pe.bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: pe.bcs.tuple([r0, It.Owner])
});
var R7 = pe.bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: pe.bcs.tuple([It.ObjectDigest, It.Owner]),
  PackageWrite: r0
});
var P7 = pe.bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var N7 = pe.bcs.struct("EffectsObjectChange", {
  inputState: O7,
  outputState: R7,
  idOperation: P7
});
var j7 = pe.bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: r0,
  MutateDeleted: pe.bcs.u64(),
  ReadDeleted: pe.bcs.u64(),
  Cancelled: pe.bcs.u64(),
  PerEpochConfig: null
});
var k7 = pe.bcs.struct("TransactionEffectsV2", {
  status: jv,
  executedEpoch: pe.bcs.u64(),
  gasUsed: kv,
  transactionDigest: It.ObjectDigest,
  gasObjectIndex: pe.bcs.option(pe.bcs.u32()),
  eventsDigest: pe.bcs.option(It.ObjectDigest),
  dependencies: pe.bcs.vector(It.ObjectDigest),
  lamportVersion: pe.bcs.u64(),
  changedObjects: pe.bcs.vector(pe.bcs.tuple([It.Address, N7])),
  unchangedSharedObjects: pe.bcs.vector(pe.bcs.tuple([It.Address, j7])),
  auxDataDigest: pe.bcs.option(It.ObjectDigest)
});
var D7 = pe.bcs.enum("TransactionEffects", {
  V1: I7,
  V2: k7
});
var n0 = Object.defineProperty;
var L7 = Object.getOwnPropertyDescriptor;
var B7 = Object.getOwnPropertyNames;
var U7 = Object.prototype.hasOwnProperty;
var F7 = (e10, t10) => {
  for (var r10 in t10)
    n0(e10, r10, { get: t10[r10], enumerable: true });
};
var $7 = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of B7(t10))
      !U7.call(e10, i10) && i10 !== r10 && n0(e10, i10, { get: () => t10[i10], enumerable: !(n10 = L7(t10, i10)) || n10.enumerable });
  return e10;
};
var V7 = (e10) => $7(n0({}, "__esModule", { value: true }), e10);
var Dv = {};
F7(Dv, {
  pureBcsSchemaFromTypeName: () => Bf
});
var z7 = V7(Dv);
var zn = Vo;
var q7 = Zd;
function Bf(e10) {
  switch (e10) {
    case "u8":
      return zn.bcs.u8();
    case "u16":
      return zn.bcs.u16();
    case "u32":
      return zn.bcs.u32();
    case "u64":
      return zn.bcs.u64();
    case "u128":
      return zn.bcs.u128();
    case "u256":
      return zn.bcs.u256();
    case "bool":
      return zn.bcs.bool();
    case "string":
      return zn.bcs.string();
    case "id":
    case "address":
      return q7.Address;
  }
  const t10 = e10.match(/^(vector|option)<(.+)>$/);
  if (t10) {
    const [r10, n10] = t10.slice(1);
    return r10 === "vector" ? zn.bcs.vector(Bf(n10)) : zn.bcs.option(Bf(n10));
  }
  throw new Error(`Invalid Pure type name: ${e10}`);
}
var i0 = Object.defineProperty;
var H7 = Object.getOwnPropertyDescriptor;
var W7 = Object.getOwnPropertyNames;
var G7 = Object.prototype.hasOwnProperty;
var K7 = (e10, t10) => {
  for (var r10 in t10)
    i0(e10, r10, { get: t10[r10], enumerable: true });
};
var Y7 = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of W7(t10))
      !G7.call(e10, i10) && i10 !== r10 && i0(e10, i10, { get: () => t10[i10], enumerable: !(n10 = H7(t10, i10)) || n10.enumerable });
  return e10;
};
var X7 = (e10) => Y7(i0({}, "__esModule", { value: true }), e10);
var Lv = {};
K7(Lv, {
  BcsType: () => e9.BcsType,
  TypeTagSerializer: () => Q7.TypeTagSerializer,
  bcs: () => r9,
  pureBcsSchemaFromTypeName: () => t9.pureBcsSchemaFromTypeName
});
var J7 = X7(Lv);
var qn = Vo;
var Bt = Zd;
var Z7 = _7;
var Q7 = av;
var e9 = Vo;
var t9 = z7;
var r9 = {
  ...qn.bcs,
  U8: qn.bcs.u8(),
  U16: qn.bcs.u16(),
  U32: qn.bcs.u32(),
  U64: qn.bcs.u64(),
  U128: qn.bcs.u128(),
  U256: qn.bcs.u256(),
  ULEB128: qn.bcs.uleb128(),
  Bool: qn.bcs.bool(),
  String: qn.bcs.string(),
  Address: Bt.Address,
  AppId: Bt.AppId,
  Argument: Bt.Argument,
  CallArg: Bt.CallArg,
  CompressedSignature: Bt.CompressedSignature,
  GasData: Bt.GasData,
  Intent: Bt.Intent,
  IntentMessage: Bt.IntentMessage,
  IntentScope: Bt.IntentScope,
  IntentVersion: Bt.IntentVersion,
  MultiSig: Bt.MultiSig,
  MultiSigPkMap: Bt.MultiSigPkMap,
  MultiSigPublicKey: Bt.MultiSigPublicKey,
  ObjectArg: Bt.ObjectArg,
  ObjectDigest: Bt.ObjectDigest,
  Owner: Bt.Owner,
  ProgrammableMoveCall: Bt.ProgrammableMoveCall,
  ProgrammableTransaction: Bt.ProgrammableTransaction,
  PublicKey: Bt.PublicKey,
  SenderSignedData: Bt.SenderSignedData,
  SenderSignedTransaction: Bt.SenderSignedTransaction,
  SharedObjectRef: Bt.SharedObjectRef,
  StructTag: Bt.StructTag,
  SuiObjectRef: Bt.SuiObjectRef,
  Command: Bt.Command,
  TransactionData: Bt.TransactionData,
  TransactionDataV1: Bt.TransactionDataV1,
  TransactionExpiration: Bt.TransactionExpiration,
  TransactionKind: Bt.TransactionKind,
  TypeTag: Bt.TypeTag,
  TransactionEffects: Z7.TransactionEffects,
  PasskeyAuthenticator: Bt.PasskeyAuthenticator
};
Object.defineProperty(Ml, "__esModule", { value: true });
Ml.SuiPythClient = void 0;
var Ja = dS;
var Yo = J7;
var n9 = ja;
var Fu = 16 * 1024;
var i9 = class {
  constructor(t10, r10, n10) {
    mt(this, "provider");
    mt(this, "pythStateId");
    mt(this, "wormholeStateId");
    mt(this, "pythPackageId");
    mt(this, "wormholePackageId");
    mt(this, "priceTableInfo");
    mt(this, "priceFeedObjectIdCache", /* @__PURE__ */ new Map());
    mt(this, "baseUpdateFee");
    this.provider = t10, this.pythStateId = r10, this.wormholeStateId = n10, this.pythPackageId = void 0, this.wormholePackageId = void 0;
  }
  async getBaseUpdateFee() {
    if (this.baseUpdateFee === void 0) {
      const t10 = await this.provider.getObject({
        id: this.pythStateId,
        options: { showContent: true }
      });
      if (!t10.data || !t10.data.content || t10.data.content.dataType !== "moveObject")
        throw new Error("Unable to fetch pyth state object");
      this.baseUpdateFee = t10.data.content.fields.base_update_fee;
    }
    return this.baseUpdateFee;
  }
  /**
   * getPackageId returns the latest package id that the object belongs to. Use this to
   * fetch the latest package id for a given object id and handle package upgrades automatically.
   * @param objectId
   * @returns package id
   */
  async getPackageId(t10) {
    const r10 = await this.provider.getObject({
      id: t10,
      options: {
        showContent: true
      }
    }).then((n10) => {
      var i10, o10;
      if (((o10 = (i10 = n10.data) == null ? void 0 : i10.content) == null ? void 0 : o10.dataType) == "moveObject")
        return n10.data.content.fields;
      throw new Error(`Cannot fetch package id for object ${t10}`);
    });
    if ("upgrade_cap" in r10)
      return r10.upgrade_cap.fields.package;
    throw new Error("upgrade_cap not found");
  }
  /**
   * Adds the commands for calling wormhole and verifying the vaas and returns the verified vaas.
   * @param vaas array of vaas to verify
   * @param tx transaction block to add commands to
   */
  async verifyVaas(t10, r10) {
    const n10 = await this.getWormholePackageId(), i10 = [];
    for (const o10 of t10) {
      const [s10] = r10.moveCall({
        target: `${n10}::vaa::parse_and_verify`,
        arguments: [
          r10.object(this.wormholeStateId),
          r10.pure(Yo.bcs.vector(Yo.bcs.U8).serialize(Array.from(o10), {
            maxSize: Fu
          }).toBytes()),
          r10.object(Ja.SUI_CLOCK_OBJECT_ID)
        ]
      });
      i10.push(s10);
    }
    return i10;
  }
  /**
   * Adds the necessary commands for updating the pyth price feeds to the transaction block.
   * @param tx transaction block to add commands to
   * @param updates array of price feed updates received from the price service
   * @param feedIds array of feed ids to update (in hex format)
   */
  async updatePriceFeeds(t10, r10, n10) {
    const i10 = await this.getPythPackageId();
    let o10;
    if (r10.length > 1)
      throw new Error("SDK does not support sending multiple accumulator messages in a single transaction");
    const s10 = this.extractVaaBytesFromAccumulatorMessage(r10[0]), a10 = await this.verifyVaas([s10], t10);
    [o10] = t10.moveCall({
      target: `${i10}::pyth::create_authenticated_price_infos_using_accumulator`,
      arguments: [
        t10.object(this.pythStateId),
        t10.pure(Yo.bcs.vector(Yo.bcs.U8).serialize(Array.from(r10[0]), {
          maxSize: Fu
        }).toBytes()),
        a10[0],
        t10.object(Ja.SUI_CLOCK_OBJECT_ID)
      ]
    });
    const c = [], l10 = await this.getBaseUpdateFee(), u10 = t10.splitCoins(t10.gas, n10.map(() => t10.pure.u64(l10)));
    let d6 = 0;
    for (const p of n10) {
      const y = await this.getPriceFeedObjectId(p);
      if (!y)
        throw new Error(`Price feed ${p} not found, please create it first`);
      c.push(y), [o10] = t10.moveCall({
        target: `${i10}::pyth::update_single_price_feed`,
        arguments: [
          t10.object(this.pythStateId),
          o10,
          t10.object(y),
          u10[d6],
          t10.object(Ja.SUI_CLOCK_OBJECT_ID)
        ]
      }), d6++;
    }
    return t10.moveCall({
      target: `${i10}::hot_potato_vector::destroy`,
      arguments: [o10],
      typeArguments: [`${i10}::price_info::PriceInfo`]
    }), c;
  }
  async createPriceFeed(t10, r10) {
    const n10 = await this.getPythPackageId();
    if (r10.length > 1)
      throw new Error("SDK does not support sending multiple accumulator messages in a single transaction");
    const i10 = this.extractVaaBytesFromAccumulatorMessage(r10[0]), o10 = await this.verifyVaas([i10], t10);
    t10.moveCall({
      target: `${n10}::pyth::create_price_feeds_using_accumulator`,
      arguments: [
        t10.object(this.pythStateId),
        t10.pure(Yo.bcs.vector(Yo.bcs.U8).serialize(Array.from(r10[0]), {
          maxSize: Fu
        }).toBytes()),
        o10[0],
        t10.object(Ja.SUI_CLOCK_OBJECT_ID)
      ]
    });
  }
  /**
   * Get the packageId for the wormhole package if not already cached
   */
  async getWormholePackageId() {
    return this.wormholePackageId || (this.wormholePackageId = await this.getPackageId(this.wormholeStateId)), this.wormholePackageId;
  }
  /**
   * Get the packageId for the pyth package if not already cached
   */
  async getPythPackageId() {
    return this.pythPackageId || (this.pythPackageId = await this.getPackageId(this.pythStateId)), this.pythPackageId;
  }
  /**
   * Get the priceFeedObjectId for a given feedId if not already cached
   * @param feedId
   */
  async getPriceFeedObjectId(t10) {
    const r10 = t10.replace("0x", "");
    if (!this.priceFeedObjectIdCache.has(r10)) {
      const { id: n10, fieldType: i10 } = await this.getPriceTableInfo(), o10 = await this.provider.getDynamicFieldObject({
        parentId: n10,
        name: {
          type: `${i10}::price_identifier::PriceIdentifier`,
          value: {
            bytes: Array.from(n9.Buffer.from(r10, "hex"))
          }
        }
      });
      if (!o10.data || !o10.data.content)
        return;
      if (o10.data.content.dataType !== "moveObject")
        throw new Error("Price feed type mismatch");
      this.priceFeedObjectIdCache.set(
        r10,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        o10.data.content.fields.value
      );
    }
    return this.priceFeedObjectIdCache.get(r10);
  }
  /**
   * Fetches the price table object id for the current state id if not cached
   * @returns price table object id
   */
  async getPriceTableInfo() {
    if (this.priceTableInfo === void 0) {
      const t10 = await this.provider.getDynamicFieldObject({
        parentId: this.pythStateId,
        name: {
          type: "vector<u8>",
          value: "price_info"
        }
      });
      if (!t10.data || !t10.data.type)
        throw new Error("Price Table not found, contract may not be initialized");
      let r10 = t10.data.type.replace("0x2::table::Table<", "");
      r10 = r10.replace("::price_identifier::PriceIdentifier, 0x2::object::ID>", ""), this.priceTableInfo = { id: t10.data.objectId, fieldType: r10 };
    }
    return this.priceTableInfo;
  }
  /**
   * Obtains the vaa bytes embedded in an accumulator message.
   * @param accumulatorMessage - the accumulator price update message
   * @returns vaa bytes as a uint8 array
   */
  extractVaaBytesFromAccumulatorMessage(t10) {
    const n10 = 7 + t10.readUint8(6) + // trailing payload (variable number of bytes)
    1, i10 = t10.readUint16BE(n10), o10 = n10 + 2;
    return t10.subarray(o10, o10 + i10);
  }
};
Ml.SuiPythClient = i9;
(function(e10) {
  Object.defineProperty(e10, "__esModule", { value: true }), e10.PriceFeed = e10.Price = e10.SuiPythClient = e10.SuiPriceServiceConnection = void 0;
  var t10 = ml;
  Object.defineProperty(e10, "SuiPriceServiceConnection", { enumerable: true, get: function() {
    return t10.SuiPriceServiceConnection;
  } });
  var r10 = Ml;
  Object.defineProperty(e10, "SuiPythClient", { enumerable: true, get: function() {
    return r10.SuiPythClient;
  } });
  var n10 = Id;
  Object.defineProperty(e10, "Price", { enumerable: true, get: function() {
    return n10.Price;
  } }), Object.defineProperty(e10, "PriceFeed", { enumerable: true, get: function() {
    return n10.PriceFeed;
  } });
})(Mf);
var o9 = Object.create;
var o0 = Object.defineProperty;
var s9 = Object.defineProperties;
var a9 = Object.getOwnPropertyDescriptor;
var c9 = Object.getOwnPropertyDescriptors;
var Bv = Object.getOwnPropertyNames;
var ep = Object.getOwnPropertySymbols;
var l9 = Object.getPrototypeOf;
var Uv = Object.prototype.hasOwnProperty;
var u9 = Object.prototype.propertyIsEnumerable;
var tp = (e10, t10, r10) => t10 in e10 ? o0(e10, t10, { enumerable: true, configurable: true, writable: true, value: r10 }) : e10[t10] = r10;
var f9 = (e10, t10) => {
  for (var r10 in t10 || (t10 = {}))
    Uv.call(t10, r10) && tp(e10, r10, t10[r10]);
  if (ep)
    for (var r10 of ep(t10))
      u9.call(t10, r10) && tp(e10, r10, t10[r10]);
  return e10;
};
var d9 = (e10, t10) => s9(e10, c9(t10));
var h9 = ((e10) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(e10, {
  get: (t10, r10) => (typeof __require < "u" ? __require : t10)[r10]
}) : e10)(function(e10) {
  if (typeof __require < "u")
    return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + e10 + '" is not supported');
});
var p9 = (e10, t10) => function() {
  return t10 || (0, e10[Bv(e10)[0]])((t10 = { exports: {} }).exports, t10), t10.exports;
};
var m9 = (e10, t10, r10, n10) => {
  if (t10 && typeof t10 == "object" || typeof t10 == "function")
    for (let i10 of Bv(t10))
      !Uv.call(e10, i10) && i10 !== r10 && o0(e10, i10, { get: () => t10[i10], enumerable: !(n10 = a9(t10, i10)) || n10.enumerable });
  return e10;
};
var zo = (e10, t10, r10) => (r10 = e10 != null ? o9(l9(e10)) : {}, m9(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !e10 || !e10.__esModule ? o0(r10, "default", { value: e10, enumerable: true }) : r10,
  e10
));
var at = (e10, t10, r10) => new Promise((n10, i10) => {
  var o10 = (c) => {
    try {
      a10(r10.next(c));
    } catch (l10) {
      i10(l10);
    }
  }, s10 = (c) => {
    try {
      a10(r10.throw(c));
    } catch (l10) {
      i10(l10);
    }
  }, a10 = (c) => c.done ? n10(c.value) : Promise.resolve(c.value).then(o10, s10);
  a10((r10 = r10.apply(e10, t10)).next());
});
var qo = p9({
  "node_modules/bn.js/lib/bn.js"(e10, t10) {
    (function(r10, n10) {
      function i10(h, f) {
        if (!h)
          throw new Error(f || "Assertion failed");
      }
      function o10(h, f) {
        h.super_ = f;
        var m = function() {
        };
        m.prototype = f.prototype, h.prototype = new m(), h.prototype.constructor = h;
      }
      function s10(h, f, m) {
        if (s10.isBN(h))
          return h;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h !== null && ((f === "le" || f === "be") && (m = f, f = 10), this._init(h || 0, f || 10, m || "be"));
      }
      typeof r10 == "object" ? r10.exports = s10 : n10.BN = s10, s10.BN = s10, s10.wordSize = 26;
      var a10;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? a10 = window.Buffer : a10 = h9("buffer").Buffer;
      } catch {
      }
      s10.isBN = function(f) {
        return f instanceof s10 ? true : f !== null && typeof f == "object" && f.constructor.wordSize === s10.wordSize && Array.isArray(f.words);
      }, s10.max = function(f, m) {
        return f.cmp(m) > 0 ? f : m;
      }, s10.min = function(f, m) {
        return f.cmp(m) < 0 ? f : m;
      }, s10.prototype._init = function(f, m, S) {
        if (typeof f == "number")
          return this._initNumber(f, m, S);
        if (typeof f == "object")
          return this._initArray(f, m, S);
        m === "hex" && (m = 16), i10(m === (m | 0) && m >= 2 && m <= 36), f = f.toString().replace(/\s+/g, "");
        var T = 0;
        f[0] === "-" && (T++, this.negative = 1), T < f.length && (m === 16 ? this._parseHex(f, T, S) : (this._parseBase(f, m, T), S === "le" && this._initArray(this.toArray(), m, S)));
      }, s10.prototype._initNumber = function(f, m, S) {
        f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
          f & 67108863,
          f / 67108864 & 67108863
        ], this.length = 2) : (i10(f < 9007199254740992), this.words = [
          f & 67108863,
          f / 67108864 & 67108863,
          1
        ], this.length = 3), S === "le" && this._initArray(this.toArray(), m, S);
      }, s10.prototype._initArray = function(f, m, S) {
        if (i10(typeof f.length == "number"), f.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
        for (var T = 0; T < this.length; T++)
          this.words[T] = 0;
        var E, I, C = 0;
        if (S === "be")
          for (T = f.length - 1, E = 0; T >= 0; T -= 3)
            I = f[T] | f[T - 1] << 8 | f[T - 2] << 16, this.words[E] |= I << C & 67108863, this.words[E + 1] = I >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, E++);
        else if (S === "le")
          for (T = 0, E = 0; T < f.length; T += 3)
            I = f[T] | f[T + 1] << 8 | f[T + 2] << 16, this.words[E] |= I << C & 67108863, this.words[E + 1] = I >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, E++);
        return this._strip();
      };
      function c(h, f) {
        var m = h.charCodeAt(f);
        if (m >= 48 && m <= 57)
          return m - 48;
        if (m >= 65 && m <= 70)
          return m - 55;
        if (m >= 97 && m <= 102)
          return m - 87;
        i10(false, "Invalid character in " + h);
      }
      function l10(h, f, m) {
        var S = c(h, m);
        return m - 1 >= f && (S |= c(h, m - 1) << 4), S;
      }
      s10.prototype._parseHex = function(f, m, S) {
        this.length = Math.ceil((f.length - m) / 6), this.words = new Array(this.length);
        for (var T = 0; T < this.length; T++)
          this.words[T] = 0;
        var E = 0, I = 0, C;
        if (S === "be")
          for (T = f.length - 1; T >= m; T -= 2)
            C = l10(f, m, T) << E, this.words[I] |= C & 67108863, E >= 18 ? (E -= 18, I += 1, this.words[I] |= C >>> 26) : E += 8;
        else {
          var g = f.length - m;
          for (T = g % 2 === 0 ? m + 1 : m; T < f.length; T += 2)
            C = l10(f, m, T) << E, this.words[I] |= C & 67108863, E >= 18 ? (E -= 18, I += 1, this.words[I] |= C >>> 26) : E += 8;
        }
        this._strip();
      };
      function u10(h, f, m, S) {
        for (var T = 0, E = 0, I = Math.min(h.length, m), C = f; C < I; C++) {
          var g = h.charCodeAt(C) - 48;
          T *= S, g >= 49 ? E = g - 49 + 10 : g >= 17 ? E = g - 17 + 10 : E = g, i10(g >= 0 && E < S, "Invalid character"), T += E;
        }
        return T;
      }
      s10.prototype._parseBase = function(f, m, S) {
        this.words = [0], this.length = 1;
        for (var T = 0, E = 1; E <= 67108863; E *= m)
          T++;
        T--, E = E / m | 0;
        for (var I = f.length - S, C = I % T, g = Math.min(I, I - C) + S, v10 = 0, k = S; k < g; k += T)
          v10 = u10(f, k, k + T, m), this.imuln(E), this.words[0] + v10 < 67108864 ? this.words[0] += v10 : this._iaddn(v10);
        if (C !== 0) {
          var Q = 1;
          for (v10 = u10(f, k, f.length, m), k = 0; k < C; k++)
            Q *= m;
          this.imuln(Q), this.words[0] + v10 < 67108864 ? this.words[0] += v10 : this._iaddn(v10);
        }
        this._strip();
      }, s10.prototype.copy = function(f) {
        f.words = new Array(this.length);
        for (var m = 0; m < this.length; m++)
          f.words[m] = this.words[m];
        f.length = this.length, f.negative = this.negative, f.red = this.red;
      };
      function d6(h, f) {
        h.words = f.words, h.length = f.length, h.negative = f.negative, h.red = f.red;
      }
      if (s10.prototype._move = function(f) {
        d6(f, this);
      }, s10.prototype.clone = function() {
        var f = new s10(null);
        return this.copy(f), f;
      }, s10.prototype._expand = function(f) {
        for (; this.length < f; )
          this.words[this.length++] = 0;
        return this;
      }, s10.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, s10.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          s10.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
        } catch {
          s10.prototype.inspect = p;
        }
      else
        s10.prototype.inspect = p;
      function p() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var y = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], x = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], b = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      s10.prototype.toString = function(f, m) {
        f = f || 10, m = m | 0 || 1;
        var S;
        if (f === 16 || f === "hex") {
          S = "";
          for (var T = 0, E = 0, I = 0; I < this.length; I++) {
            var C = this.words[I], g = ((C << T | E) & 16777215).toString(16);
            E = C >>> 24 - T & 16777215, T += 2, T >= 26 && (T -= 26, I--), E !== 0 || I !== this.length - 1 ? S = y[6 - g.length] + g + S : S = g + S;
          }
          for (E !== 0 && (S = E.toString(16) + S); S.length % m !== 0; )
            S = "0" + S;
          return this.negative !== 0 && (S = "-" + S), S;
        }
        if (f === (f | 0) && f >= 2 && f <= 36) {
          var v10 = x[f], k = b[f];
          S = "";
          var Q = this.clone();
          for (Q.negative = 0; !Q.isZero(); ) {
            var Z = Q.modrn(k).toString(f);
            Q = Q.idivn(k), Q.isZero() ? S = Z + S : S = y[v10 - Z.length] + Z + S;
          }
          for (this.isZero() && (S = "0" + S); S.length % m !== 0; )
            S = "0" + S;
          return this.negative !== 0 && (S = "-" + S), S;
        }
        i10(false, "Base should be between 2 and 36");
      }, s10.prototype.toNumber = function() {
        var f = this.words[0];
        return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i10(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
      }, s10.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, a10 && (s10.prototype.toBuffer = function(f, m) {
        return this.toArrayLike(a10, f, m);
      }), s10.prototype.toArray = function(f, m) {
        return this.toArrayLike(Array, f, m);
      };
      var M = function(f, m) {
        return f.allocUnsafe ? f.allocUnsafe(m) : new f(m);
      };
      s10.prototype.toArrayLike = function(f, m, S) {
        this._strip();
        var T = this.byteLength(), E = S || Math.max(1, T);
        i10(T <= E, "byte array longer than desired length"), i10(E > 0, "Requested array length <= 0");
        var I = M(f, E), C = m === "le" ? "LE" : "BE";
        return this["_toArrayLike" + C](I, T), I;
      }, s10.prototype._toArrayLikeLE = function(f, m) {
        for (var S = 0, T = 0, E = 0, I = 0; E < this.length; E++) {
          var C = this.words[E] << I | T;
          f[S++] = C & 255, S < f.length && (f[S++] = C >> 8 & 255), S < f.length && (f[S++] = C >> 16 & 255), I === 6 ? (S < f.length && (f[S++] = C >> 24 & 255), T = 0, I = 0) : (T = C >>> 24, I += 2);
        }
        if (S < f.length)
          for (f[S++] = T; S < f.length; )
            f[S++] = 0;
      }, s10.prototype._toArrayLikeBE = function(f, m) {
        for (var S = f.length - 1, T = 0, E = 0, I = 0; E < this.length; E++) {
          var C = this.words[E] << I | T;
          f[S--] = C & 255, S >= 0 && (f[S--] = C >> 8 & 255), S >= 0 && (f[S--] = C >> 16 & 255), I === 6 ? (S >= 0 && (f[S--] = C >> 24 & 255), T = 0, I = 0) : (T = C >>> 24, I += 2);
        }
        if (S >= 0)
          for (f[S--] = T; S >= 0; )
            f[S--] = 0;
      }, Math.clz32 ? s10.prototype._countBits = function(f) {
        return 32 - Math.clz32(f);
      } : s10.prototype._countBits = function(f) {
        var m = f, S = 0;
        return m >= 4096 && (S += 13, m >>>= 13), m >= 64 && (S += 7, m >>>= 7), m >= 8 && (S += 4, m >>>= 4), m >= 2 && (S += 2, m >>>= 2), S + m;
      }, s10.prototype._zeroBits = function(f) {
        if (f === 0)
          return 26;
        var m = f, S = 0;
        return m & 8191 || (S += 13, m >>>= 13), m & 127 || (S += 7, m >>>= 7), m & 15 || (S += 4, m >>>= 4), m & 3 || (S += 2, m >>>= 2), m & 1 || S++, S;
      }, s10.prototype.bitLength = function() {
        var f = this.words[this.length - 1], m = this._countBits(f);
        return (this.length - 1) * 26 + m;
      };
      function O(h) {
        for (var f = new Array(h.bitLength()), m = 0; m < f.length; m++) {
          var S = m / 26 | 0, T = m % 26;
          f[m] = h.words[S] >>> T & 1;
        }
        return f;
      }
      s10.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var f = 0, m = 0; m < this.length; m++) {
          var S = this._zeroBits(this.words[m]);
          if (f += S, S !== 26)
            break;
        }
        return f;
      }, s10.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, s10.prototype.toTwos = function(f) {
        return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
      }, s10.prototype.fromTwos = function(f) {
        return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
      }, s10.prototype.isNeg = function() {
        return this.negative !== 0;
      }, s10.prototype.neg = function() {
        return this.clone().ineg();
      }, s10.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, s10.prototype.iuor = function(f) {
        for (; this.length < f.length; )
          this.words[this.length++] = 0;
        for (var m = 0; m < f.length; m++)
          this.words[m] = this.words[m] | f.words[m];
        return this._strip();
      }, s10.prototype.ior = function(f) {
        return i10((this.negative | f.negative) === 0), this.iuor(f);
      }, s10.prototype.or = function(f) {
        return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
      }, s10.prototype.uor = function(f) {
        return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
      }, s10.prototype.iuand = function(f) {
        var m;
        this.length > f.length ? m = f : m = this;
        for (var S = 0; S < m.length; S++)
          this.words[S] = this.words[S] & f.words[S];
        return this.length = m.length, this._strip();
      }, s10.prototype.iand = function(f) {
        return i10((this.negative | f.negative) === 0), this.iuand(f);
      }, s10.prototype.and = function(f) {
        return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
      }, s10.prototype.uand = function(f) {
        return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
      }, s10.prototype.iuxor = function(f) {
        var m, S;
        this.length > f.length ? (m = this, S = f) : (m = f, S = this);
        for (var T = 0; T < S.length; T++)
          this.words[T] = m.words[T] ^ S.words[T];
        if (this !== m)
          for (; T < m.length; T++)
            this.words[T] = m.words[T];
        return this.length = m.length, this._strip();
      }, s10.prototype.ixor = function(f) {
        return i10((this.negative | f.negative) === 0), this.iuxor(f);
      }, s10.prototype.xor = function(f) {
        return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
      }, s10.prototype.uxor = function(f) {
        return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
      }, s10.prototype.inotn = function(f) {
        i10(typeof f == "number" && f >= 0);
        var m = Math.ceil(f / 26) | 0, S = f % 26;
        this._expand(m), S > 0 && m--;
        for (var T = 0; T < m; T++)
          this.words[T] = ~this.words[T] & 67108863;
        return S > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - S), this._strip();
      }, s10.prototype.notn = function(f) {
        return this.clone().inotn(f);
      }, s10.prototype.setn = function(f, m) {
        i10(typeof f == "number" && f >= 0);
        var S = f / 26 | 0, T = f % 26;
        return this._expand(S + 1), m ? this.words[S] = this.words[S] | 1 << T : this.words[S] = this.words[S] & ~(1 << T), this._strip();
      }, s10.prototype.iadd = function(f) {
        var m;
        if (this.negative !== 0 && f.negative === 0)
          return this.negative = 0, m = this.isub(f), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && f.negative !== 0)
          return f.negative = 0, m = this.isub(f), f.negative = 1, m._normSign();
        var S, T;
        this.length > f.length ? (S = this, T = f) : (S = f, T = this);
        for (var E = 0, I = 0; I < T.length; I++)
          m = (S.words[I] | 0) + (T.words[I] | 0) + E, this.words[I] = m & 67108863, E = m >>> 26;
        for (; E !== 0 && I < S.length; I++)
          m = (S.words[I] | 0) + E, this.words[I] = m & 67108863, E = m >>> 26;
        if (this.length = S.length, E !== 0)
          this.words[this.length] = E, this.length++;
        else if (S !== this)
          for (; I < S.length; I++)
            this.words[I] = S.words[I];
        return this;
      }, s10.prototype.add = function(f) {
        var m;
        return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, m = this.sub(f), f.negative ^= 1, m) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = f.sub(this), this.negative = 1, m) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
      }, s10.prototype.isub = function(f) {
        if (f.negative !== 0) {
          f.negative = 0;
          var m = this.iadd(f);
          return f.negative = 1, m._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
        var S = this.cmp(f);
        if (S === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var T, E;
        S > 0 ? (T = this, E = f) : (T = f, E = this);
        for (var I = 0, C = 0; C < E.length; C++)
          m = (T.words[C] | 0) - (E.words[C] | 0) + I, I = m >> 26, this.words[C] = m & 67108863;
        for (; I !== 0 && C < T.length; C++)
          m = (T.words[C] | 0) + I, I = m >> 26, this.words[C] = m & 67108863;
        if (I === 0 && C < T.length && T !== this)
          for (; C < T.length; C++)
            this.words[C] = T.words[C];
        return this.length = Math.max(this.length, C), T !== this && (this.negative = 1), this._strip();
      }, s10.prototype.sub = function(f) {
        return this.clone().isub(f);
      };
      function P(h, f, m) {
        m.negative = f.negative ^ h.negative;
        var S = h.length + f.length | 0;
        m.length = S, S = S - 1 | 0;
        var T = h.words[0] | 0, E = f.words[0] | 0, I = T * E, C = I & 67108863, g = I / 67108864 | 0;
        m.words[0] = C;
        for (var v10 = 1; v10 < S; v10++) {
          for (var k = g >>> 26, Q = g & 67108863, Z = Math.min(v10, f.length - 1), ae = Math.max(0, v10 - h.length + 1); ae <= Z; ae++) {
            var ve = v10 - ae | 0;
            T = h.words[ve] | 0, E = f.words[ae] | 0, I = T * E + Q, k += I / 67108864 | 0, Q = I & 67108863;
          }
          m.words[v10] = Q | 0, g = k | 0;
        }
        return g !== 0 ? m.words[v10] = g | 0 : m.length--, m._strip();
      }
      var j = function(f, m, S) {
        var T = f.words, E = m.words, I = S.words, C = 0, g, v10, k, Q = T[0] | 0, Z = Q & 8191, ae = Q >>> 13, ve = T[1] | 0, we = ve & 8191, he = ve >>> 13, De = T[2] | 0, Te = De & 8191, Xe = De >>> 13, ft = T[3] | 0, je = ft & 8191, ht = ft >>> 13, ye = T[4] | 0, de = ye & 8191, Ee = ye >>> 13, $e = T[5] | 0, Ne = $e & 8191, Ce = $e >>> 13, Ae = T[6] | 0, Be = Ae & 8191, lt = Ae >>> 13, ut = T[7] | 0, Ve = ut & 8191, kt = ut >>> 13, _t = T[8] | 0, Ge = _t & 8191, Ot = _t >>> 13, $t = T[9] | 0, Qe = $t & 8191, Et = $t >>> 13, Rt = E[0] | 0, rt = Rt & 8191, Dt = Rt >>> 13, Nt = E[1] | 0, et = Nt & 8191, wt = Nt >>> 13, Ct = E[2] | 0, We = Ct & 8191, pt = Ct >>> 13, jt = E[3] | 0, nt = jt & 8191, xt = jt >>> 13, Ht = E[4] | 0, N = Ht & 8191, _ = Ht >>> 13, A = E[5] | 0, U = A & 8191, Y = A >>> 13, ee = E[6] | 0, ne = ee & 8191, ke = ee >>> 13, Je = E[7] | 0, Pe = Je & 8191, V = Je >>> 13, se = E[8] | 0, ue = se & 8191, Oe = se >>> 13, ze = E[9] | 0, Re = ze & 8191, Ue = ze >>> 13;
        S.negative = f.negative ^ m.negative, S.length = 19, g = Math.imul(Z, rt), v10 = Math.imul(Z, Dt), v10 = v10 + Math.imul(ae, rt) | 0, k = Math.imul(ae, Dt);
        var it = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, g = Math.imul(we, rt), v10 = Math.imul(we, Dt), v10 = v10 + Math.imul(he, rt) | 0, k = Math.imul(he, Dt), g = g + Math.imul(Z, et) | 0, v10 = v10 + Math.imul(Z, wt) | 0, v10 = v10 + Math.imul(ae, et) | 0, k = k + Math.imul(ae, wt) | 0;
        var Qt = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, g = Math.imul(Te, rt), v10 = Math.imul(Te, Dt), v10 = v10 + Math.imul(Xe, rt) | 0, k = Math.imul(Xe, Dt), g = g + Math.imul(we, et) | 0, v10 = v10 + Math.imul(we, wt) | 0, v10 = v10 + Math.imul(he, et) | 0, k = k + Math.imul(he, wt) | 0, g = g + Math.imul(Z, We) | 0, v10 = v10 + Math.imul(Z, pt) | 0, v10 = v10 + Math.imul(ae, We) | 0, k = k + Math.imul(ae, pt) | 0;
        var Lt = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, g = Math.imul(je, rt), v10 = Math.imul(je, Dt), v10 = v10 + Math.imul(ht, rt) | 0, k = Math.imul(ht, Dt), g = g + Math.imul(Te, et) | 0, v10 = v10 + Math.imul(Te, wt) | 0, v10 = v10 + Math.imul(Xe, et) | 0, k = k + Math.imul(Xe, wt) | 0, g = g + Math.imul(we, We) | 0, v10 = v10 + Math.imul(we, pt) | 0, v10 = v10 + Math.imul(he, We) | 0, k = k + Math.imul(he, pt) | 0, g = g + Math.imul(Z, nt) | 0, v10 = v10 + Math.imul(Z, xt) | 0, v10 = v10 + Math.imul(ae, nt) | 0, k = k + Math.imul(ae, xt) | 0;
        var Vt = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, g = Math.imul(de, rt), v10 = Math.imul(de, Dt), v10 = v10 + Math.imul(Ee, rt) | 0, k = Math.imul(Ee, Dt), g = g + Math.imul(je, et) | 0, v10 = v10 + Math.imul(je, wt) | 0, v10 = v10 + Math.imul(ht, et) | 0, k = k + Math.imul(ht, wt) | 0, g = g + Math.imul(Te, We) | 0, v10 = v10 + Math.imul(Te, pt) | 0, v10 = v10 + Math.imul(Xe, We) | 0, k = k + Math.imul(Xe, pt) | 0, g = g + Math.imul(we, nt) | 0, v10 = v10 + Math.imul(we, xt) | 0, v10 = v10 + Math.imul(he, nt) | 0, k = k + Math.imul(he, xt) | 0, g = g + Math.imul(Z, N) | 0, v10 = v10 + Math.imul(Z, _) | 0, v10 = v10 + Math.imul(ae, N) | 0, k = k + Math.imul(ae, _) | 0;
        var cr = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, g = Math.imul(Ne, rt), v10 = Math.imul(Ne, Dt), v10 = v10 + Math.imul(Ce, rt) | 0, k = Math.imul(Ce, Dt), g = g + Math.imul(de, et) | 0, v10 = v10 + Math.imul(de, wt) | 0, v10 = v10 + Math.imul(Ee, et) | 0, k = k + Math.imul(Ee, wt) | 0, g = g + Math.imul(je, We) | 0, v10 = v10 + Math.imul(je, pt) | 0, v10 = v10 + Math.imul(ht, We) | 0, k = k + Math.imul(ht, pt) | 0, g = g + Math.imul(Te, nt) | 0, v10 = v10 + Math.imul(Te, xt) | 0, v10 = v10 + Math.imul(Xe, nt) | 0, k = k + Math.imul(Xe, xt) | 0, g = g + Math.imul(we, N) | 0, v10 = v10 + Math.imul(we, _) | 0, v10 = v10 + Math.imul(he, N) | 0, k = k + Math.imul(he, _) | 0, g = g + Math.imul(Z, U) | 0, v10 = v10 + Math.imul(Z, Y) | 0, v10 = v10 + Math.imul(ae, U) | 0, k = k + Math.imul(ae, Y) | 0;
        var Ar = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (Ar >>> 26) | 0, Ar &= 67108863, g = Math.imul(Be, rt), v10 = Math.imul(Be, Dt), v10 = v10 + Math.imul(lt, rt) | 0, k = Math.imul(lt, Dt), g = g + Math.imul(Ne, et) | 0, v10 = v10 + Math.imul(Ne, wt) | 0, v10 = v10 + Math.imul(Ce, et) | 0, k = k + Math.imul(Ce, wt) | 0, g = g + Math.imul(de, We) | 0, v10 = v10 + Math.imul(de, pt) | 0, v10 = v10 + Math.imul(Ee, We) | 0, k = k + Math.imul(Ee, pt) | 0, g = g + Math.imul(je, nt) | 0, v10 = v10 + Math.imul(je, xt) | 0, v10 = v10 + Math.imul(ht, nt) | 0, k = k + Math.imul(ht, xt) | 0, g = g + Math.imul(Te, N) | 0, v10 = v10 + Math.imul(Te, _) | 0, v10 = v10 + Math.imul(Xe, N) | 0, k = k + Math.imul(Xe, _) | 0, g = g + Math.imul(we, U) | 0, v10 = v10 + Math.imul(we, Y) | 0, v10 = v10 + Math.imul(he, U) | 0, k = k + Math.imul(he, Y) | 0, g = g + Math.imul(Z, ne) | 0, v10 = v10 + Math.imul(Z, ke) | 0, v10 = v10 + Math.imul(ae, ne) | 0, k = k + Math.imul(ae, ke) | 0;
        var dr = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, g = Math.imul(Ve, rt), v10 = Math.imul(Ve, Dt), v10 = v10 + Math.imul(kt, rt) | 0, k = Math.imul(kt, Dt), g = g + Math.imul(Be, et) | 0, v10 = v10 + Math.imul(Be, wt) | 0, v10 = v10 + Math.imul(lt, et) | 0, k = k + Math.imul(lt, wt) | 0, g = g + Math.imul(Ne, We) | 0, v10 = v10 + Math.imul(Ne, pt) | 0, v10 = v10 + Math.imul(Ce, We) | 0, k = k + Math.imul(Ce, pt) | 0, g = g + Math.imul(de, nt) | 0, v10 = v10 + Math.imul(de, xt) | 0, v10 = v10 + Math.imul(Ee, nt) | 0, k = k + Math.imul(Ee, xt) | 0, g = g + Math.imul(je, N) | 0, v10 = v10 + Math.imul(je, _) | 0, v10 = v10 + Math.imul(ht, N) | 0, k = k + Math.imul(ht, _) | 0, g = g + Math.imul(Te, U) | 0, v10 = v10 + Math.imul(Te, Y) | 0, v10 = v10 + Math.imul(Xe, U) | 0, k = k + Math.imul(Xe, Y) | 0, g = g + Math.imul(we, ne) | 0, v10 = v10 + Math.imul(we, ke) | 0, v10 = v10 + Math.imul(he, ne) | 0, k = k + Math.imul(he, ke) | 0, g = g + Math.imul(Z, Pe) | 0, v10 = v10 + Math.imul(Z, V) | 0, v10 = v10 + Math.imul(ae, Pe) | 0, k = k + Math.imul(ae, V) | 0;
        var er = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, g = Math.imul(Ge, rt), v10 = Math.imul(Ge, Dt), v10 = v10 + Math.imul(Ot, rt) | 0, k = Math.imul(Ot, Dt), g = g + Math.imul(Ve, et) | 0, v10 = v10 + Math.imul(Ve, wt) | 0, v10 = v10 + Math.imul(kt, et) | 0, k = k + Math.imul(kt, wt) | 0, g = g + Math.imul(Be, We) | 0, v10 = v10 + Math.imul(Be, pt) | 0, v10 = v10 + Math.imul(lt, We) | 0, k = k + Math.imul(lt, pt) | 0, g = g + Math.imul(Ne, nt) | 0, v10 = v10 + Math.imul(Ne, xt) | 0, v10 = v10 + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, xt) | 0, g = g + Math.imul(de, N) | 0, v10 = v10 + Math.imul(de, _) | 0, v10 = v10 + Math.imul(Ee, N) | 0, k = k + Math.imul(Ee, _) | 0, g = g + Math.imul(je, U) | 0, v10 = v10 + Math.imul(je, Y) | 0, v10 = v10 + Math.imul(ht, U) | 0, k = k + Math.imul(ht, Y) | 0, g = g + Math.imul(Te, ne) | 0, v10 = v10 + Math.imul(Te, ke) | 0, v10 = v10 + Math.imul(Xe, ne) | 0, k = k + Math.imul(Xe, ke) | 0, g = g + Math.imul(we, Pe) | 0, v10 = v10 + Math.imul(we, V) | 0, v10 = v10 + Math.imul(he, Pe) | 0, k = k + Math.imul(he, V) | 0, g = g + Math.imul(Z, ue) | 0, v10 = v10 + Math.imul(Z, Oe) | 0, v10 = v10 + Math.imul(ae, ue) | 0, k = k + Math.imul(ae, Oe) | 0;
        var _r = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, g = Math.imul(Qe, rt), v10 = Math.imul(Qe, Dt), v10 = v10 + Math.imul(Et, rt) | 0, k = Math.imul(Et, Dt), g = g + Math.imul(Ge, et) | 0, v10 = v10 + Math.imul(Ge, wt) | 0, v10 = v10 + Math.imul(Ot, et) | 0, k = k + Math.imul(Ot, wt) | 0, g = g + Math.imul(Ve, We) | 0, v10 = v10 + Math.imul(Ve, pt) | 0, v10 = v10 + Math.imul(kt, We) | 0, k = k + Math.imul(kt, pt) | 0, g = g + Math.imul(Be, nt) | 0, v10 = v10 + Math.imul(Be, xt) | 0, v10 = v10 + Math.imul(lt, nt) | 0, k = k + Math.imul(lt, xt) | 0, g = g + Math.imul(Ne, N) | 0, v10 = v10 + Math.imul(Ne, _) | 0, v10 = v10 + Math.imul(Ce, N) | 0, k = k + Math.imul(Ce, _) | 0, g = g + Math.imul(de, U) | 0, v10 = v10 + Math.imul(de, Y) | 0, v10 = v10 + Math.imul(Ee, U) | 0, k = k + Math.imul(Ee, Y) | 0, g = g + Math.imul(je, ne) | 0, v10 = v10 + Math.imul(je, ke) | 0, v10 = v10 + Math.imul(ht, ne) | 0, k = k + Math.imul(ht, ke) | 0, g = g + Math.imul(Te, Pe) | 0, v10 = v10 + Math.imul(Te, V) | 0, v10 = v10 + Math.imul(Xe, Pe) | 0, k = k + Math.imul(Xe, V) | 0, g = g + Math.imul(we, ue) | 0, v10 = v10 + Math.imul(we, Oe) | 0, v10 = v10 + Math.imul(he, ue) | 0, k = k + Math.imul(he, Oe) | 0, g = g + Math.imul(Z, Re) | 0, v10 = v10 + Math.imul(Z, Ue) | 0, v10 = v10 + Math.imul(ae, Re) | 0, k = k + Math.imul(ae, Ue) | 0;
        var wn = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (wn >>> 26) | 0, wn &= 67108863, g = Math.imul(Qe, et), v10 = Math.imul(Qe, wt), v10 = v10 + Math.imul(Et, et) | 0, k = Math.imul(Et, wt), g = g + Math.imul(Ge, We) | 0, v10 = v10 + Math.imul(Ge, pt) | 0, v10 = v10 + Math.imul(Ot, We) | 0, k = k + Math.imul(Ot, pt) | 0, g = g + Math.imul(Ve, nt) | 0, v10 = v10 + Math.imul(Ve, xt) | 0, v10 = v10 + Math.imul(kt, nt) | 0, k = k + Math.imul(kt, xt) | 0, g = g + Math.imul(Be, N) | 0, v10 = v10 + Math.imul(Be, _) | 0, v10 = v10 + Math.imul(lt, N) | 0, k = k + Math.imul(lt, _) | 0, g = g + Math.imul(Ne, U) | 0, v10 = v10 + Math.imul(Ne, Y) | 0, v10 = v10 + Math.imul(Ce, U) | 0, k = k + Math.imul(Ce, Y) | 0, g = g + Math.imul(de, ne) | 0, v10 = v10 + Math.imul(de, ke) | 0, v10 = v10 + Math.imul(Ee, ne) | 0, k = k + Math.imul(Ee, ke) | 0, g = g + Math.imul(je, Pe) | 0, v10 = v10 + Math.imul(je, V) | 0, v10 = v10 + Math.imul(ht, Pe) | 0, k = k + Math.imul(ht, V) | 0, g = g + Math.imul(Te, ue) | 0, v10 = v10 + Math.imul(Te, Oe) | 0, v10 = v10 + Math.imul(Xe, ue) | 0, k = k + Math.imul(Xe, Oe) | 0, g = g + Math.imul(we, Re) | 0, v10 = v10 + Math.imul(we, Ue) | 0, v10 = v10 + Math.imul(he, Re) | 0, k = k + Math.imul(he, Ue) | 0;
        var Wr = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, g = Math.imul(Qe, We), v10 = Math.imul(Qe, pt), v10 = v10 + Math.imul(Et, We) | 0, k = Math.imul(Et, pt), g = g + Math.imul(Ge, nt) | 0, v10 = v10 + Math.imul(Ge, xt) | 0, v10 = v10 + Math.imul(Ot, nt) | 0, k = k + Math.imul(Ot, xt) | 0, g = g + Math.imul(Ve, N) | 0, v10 = v10 + Math.imul(Ve, _) | 0, v10 = v10 + Math.imul(kt, N) | 0, k = k + Math.imul(kt, _) | 0, g = g + Math.imul(Be, U) | 0, v10 = v10 + Math.imul(Be, Y) | 0, v10 = v10 + Math.imul(lt, U) | 0, k = k + Math.imul(lt, Y) | 0, g = g + Math.imul(Ne, ne) | 0, v10 = v10 + Math.imul(Ne, ke) | 0, v10 = v10 + Math.imul(Ce, ne) | 0, k = k + Math.imul(Ce, ke) | 0, g = g + Math.imul(de, Pe) | 0, v10 = v10 + Math.imul(de, V) | 0, v10 = v10 + Math.imul(Ee, Pe) | 0, k = k + Math.imul(Ee, V) | 0, g = g + Math.imul(je, ue) | 0, v10 = v10 + Math.imul(je, Oe) | 0, v10 = v10 + Math.imul(ht, ue) | 0, k = k + Math.imul(ht, Oe) | 0, g = g + Math.imul(Te, Re) | 0, v10 = v10 + Math.imul(Te, Ue) | 0, v10 = v10 + Math.imul(Xe, Re) | 0, k = k + Math.imul(Xe, Ue) | 0;
        var xn = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, g = Math.imul(Qe, nt), v10 = Math.imul(Qe, xt), v10 = v10 + Math.imul(Et, nt) | 0, k = Math.imul(Et, xt), g = g + Math.imul(Ge, N) | 0, v10 = v10 + Math.imul(Ge, _) | 0, v10 = v10 + Math.imul(Ot, N) | 0, k = k + Math.imul(Ot, _) | 0, g = g + Math.imul(Ve, U) | 0, v10 = v10 + Math.imul(Ve, Y) | 0, v10 = v10 + Math.imul(kt, U) | 0, k = k + Math.imul(kt, Y) | 0, g = g + Math.imul(Be, ne) | 0, v10 = v10 + Math.imul(Be, ke) | 0, v10 = v10 + Math.imul(lt, ne) | 0, k = k + Math.imul(lt, ke) | 0, g = g + Math.imul(Ne, Pe) | 0, v10 = v10 + Math.imul(Ne, V) | 0, v10 = v10 + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, V) | 0, g = g + Math.imul(de, ue) | 0, v10 = v10 + Math.imul(de, Oe) | 0, v10 = v10 + Math.imul(Ee, ue) | 0, k = k + Math.imul(Ee, Oe) | 0, g = g + Math.imul(je, Re) | 0, v10 = v10 + Math.imul(je, Ue) | 0, v10 = v10 + Math.imul(ht, Re) | 0, k = k + Math.imul(ht, Ue) | 0;
        var ci = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, g = Math.imul(Qe, N), v10 = Math.imul(Qe, _), v10 = v10 + Math.imul(Et, N) | 0, k = Math.imul(Et, _), g = g + Math.imul(Ge, U) | 0, v10 = v10 + Math.imul(Ge, Y) | 0, v10 = v10 + Math.imul(Ot, U) | 0, k = k + Math.imul(Ot, Y) | 0, g = g + Math.imul(Ve, ne) | 0, v10 = v10 + Math.imul(Ve, ke) | 0, v10 = v10 + Math.imul(kt, ne) | 0, k = k + Math.imul(kt, ke) | 0, g = g + Math.imul(Be, Pe) | 0, v10 = v10 + Math.imul(Be, V) | 0, v10 = v10 + Math.imul(lt, Pe) | 0, k = k + Math.imul(lt, V) | 0, g = g + Math.imul(Ne, ue) | 0, v10 = v10 + Math.imul(Ne, Oe) | 0, v10 = v10 + Math.imul(Ce, ue) | 0, k = k + Math.imul(Ce, Oe) | 0, g = g + Math.imul(de, Re) | 0, v10 = v10 + Math.imul(de, Ue) | 0, v10 = v10 + Math.imul(Ee, Re) | 0, k = k + Math.imul(Ee, Ue) | 0;
        var li = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, g = Math.imul(Qe, U), v10 = Math.imul(Qe, Y), v10 = v10 + Math.imul(Et, U) | 0, k = Math.imul(Et, Y), g = g + Math.imul(Ge, ne) | 0, v10 = v10 + Math.imul(Ge, ke) | 0, v10 = v10 + Math.imul(Ot, ne) | 0, k = k + Math.imul(Ot, ke) | 0, g = g + Math.imul(Ve, Pe) | 0, v10 = v10 + Math.imul(Ve, V) | 0, v10 = v10 + Math.imul(kt, Pe) | 0, k = k + Math.imul(kt, V) | 0, g = g + Math.imul(Be, ue) | 0, v10 = v10 + Math.imul(Be, Oe) | 0, v10 = v10 + Math.imul(lt, ue) | 0, k = k + Math.imul(lt, Oe) | 0, g = g + Math.imul(Ne, Re) | 0, v10 = v10 + Math.imul(Ne, Ue) | 0, v10 = v10 + Math.imul(Ce, Re) | 0, k = k + Math.imul(Ce, Ue) | 0;
        var Sn = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, g = Math.imul(Qe, ne), v10 = Math.imul(Qe, ke), v10 = v10 + Math.imul(Et, ne) | 0, k = Math.imul(Et, ke), g = g + Math.imul(Ge, Pe) | 0, v10 = v10 + Math.imul(Ge, V) | 0, v10 = v10 + Math.imul(Ot, Pe) | 0, k = k + Math.imul(Ot, V) | 0, g = g + Math.imul(Ve, ue) | 0, v10 = v10 + Math.imul(Ve, Oe) | 0, v10 = v10 + Math.imul(kt, ue) | 0, k = k + Math.imul(kt, Oe) | 0, g = g + Math.imul(Be, Re) | 0, v10 = v10 + Math.imul(Be, Ue) | 0, v10 = v10 + Math.imul(lt, Re) | 0, k = k + Math.imul(lt, Ue) | 0;
        var ui = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, g = Math.imul(Qe, Pe), v10 = Math.imul(Qe, V), v10 = v10 + Math.imul(Et, Pe) | 0, k = Math.imul(Et, V), g = g + Math.imul(Ge, ue) | 0, v10 = v10 + Math.imul(Ge, Oe) | 0, v10 = v10 + Math.imul(Ot, ue) | 0, k = k + Math.imul(Ot, Oe) | 0, g = g + Math.imul(Ve, Re) | 0, v10 = v10 + Math.imul(Ve, Ue) | 0, v10 = v10 + Math.imul(kt, Re) | 0, k = k + Math.imul(kt, Ue) | 0;
        var fi = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, g = Math.imul(Qe, ue), v10 = Math.imul(Qe, Oe), v10 = v10 + Math.imul(Et, ue) | 0, k = Math.imul(Et, Oe), g = g + Math.imul(Ge, Re) | 0, v10 = v10 + Math.imul(Ge, Ue) | 0, v10 = v10 + Math.imul(Ot, Re) | 0, k = k + Math.imul(Ot, Ue) | 0;
        var D = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        C = (k + (v10 >>> 13) | 0) + (D >>> 26) | 0, D &= 67108863, g = Math.imul(Qe, Re), v10 = Math.imul(Qe, Ue), v10 = v10 + Math.imul(Et, Re) | 0, k = Math.imul(Et, Ue);
        var K = (C + g | 0) + ((v10 & 8191) << 13) | 0;
        return C = (k + (v10 >>> 13) | 0) + (K >>> 26) | 0, K &= 67108863, I[0] = it, I[1] = Qt, I[2] = Lt, I[3] = Vt, I[4] = cr, I[5] = Ar, I[6] = dr, I[7] = er, I[8] = _r, I[9] = wn, I[10] = Wr, I[11] = xn, I[12] = ci, I[13] = li, I[14] = Sn, I[15] = ui, I[16] = fi, I[17] = D, I[18] = K, C !== 0 && (I[19] = C, S.length++), S;
      };
      Math.imul || (j = P);
      function F(h, f, m) {
        m.negative = f.negative ^ h.negative, m.length = h.length + f.length;
        for (var S = 0, T = 0, E = 0; E < m.length - 1; E++) {
          var I = T;
          T = 0;
          for (var C = S & 67108863, g = Math.min(E, f.length - 1), v10 = Math.max(0, E - h.length + 1); v10 <= g; v10++) {
            var k = E - v10, Q = h.words[k] | 0, Z = f.words[v10] | 0, ae = Q * Z, ve = ae & 67108863;
            I = I + (ae / 67108864 | 0) | 0, ve = ve + C | 0, C = ve & 67108863, I = I + (ve >>> 26) | 0, T += I >>> 26, I &= 67108863;
          }
          m.words[E] = C, S = I, I = T;
        }
        return S !== 0 ? m.words[E] = S : m.length--, m._strip();
      }
      function B(h, f, m) {
        return F(h, f, m);
      }
      s10.prototype.mulTo = function(f, m) {
        var S, T = this.length + f.length;
        return this.length === 10 && f.length === 10 ? S = j(this, f, m) : T < 63 ? S = P(this, f, m) : T < 1024 ? S = F(this, f, m) : S = B(this, f, m), S;
      }, s10.prototype.mul = function(f) {
        var m = new s10(null);
        return m.words = new Array(this.length + f.length), this.mulTo(f, m);
      }, s10.prototype.mulf = function(f) {
        var m = new s10(null);
        return m.words = new Array(this.length + f.length), B(this, f, m);
      }, s10.prototype.imul = function(f) {
        return this.clone().mulTo(f, this);
      }, s10.prototype.imuln = function(f) {
        var m = f < 0;
        m && (f = -f), i10(typeof f == "number"), i10(f < 67108864);
        for (var S = 0, T = 0; T < this.length; T++) {
          var E = (this.words[T] | 0) * f, I = (E & 67108863) + (S & 67108863);
          S >>= 26, S += E / 67108864 | 0, S += I >>> 26, this.words[T] = I & 67108863;
        }
        return S !== 0 && (this.words[T] = S, this.length++), m ? this.ineg() : this;
      }, s10.prototype.muln = function(f) {
        return this.clone().imuln(f);
      }, s10.prototype.sqr = function() {
        return this.mul(this);
      }, s10.prototype.isqr = function() {
        return this.imul(this.clone());
      }, s10.prototype.pow = function(f) {
        var m = O(f);
        if (m.length === 0)
          return new s10(1);
        for (var S = this, T = 0; T < m.length && m[T] === 0; T++, S = S.sqr())
          ;
        if (++T < m.length)
          for (var E = S.sqr(); T < m.length; T++, E = E.sqr())
            m[T] !== 0 && (S = S.mul(E));
        return S;
      }, s10.prototype.iushln = function(f) {
        i10(typeof f == "number" && f >= 0);
        var m = f % 26, S = (f - m) / 26, T = 67108863 >>> 26 - m << 26 - m, E;
        if (m !== 0) {
          var I = 0;
          for (E = 0; E < this.length; E++) {
            var C = this.words[E] & T, g = (this.words[E] | 0) - C << m;
            this.words[E] = g | I, I = C >>> 26 - m;
          }
          I && (this.words[E] = I, this.length++);
        }
        if (S !== 0) {
          for (E = this.length - 1; E >= 0; E--)
            this.words[E + S] = this.words[E];
          for (E = 0; E < S; E++)
            this.words[E] = 0;
          this.length += S;
        }
        return this._strip();
      }, s10.prototype.ishln = function(f) {
        return i10(this.negative === 0), this.iushln(f);
      }, s10.prototype.iushrn = function(f, m, S) {
        i10(typeof f == "number" && f >= 0);
        var T;
        m ? T = (m - m % 26) / 26 : T = 0;
        var E = f % 26, I = Math.min((f - E) / 26, this.length), C = 67108863 ^ 67108863 >>> E << E, g = S;
        if (T -= I, T = Math.max(0, T), g) {
          for (var v10 = 0; v10 < I; v10++)
            g.words[v10] = this.words[v10];
          g.length = I;
        }
        if (I !== 0)
          if (this.length > I)
            for (this.length -= I, v10 = 0; v10 < this.length; v10++)
              this.words[v10] = this.words[v10 + I];
          else
            this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v10 = this.length - 1; v10 >= 0 && (k !== 0 || v10 >= T); v10--) {
          var Q = this.words[v10] | 0;
          this.words[v10] = k << 26 - E | Q >>> E, k = Q & C;
        }
        return g && k !== 0 && (g.words[g.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, s10.prototype.ishrn = function(f, m, S) {
        return i10(this.negative === 0), this.iushrn(f, m, S);
      }, s10.prototype.shln = function(f) {
        return this.clone().ishln(f);
      }, s10.prototype.ushln = function(f) {
        return this.clone().iushln(f);
      }, s10.prototype.shrn = function(f) {
        return this.clone().ishrn(f);
      }, s10.prototype.ushrn = function(f) {
        return this.clone().iushrn(f);
      }, s10.prototype.testn = function(f) {
        i10(typeof f == "number" && f >= 0);
        var m = f % 26, S = (f - m) / 26, T = 1 << m;
        if (this.length <= S)
          return false;
        var E = this.words[S];
        return !!(E & T);
      }, s10.prototype.imaskn = function(f) {
        i10(typeof f == "number" && f >= 0);
        var m = f % 26, S = (f - m) / 26;
        if (i10(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
          return this;
        if (m !== 0 && S++, this.length = Math.min(S, this.length), m !== 0) {
          var T = 67108863 ^ 67108863 >>> m << m;
          this.words[this.length - 1] &= T;
        }
        return this._strip();
      }, s10.prototype.maskn = function(f) {
        return this.clone().imaskn(f);
      }, s10.prototype.iaddn = function(f) {
        return i10(typeof f == "number"), i10(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
      }, s10.prototype._iaddn = function(f) {
        this.words[0] += f;
        for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
          this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
        return this.length = Math.max(this.length, m + 1), this;
      }, s10.prototype.isubn = function(f) {
        if (i10(typeof f == "number"), i10(f < 67108864), f < 0)
          return this.iaddn(-f);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(f), this.negative = 1, this;
        if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var m = 0; m < this.length && this.words[m] < 0; m++)
            this.words[m] += 67108864, this.words[m + 1] -= 1;
        return this._strip();
      }, s10.prototype.addn = function(f) {
        return this.clone().iaddn(f);
      }, s10.prototype.subn = function(f) {
        return this.clone().isubn(f);
      }, s10.prototype.iabs = function() {
        return this.negative = 0, this;
      }, s10.prototype.abs = function() {
        return this.clone().iabs();
      }, s10.prototype._ishlnsubmul = function(f, m, S) {
        var T = f.length + S, E;
        this._expand(T);
        var I, C = 0;
        for (E = 0; E < f.length; E++) {
          I = (this.words[E + S] | 0) + C;
          var g = (f.words[E] | 0) * m;
          I -= g & 67108863, C = (I >> 26) - (g / 67108864 | 0), this.words[E + S] = I & 67108863;
        }
        for (; E < this.length - S; E++)
          I = (this.words[E + S] | 0) + C, C = I >> 26, this.words[E + S] = I & 67108863;
        if (C === 0)
          return this._strip();
        for (i10(C === -1), C = 0, E = 0; E < this.length; E++)
          I = -(this.words[E] | 0) + C, C = I >> 26, this.words[E] = I & 67108863;
        return this.negative = 1, this._strip();
      }, s10.prototype._wordDiv = function(f, m) {
        var S = this.length - f.length, T = this.clone(), E = f, I = E.words[E.length - 1] | 0, C = this._countBits(I);
        S = 26 - C, S !== 0 && (E = E.ushln(S), T.iushln(S), I = E.words[E.length - 1] | 0);
        var g = T.length - E.length, v10;
        if (m !== "mod") {
          v10 = new s10(null), v10.length = g + 1, v10.words = new Array(v10.length);
          for (var k = 0; k < v10.length; k++)
            v10.words[k] = 0;
        }
        var Q = T.clone()._ishlnsubmul(E, 1, g);
        Q.negative === 0 && (T = Q, v10 && (v10.words[g] = 1));
        for (var Z = g - 1; Z >= 0; Z--) {
          var ae = (T.words[E.length + Z] | 0) * 67108864 + (T.words[E.length + Z - 1] | 0);
          for (ae = Math.min(ae / I | 0, 67108863), T._ishlnsubmul(E, ae, Z); T.negative !== 0; )
            ae--, T.negative = 0, T._ishlnsubmul(E, 1, Z), T.isZero() || (T.negative ^= 1);
          v10 && (v10.words[Z] = ae);
        }
        return v10 && v10._strip(), T._strip(), m !== "div" && S !== 0 && T.iushrn(S), {
          div: v10 || null,
          mod: T
        };
      }, s10.prototype.divmod = function(f, m, S) {
        if (i10(!f.isZero()), this.isZero())
          return {
            div: new s10(0),
            mod: new s10(0)
          };
        var T, E, I;
        return this.negative !== 0 && f.negative === 0 ? (I = this.neg().divmod(f, m), m !== "mod" && (T = I.div.neg()), m !== "div" && (E = I.mod.neg(), S && E.negative !== 0 && E.iadd(f)), {
          div: T,
          mod: E
        }) : this.negative === 0 && f.negative !== 0 ? (I = this.divmod(f.neg(), m), m !== "mod" && (T = I.div.neg()), {
          div: T,
          mod: I.mod
        }) : this.negative & f.negative ? (I = this.neg().divmod(f.neg(), m), m !== "div" && (E = I.mod.neg(), S && E.negative !== 0 && E.isub(f)), {
          div: I.div,
          mod: E
        }) : f.length > this.length || this.cmp(f) < 0 ? {
          div: new s10(0),
          mod: this
        } : f.length === 1 ? m === "div" ? {
          div: this.divn(f.words[0]),
          mod: null
        } : m === "mod" ? {
          div: null,
          mod: new s10(this.modrn(f.words[0]))
        } : {
          div: this.divn(f.words[0]),
          mod: new s10(this.modrn(f.words[0]))
        } : this._wordDiv(f, m);
      }, s10.prototype.div = function(f) {
        return this.divmod(f, "div", false).div;
      }, s10.prototype.mod = function(f) {
        return this.divmod(f, "mod", false).mod;
      }, s10.prototype.umod = function(f) {
        return this.divmod(f, "mod", true).mod;
      }, s10.prototype.divRound = function(f) {
        var m = this.divmod(f);
        if (m.mod.isZero())
          return m.div;
        var S = m.div.negative !== 0 ? m.mod.isub(f) : m.mod, T = f.ushrn(1), E = f.andln(1), I = S.cmp(T);
        return I < 0 || E === 1 && I === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
      }, s10.prototype.modrn = function(f) {
        var m = f < 0;
        m && (f = -f), i10(f <= 67108863);
        for (var S = (1 << 26) % f, T = 0, E = this.length - 1; E >= 0; E--)
          T = (S * T + (this.words[E] | 0)) % f;
        return m ? -T : T;
      }, s10.prototype.modn = function(f) {
        return this.modrn(f);
      }, s10.prototype.idivn = function(f) {
        var m = f < 0;
        m && (f = -f), i10(f <= 67108863);
        for (var S = 0, T = this.length - 1; T >= 0; T--) {
          var E = (this.words[T] | 0) + S * 67108864;
          this.words[T] = E / f | 0, S = E % f;
        }
        return this._strip(), m ? this.ineg() : this;
      }, s10.prototype.divn = function(f) {
        return this.clone().idivn(f);
      }, s10.prototype.egcd = function(f) {
        i10(f.negative === 0), i10(!f.isZero());
        var m = this, S = f.clone();
        m.negative !== 0 ? m = m.umod(f) : m = m.clone();
        for (var T = new s10(1), E = new s10(0), I = new s10(0), C = new s10(1), g = 0; m.isEven() && S.isEven(); )
          m.iushrn(1), S.iushrn(1), ++g;
        for (var v10 = S.clone(), k = m.clone(); !m.isZero(); ) {
          for (var Q = 0, Z = 1; !(m.words[0] & Z) && Q < 26; ++Q, Z <<= 1)
            ;
          if (Q > 0)
            for (m.iushrn(Q); Q-- > 0; )
              (T.isOdd() || E.isOdd()) && (T.iadd(v10), E.isub(k)), T.iushrn(1), E.iushrn(1);
          for (var ae = 0, ve = 1; !(S.words[0] & ve) && ae < 26; ++ae, ve <<= 1)
            ;
          if (ae > 0)
            for (S.iushrn(ae); ae-- > 0; )
              (I.isOdd() || C.isOdd()) && (I.iadd(v10), C.isub(k)), I.iushrn(1), C.iushrn(1);
          m.cmp(S) >= 0 ? (m.isub(S), T.isub(I), E.isub(C)) : (S.isub(m), I.isub(T), C.isub(E));
        }
        return {
          a: I,
          b: C,
          gcd: S.iushln(g)
        };
      }, s10.prototype._invmp = function(f) {
        i10(f.negative === 0), i10(!f.isZero());
        var m = this, S = f.clone();
        m.negative !== 0 ? m = m.umod(f) : m = m.clone();
        for (var T = new s10(1), E = new s10(0), I = S.clone(); m.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
          for (var C = 0, g = 1; !(m.words[0] & g) && C < 26; ++C, g <<= 1)
            ;
          if (C > 0)
            for (m.iushrn(C); C-- > 0; )
              T.isOdd() && T.iadd(I), T.iushrn(1);
          for (var v10 = 0, k = 1; !(S.words[0] & k) && v10 < 26; ++v10, k <<= 1)
            ;
          if (v10 > 0)
            for (S.iushrn(v10); v10-- > 0; )
              E.isOdd() && E.iadd(I), E.iushrn(1);
          m.cmp(S) >= 0 ? (m.isub(S), T.isub(E)) : (S.isub(m), E.isub(T));
        }
        var Q;
        return m.cmpn(1) === 0 ? Q = T : Q = E, Q.cmpn(0) < 0 && Q.iadd(f), Q;
      }, s10.prototype.gcd = function(f) {
        if (this.isZero())
          return f.abs();
        if (f.isZero())
          return this.abs();
        var m = this.clone(), S = f.clone();
        m.negative = 0, S.negative = 0;
        for (var T = 0; m.isEven() && S.isEven(); T++)
          m.iushrn(1), S.iushrn(1);
        do {
          for (; m.isEven(); )
            m.iushrn(1);
          for (; S.isEven(); )
            S.iushrn(1);
          var E = m.cmp(S);
          if (E < 0) {
            var I = m;
            m = S, S = I;
          } else if (E === 0 || S.cmpn(1) === 0)
            break;
          m.isub(S);
        } while (true);
        return S.iushln(T);
      }, s10.prototype.invm = function(f) {
        return this.egcd(f).a.umod(f);
      }, s10.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, s10.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, s10.prototype.andln = function(f) {
        return this.words[0] & f;
      }, s10.prototype.bincn = function(f) {
        i10(typeof f == "number");
        var m = f % 26, S = (f - m) / 26, T = 1 << m;
        if (this.length <= S)
          return this._expand(S + 1), this.words[S] |= T, this;
        for (var E = T, I = S; E !== 0 && I < this.length; I++) {
          var C = this.words[I] | 0;
          C += E, E = C >>> 26, C &= 67108863, this.words[I] = C;
        }
        return E !== 0 && (this.words[I] = E, this.length++), this;
      }, s10.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, s10.prototype.cmpn = function(f) {
        var m = f < 0;
        if (this.negative !== 0 && !m)
          return -1;
        if (this.negative === 0 && m)
          return 1;
        this._strip();
        var S;
        if (this.length > 1)
          S = 1;
        else {
          m && (f = -f), i10(f <= 67108863, "Number is too big");
          var T = this.words[0] | 0;
          S = T === f ? 0 : T < f ? -1 : 1;
        }
        return this.negative !== 0 ? -S | 0 : S;
      }, s10.prototype.cmp = function(f) {
        if (this.negative !== 0 && f.negative === 0)
          return -1;
        if (this.negative === 0 && f.negative !== 0)
          return 1;
        var m = this.ucmp(f);
        return this.negative !== 0 ? -m | 0 : m;
      }, s10.prototype.ucmp = function(f) {
        if (this.length > f.length)
          return 1;
        if (this.length < f.length)
          return -1;
        for (var m = 0, S = this.length - 1; S >= 0; S--) {
          var T = this.words[S] | 0, E = f.words[S] | 0;
          if (T !== E) {
            T < E ? m = -1 : T > E && (m = 1);
            break;
          }
        }
        return m;
      }, s10.prototype.gtn = function(f) {
        return this.cmpn(f) === 1;
      }, s10.prototype.gt = function(f) {
        return this.cmp(f) === 1;
      }, s10.prototype.gten = function(f) {
        return this.cmpn(f) >= 0;
      }, s10.prototype.gte = function(f) {
        return this.cmp(f) >= 0;
      }, s10.prototype.ltn = function(f) {
        return this.cmpn(f) === -1;
      }, s10.prototype.lt = function(f) {
        return this.cmp(f) === -1;
      }, s10.prototype.lten = function(f) {
        return this.cmpn(f) <= 0;
      }, s10.prototype.lte = function(f) {
        return this.cmp(f) <= 0;
      }, s10.prototype.eqn = function(f) {
        return this.cmpn(f) === 0;
      }, s10.prototype.eq = function(f) {
        return this.cmp(f) === 0;
      }, s10.red = function(f) {
        return new q(f);
      }, s10.prototype.toRed = function(f) {
        return i10(!this.red, "Already a number in reduction context"), i10(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
      }, s10.prototype.fromRed = function() {
        return i10(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, s10.prototype._forceRed = function(f) {
        return this.red = f, this;
      }, s10.prototype.forceRed = function(f) {
        return i10(!this.red, "Already a number in reduction context"), this._forceRed(f);
      }, s10.prototype.redAdd = function(f) {
        return i10(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
      }, s10.prototype.redIAdd = function(f) {
        return i10(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
      }, s10.prototype.redSub = function(f) {
        return i10(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
      }, s10.prototype.redISub = function(f) {
        return i10(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
      }, s10.prototype.redShl = function(f) {
        return i10(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
      }, s10.prototype.redMul = function(f) {
        return i10(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
      }, s10.prototype.redIMul = function(f) {
        return i10(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
      }, s10.prototype.redSqr = function() {
        return i10(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, s10.prototype.redISqr = function() {
        return i10(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, s10.prototype.redSqrt = function() {
        return i10(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, s10.prototype.redInvm = function() {
        return i10(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, s10.prototype.redNeg = function() {
        return i10(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, s10.prototype.redPow = function(f) {
        return i10(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
      };
      var W = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function z(h, f) {
        this.name = h, this.p = new s10(f, 16), this.n = this.p.bitLength(), this.k = new s10(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      z.prototype._tmp = function() {
        var f = new s10(null);
        return f.words = new Array(Math.ceil(this.n / 13)), f;
      }, z.prototype.ireduce = function(f) {
        var m = f, S;
        do
          this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), S = m.bitLength();
        while (S > this.n);
        var T = S < this.n ? -1 : m.ucmp(this.p);
        return T === 0 ? (m.words[0] = 0, m.length = 1) : T > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
      }, z.prototype.split = function(f, m) {
        f.iushrn(this.n, 0, m);
      }, z.prototype.imulK = function(f) {
        return f.imul(this.k);
      };
      function G() {
        z.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      o10(G, z), G.prototype.split = function(f, m) {
        for (var S = 4194303, T = Math.min(f.length, 9), E = 0; E < T; E++)
          m.words[E] = f.words[E];
        if (m.length = T, f.length <= 9) {
          f.words[0] = 0, f.length = 1;
          return;
        }
        var I = f.words[9];
        for (m.words[m.length++] = I & S, E = 10; E < f.length; E++) {
          var C = f.words[E] | 0;
          f.words[E - 10] = (C & S) << 4 | I >>> 22, I = C;
        }
        I >>>= 22, f.words[E - 10] = I, I === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
      }, G.prototype.imulK = function(f) {
        f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
        for (var m = 0, S = 0; S < f.length; S++) {
          var T = f.words[S] | 0;
          m += T * 977, f.words[S] = m & 67108863, m = T * 64 + (m / 67108864 | 0);
        }
        return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
      };
      function re() {
        z.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      o10(re, z);
      function ie() {
        z.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      o10(ie, z);
      function oe() {
        z.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      o10(oe, z), oe.prototype.imulK = function(f) {
        for (var m = 0, S = 0; S < f.length; S++) {
          var T = (f.words[S] | 0) * 19 + m, E = T & 67108863;
          T >>>= 26, f.words[S] = E, m = T;
        }
        return m !== 0 && (f.words[f.length++] = m), f;
      }, s10._prime = function(f) {
        if (W[f])
          return W[f];
        var m;
        if (f === "k256")
          m = new G();
        else if (f === "p224")
          m = new re();
        else if (f === "p192")
          m = new ie();
        else if (f === "p25519")
          m = new oe();
        else
          throw new Error("Unknown prime " + f);
        return W[f] = m, m;
      };
      function q(h) {
        if (typeof h == "string") {
          var f = s10._prime(h);
          this.m = f.p, this.prime = f;
        } else
          i10(h.gtn(1), "modulus must be greater than 1"), this.m = h, this.prime = null;
      }
      q.prototype._verify1 = function(f) {
        i10(f.negative === 0, "red works only with positives"), i10(f.red, "red works only with red numbers");
      }, q.prototype._verify2 = function(f, m) {
        i10((f.negative | m.negative) === 0, "red works only with positives"), i10(
          f.red && f.red === m.red,
          "red works only with red numbers"
        );
      }, q.prototype.imod = function(f) {
        return this.prime ? this.prime.ireduce(f)._forceRed(this) : (d6(f, f.umod(this.m)._forceRed(this)), f);
      }, q.prototype.neg = function(f) {
        return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
      }, q.prototype.add = function(f, m) {
        this._verify2(f, m);
        var S = f.add(m);
        return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
      }, q.prototype.iadd = function(f, m) {
        this._verify2(f, m);
        var S = f.iadd(m);
        return S.cmp(this.m) >= 0 && S.isub(this.m), S;
      }, q.prototype.sub = function(f, m) {
        this._verify2(f, m);
        var S = f.sub(m);
        return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
      }, q.prototype.isub = function(f, m) {
        this._verify2(f, m);
        var S = f.isub(m);
        return S.cmpn(0) < 0 && S.iadd(this.m), S;
      }, q.prototype.shl = function(f, m) {
        return this._verify1(f), this.imod(f.ushln(m));
      }, q.prototype.imul = function(f, m) {
        return this._verify2(f, m), this.imod(f.imul(m));
      }, q.prototype.mul = function(f, m) {
        return this._verify2(f, m), this.imod(f.mul(m));
      }, q.prototype.isqr = function(f) {
        return this.imul(f, f.clone());
      }, q.prototype.sqr = function(f) {
        return this.mul(f, f);
      }, q.prototype.sqrt = function(f) {
        if (f.isZero())
          return f.clone();
        var m = this.m.andln(3);
        if (i10(m % 2 === 1), m === 3) {
          var S = this.m.add(new s10(1)).iushrn(2);
          return this.pow(f, S);
        }
        for (var T = this.m.subn(1), E = 0; !T.isZero() && T.andln(1) === 0; )
          E++, T.iushrn(1);
        i10(!T.isZero());
        var I = new s10(1).toRed(this), C = I.redNeg(), g = this.m.subn(1).iushrn(1), v10 = this.m.bitLength();
        for (v10 = new s10(2 * v10 * v10).toRed(this); this.pow(v10, g).cmp(C) !== 0; )
          v10.redIAdd(C);
        for (var k = this.pow(v10, T), Q = this.pow(f, T.addn(1).iushrn(1)), Z = this.pow(f, T), ae = E; Z.cmp(I) !== 0; ) {
          for (var ve = Z, we = 0; ve.cmp(I) !== 0; we++)
            ve = ve.redSqr();
          i10(we < ae);
          var he = this.pow(k, new s10(1).iushln(ae - we - 1));
          Q = Q.redMul(he), k = he.redSqr(), Z = Z.redMul(k), ae = we;
        }
        return Q;
      }, q.prototype.invm = function(f) {
        var m = f._invmp(this.m);
        return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
      }, q.prototype.pow = function(f, m) {
        if (m.isZero())
          return new s10(1).toRed(this);
        if (m.cmpn(1) === 0)
          return f.clone();
        var S = 4, T = new Array(1 << S);
        T[0] = new s10(1).toRed(this), T[1] = f;
        for (var E = 2; E < T.length; E++)
          T[E] = this.mul(T[E - 1], f);
        var I = T[0], C = 0, g = 0, v10 = m.bitLength() % 26;
        for (v10 === 0 && (v10 = 26), E = m.length - 1; E >= 0; E--) {
          for (var k = m.words[E], Q = v10 - 1; Q >= 0; Q--) {
            var Z = k >> Q & 1;
            if (I !== T[0] && (I = this.sqr(I)), Z === 0 && C === 0) {
              g = 0;
              continue;
            }
            C <<= 1, C |= Z, g++, !(g !== S && (E !== 0 || Q !== 0)) && (I = this.mul(I, T[C]), g = 0, C = 0);
          }
          v10 = 26;
        }
        return I;
      }, q.prototype.convertTo = function(f) {
        var m = f.umod(this.m);
        return m === f ? m.clone() : m;
      }, q.prototype.convertFrom = function(f) {
        var m = f.clone();
        return m.red = null, m;
      }, s10.mont = function(f) {
        return new L(f);
      };
      function L(h) {
        q.call(this, h), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s10(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o10(L, q), L.prototype.convertTo = function(f) {
        return this.imod(f.ushln(this.shift));
      }, L.prototype.convertFrom = function(f) {
        var m = this.imod(f.mul(this.rinv));
        return m.red = null, m;
      }, L.prototype.imul = function(f, m) {
        if (f.isZero() || m.isZero())
          return f.words[0] = 0, f.length = 1, f;
        var S = f.imul(m), T = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = S.isub(T).iushrn(this.shift), I = E;
        return E.cmp(this.m) >= 0 ? I = E.isub(this.m) : E.cmpn(0) < 0 && (I = E.iadd(this.m)), I._forceRed(this);
      }, L.prototype.mul = function(f, m) {
        if (f.isZero() || m.isZero())
          return new s10(0)._forceRed(this);
        var S = f.mul(m), T = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = S.isub(T).iushrn(this.shift), I = E;
        return E.cmp(this.m) >= 0 ? I = E.isub(this.m) : E.cmpn(0) < 0 && (I = E.iadd(this.m)), I._forceRed(this);
      }, L.prototype.invm = function(f) {
        var m = this.imod(f._invmp(this.m).mul(this.r2));
        return m._forceRed(this);
      };
    })(typeof t10 > "u" || t10, e10);
  }
});
var cs = 9e15;
var ao = 1e9;
var Uf = "0123456789abcdef";
var zc = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var qc = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var Ff = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -cs,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: cs,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var Fv;
var Ei;
var ot = true;
var Il = "[DecimalError] ";
var Qi = Il + "Invalid argument: ";
var $v = Il + "Precision limit exceeded";
var Vv = Il + "crypto unavailable";
var zv = "[object Decimal]";
var Ur = Math.floor;
var br = Math.pow;
var g9 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var v9 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var b9 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var qv = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var Nn = 1e7;
var Ke = 7;
var y9 = 9007199254740991;
var w9 = zc.length - 1;
var $f = qc.length - 1;
var me = { toStringTag: zv };
me.absoluteValue = me.abs = function() {
  var e10 = new this.constructor(this);
  return e10.s < 0 && (e10.s = 1), qe(e10);
};
me.ceil = function() {
  return qe(new this.constructor(this), this.e + 1, 2);
};
me.clampedTo = me.clamp = function(e10, t10) {
  var r10, n10 = this, i10 = n10.constructor;
  if (e10 = new i10(e10), t10 = new i10(t10), !e10.s || !t10.s)
    return new i10(NaN);
  if (e10.gt(t10))
    throw Error(Qi + t10);
  return r10 = n10.cmp(e10), r10 < 0 ? e10 : n10.cmp(t10) > 0 ? t10 : new i10(n10);
};
me.comparedTo = me.cmp = function(e10) {
  var t10, r10, n10, i10, o10 = this, s10 = o10.d, a10 = (e10 = new o10.constructor(e10)).d, c = o10.s, l10 = e10.s;
  if (!s10 || !a10)
    return !c || !l10 ? NaN : c !== l10 ? c : s10 === a10 ? 0 : !s10 ^ c < 0 ? 1 : -1;
  if (!s10[0] || !a10[0])
    return s10[0] ? c : a10[0] ? -l10 : 0;
  if (c !== l10)
    return c;
  if (o10.e !== e10.e)
    return o10.e > e10.e ^ c < 0 ? 1 : -1;
  for (n10 = s10.length, i10 = a10.length, t10 = 0, r10 = n10 < i10 ? n10 : i10; t10 < r10; ++t10)
    if (s10[t10] !== a10[t10])
      return s10[t10] > a10[t10] ^ c < 0 ? 1 : -1;
  return n10 === i10 ? 0 : n10 > i10 ^ c < 0 ? 1 : -1;
};
me.cosine = me.cos = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.d ? r10.d[0] ? (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + Math.max(r10.e, r10.sd()) + Ke, n10.rounding = 1, r10 = x9(n10, Yv(n10, r10)), n10.precision = e10, n10.rounding = t10, qe(Ei == 2 || Ei == 3 ? r10.neg() : r10, e10, t10, true)) : new n10(1) : new n10(NaN);
};
me.cubeRoot = me.cbrt = function() {
  var e10, t10, r10, n10, i10, o10, s10, a10, c, l10, u10 = this, d6 = u10.constructor;
  if (!u10.isFinite() || u10.isZero())
    return new d6(u10);
  for (ot = false, o10 = u10.s * br(u10.s * u10, 1 / 3), !o10 || Math.abs(o10) == 1 / 0 ? (r10 = Pr(u10.d), e10 = u10.e, (o10 = (e10 - r10.length + 1) % 3) && (r10 += o10 == 1 || o10 == -2 ? "0" : "00"), o10 = br(r10, 1 / 3), e10 = Ur((e10 + 1) / 3) - (e10 % 3 == (e10 < 0 ? -1 : 2)), o10 == 1 / 0 ? r10 = "5e" + e10 : (r10 = o10.toExponential(), r10 = r10.slice(0, r10.indexOf("e") + 1) + e10), n10 = new d6(r10), n10.s = u10.s) : n10 = new d6(o10.toString()), s10 = (e10 = d6.precision) + 3; ; )
    if (a10 = n10, c = a10.times(a10).times(a10), l10 = c.plus(u10), n10 = Yt(l10.plus(u10).times(a10), l10.plus(c), s10 + 2, 1), Pr(a10.d).slice(0, s10) === (r10 = Pr(n10.d)).slice(0, s10))
      if (r10 = r10.slice(s10 - 3, s10 + 1), r10 == "9999" || !i10 && r10 == "4999") {
        if (!i10 && (qe(a10, e10 + 1, 0), a10.times(a10).times(a10).eq(u10))) {
          n10 = a10;
          break;
        }
        s10 += 4, i10 = 1;
      } else {
        (!+r10 || !+r10.slice(1) && r10.charAt(0) == "5") && (qe(n10, e10 + 1, 1), t10 = !n10.times(n10).times(n10).eq(u10));
        break;
      }
  return ot = true, qe(n10, e10, d6.rounding, t10);
};
me.decimalPlaces = me.dp = function() {
  var e10, t10 = this.d, r10 = NaN;
  if (t10) {
    if (e10 = t10.length - 1, r10 = (e10 - Ur(this.e / Ke)) * Ke, e10 = t10[e10], e10)
      for (; e10 % 10 == 0; e10 /= 10)
        r10--;
    r10 < 0 && (r10 = 0);
  }
  return r10;
};
me.dividedBy = me.div = function(e10) {
  return Yt(this, new this.constructor(e10));
};
me.dividedToIntegerBy = me.divToInt = function(e10) {
  var t10 = this, r10 = t10.constructor;
  return qe(Yt(t10, new r10(e10), 0, 1, 1), r10.precision, r10.rounding);
};
me.equals = me.eq = function(e10) {
  return this.cmp(e10) === 0;
};
me.floor = function() {
  return qe(new this.constructor(this), this.e + 1, 3);
};
me.greaterThan = me.gt = function(e10) {
  return this.cmp(e10) > 0;
};
me.greaterThanOrEqualTo = me.gte = function(e10) {
  var t10 = this.cmp(e10);
  return t10 == 1 || t10 === 0;
};
me.hyperbolicCosine = me.cosh = function() {
  var e10, t10, r10, n10, i10, o10 = this, s10 = o10.constructor, a10 = new s10(1);
  if (!o10.isFinite())
    return new s10(o10.s ? 1 / 0 : NaN);
  if (o10.isZero())
    return a10;
  r10 = s10.precision, n10 = s10.rounding, s10.precision = r10 + Math.max(o10.e, o10.sd()) + 4, s10.rounding = 1, i10 = o10.d.length, i10 < 32 ? (e10 = Math.ceil(i10 / 3), t10 = (1 / Rl(4, e10)).toString()) : (e10 = 16, t10 = "2.3283064365386962890625e-10"), o10 = ws(s10, 1, o10.times(t10), new s10(1), true);
  for (var c, l10 = e10, u10 = new s10(8); l10--; )
    c = o10.times(o10), o10 = a10.minus(c.times(u10.minus(c.times(u10))));
  return qe(o10, s10.precision = r10, s10.rounding = n10, true);
};
me.hyperbolicSine = me.sinh = function() {
  var e10, t10, r10, n10, i10 = this, o10 = i10.constructor;
  if (!i10.isFinite() || i10.isZero())
    return new o10(i10);
  if (t10 = o10.precision, r10 = o10.rounding, o10.precision = t10 + Math.max(i10.e, i10.sd()) + 4, o10.rounding = 1, n10 = i10.d.length, n10 < 3)
    i10 = ws(o10, 2, i10, i10, true);
  else {
    e10 = 1.4 * Math.sqrt(n10), e10 = e10 > 16 ? 16 : e10 | 0, i10 = i10.times(1 / Rl(5, e10)), i10 = ws(o10, 2, i10, i10, true);
    for (var s10, a10 = new o10(5), c = new o10(16), l10 = new o10(20); e10--; )
      s10 = i10.times(i10), i10 = i10.times(a10.plus(s10.times(c.times(s10).plus(l10))));
  }
  return o10.precision = t10, o10.rounding = r10, qe(i10, t10, r10, true);
};
me.hyperbolicTangent = me.tanh = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.isFinite() ? r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + 7, n10.rounding = 1, Yt(r10.sinh(), r10.cosh(), n10.precision = e10, n10.rounding = t10)) : new n10(r10.s);
};
me.inverseCosine = me.acos = function() {
  var e10, t10 = this, r10 = t10.constructor, n10 = t10.abs().cmp(1), i10 = r10.precision, o10 = r10.rounding;
  return n10 !== -1 ? n10 === 0 ? t10.isNeg() ? On(r10, i10, o10) : new r10(0) : new r10(NaN) : t10.isZero() ? On(r10, i10 + 4, o10).times(0.5) : (r10.precision = i10 + 6, r10.rounding = 1, t10 = t10.asin(), e10 = On(r10, i10 + 4, o10).times(0.5), r10.precision = i10, r10.rounding = o10, e10.minus(t10));
};
me.inverseHyperbolicCosine = me.acosh = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.lte(1) ? new n10(r10.eq(1) ? 0 : NaN) : r10.isFinite() ? (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + Math.max(Math.abs(r10.e), r10.sd()) + 4, n10.rounding = 1, ot = false, r10 = r10.times(r10).minus(1).sqrt().plus(r10), ot = true, n10.precision = e10, n10.rounding = t10, r10.ln()) : new n10(r10);
};
me.inverseHyperbolicSine = me.asinh = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return !r10.isFinite() || r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + 2 * Math.max(Math.abs(r10.e), r10.sd()) + 6, n10.rounding = 1, ot = false, r10 = r10.times(r10).plus(1).sqrt().plus(r10), ot = true, n10.precision = e10, n10.rounding = t10, r10.ln());
};
me.inverseHyperbolicTangent = me.atanh = function() {
  var e10, t10, r10, n10, i10 = this, o10 = i10.constructor;
  return i10.isFinite() ? i10.e >= 0 ? new o10(i10.abs().eq(1) ? i10.s / 0 : i10.isZero() ? i10 : NaN) : (e10 = o10.precision, t10 = o10.rounding, n10 = i10.sd(), Math.max(n10, e10) < 2 * -i10.e - 1 ? qe(new o10(i10), e10, t10, true) : (o10.precision = r10 = n10 - i10.e, i10 = Yt(i10.plus(1), new o10(1).minus(i10), r10 + e10, 1), o10.precision = e10 + 4, o10.rounding = 1, i10 = i10.ln(), o10.precision = e10, o10.rounding = t10, i10.times(0.5))) : new o10(NaN);
};
me.inverseSine = me.asin = function() {
  var e10, t10, r10, n10, i10 = this, o10 = i10.constructor;
  return i10.isZero() ? new o10(i10) : (t10 = i10.abs().cmp(1), r10 = o10.precision, n10 = o10.rounding, t10 !== -1 ? t10 === 0 ? (e10 = On(o10, r10 + 4, n10).times(0.5), e10.s = i10.s, e10) : new o10(NaN) : (o10.precision = r10 + 6, o10.rounding = 1, i10 = i10.div(new o10(1).minus(i10.times(i10)).sqrt().plus(1)).atan(), o10.precision = r10, o10.rounding = n10, i10.times(2)));
};
me.inverseTangent = me.atan = function() {
  var e10, t10, r10, n10, i10, o10, s10, a10, c, l10 = this, u10 = l10.constructor, d6 = u10.precision, p = u10.rounding;
  if (l10.isFinite()) {
    if (l10.isZero())
      return new u10(l10);
    if (l10.abs().eq(1) && d6 + 4 <= $f)
      return s10 = On(u10, d6 + 4, p).times(0.25), s10.s = l10.s, s10;
  } else {
    if (!l10.s)
      return new u10(NaN);
    if (d6 + 4 <= $f)
      return s10 = On(u10, d6 + 4, p).times(0.5), s10.s = l10.s, s10;
  }
  for (u10.precision = a10 = d6 + 10, u10.rounding = 1, r10 = Math.min(28, a10 / Ke + 2 | 0), e10 = r10; e10; --e10)
    l10 = l10.div(l10.times(l10).plus(1).sqrt().plus(1));
  for (ot = false, t10 = Math.ceil(a10 / Ke), n10 = 1, c = l10.times(l10), s10 = new u10(l10), i10 = l10; e10 !== -1; )
    if (i10 = i10.times(c), o10 = s10.minus(i10.div(n10 += 2)), i10 = i10.times(c), s10 = o10.plus(i10.div(n10 += 2)), s10.d[t10] !== void 0)
      for (e10 = t10; s10.d[e10] === o10.d[e10] && e10--; )
        ;
  return r10 && (s10 = s10.times(2 << r10 - 1)), ot = true, qe(s10, u10.precision = d6, u10.rounding = p, true);
};
me.isFinite = function() {
  return !!this.d;
};
me.isInteger = me.isInt = function() {
  return !!this.d && Ur(this.e / Ke) > this.d.length - 2;
};
me.isNaN = function() {
  return !this.s;
};
me.isNegative = me.isNeg = function() {
  return this.s < 0;
};
me.isPositive = me.isPos = function() {
  return this.s > 0;
};
me.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
me.lessThan = me.lt = function(e10) {
  return this.cmp(e10) < 0;
};
me.lessThanOrEqualTo = me.lte = function(e10) {
  return this.cmp(e10) < 1;
};
me.logarithm = me.log = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10 = this, u10 = l10.constructor, d6 = u10.precision, p = u10.rounding, y = 5;
  if (e10 == null)
    e10 = new u10(10), t10 = true;
  else {
    if (e10 = new u10(e10), r10 = e10.d, e10.s < 0 || !r10 || !r10[0] || e10.eq(1))
      return new u10(NaN);
    t10 = e10.eq(10);
  }
  if (r10 = l10.d, l10.s < 0 || !r10 || !r10[0] || l10.eq(1))
    return new u10(r10 && !r10[0] ? -1 / 0 : l10.s != 1 ? NaN : r10 ? 0 : 1 / 0);
  if (t10)
    if (r10.length > 1)
      o10 = true;
    else {
      for (i10 = r10[0]; i10 % 10 === 0; )
        i10 /= 10;
      o10 = i10 !== 1;
    }
  if (ot = false, a10 = d6 + y, s10 = Ki(l10, a10), n10 = t10 ? Hc(u10, a10 + 10) : Ki(e10, a10), c = Yt(s10, n10, a10, 1), va(c.d, i10 = d6, p))
    do
      if (a10 += 10, s10 = Ki(l10, a10), n10 = t10 ? Hc(u10, a10 + 10) : Ki(e10, a10), c = Yt(s10, n10, a10, 1), !o10) {
        +Pr(c.d).slice(i10 + 1, i10 + 15) + 1 == 1e14 && (c = qe(c, d6 + 1, 0));
        break;
      }
    while (va(c.d, i10 += 10, p));
  return ot = true, qe(c, d6, p);
};
me.minus = me.sub = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y = this, x = y.constructor;
  if (e10 = new x(e10), !y.d || !e10.d)
    return !y.s || !e10.s ? e10 = new x(NaN) : y.d ? e10.s = -e10.s : e10 = new x(e10.d || y.s !== e10.s ? y : NaN), e10;
  if (y.s != e10.s)
    return e10.s = -e10.s, y.plus(e10);
  if (l10 = y.d, p = e10.d, a10 = x.precision, c = x.rounding, !l10[0] || !p[0]) {
    if (p[0])
      e10.s = -e10.s;
    else if (l10[0])
      e10 = new x(y);
    else
      return new x(c === 3 ? -0 : 0);
    return ot ? qe(e10, a10, c) : e10;
  }
  if (r10 = Ur(e10.e / Ke), u10 = Ur(y.e / Ke), l10 = l10.slice(), o10 = u10 - r10, o10) {
    for (d6 = o10 < 0, d6 ? (t10 = l10, o10 = -o10, s10 = p.length) : (t10 = p, r10 = u10, s10 = l10.length), n10 = Math.max(Math.ceil(a10 / Ke), s10) + 2, o10 > n10 && (o10 = n10, t10.length = 1), t10.reverse(), n10 = o10; n10--; )
      t10.push(0);
    t10.reverse();
  } else {
    for (n10 = l10.length, s10 = p.length, d6 = n10 < s10, d6 && (s10 = n10), n10 = 0; n10 < s10; n10++)
      if (l10[n10] != p[n10]) {
        d6 = l10[n10] < p[n10];
        break;
      }
    o10 = 0;
  }
  for (d6 && (t10 = l10, l10 = p, p = t10, e10.s = -e10.s), s10 = l10.length, n10 = p.length - s10; n10 > 0; --n10)
    l10[s10++] = 0;
  for (n10 = p.length; n10 > o10; ) {
    if (l10[--n10] < p[n10]) {
      for (i10 = n10; i10 && l10[--i10] === 0; )
        l10[i10] = Nn - 1;
      --l10[i10], l10[n10] += Nn;
    }
    l10[n10] -= p[n10];
  }
  for (; l10[--s10] === 0; )
    l10.pop();
  for (; l10[0] === 0; l10.shift())
    --r10;
  return l10[0] ? (e10.d = l10, e10.e = Ol(l10, r10), ot ? qe(e10, a10, c) : e10) : new x(c === 3 ? -0 : 0);
};
me.modulo = me.mod = function(e10) {
  var t10, r10 = this, n10 = r10.constructor;
  return e10 = new n10(e10), !r10.d || !e10.s || e10.d && !e10.d[0] ? new n10(NaN) : !e10.d || r10.d && !r10.d[0] ? qe(new n10(r10), n10.precision, n10.rounding) : (ot = false, n10.modulo == 9 ? (t10 = Yt(r10, e10.abs(), 0, 3, 1), t10.s *= e10.s) : t10 = Yt(r10, e10, 0, n10.modulo, 1), t10 = t10.times(e10), ot = true, r10.minus(t10));
};
me.naturalExponential = me.exp = function() {
  return Vf(this);
};
me.naturalLogarithm = me.ln = function() {
  return Ki(this);
};
me.negated = me.neg = function() {
  var e10 = new this.constructor(this);
  return e10.s = -e10.s, qe(e10);
};
me.plus = me.add = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6 = this, p = d6.constructor;
  if (e10 = new p(e10), !d6.d || !e10.d)
    return !d6.s || !e10.s ? e10 = new p(NaN) : d6.d || (e10 = new p(e10.d || d6.s === e10.s ? d6 : NaN)), e10;
  if (d6.s != e10.s)
    return e10.s = -e10.s, d6.minus(e10);
  if (l10 = d6.d, u10 = e10.d, a10 = p.precision, c = p.rounding, !l10[0] || !u10[0])
    return u10[0] || (e10 = new p(d6)), ot ? qe(e10, a10, c) : e10;
  if (o10 = Ur(d6.e / Ke), n10 = Ur(e10.e / Ke), l10 = l10.slice(), i10 = o10 - n10, i10) {
    for (i10 < 0 ? (r10 = l10, i10 = -i10, s10 = u10.length) : (r10 = u10, n10 = o10, s10 = l10.length), o10 = Math.ceil(a10 / Ke), s10 = o10 > s10 ? o10 + 1 : s10 + 1, i10 > s10 && (i10 = s10, r10.length = 1), r10.reverse(); i10--; )
      r10.push(0);
    r10.reverse();
  }
  for (s10 = l10.length, i10 = u10.length, s10 - i10 < 0 && (i10 = s10, r10 = u10, u10 = l10, l10 = r10), t10 = 0; i10; )
    t10 = (l10[--i10] = l10[i10] + u10[i10] + t10) / Nn | 0, l10[i10] %= Nn;
  for (t10 && (l10.unshift(t10), ++n10), s10 = l10.length; l10[--s10] == 0; )
    l10.pop();
  return e10.d = l10, e10.e = Ol(l10, n10), ot ? qe(e10, a10, c) : e10;
};
me.precision = me.sd = function(e10) {
  var t10, r10 = this;
  if (e10 !== void 0 && e10 !== !!e10 && e10 !== 1 && e10 !== 0)
    throw Error(Qi + e10);
  return r10.d ? (t10 = Hv(r10.d), e10 && r10.e + 1 > t10 && (t10 = r10.e + 1)) : t10 = NaN, t10;
};
me.round = function() {
  var e10 = this, t10 = e10.constructor;
  return qe(new t10(e10), e10.e + 1, t10.rounding);
};
me.sine = me.sin = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.isFinite() ? r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + Math.max(r10.e, r10.sd()) + Ke, n10.rounding = 1, r10 = _9(n10, Yv(n10, r10)), n10.precision = e10, n10.rounding = t10, qe(Ei > 2 ? r10.neg() : r10, e10, t10, true)) : new n10(NaN);
};
me.squareRoot = me.sqrt = function() {
  var e10, t10, r10, n10, i10, o10, s10 = this, a10 = s10.d, c = s10.e, l10 = s10.s, u10 = s10.constructor;
  if (l10 !== 1 || !a10 || !a10[0])
    return new u10(!l10 || l10 < 0 && (!a10 || a10[0]) ? NaN : a10 ? s10 : 1 / 0);
  for (ot = false, l10 = Math.sqrt(+s10), l10 == 0 || l10 == 1 / 0 ? (t10 = Pr(a10), (t10.length + c) % 2 == 0 && (t10 += "0"), l10 = Math.sqrt(t10), c = Ur((c + 1) / 2) - (c < 0 || c % 2), l10 == 1 / 0 ? t10 = "5e" + c : (t10 = l10.toExponential(), t10 = t10.slice(0, t10.indexOf("e") + 1) + c), n10 = new u10(t10)) : n10 = new u10(l10.toString()), r10 = (c = u10.precision) + 3; ; )
    if (o10 = n10, n10 = o10.plus(Yt(s10, o10, r10 + 2, 1)).times(0.5), Pr(o10.d).slice(0, r10) === (t10 = Pr(n10.d)).slice(0, r10))
      if (t10 = t10.slice(r10 - 3, r10 + 1), t10 == "9999" || !i10 && t10 == "4999") {
        if (!i10 && (qe(o10, c + 1, 0), o10.times(o10).eq(s10))) {
          n10 = o10;
          break;
        }
        r10 += 4, i10 = 1;
      } else {
        (!+t10 || !+t10.slice(1) && t10.charAt(0) == "5") && (qe(n10, c + 1, 1), e10 = !n10.times(n10).eq(s10));
        break;
      }
  return ot = true, qe(n10, c, u10.rounding, e10);
};
me.tangent = me.tan = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.isFinite() ? r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + 10, n10.rounding = 1, r10 = r10.sin(), r10.s = 1, r10 = Yt(r10, new n10(1).minus(r10.times(r10)).sqrt(), e10 + 10, 0), n10.precision = e10, n10.rounding = t10, qe(Ei == 2 || Ei == 4 ? r10.neg() : r10, e10, t10, true)) : new n10(NaN);
};
me.times = me.mul = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10 = this, d6 = u10.constructor, p = u10.d, y = (e10 = new d6(e10)).d;
  if (e10.s *= u10.s, !p || !p[0] || !y || !y[0])
    return new d6(!e10.s || p && !p[0] && !y || y && !y[0] && !p ? NaN : !p || !y ? e10.s / 0 : e10.s * 0);
  for (r10 = Ur(u10.e / Ke) + Ur(e10.e / Ke), c = p.length, l10 = y.length, c < l10 && (o10 = p, p = y, y = o10, s10 = c, c = l10, l10 = s10), o10 = [], s10 = c + l10, n10 = s10; n10--; )
    o10.push(0);
  for (n10 = l10; --n10 >= 0; ) {
    for (t10 = 0, i10 = c + n10; i10 > n10; )
      a10 = o10[i10] + y[n10] * p[i10 - n10 - 1] + t10, o10[i10--] = a10 % Nn | 0, t10 = a10 / Nn | 0;
    o10[i10] = (o10[i10] + t10) % Nn | 0;
  }
  for (; !o10[--s10]; )
    o10.pop();
  return t10 ? ++r10 : o10.shift(), e10.d = o10, e10.e = Ol(o10, r10), ot ? qe(e10, d6.precision, d6.rounding) : e10;
};
me.toBinary = function(e10, t10) {
  return s0(this, 2, e10, t10);
};
me.toDecimalPlaces = me.toDP = function(e10, t10) {
  var r10 = this, n10 = r10.constructor;
  return r10 = new n10(r10), e10 === void 0 ? r10 : (Kr(e10, 0, ao), t10 === void 0 ? t10 = n10.rounding : Kr(t10, 0, 8), qe(r10, e10 + r10.e + 1, t10));
};
me.toExponential = function(e10, t10) {
  var r10, n10 = this, i10 = n10.constructor;
  return e10 === void 0 ? r10 = ti(n10, true) : (Kr(e10, 0, ao), t10 === void 0 ? t10 = i10.rounding : Kr(t10, 0, 8), n10 = qe(new i10(n10), e10 + 1, t10), r10 = ti(n10, true, e10 + 1)), n10.isNeg() && !n10.isZero() ? "-" + r10 : r10;
};
me.toFixed = function(e10, t10) {
  var r10, n10, i10 = this, o10 = i10.constructor;
  return e10 === void 0 ? r10 = ti(i10) : (Kr(e10, 0, ao), t10 === void 0 ? t10 = o10.rounding : Kr(t10, 0, 8), n10 = qe(new o10(i10), e10 + i10.e + 1, t10), r10 = ti(n10, false, e10 + n10.e + 1)), i10.isNeg() && !i10.isZero() ? "-" + r10 : r10;
};
me.toFraction = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y = this, x = y.d, b = y.constructor;
  if (!x)
    return new b(y);
  if (l10 = r10 = new b(1), n10 = c = new b(0), t10 = new b(n10), o10 = t10.e = Hv(x) - y.e - 1, s10 = o10 % Ke, t10.d[0] = br(10, s10 < 0 ? Ke + s10 : s10), e10 == null)
    e10 = o10 > 0 ? t10 : l10;
  else {
    if (a10 = new b(e10), !a10.isInt() || a10.lt(l10))
      throw Error(Qi + a10);
    e10 = a10.gt(t10) ? o10 > 0 ? t10 : l10 : a10;
  }
  for (ot = false, a10 = new b(Pr(x)), u10 = b.precision, b.precision = o10 = x.length * Ke * 2; d6 = Yt(a10, t10, 0, 1, 1), i10 = r10.plus(d6.times(n10)), i10.cmp(e10) != 1; )
    r10 = n10, n10 = i10, i10 = l10, l10 = c.plus(d6.times(i10)), c = i10, i10 = t10, t10 = a10.minus(d6.times(i10)), a10 = i10;
  return i10 = Yt(e10.minus(r10), n10, 0, 1, 1), c = c.plus(i10.times(l10)), r10 = r10.plus(i10.times(n10)), c.s = l10.s = y.s, p = Yt(l10, n10, o10, 1).minus(y).abs().cmp(Yt(c, r10, o10, 1).minus(y).abs()) < 1 ? [l10, n10] : [c, r10], b.precision = u10, ot = true, p;
};
me.toHexadecimal = me.toHex = function(e10, t10) {
  return s0(this, 16, e10, t10);
};
me.toNearest = function(e10, t10) {
  var r10 = this, n10 = r10.constructor;
  if (r10 = new n10(r10), e10 == null) {
    if (!r10.d)
      return r10;
    e10 = new n10(1), t10 = n10.rounding;
  } else {
    if (e10 = new n10(e10), t10 === void 0 ? t10 = n10.rounding : Kr(t10, 0, 8), !r10.d)
      return e10.s ? r10 : e10;
    if (!e10.d)
      return e10.s && (e10.s = r10.s), e10;
  }
  return e10.d[0] ? (ot = false, r10 = Yt(r10, e10, 0, t10, 1).times(e10), ot = true, qe(r10)) : (e10.s = r10.s, r10 = e10), r10;
};
me.toNumber = function() {
  return +this;
};
me.toOctal = function(e10, t10) {
  return s0(this, 8, e10, t10);
};
me.toPower = me.pow = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10 = this, c = a10.constructor, l10 = +(e10 = new c(e10));
  if (!a10.d || !e10.d || !a10.d[0] || !e10.d[0])
    return new c(br(+a10, l10));
  if (a10 = new c(a10), a10.eq(1))
    return a10;
  if (n10 = c.precision, o10 = c.rounding, e10.eq(1))
    return qe(a10, n10, o10);
  if (t10 = Ur(e10.e / Ke), t10 >= e10.d.length - 1 && (r10 = l10 < 0 ? -l10 : l10) <= y9)
    return i10 = Wv(c, a10, r10, n10), e10.s < 0 ? new c(1).div(i10) : qe(i10, n10, o10);
  if (s10 = a10.s, s10 < 0) {
    if (t10 < e10.d.length - 1)
      return new c(NaN);
    if (e10.d[t10] & 1 || (s10 = 1), a10.e == 0 && a10.d[0] == 1 && a10.d.length == 1)
      return a10.s = s10, a10;
  }
  return r10 = br(+a10, l10), t10 = r10 == 0 || !isFinite(r10) ? Ur(l10 * (Math.log("0." + Pr(a10.d)) / Math.LN10 + a10.e + 1)) : new c(r10 + "").e, t10 > c.maxE + 1 || t10 < c.minE - 1 ? new c(t10 > 0 ? s10 / 0 : 0) : (ot = false, c.rounding = a10.s = 1, r10 = Math.min(12, (t10 + "").length), i10 = Vf(e10.times(Ki(a10, n10 + r10)), n10), i10.d && (i10 = qe(i10, n10 + 5, 1), va(i10.d, n10, o10) && (t10 = n10 + 10, i10 = qe(Vf(e10.times(Ki(a10, t10 + r10)), t10), t10 + 5, 1), +Pr(i10.d).slice(n10 + 1, n10 + 15) + 1 == 1e14 && (i10 = qe(i10, n10 + 1, 0)))), i10.s = s10, ot = true, c.rounding = o10, qe(i10, n10, o10));
};
me.toPrecision = function(e10, t10) {
  var r10, n10 = this, i10 = n10.constructor;
  return e10 === void 0 ? r10 = ti(n10, n10.e <= i10.toExpNeg || n10.e >= i10.toExpPos) : (Kr(e10, 1, ao), t10 === void 0 ? t10 = i10.rounding : Kr(t10, 0, 8), n10 = qe(new i10(n10), e10, t10), r10 = ti(n10, e10 <= n10.e || n10.e <= i10.toExpNeg, e10)), n10.isNeg() && !n10.isZero() ? "-" + r10 : r10;
};
me.toSignificantDigits = me.toSD = function(e10, t10) {
  var r10 = this, n10 = r10.constructor;
  return e10 === void 0 ? (e10 = n10.precision, t10 = n10.rounding) : (Kr(e10, 1, ao), t10 === void 0 ? t10 = n10.rounding : Kr(t10, 0, 8)), qe(new n10(r10), e10, t10);
};
me.toString = function() {
  var e10 = this, t10 = e10.constructor, r10 = ti(e10, e10.e <= t10.toExpNeg || e10.e >= t10.toExpPos);
  return e10.isNeg() && !e10.isZero() ? "-" + r10 : r10;
};
me.truncated = me.trunc = function() {
  return qe(new this.constructor(this), this.e + 1, 1);
};
me.valueOf = me.toJSON = function() {
  var e10 = this, t10 = e10.constructor, r10 = ti(e10, e10.e <= t10.toExpNeg || e10.e >= t10.toExpPos);
  return e10.isNeg() ? "-" + r10 : r10;
};
function Pr(e10) {
  var t10, r10, n10, i10 = e10.length - 1, o10 = "", s10 = e10[0];
  if (i10 > 0) {
    for (o10 += s10, t10 = 1; t10 < i10; t10++)
      n10 = e10[t10] + "", r10 = Ke - n10.length, r10 && (o10 += qi(r10)), o10 += n10;
    s10 = e10[t10], n10 = s10 + "", r10 = Ke - n10.length, r10 && (o10 += qi(r10));
  } else if (s10 === 0)
    return "0";
  for (; s10 % 10 === 0; )
    s10 /= 10;
  return o10 + s10;
}
function Kr(e10, t10, r10) {
  if (e10 !== ~~e10 || e10 < t10 || e10 > r10)
    throw Error(Qi + e10);
}
function va(e10, t10, r10, n10) {
  var i10, o10, s10, a10;
  for (o10 = e10[0]; o10 >= 10; o10 /= 10)
    --t10;
  return --t10 < 0 ? (t10 += Ke, i10 = 0) : (i10 = Math.ceil((t10 + 1) / Ke), t10 %= Ke), o10 = br(10, Ke - t10), a10 = e10[i10] % o10 | 0, n10 == null ? t10 < 3 ? (t10 == 0 ? a10 = a10 / 100 | 0 : t10 == 1 && (a10 = a10 / 10 | 0), s10 = r10 < 4 && a10 == 99999 || r10 > 3 && a10 == 49999 || a10 == 5e4 || a10 == 0) : s10 = (r10 < 4 && a10 + 1 == o10 || r10 > 3 && a10 + 1 == o10 / 2) && (e10[i10 + 1] / o10 / 100 | 0) == br(10, t10 - 2) - 1 || (a10 == o10 / 2 || a10 == 0) && (e10[i10 + 1] / o10 / 100 | 0) == 0 : t10 < 4 ? (t10 == 0 ? a10 = a10 / 1e3 | 0 : t10 == 1 ? a10 = a10 / 100 | 0 : t10 == 2 && (a10 = a10 / 10 | 0), s10 = (n10 || r10 < 4) && a10 == 9999 || !n10 && r10 > 3 && a10 == 4999) : s10 = ((n10 || r10 < 4) && a10 + 1 == o10 || !n10 && r10 > 3 && a10 + 1 == o10 / 2) && (e10[i10 + 1] / o10 / 1e3 | 0) == br(10, t10 - 3) - 1, s10;
}
function yc(e10, t10, r10) {
  for (var n10, i10 = [0], o10, s10 = 0, a10 = e10.length; s10 < a10; ) {
    for (o10 = i10.length; o10--; )
      i10[o10] *= t10;
    for (i10[0] += Uf.indexOf(e10.charAt(s10++)), n10 = 0; n10 < i10.length; n10++)
      i10[n10] > r10 - 1 && (i10[n10 + 1] === void 0 && (i10[n10 + 1] = 0), i10[n10 + 1] += i10[n10] / r10 | 0, i10[n10] %= r10);
  }
  return i10.reverse();
}
function x9(e10, t10) {
  var r10, n10, i10;
  if (t10.isZero())
    return t10;
  n10 = t10.d.length, n10 < 32 ? (r10 = Math.ceil(n10 / 3), i10 = (1 / Rl(4, r10)).toString()) : (r10 = 16, i10 = "2.3283064365386962890625e-10"), e10.precision += r10, t10 = ws(e10, 1, t10.times(i10), new e10(1));
  for (var o10 = r10; o10--; ) {
    var s10 = t10.times(t10);
    t10 = s10.times(s10).minus(s10).times(8).plus(1);
  }
  return e10.precision -= r10, t10;
}
var Yt = /* @__PURE__ */ function() {
  function e10(n10, i10, o10) {
    var s10, a10 = 0, c = n10.length;
    for (n10 = n10.slice(); c--; )
      s10 = n10[c] * i10 + a10, n10[c] = s10 % o10 | 0, a10 = s10 / o10 | 0;
    return a10 && n10.unshift(a10), n10;
  }
  function t10(n10, i10, o10, s10) {
    var a10, c;
    if (o10 != s10)
      c = o10 > s10 ? 1 : -1;
    else
      for (a10 = c = 0; a10 < o10; a10++)
        if (n10[a10] != i10[a10]) {
          c = n10[a10] > i10[a10] ? 1 : -1;
          break;
        }
    return c;
  }
  function r10(n10, i10, o10, s10) {
    for (var a10 = 0; o10--; )
      n10[o10] -= a10, a10 = n10[o10] < i10[o10] ? 1 : 0, n10[o10] = a10 * s10 + n10[o10] - i10[o10];
    for (; !n10[0] && n10.length > 1; )
      n10.shift();
  }
  return function(n10, i10, o10, s10, a10, c) {
    var l10, u10, d6, p, y, x, b, M, O, P, j, F, B, W, z, G, re, ie, oe, q, L = n10.constructor, h = n10.s == i10.s ? 1 : -1, f = n10.d, m = i10.d;
    if (!f || !f[0] || !m || !m[0])
      return new L(
        // Return NaN if either NaN, or both Infinity or 0.
        !n10.s || !i10.s || (f ? m && f[0] == m[0] : !m) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          f && f[0] == 0 || !m ? h * 0 : h / 0
        )
      );
    for (c ? (y = 1, u10 = n10.e - i10.e) : (c = Nn, y = Ke, u10 = Ur(n10.e / y) - Ur(i10.e / y)), oe = m.length, re = f.length, O = new L(h), P = O.d = [], d6 = 0; m[d6] == (f[d6] || 0); d6++)
      ;
    if (m[d6] > (f[d6] || 0) && u10--, o10 == null ? (W = o10 = L.precision, s10 = L.rounding) : a10 ? W = o10 + (n10.e - i10.e) + 1 : W = o10, W < 0)
      P.push(1), x = true;
    else {
      if (W = W / y + 2 | 0, d6 = 0, oe == 1) {
        for (p = 0, m = m[0], W++; (d6 < re || p) && W--; d6++)
          z = p * c + (f[d6] || 0), P[d6] = z / m | 0, p = z % m | 0;
        x = p || d6 < re;
      } else {
        for (p = c / (m[0] + 1) | 0, p > 1 && (m = e10(m, p, c), f = e10(f, p, c), oe = m.length, re = f.length), G = oe, j = f.slice(0, oe), F = j.length; F < oe; )
          j[F++] = 0;
        q = m.slice(), q.unshift(0), ie = m[0], m[1] >= c / 2 && ++ie;
        do
          p = 0, l10 = t10(m, j, oe, F), l10 < 0 ? (B = j[0], oe != F && (B = B * c + (j[1] || 0)), p = B / ie | 0, p > 1 ? (p >= c && (p = c - 1), b = e10(m, p, c), M = b.length, F = j.length, l10 = t10(b, j, M, F), l10 == 1 && (p--, r10(b, oe < M ? q : m, M, c))) : (p == 0 && (l10 = p = 1), b = m.slice()), M = b.length, M < F && b.unshift(0), r10(j, b, F, c), l10 == -1 && (F = j.length, l10 = t10(m, j, oe, F), l10 < 1 && (p++, r10(j, oe < F ? q : m, F, c))), F = j.length) : l10 === 0 && (p++, j = [0]), P[d6++] = p, l10 && j[0] ? j[F++] = f[G] || 0 : (j = [f[G]], F = 1);
        while ((G++ < re || j[0] !== void 0) && W--);
        x = j[0] !== void 0;
      }
      P[0] || P.shift();
    }
    if (y == 1)
      O.e = u10, Fv = x;
    else {
      for (d6 = 1, p = P[0]; p >= 10; p /= 10)
        d6++;
      O.e = d6 + u10 * y - 1, qe(O, a10 ? o10 + O.e + 1 : o10, s10, x);
    }
    return O;
  };
}();
function qe(e10, t10, r10, n10) {
  var i10, o10, s10, a10, c, l10, u10, d6, p, y = e10.constructor;
  e:
    if (t10 != null) {
      if (d6 = e10.d, !d6)
        return e10;
      for (i10 = 1, a10 = d6[0]; a10 >= 10; a10 /= 10)
        i10++;
      if (o10 = t10 - i10, o10 < 0)
        o10 += Ke, s10 = t10, u10 = d6[p = 0], c = u10 / br(10, i10 - s10 - 1) % 10 | 0;
      else if (p = Math.ceil((o10 + 1) / Ke), a10 = d6.length, p >= a10)
        if (n10) {
          for (; a10++ <= p; )
            d6.push(0);
          u10 = c = 0, i10 = 1, o10 %= Ke, s10 = o10 - Ke + 1;
        } else
          break e;
      else {
        for (u10 = a10 = d6[p], i10 = 1; a10 >= 10; a10 /= 10)
          i10++;
        o10 %= Ke, s10 = o10 - Ke + i10, c = s10 < 0 ? 0 : u10 / br(10, i10 - s10 - 1) % 10 | 0;
      }
      if (n10 = n10 || t10 < 0 || d6[p + 1] !== void 0 || (s10 < 0 ? u10 : u10 % br(10, i10 - s10 - 1)), l10 = r10 < 4 ? (c || n10) && (r10 == 0 || r10 == (e10.s < 0 ? 3 : 2)) : c > 5 || c == 5 && (r10 == 4 || n10 || r10 == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (o10 > 0 ? s10 > 0 ? u10 / br(10, i10 - s10) : 0 : d6[p - 1]) % 10 & 1 || r10 == (e10.s < 0 ? 8 : 7)), t10 < 1 || !d6[0])
        return d6.length = 0, l10 ? (t10 -= e10.e + 1, d6[0] = br(10, (Ke - t10 % Ke) % Ke), e10.e = -t10 || 0) : d6[0] = e10.e = 0, e10;
      if (o10 == 0 ? (d6.length = p, a10 = 1, p--) : (d6.length = p + 1, a10 = br(10, Ke - o10), d6[p] = s10 > 0 ? (u10 / br(10, i10 - s10) % br(10, s10) | 0) * a10 : 0), l10)
        for (; ; )
          if (p == 0) {
            for (o10 = 1, s10 = d6[0]; s10 >= 10; s10 /= 10)
              o10++;
            for (s10 = d6[0] += a10, a10 = 1; s10 >= 10; s10 /= 10)
              a10++;
            o10 != a10 && (e10.e++, d6[0] == Nn && (d6[0] = 1));
            break;
          } else {
            if (d6[p] += a10, d6[p] != Nn)
              break;
            d6[p--] = 0, a10 = 1;
          }
      for (o10 = d6.length; d6[--o10] === 0; )
        d6.pop();
    }
  return ot && (e10.e > y.maxE ? (e10.d = null, e10.e = NaN) : e10.e < y.minE && (e10.e = 0, e10.d = [0])), e10;
}
function ti(e10, t10, r10) {
  if (!e10.isFinite())
    return Kv(e10);
  var n10, i10 = e10.e, o10 = Pr(e10.d), s10 = o10.length;
  return t10 ? (r10 && (n10 = r10 - s10) > 0 ? o10 = o10.charAt(0) + "." + o10.slice(1) + qi(n10) : s10 > 1 && (o10 = o10.charAt(0) + "." + o10.slice(1)), o10 = o10 + (e10.e < 0 ? "e" : "e+") + e10.e) : i10 < 0 ? (o10 = "0." + qi(-i10 - 1) + o10, r10 && (n10 = r10 - s10) > 0 && (o10 += qi(n10))) : i10 >= s10 ? (o10 += qi(i10 + 1 - s10), r10 && (n10 = r10 - i10 - 1) > 0 && (o10 = o10 + "." + qi(n10))) : ((n10 = i10 + 1) < s10 && (o10 = o10.slice(0, n10) + "." + o10.slice(n10)), r10 && (n10 = r10 - s10) > 0 && (i10 + 1 === s10 && (o10 += "."), o10 += qi(n10))), o10;
}
function Ol(e10, t10) {
  var r10 = e10[0];
  for (t10 *= Ke; r10 >= 10; r10 /= 10)
    t10++;
  return t10;
}
function Hc(e10, t10, r10) {
  if (t10 > w9)
    throw ot = true, r10 && (e10.precision = r10), Error($v);
  return qe(new e10(zc), t10, 1, true);
}
function On(e10, t10, r10) {
  if (t10 > $f)
    throw Error($v);
  return qe(new e10(qc), t10, r10, true);
}
function Hv(e10) {
  var t10 = e10.length - 1, r10 = t10 * Ke + 1;
  if (t10 = e10[t10], t10) {
    for (; t10 % 10 == 0; t10 /= 10)
      r10--;
    for (t10 = e10[0]; t10 >= 10; t10 /= 10)
      r10++;
  }
  return r10;
}
function qi(e10) {
  for (var t10 = ""; e10--; )
    t10 += "0";
  return t10;
}
function Wv(e10, t10, r10, n10) {
  var i10, o10 = new e10(1), s10 = Math.ceil(n10 / Ke + 4);
  for (ot = false; ; ) {
    if (r10 % 2 && (o10 = o10.times(t10), np(o10.d, s10) && (i10 = true)), r10 = Ur(r10 / 2), r10 === 0) {
      r10 = o10.d.length - 1, i10 && o10.d[r10] === 0 && ++o10.d[r10];
      break;
    }
    t10 = t10.times(t10), np(t10.d, s10);
  }
  return ot = true, o10;
}
function rp(e10) {
  return e10.d[e10.d.length - 1] & 1;
}
function Gv(e10, t10, r10) {
  for (var n10, i10 = new e10(t10[0]), o10 = 0; ++o10 < t10.length; )
    if (n10 = new e10(t10[o10]), n10.s)
      i10[r10](n10) && (i10 = n10);
    else {
      i10 = n10;
      break;
    }
  return i10;
}
function Vf(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c, l10 = 0, u10 = 0, d6 = 0, p = e10.constructor, y = p.rounding, x = p.precision;
  if (!e10.d || !e10.d[0] || e10.e > 17)
    return new p(e10.d ? e10.d[0] ? e10.s < 0 ? 0 : 1 / 0 : 1 : e10.s ? e10.s < 0 ? 0 : e10 : 0 / 0);
  for (t10 == null ? (ot = false, c = x) : c = t10, a10 = new p(0.03125); e10.e > -2; )
    e10 = e10.times(a10), d6 += 5;
  for (n10 = Math.log(br(2, d6)) / Math.LN10 * 2 + 5 | 0, c += n10, r10 = o10 = s10 = new p(1), p.precision = c; ; ) {
    if (o10 = qe(o10.times(e10), c, 1), r10 = r10.times(++u10), a10 = s10.plus(Yt(o10, r10, c, 1)), Pr(a10.d).slice(0, c) === Pr(s10.d).slice(0, c)) {
      for (i10 = d6; i10--; )
        s10 = qe(s10.times(s10), c, 1);
      if (t10 == null)
        if (l10 < 3 && va(s10.d, c - n10, y, l10))
          p.precision = c += 10, r10 = o10 = a10 = new p(1), u10 = 0, l10++;
        else
          return qe(s10, p.precision = x, y, ot = true);
      else
        return p.precision = x, s10;
    }
    s10 = a10;
  }
}
function Ki(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y = 1, x = 10, b = e10, M = b.d, O = b.constructor, P = O.rounding, j = O.precision;
  if (b.s < 0 || !M || !M[0] || !b.e && M[0] == 1 && M.length == 1)
    return new O(M && !M[0] ? -1 / 0 : b.s != 1 ? NaN : M ? 0 : b);
  if (t10 == null ? (ot = false, u10 = j) : u10 = t10, O.precision = u10 += x, r10 = Pr(M), n10 = r10.charAt(0), Math.abs(o10 = b.e) < 15e14) {
    for (; n10 < 7 && n10 != 1 || n10 == 1 && r10.charAt(1) > 3; )
      b = b.times(e10), r10 = Pr(b.d), n10 = r10.charAt(0), y++;
    o10 = b.e, n10 > 1 ? (b = new O("0." + r10), o10++) : b = new O(n10 + "." + r10.slice(1));
  } else
    return l10 = Hc(O, u10 + 2, j).times(o10 + ""), b = Ki(new O(n10 + "." + r10.slice(1)), u10 - x).plus(l10), O.precision = j, t10 == null ? qe(b, j, P, ot = true) : b;
  for (d6 = b, c = s10 = b = Yt(b.minus(1), b.plus(1), u10, 1), p = qe(b.times(b), u10, 1), i10 = 3; ; ) {
    if (s10 = qe(s10.times(p), u10, 1), l10 = c.plus(Yt(s10, new O(i10), u10, 1)), Pr(l10.d).slice(0, u10) === Pr(c.d).slice(0, u10))
      if (c = c.times(2), o10 !== 0 && (c = c.plus(Hc(O, u10 + 2, j).times(o10 + ""))), c = Yt(c, new O(y), u10, 1), t10 == null)
        if (va(c.d, u10 - x, P, a10))
          O.precision = u10 += x, l10 = s10 = b = Yt(d6.minus(1), d6.plus(1), u10, 1), p = qe(b.times(b), u10, 1), i10 = a10 = 1;
        else
          return qe(c, O.precision = j, P, ot = true);
      else
        return O.precision = j, c;
    c = l10, i10 += 2;
  }
}
function Kv(e10) {
  return String(e10.s * e10.s / 0);
}
function zf(e10, t10) {
  var r10, n10, i10;
  for ((r10 = t10.indexOf(".")) > -1 && (t10 = t10.replace(".", "")), (n10 = t10.search(/e/i)) > 0 ? (r10 < 0 && (r10 = n10), r10 += +t10.slice(n10 + 1), t10 = t10.substring(0, n10)) : r10 < 0 && (r10 = t10.length), n10 = 0; t10.charCodeAt(n10) === 48; n10++)
    ;
  for (i10 = t10.length; t10.charCodeAt(i10 - 1) === 48; --i10)
    ;
  if (t10 = t10.slice(n10, i10), t10) {
    if (i10 -= n10, e10.e = r10 = r10 - n10 - 1, e10.d = [], n10 = (r10 + 1) % Ke, r10 < 0 && (n10 += Ke), n10 < i10) {
      for (n10 && e10.d.push(+t10.slice(0, n10)), i10 -= Ke; n10 < i10; )
        e10.d.push(+t10.slice(n10, n10 += Ke));
      t10 = t10.slice(n10), n10 = Ke - t10.length;
    } else
      n10 -= i10;
    for (; n10--; )
      t10 += "0";
    e10.d.push(+t10), ot && (e10.e > e10.constructor.maxE ? (e10.d = null, e10.e = NaN) : e10.e < e10.constructor.minE && (e10.e = 0, e10.d = [0]));
  } else
    e10.e = 0, e10.d = [0];
  return e10;
}
function S9(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c, l10, u10;
  if (t10.indexOf("_") > -1) {
    if (t10 = t10.replace(/(\d)_(?=\d)/g, "$1"), qv.test(t10))
      return zf(e10, t10);
  } else if (t10 === "Infinity" || t10 === "NaN")
    return +t10 || (e10.s = NaN), e10.e = NaN, e10.d = null, e10;
  if (v9.test(t10))
    r10 = 16, t10 = t10.toLowerCase();
  else if (g9.test(t10))
    r10 = 2;
  else if (b9.test(t10))
    r10 = 8;
  else
    throw Error(Qi + t10);
  for (o10 = t10.search(/p/i), o10 > 0 ? (c = +t10.slice(o10 + 1), t10 = t10.substring(2, o10)) : t10 = t10.slice(2), o10 = t10.indexOf("."), s10 = o10 >= 0, n10 = e10.constructor, s10 && (t10 = t10.replace(".", ""), a10 = t10.length, o10 = a10 - o10, i10 = Wv(n10, new n10(r10), o10, o10 * 2)), l10 = yc(t10, r10, Nn), u10 = l10.length - 1, o10 = u10; l10[o10] === 0; --o10)
    l10.pop();
  return o10 < 0 ? new n10(e10.s * 0) : (e10.e = Ol(l10, u10), e10.d = l10, ot = false, s10 && (e10 = Yt(e10, i10, a10 * 4)), c && (e10 = e10.times(Math.abs(c) < 54 ? br(2, c) : La.pow(2, c))), ot = true, e10);
}
function _9(e10, t10) {
  var r10, n10 = t10.d.length;
  if (n10 < 3)
    return t10.isZero() ? t10 : ws(e10, 2, t10, t10);
  r10 = 1.4 * Math.sqrt(n10), r10 = r10 > 16 ? 16 : r10 | 0, t10 = t10.times(1 / Rl(5, r10)), t10 = ws(e10, 2, t10, t10);
  for (var i10, o10 = new e10(5), s10 = new e10(16), a10 = new e10(20); r10--; )
    i10 = t10.times(t10), t10 = t10.times(o10.plus(i10.times(s10.times(i10).minus(a10))));
  return t10;
}
function ws(e10, t10, r10, n10, i10) {
  var o10, s10, a10, c, l10 = e10.precision, u10 = Math.ceil(l10 / Ke);
  for (ot = false, c = r10.times(r10), a10 = new e10(n10); ; ) {
    if (s10 = Yt(a10.times(c), new e10(t10++ * t10++), l10, 1), a10 = i10 ? n10.plus(s10) : n10.minus(s10), n10 = Yt(s10.times(c), new e10(t10++ * t10++), l10, 1), s10 = a10.plus(n10), s10.d[u10] !== void 0) {
      for (o10 = u10; s10.d[o10] === a10.d[o10] && o10--; )
        ;
      if (o10 == -1)
        break;
    }
    o10 = a10, a10 = n10, n10 = s10, s10 = o10;
  }
  return ot = true, s10.d.length = u10 + 1, s10;
}
function Rl(e10, t10) {
  for (var r10 = e10; --t10; )
    r10 *= e10;
  return r10;
}
function Yv(e10, t10) {
  var r10, n10 = t10.s < 0, i10 = On(e10, e10.precision, 1), o10 = i10.times(0.5);
  if (t10 = t10.abs(), t10.lte(o10))
    return Ei = n10 ? 4 : 1, t10;
  if (r10 = t10.divToInt(i10), r10.isZero())
    Ei = n10 ? 3 : 2;
  else {
    if (t10 = t10.minus(r10.times(i10)), t10.lte(o10))
      return Ei = rp(r10) ? n10 ? 2 : 3 : n10 ? 4 : 1, t10;
    Ei = rp(r10) ? n10 ? 1 : 4 : n10 ? 3 : 2;
  }
  return t10.minus(i10).abs();
}
function s0(e10, t10, r10, n10) {
  var i10, o10, s10, a10, c, l10, u10, d6, p, y = e10.constructor, x = r10 !== void 0;
  if (x ? (Kr(r10, 1, ao), n10 === void 0 ? n10 = y.rounding : Kr(n10, 0, 8)) : (r10 = y.precision, n10 = y.rounding), !e10.isFinite())
    u10 = Kv(e10);
  else {
    for (u10 = ti(e10), s10 = u10.indexOf("."), x ? (i10 = 2, t10 == 16 ? r10 = r10 * 4 - 3 : t10 == 8 && (r10 = r10 * 3 - 2)) : i10 = t10, s10 >= 0 && (u10 = u10.replace(".", ""), p = new y(1), p.e = u10.length - s10, p.d = yc(ti(p), 10, i10), p.e = p.d.length), d6 = yc(u10, 10, i10), o10 = c = d6.length; d6[--c] == 0; )
      d6.pop();
    if (!d6[0])
      u10 = x ? "0p+0" : "0";
    else {
      if (s10 < 0 ? o10-- : (e10 = new y(e10), e10.d = d6, e10.e = o10, e10 = Yt(e10, p, r10, n10, 0, i10), d6 = e10.d, o10 = e10.e, l10 = Fv), s10 = d6[r10], a10 = i10 / 2, l10 = l10 || d6[r10 + 1] !== void 0, l10 = n10 < 4 ? (s10 !== void 0 || l10) && (n10 === 0 || n10 === (e10.s < 0 ? 3 : 2)) : s10 > a10 || s10 === a10 && (n10 === 4 || l10 || n10 === 6 && d6[r10 - 1] & 1 || n10 === (e10.s < 0 ? 8 : 7)), d6.length = r10, l10)
        for (; ++d6[--r10] > i10 - 1; )
          d6[r10] = 0, r10 || (++o10, d6.unshift(1));
      for (c = d6.length; !d6[c - 1]; --c)
        ;
      for (s10 = 0, u10 = ""; s10 < c; s10++)
        u10 += Uf.charAt(d6[s10]);
      if (x) {
        if (c > 1)
          if (t10 == 16 || t10 == 8) {
            for (s10 = t10 == 16 ? 4 : 3, --c; c % s10; c++)
              u10 += "0";
            for (d6 = yc(u10, i10, t10), c = d6.length; !d6[c - 1]; --c)
              ;
            for (s10 = 1, u10 = "1."; s10 < c; s10++)
              u10 += Uf.charAt(d6[s10]);
          } else
            u10 = u10.charAt(0) + "." + u10.slice(1);
        u10 = u10 + (o10 < 0 ? "p" : "p+") + o10;
      } else if (o10 < 0) {
        for (; ++o10; )
          u10 = "0" + u10;
        u10 = "0." + u10;
      } else if (++o10 > c)
        for (o10 -= c; o10--; )
          u10 += "0";
      else
        o10 < c && (u10 = u10.slice(0, o10) + "." + u10.slice(o10));
    }
    u10 = (t10 == 16 ? "0x" : t10 == 2 ? "0b" : t10 == 8 ? "0o" : "") + u10;
  }
  return e10.s < 0 ? "-" + u10 : u10;
}
function np(e10, t10) {
  if (e10.length > t10)
    return e10.length = t10, true;
}
function E9(e10) {
  return new this(e10).abs();
}
function C9(e10) {
  return new this(e10).acos();
}
function T9(e10) {
  return new this(e10).acosh();
}
function A9(e10, t10) {
  return new this(e10).plus(t10);
}
function M9(e10) {
  return new this(e10).asin();
}
function I9(e10) {
  return new this(e10).asinh();
}
function O9(e10) {
  return new this(e10).atan();
}
function R9(e10) {
  return new this(e10).atanh();
}
function P9(e10, t10) {
  e10 = new this(e10), t10 = new this(t10);
  var r10, n10 = this.precision, i10 = this.rounding, o10 = n10 + 4;
  return !e10.s || !t10.s ? r10 = new this(NaN) : !e10.d && !t10.d ? (r10 = On(this, o10, 1).times(t10.s > 0 ? 0.25 : 0.75), r10.s = e10.s) : !t10.d || e10.isZero() ? (r10 = t10.s < 0 ? On(this, n10, i10) : new this(0), r10.s = e10.s) : !e10.d || t10.isZero() ? (r10 = On(this, o10, 1).times(0.5), r10.s = e10.s) : t10.s < 0 ? (this.precision = o10, this.rounding = 1, r10 = this.atan(Yt(e10, t10, o10, 1)), t10 = On(this, o10, 1), this.precision = n10, this.rounding = i10, r10 = e10.s < 0 ? r10.minus(t10) : r10.plus(t10)) : r10 = this.atan(Yt(e10, t10, o10, 1)), r10;
}
function N9(e10) {
  return new this(e10).cbrt();
}
function j9(e10) {
  return qe(e10 = new this(e10), e10.e + 1, 2);
}
function k9(e10, t10, r10) {
  return new this(e10).clamp(t10, r10);
}
function D9(e10) {
  if (!e10 || typeof e10 != "object")
    throw Error(Il + "Object expected");
  var t10, r10, n10, i10 = e10.defaults === true, o10 = [
    "precision",
    1,
    ao,
    "rounding",
    0,
    8,
    "toExpNeg",
    -cs,
    0,
    "toExpPos",
    0,
    cs,
    "maxE",
    0,
    cs,
    "minE",
    -cs,
    0,
    "modulo",
    0,
    9
  ];
  for (t10 = 0; t10 < o10.length; t10 += 3)
    if (r10 = o10[t10], i10 && (this[r10] = Ff[r10]), (n10 = e10[r10]) !== void 0)
      if (Ur(n10) === n10 && n10 >= o10[t10 + 1] && n10 <= o10[t10 + 2])
        this[r10] = n10;
      else
        throw Error(Qi + r10 + ": " + n10);
  if (r10 = "crypto", i10 && (this[r10] = Ff[r10]), (n10 = e10[r10]) !== void 0)
    if (n10 === true || n10 === false || n10 === 0 || n10 === 1)
      if (n10)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r10] = true;
        else
          throw Error(Vv);
      else
        this[r10] = false;
    else
      throw Error(Qi + r10 + ": " + n10);
  return this;
}
function L9(e10) {
  return new this(e10).cos();
}
function B9(e10) {
  return new this(e10).cosh();
}
function Xv(e10) {
  var t10, r10, n10;
  function i10(o10) {
    var s10, a10, c, l10 = this;
    if (!(l10 instanceof i10))
      return new i10(o10);
    if (l10.constructor = i10, ip(o10)) {
      l10.s = o10.s, ot ? !o10.d || o10.e > i10.maxE ? (l10.e = NaN, l10.d = null) : o10.e < i10.minE ? (l10.e = 0, l10.d = [0]) : (l10.e = o10.e, l10.d = o10.d.slice()) : (l10.e = o10.e, l10.d = o10.d ? o10.d.slice() : o10.d);
      return;
    }
    if (c = typeof o10, c === "number") {
      if (o10 === 0) {
        l10.s = 1 / o10 < 0 ? -1 : 1, l10.e = 0, l10.d = [0];
        return;
      }
      if (o10 < 0 ? (o10 = -o10, l10.s = -1) : l10.s = 1, o10 === ~~o10 && o10 < 1e7) {
        for (s10 = 0, a10 = o10; a10 >= 10; a10 /= 10)
          s10++;
        ot ? s10 > i10.maxE ? (l10.e = NaN, l10.d = null) : s10 < i10.minE ? (l10.e = 0, l10.d = [0]) : (l10.e = s10, l10.d = [o10]) : (l10.e = s10, l10.d = [o10]);
        return;
      } else if (o10 * 0 !== 0) {
        o10 || (l10.s = NaN), l10.e = NaN, l10.d = null;
        return;
      }
      return zf(l10, o10.toString());
    } else if (c !== "string")
      throw Error(Qi + o10);
    return (a10 = o10.charCodeAt(0)) === 45 ? (o10 = o10.slice(1), l10.s = -1) : (a10 === 43 && (o10 = o10.slice(1)), l10.s = 1), qv.test(o10) ? zf(l10, o10) : S9(l10, o10);
  }
  if (i10.prototype = me, i10.ROUND_UP = 0, i10.ROUND_DOWN = 1, i10.ROUND_CEIL = 2, i10.ROUND_FLOOR = 3, i10.ROUND_HALF_UP = 4, i10.ROUND_HALF_DOWN = 5, i10.ROUND_HALF_EVEN = 6, i10.ROUND_HALF_CEIL = 7, i10.ROUND_HALF_FLOOR = 8, i10.EUCLID = 9, i10.config = i10.set = D9, i10.clone = Xv, i10.isDecimal = ip, i10.abs = E9, i10.acos = C9, i10.acosh = T9, i10.add = A9, i10.asin = M9, i10.asinh = I9, i10.atan = O9, i10.atanh = R9, i10.atan2 = P9, i10.cbrt = N9, i10.ceil = j9, i10.clamp = k9, i10.cos = L9, i10.cosh = B9, i10.div = U9, i10.exp = F9, i10.floor = $9, i10.hypot = V9, i10.ln = z9, i10.log = q9, i10.log10 = W9, i10.log2 = H9, i10.max = G9, i10.min = K9, i10.mod = Y9, i10.mul = X9, i10.pow = J9, i10.random = Z9, i10.round = Q9, i10.sign = e_, i10.sin = t_, i10.sinh = r_, i10.sqrt = n_, i10.sub = i_, i10.sum = o_, i10.tan = s_, i10.tanh = a_, i10.trunc = c_, e10 === void 0 && (e10 = {}), e10 && e10.defaults !== true)
    for (n10 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t10 = 0; t10 < n10.length; )
      e10.hasOwnProperty(r10 = n10[t10++]) || (e10[r10] = this[r10]);
  return i10.config(e10), i10;
}
function U9(e10, t10) {
  return new this(e10).div(t10);
}
function F9(e10) {
  return new this(e10).exp();
}
function $9(e10) {
  return qe(e10 = new this(e10), e10.e + 1, 3);
}
function V9() {
  var e10, t10, r10 = new this(0);
  for (ot = false, e10 = 0; e10 < arguments.length; )
    if (t10 = new this(arguments[e10++]), t10.d)
      r10.d && (r10 = r10.plus(t10.times(t10)));
    else {
      if (t10.s)
        return ot = true, new this(1 / 0);
      r10 = t10;
    }
  return ot = true, r10.sqrt();
}
function ip(e10) {
  return e10 instanceof La || e10 && e10.toStringTag === zv || false;
}
function z9(e10) {
  return new this(e10).ln();
}
function q9(e10, t10) {
  return new this(e10).log(t10);
}
function H9(e10) {
  return new this(e10).log(2);
}
function W9(e10) {
  return new this(e10).log(10);
}
function G9() {
  return Gv(this, arguments, "lt");
}
function K9() {
  return Gv(this, arguments, "gt");
}
function Y9(e10, t10) {
  return new this(e10).mod(t10);
}
function X9(e10, t10) {
  return new this(e10).mul(t10);
}
function J9(e10, t10) {
  return new this(e10).pow(t10);
}
function Z9(e10) {
  var t10, r10, n10, i10, o10 = 0, s10 = new this(1), a10 = [];
  if (e10 === void 0 ? e10 = this.precision : Kr(e10, 1, ao), n10 = Math.ceil(e10 / Ke), this.crypto)
    if (crypto.getRandomValues)
      for (t10 = crypto.getRandomValues(new Uint32Array(n10)); o10 < n10; )
        i10 = t10[o10], i10 >= 429e7 ? t10[o10] = crypto.getRandomValues(new Uint32Array(1))[0] : a10[o10++] = i10 % 1e7;
    else if (crypto.randomBytes) {
      for (t10 = crypto.randomBytes(n10 *= 4); o10 < n10; )
        i10 = t10[o10] + (t10[o10 + 1] << 8) + (t10[o10 + 2] << 16) + ((t10[o10 + 3] & 127) << 24), i10 >= 214e7 ? crypto.randomBytes(4).copy(t10, o10) : (a10.push(i10 % 1e7), o10 += 4);
      o10 = n10 / 4;
    } else
      throw Error(Vv);
  else
    for (; o10 < n10; )
      a10[o10++] = Math.random() * 1e7 | 0;
  for (n10 = a10[--o10], e10 %= Ke, n10 && e10 && (i10 = br(10, Ke - e10), a10[o10] = (n10 / i10 | 0) * i10); a10[o10] === 0; o10--)
    a10.pop();
  if (o10 < 0)
    r10 = 0, a10 = [0];
  else {
    for (r10 = -1; a10[0] === 0; r10 -= Ke)
      a10.shift();
    for (n10 = 1, i10 = a10[0]; i10 >= 10; i10 /= 10)
      n10++;
    n10 < Ke && (r10 -= Ke - n10);
  }
  return s10.e = r10, s10.d = a10, s10;
}
function Q9(e10) {
  return qe(e10 = new this(e10), e10.e + 1, this.rounding);
}
function e_(e10) {
  return e10 = new this(e10), e10.d ? e10.d[0] ? e10.s : 0 * e10.s : e10.s || NaN;
}
function t_(e10) {
  return new this(e10).sin();
}
function r_(e10) {
  return new this(e10).sinh();
}
function n_(e10) {
  return new this(e10).sqrt();
}
function i_(e10, t10) {
  return new this(e10).sub(t10);
}
function o_() {
  var e10 = 0, t10 = arguments, r10 = new this(t10[e10]);
  for (ot = false; r10.s && ++e10 < t10.length; )
    r10 = r10.plus(t10[e10]);
  return ot = true, qe(r10, this.precision, this.rounding);
}
function s_(e10) {
  return new this(e10).tan();
}
function a_(e10) {
  return new this(e10).tanh();
}
function c_(e10) {
  return qe(e10 = new this(e10), e10.e + 1, 1);
}
me[Symbol.for("nodejs.util.inspect.custom")] = me.toString;
me[Symbol.toStringTag] = "Decimal";
var La = me.constructor = Xv(Ff);
zc = new La(zc);
qc = new La(qc);
var wc = La;
var Gt = zo(qo());
var $u = zo(qo());
var l_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Aftermath only supported on mainnet");
    this.slippage = "900000000000000000", this.poolRegistry = "0xfcc774493db2c45c79f688f88d28023a3e7d98e4ee9f48bbf5c7990f651577ae", this.protocolFeeVault = "0xf194d9b1bcad972e45a7dd67dd49b3ee1e3357a00a50850c52cd51bb450e13b4", this.treasury = "0x28e499dff5e864a2eafe476269a4f5035f1c16f338da7be18b103499abf271ce", this.insuranceFund = "0xf0c40d67b078000e18032334c3325c47b9ec9f3d9ae4128be820d54663d14e3b", this.referrealVault = "0x35d35b0e5b177593d8c3a801462485572fc30861e6ce96a55af6dc4730709278";
  }
  amountLimit(e10) {
    return new $u.default(e10).mul(new $u.default(this.slippage)).div(new $u.default("1000000000000000000")).toString();
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10];
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported");
      if (r10.extendedDetails.aftermathLpSupplyType == null)
        throw new Error("LP supply type not supported");
      const d6 = [
        t10.object(r10.id),
        t10.object(this.poolRegistry),
        t10.object(this.protocolFeeVault),
        t10.object(this.treasury),
        t10.object(this.insuranceFund),
        t10.object(this.referrealVault),
        t10.pure.u64(this.amountLimit(r10.amountOut)),
        t10.pure.u64(this.slippage),
        n10
      ], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::aftermath::${c}`,
        typeArguments: [
          l10,
          u10,
          r10.extendedDetails.aftermathLpSupplyType
        ],
        arguments: d6
      });
    });
  }
};
var op = "0x000000000000000000000000000000000000000000000000000000000000dee9";
var u_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Aftermath only supported on mainnet");
  }
  getAccountCap(e10, t10) {
    return at(this, null, function* () {
      let r10 = 50, n10 = null;
      for (; ; ) {
        const i10 = e10.getOwnedObjects({
          owner: t10,
          cursor: n10,
          limit: r10,
          filter: {
            MoveModule: {
              package: op,
              module: "custodian_v2"
            }
          }
        });
        if (i10 != null && i10.data != null) {
          if (i10.data.length !== 0)
            return i10.data[0].data.objectId;
          if (i10.data.length < 50)
            break;
        } else
          break;
      }
      return null;
    });
  }
  getOrCreateAccountCap(e10, t10, r10) {
    return at(this, null, function* () {
      let n10 = yield this.getAccountCap(t10, r10);
      return n10 !== null ? {
        accountCap: e10.object(n10),
        isCreate: false
      } : {
        accountCap: e10.moveCall({
          target: `${op}::clob_v2::create_account`,
          typeArguments: [],
          arguments: []
        }),
        isCreate: true
      };
    });
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = yield this.getOrCreateAccountCap(
        t10,
        e10.client,
        e10.signer
      ), p = [
        t10.object(r10.id),
        n10,
        d6.accountCap,
        t10.object(Tr)
      ], y = Er(e10.publishedAtV2(), i10), x = t10.moveCall({
        target: `${y}::deepbook::${c}`,
        typeArguments: [l10, u10],
        arguments: p
      });
      return d6.isCreate && t10.transferObjects([d6.accountCap], e10.signer), x;
    });
  }
};
var f_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Kriya amm only supported on mainnet");
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [t10.object(r10.id), n10], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::kriya_amm::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var d_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Kriya clmm only supported on mainnet");
    this.version = "0xf5145a7ac345ca8736cf8c76047d00d6d378f30e81be6f6eb557184d9de93c78";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [
        t10.object(r10.id),
        n10,
        t10.object(this.version),
        t10.object(Tr)
      ], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::kriya_clmm::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var h_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Flowx only supported on mainnet");
    this.container = "0xb65dcbf63fd3ad5d0ebfbf334780dc9f785eff38a4459e37ab08fa79576ee511";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [t10.object(this.container), n10], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::flowx_amm::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var p_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Flowx clmm only supported on mainnet");
    this.versioned = "0x67624a1533b5aff5d0dfcf5e598684350efd38134d2d245f475524c03a64e656", this.poolRegistry = "0x27565d24a4cd51127ac90e4074a841bbe356cca7bf5759ddc14a975be1632abc";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [
        t10.object(this.poolRegistry),
        t10.pure.u64(r10.feeRate * 1e6),
        n10,
        t10.object(this.versioned),
        t10.object(Tr)
      ], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::flowx_clmm::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var m_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Turbos only supported on mainnet");
    this.versioned = "0xf1cf0e81048df168ebeb1b8030fad24b3e0b53ae827c25053fff0779c1445b6f";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10];
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported");
      if (r10.extendedDetails.turbosFeeType == null)
        throw new Error("Turbos fee type not supported");
      const d6 = [
        t10.object(r10.id),
        n10,
        t10.object(Tr),
        t10.object(this.versioned)
      ], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::turbos::${c}`,
        typeArguments: [l10, u10, r10.extendedDetails.turbosFeeType],
        arguments: d6
      });
    });
  }
};
var sp = class {
  constructor(e10, t10) {
    this.globalConfig = e10 === 0 ? "0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f" : "0x9774e359588ead122af1c7e7f64e14ade261cfeecdb5d0eb4a5b3b4c8ab8bd3e", this.partner = t10 ?? (e10 === 0 ? "0x639b5e433da31739e800cd085f356e64cae222966d0f1b11bd9dc76b322ff58b" : "0x1f5fa5c820f40d43fc47815ad06d95e40a1942ff72a732a92e8ef4aa8cde70a5");
  }
  flash_swap(e10, t10, r10, n10, i10) {
    const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["flash_swap_a2b", s10, a10] : ["flash_swap_b2a", a10, s10];
    let d6 = n10 ? r10.amountIn : r10.amountOut;
    const p = [
      t10.object(this.globalConfig),
      t10.object(r10.id),
      t10.object(this.partner),
      t10.pure.u64(d6),
      t10.pure.bool(n10),
      t10.object(Tr)
    ], y = Er(e10.publishedAtV2(), i10), x = t10.moveCall({
      target: `${y}::cetus::${c}`,
      typeArguments: [l10, u10],
      arguments: p
    });
    return {
      targetCoin: x[0],
      flashReceipt: x[1],
      payAmount: x[2]
    };
  }
  repay_flash_swap(e10, t10, r10, n10, i10, o10) {
    const { direction: s10, from: a10, target: c } = r10, [l10, u10, d6] = s10 ? ["repay_flash_swap_a2b", a10, c] : ["repay_flash_swap_b2a", c, a10], p = [
      t10.object(this.globalConfig),
      t10.object(r10.id),
      t10.object(this.partner),
      n10,
      i10
    ], y = Er(e10.publishedAtV2(), o10);
    return t10.moveCall({
      target: `${y}::cetus::${l10}`,
      typeArguments: [u10, d6],
      arguments: p
    })[0];
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [
        t10.object(this.globalConfig),
        t10.object(r10.id),
        t10.object(this.partner),
        n10,
        t10.object(Tr)
      ], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::cetus::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
function ap(e10, ...t10) {
  const r10 = Array.isArray(t10[t10.length - 1]) ? t10.pop() : [];
  let i10 = [e10, ...t10].filter(Boolean).join("::");
  return r10 && r10.length && (i10 += `<${r10.join(", ")}>`), i10;
}
function cp(e10) {
  return e10.split("::")[0];
}
function jn(e10) {
  var t10;
  try {
    let r10 = e10.replace(/\s/g, "");
    const n10 = r10.match(/(<.+>)$/), i10 = (t10 = n10 == null ? void 0 : n10[0]) == null ? void 0 : t10.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
    if (i10) {
      r10 = r10.slice(0, r10.indexOf("<"));
      const c = jn(r10), l10 = d9(f9({}, c), {
        type_arguments: i10.map((u10) => jn(u10).source_address)
      });
      return l10.type_arguments = l10.type_arguments.map((u10) => Gn.isSuiCoin(u10) ? u10 : jn(u10).source_address), l10.source_address = ap(l10.full_address, l10.type_arguments), l10;
    }
    const o10 = r10.split("::"), a10 = {
      full_address: r10,
      address: r10 === Jv || r10 === b_ ? "0x2" : en(o10[0]),
      module: o10[1],
      name: o10[2],
      type_arguments: [],
      source_address: ""
    };
    return a10.full_address = `${a10.address}::${a10.module}::${a10.name}`, a10.source_address = ap(a10.full_address, a10.type_arguments), a10;
  } catch {
    return {
      full_address: e10,
      address: "",
      module: "",
      name: "",
      type_arguments: [],
      source_address: e10
    };
  }
}
function lp(e10) {
  return jn(e10).source_address;
}
var g_ = "0x2::coin::Coin";
var v_ = /^0x2::coin::Coin<(.+)>$/;
var Jv = "0x2::sui::SUI";
var b_ = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
var Gn = class Vi {
  /**
   * Get the coin type argument from a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the coin type argument from.
   * @returns The coin type argument, or null if it is not found.
   */
  static getCoinTypeArg(t10) {
    const r10 = t10.type.match(v_);
    return r10 ? r10[1] : null;
  }
  /**
   * Get whether a SuiMoveObject is a SUI coin.
   *
   * @param obj The SuiMoveObject to check.
   * @returns Whether the SuiMoveObject is a SUI coin.
   */
  static isSUI(t10) {
    const r10 = Vi.getCoinTypeArg(t10);
    return r10 ? Vi.getCoinSymbol(r10) === "SUI" : false;
  }
  /**
   * Get the coin symbol from a coin type argument.
   *
   * @param coinTypeArg The coin type argument to get the symbol from.
   * @returns The coin symbol.
   */
  static getCoinSymbol(t10) {
    return t10.substring(t10.lastIndexOf(":") + 1);
  }
  /**
   * Get the balance of a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the balance from.
   * @returns The balance of the SuiMoveObject.
   */
  static getBalance(t10) {
    return BigInt(t10.fields.balance);
  }
  /**
   * Get the total balance of a list of CoinAsset objects for a given coin address.
   *
   * @param objs The list of CoinAsset objects to get the total balance for.
   * @param coinAddress The coin address to get the total balance for.
   * @returns The total balance of the CoinAsset objects for the given coin address.
   */
  static totalBalance(t10, r10) {
    let n10 = BigInt(0);
    return t10.forEach((i10) => {
      r10 === i10.coinAddress && (n10 += BigInt(i10.balance));
    }), n10;
  }
  /**
   * Get the ID of a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the ID from.
   * @returns The ID of the SuiMoveObject.
   */
  static getID(t10) {
    return t10.fields.id.id;
  }
  /**
   * Get the coin type from a coin type argument.
   *
   * @param coinTypeArg The coin type argument to get the coin type from.
   * @returns The coin type.
   */
  static getCoinTypeFromArg(t10) {
    return `${g_}<${t10}>`;
  }
  /**
   * Get the CoinAsset objects for a given coin type.
   *
   * @param coinType The coin type to get the CoinAsset objects for.
   * @param allSuiObjects The list of all SuiMoveObjects.
   * @returns The CoinAsset objects for the given coin type.
   */
  static getCoinAssets(t10, r10) {
    const n10 = [];
    return r10.forEach((i10) => {
      lp(i10.coinAddress) === lp(t10) && n10.push(i10);
    }), n10;
  }
  /**
   * Get whether a coin address is a SUI coin.
   *
   * @param coinAddress The coin address to check.
   * @returns Whether the coin address is a SUI coin.
   */
  static isSuiCoin(t10) {
    return jn(t10).full_address === Jv;
  }
  /**
   * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
   *
   * @param coins The list of CoinAsset objects to select from.
   * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
   * @param exclude A list of CoinAsset objects to exclude from the selection.
   * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
   */
  static selectCoinObjectIdGreaterThanOrEqual(t10, r10, n10 = []) {
    const i10 = Vi.selectCoinAssetGreaterThanOrEqual(t10, r10, n10), o10 = i10.selectedCoins.map((c) => c.coinObjectId), s10 = i10.remainingCoins, a10 = i10.selectedCoins.map((c) => c.balance.toString());
    return { objectArray: o10, remainCoins: s10, amountArray: a10 };
  }
  /**
   * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
   *
   * @param coins The list of CoinAsset objects to select from.
   * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
   * @param exclude A list of CoinAsset objects to exclude from the selection.
   * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
   */
  static selectCoinAssetGreaterThanOrEqual(t10, r10, n10 = []) {
    const i10 = Vi.sortByBalance(t10.filter((l10) => !n10.includes(l10.coinObjectId))), o10 = Vi.calculateTotalBalance(i10);
    if (o10 < r10)
      return { selectedCoins: [], remainingCoins: i10 };
    if (o10 === r10)
      return { selectedCoins: i10, remainingCoins: [] };
    let s10 = BigInt(0);
    const a10 = [], c = [...i10];
    for (; s10 < o10; ) {
      const l10 = r10 - s10, u10 = c.findIndex((p) => p.balance >= l10);
      if (u10 !== -1) {
        a10.push(c[u10]), c.splice(u10, 1);
        break;
      }
      const d6 = c.pop();
      d6.balance > 0 && (a10.push(d6), s10 += d6.balance);
    }
    return { selectedCoins: Vi.sortByBalance(a10), remainingCoins: Vi.sortByBalance(c) };
  }
  /**
   * Sort the CoinAsset objects by their balance.
   *
   * @param coins The CoinAsset objects to sort.
   * @returns The sorted CoinAsset objects.
   */
  static sortByBalance(t10) {
    return t10.sort((r10, n10) => r10.balance < n10.balance ? -1 : r10.balance > n10.balance ? 1 : 0);
  }
  static sortByBalanceDes(t10) {
    return t10.sort((r10, n10) => r10.balance > n10.balance ? -1 : r10.balance < n10.balance ? 0 : 1);
  }
  /**
   * Calculate the total balance of a list of CoinAsset objects.
   *
   * @param coins The list of CoinAsset objects to calculate the total balance for.
   * @returns The total balance of the CoinAsset objects.
   */
  static calculateTotalBalance(t10) {
    return t10.reduce((r10, n10) => r10 + n10.balance, BigInt(0));
  }
};
function Vu(e10) {
  switch (e10) {
    case 1e4:
      return "Calculate error";
    case 10001:
      return "Input number too large can not fit in target type";
    case 10002:
      return "No router";
    case 10003:
      return "Insufficient Liquidity";
    case 10004:
      return "Target token is detected as a HoneyPot scam";
    case 10005:
      return "Too many requests. Please try again later";
    default:
      return "Unknown error";
  }
}
function eo(e10) {
  const t10 = e10.indexOf("::");
  if (t10 === -1)
    return e10;
  const r10 = e10.substring(0, t10), n10 = e10.substring(t10);
  if (!r10.startsWith("0x"))
    return e10;
  const i10 = r10.substring(2);
  return i10.length > 64 ? e10 : `0x${i10.padStart(64, "0")}${n10}`;
}
function y_(e10, t10) {
  e10 = eo(e10), t10 = eo(t10);
  const r10 = Math.min(e10.length, t10.length);
  for (let n10 = 0; n10 < r10; n10++) {
    if (e10[n10] > t10[n10])
      return true;
    if (e10[n10] < t10[n10])
      return false;
  }
  return true;
}
function Zv(e10, t10) {
  return e10.moveCall({
    target: "0x2::coin::zero",
    typeArguments: [t10]
  });
}
function zu(e10, t10, r10, n10) {
  const i10 = Gn.getCoinAssets(n10, t10);
  if (r10 === BigInt(0))
    return Gn.isSuiCoin(n10) || i10.length === 0 && !Gn.isSuiCoin(n10) ? {
      targetCoin: Zv(e10, n10),
      isMintZeroCoin: true,
      targetCoinAmount: 0
    } : {
      targetCoin: e10.object(i10[0].coinObjectId),
      isMintZeroCoin: false,
      targetCoinAmount: Number(i10[0].balance.toString())
    };
  if (Gn.calculateTotalBalance(i10) < r10)
    throw new AggregateError(
      "Insufficient balance when build merge coin, coinType: " + n10,
      "InsufficientBalance" + n10
    );
  if (Gn.isSuiCoin(n10))
    return {
      targetCoin: e10.splitCoins(e10.gas, [
        e10.pure.u64(r10.toString())
      ]),
      isMintZeroCoin: true,
      targetCoinAmount: Number(r10.toString())
    };
  let s10 = Gn.sortByBalance(i10);
  s10.slice(0, 3).reduce((p, y) => p + y.balance, BigInt(0)) < BigInt(r10) && (s10 = Gn.sortByBalanceDes(i10));
  let c = Gn.selectCoinObjectIdGreaterThanOrEqual(
    s10,
    r10
  );
  const [l10, ...u10] = c.objectArray;
  return u10.length > 0 && e10.mergeCoins(
    l10,
    u10.map((p) => e10.object(p))
  ), {
    targetCoin: e10.splitCoins(e10.object(l10), [
      e10.pure.u64(r10.toString())
    ]),
    isMintZeroCoin: false,
    targetCoinAmount: Number(r10.toString())
  };
}
function w_(e10) {
  return !(!e10.startsWith("0x") || e10.length !== 66);
}
var Xo = zo(qo());
var Yi = zo(qo());
var Ba = zo(qo());
var xi = new Ba.default(0);
new Ba.default(1);
var x_ = new Ba.default(2);
x_.pow(new Ba.default(128));
var S_ = new Ba.default("18446744073709551615");
var hn = 1e9;
function __(e10, t10, r10) {
  let n10 = xi;
  return t10 ? n10 = e10.mul(new Yi.default(hn - r10 * hn)).div(new Yi.default(hn)) : n10 = e10.mul(new Yi.default(hn + r10 * hn)).div(new Yi.default(hn)), Number(n10.toString());
}
function up(e10, t10, r10) {
  let n10 = xi;
  return t10 ? n10 = e10.mul(new Yi.default(hn - r10 * hn)).div(new Yi.default(hn)) : n10 = e10.mul(new Yi.default(hn + r10 * hn)).div(new Yi.default(hn)), n10;
}
function E_(e10, t10, r10) {
  return new wc(e10).mul(wc.pow(2, -64)).pow(2).mul(wc.pow(10, t10 - r10));
}
function C_(e10, t10, r10, n10) {
  return at(this, null, function* () {
    var i10, o10, s10, a10, c;
    const { from: l10, target: u10, amount: d6, byAmountIn: p, pools: y } = t10, x = eo(l10), b = eo(u10), M = new Oo(), O = y_(x, b), P = n10 === 0 ? "0x2d8c2e0fc6dd25b0214b3fa747e0fd27fd54608142cd2e4f64c1cd350cc4add4" : "0x4f920e1ef6318cfba77e20a0538a419a5a504c14230169438b99aba485db40a6", j = O ? x : b, F = O ? b : x, B = [j, F];
    for (let C = 0; C < y.length; C++) {
      const g = [
        M.object(y[C]),
        M.pure.bool(O),
        M.pure.bool(p),
        M.pure.u64(d6.toString())
      ];
      M.moveCall({
        target: `${P}::fetcher_script::calculate_swap_result`,
        arguments: g,
        typeArguments: B
      });
    }
    if (!w_(r10))
      throw new AggregateError(
        "Aggregator package not set",
        "InvalidWallet"
        /* InvalidWallet */
      );
    const W = yield e10.devInspectTransactionBlock({
      transactionBlock: M,
      sender: r10
    });
    if (W.error != null)
      throw new AggregateError(
        "Aggregator package not set",
        "SimulateError"
        /* SimulateError */
      );
    const z = (i10 = W.events) == null ? void 0 : i10.filter((C) => C.type.includes("CalculatedSwapResultEvent"));
    if (z.length === 0 || z.length !== y.length)
      throw new AggregateError(
        "Simulate event result error",
        "simulateEventError"
        /* SimulateEventError */
      );
    let G = p ? xi : S_, re = 0;
    for (let C = 0; C < z.length; C += 1)
      if (!z[C].parsedJson.data.is_exceed)
        if (t10.byAmountIn) {
          const g = new Xo.BN(z[C].parsedJson.data.amount_out);
          g.gt(G) && (re = C, G = g);
        } else {
          const g = new Xo.BN(z[C].parsedJson.data.amount_out);
          g.lt(G) && (re = C, G = g);
        }
    const ie = z[re].parsedJson.data, oe = ie.step_results[0].current_sqrt_price, [q, L] = yield Promise.all([
      e10.getCoinMetadata({ coinType: j }).then((C) => C == null ? void 0 : C.decimals),
      e10.getCoinMetadata({ coinType: F }).then((C) => C == null ? void 0 : C.decimals)
    ]);
    if (q == null || L == null)
      throw new AggregateError(
        "Simulate event result error",
        "CannotGetDecimals"
        /* CannotGetDecimals */
      );
    const h = E_(
      oe,
      q,
      L
    ), f = Number(ie.fee_rate) / 1e6, m = new Xo.BN((o10 = ie.amount_in) != null ? o10 : 0), S = new Xo.BN((s10 = ie.fee_amount) != null ? s10 : 0), T = m.add(S), E = {
      amountIn: T,
      amountOut: new Xo.BN((a10 = ie.amount_out) != null ? a10 : 0),
      routes: [
        {
          path: [
            {
              id: y[re],
              direction: O,
              provider: "CETUS",
              from: x,
              target: b,
              feeRate: f,
              amountIn: ie.amount_in,
              amountOut: ie.amount_out,
              extendedDetails: {
                afterSqrtPrice: ie.after_sqrt_price
              }
            }
          ],
          amountIn: T,
          amountOut: new Xo.BN((c = ie.amount_out) != null ? c : 0),
          initialPrice: h
        }
      ],
      insufficientLiquidity: false,
      byAmountIn: t10.byAmountIn
    };
    return {
      isExceed: ie.is_exceed,
      routeData: E
    };
  });
}
var T_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Haedal only supported on mainnet");
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10 } = r10, s10 = o10 ? "swap_a2b" : "swap_b2a", a10 = [t10.object(r10.id), t10.object("0x5"), n10], c = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${c}::haedal::${s10}`,
        typeArguments: [],
        arguments: a10
      });
    });
  }
};
var A_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Afsui only supported on mainnet");
    this.stakedSuiVault = "0x2f8f6d5da7f13ea37daa397724280483ed062769813b6f31e9788e59cc88994d", this.safe = "0xeb685899830dd5837b47007809c76d91a098d52aabbf61e8ac467c59e5cc4610", this.referVault = "0x4ce9a19b594599536c53edb25d22532f82f18038dc8ef618afd00fbbfb9845ef", this.validator = "0xd30018ec3f5ff1a3c75656abf927a87d7f0529e6dc89c7ddd1bd27ecb05e3db2";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10 } = r10;
      if (!o10)
        throw new Error("Afsui not support b2a swap");
      const s10 = "swap_a2b", a10 = [
        t10.object(this.stakedSuiVault),
        t10.object(this.safe),
        t10.object("0x5"),
        t10.object(this.referVault),
        t10.object(this.validator),
        n10
      ], c = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${c}::afsui::${s10}`,
        typeArguments: [],
        arguments: a10
      });
    });
  }
};
var M_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Volo only supported on mainnet");
    this.nativePool = "0x7fa2faa111b8c65bea48a23049bfd81ca8f971a262d981dcd9a17c3825cb5baf", this.metadata = "0x680cd26af32b2bde8d3361e804c53ec1d1cfe24c7f039eb7f549e8dfde389a60";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10 } = r10;
      if (!o10)
        throw new Error("Volo not support b2a swap");
      const s10 = "swap_a2b", a10 = [
        t10.object(this.nativePool),
        t10.object(this.metadata),
        t10.object("0x5"),
        n10
      ], c = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${c}::volo::${s10}`,
        typeArguments: [],
        arguments: a10
      });
    });
  }
};
var I_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Bluemove only supported on mainnet");
    this.dexInfo = "0x3f2d9f724f4a1ce5e71676448dc452be9a6243dac9c5b975a588c8c867066e92";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [t10.object(this.dexInfo), n10], p = Er(e10.publishedAtV2(), i10);
      return t10.moveCall({
        target: `${p}::bluemove::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var O_ = class {
  constructor(e10) {
    this.deepbookV3Config = e10 === 0 ? "0x699d455ab8c5e02075b4345ea1f91be55bf46064ae6026cc2528e701ce3ac135" : "0xe19b5d072346cae83a037d4e3c8492068a74410a74e5830b3a68012db38296aa";
  }
  swap(e10, t10, r10, n10, i10, o10) {
    return at(this, null, function* () {
      const { direction: s10, from: a10, target: c } = r10, [l10, u10, d6] = s10 ? ["swap_a2b_v2", a10, c] : ["swap_b2a_v2", c, a10];
      let p;
      o10 ? p = o10 : p = Zv(t10, e10.deepbookv3DeepFeeType());
      const y = [
        t10.object(this.deepbookV3Config),
        t10.object(r10.id),
        n10,
        p,
        t10.object(Tr)
      ], x = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${x}::deepbookv3::${l10}`,
        typeArguments: [u10, d6],
        arguments: y
      });
    });
  }
};
var R_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Scallop only supported on mainnet");
    this.version = e10 === 0 ? "0x07871c4b3c847a0f674510d4978d5cf6f960452795e8ff6f189fd2088a3f6ac7" : "0x0", this.market = e10 === 0 ? "0xa757975255146dc9686aa823b7838b507f315d704f428cbadad2f4ea061939d9" : "0x0";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", s10, a10];
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported");
      if (r10.extendedDetails.scallopScoinTreasury == null)
        throw new Error("Scallop coin treasury not supported");
      const d6 = [
        t10.object(this.version),
        t10.object(this.market),
        t10.object(r10.extendedDetails.scallopScoinTreasury),
        n10,
        t10.object(Tr)
      ], p = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${p}::scallop::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var fp = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Suilend only supported on mainnet");
    this.sui_system_state = e10 === 0 ? "0x0000000000000000000000000000000000000000000000000000000000000005" : "0x0";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10] = o10 ? ["swap_a2b", a10] : ["swap_b2a", s10], u10 = [
        t10.object(r10.id),
        t10.object(this.sui_system_state),
        n10
      ], d6 = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${d6}::suilend::${c}`,
        typeArguments: [l10],
        arguments: u10
      });
    });
  }
};
var P_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Bluefin only supported on mainnet");
    this.globalConfig = "0x03db251ba509a8d5d8777b6338836082335d93eecbdd09a11e190a1cff51c352";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [
        t10.object(this.globalConfig),
        t10.object(r10.id),
        n10,
        t10.object(Tr)
      ], p = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${p}::bluefin::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var N_ = class {
  constructor(e10, t10) {
    if (e10 === 1)
      throw new Error("HaedalPmm is not supported on testnet");
    this.pythPriceIDs = t10;
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10];
      let d6, p;
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported haedal pmm");
      if (!r10.extendedDetails.haedalPmmBasePriceSeed || !r10.extendedDetails.haedalPmmQuotePriceSeed)
        throw new Error("Base price seed or quote price seed not supported");
      d6 = r10.extendedDetails.haedalPmmBasePriceSeed, p = r10.extendedDetails.haedalPmmQuotePriceSeed;
      const y = this.pythPriceIDs.get(d6), x = this.pythPriceIDs.get(p);
      if (!y || !x)
        throw new Error(
          "Base price info object id or quote price info object id not found"
        );
      const b = [
        t10.object(r10.id),
        t10.object(y),
        t10.object(x),
        n10,
        t10.object(Tr)
      ], M = Ln(
        e10.publishedAtV2Extend(),
        i10
      );
      return t10.moveCall({
        target: `${M}::haedalpmm::${c}`,
        typeArguments: [l10, u10],
        arguments: b
      });
    });
  }
};
var j_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Alphafi only supported on mainnet");
    this.sui_system_state = e10 === 0 ? "0x0000000000000000000000000000000000000000000000000000000000000005" : "0x0";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10] = o10 ? ["swap_a2b", a10] : ["swap_b2a", s10], u10 = [
        t10.object(r10.id),
        t10.object(this.sui_system_state),
        n10
      ], d6 = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${d6}::alphafi::${c}`,
        typeArguments: [l10],
        arguments: u10
      });
    });
  }
};
var k_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Steamm only supported on mainnet");
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b_v2", s10, a10] : ["swap_b2a_v2", a10, s10];
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported");
      if (r10.extendedDetails.steammBankA == null)
        throw new Error("Steamm bank a type not supported");
      if (r10.extendedDetails.steammBankB == null)
        throw new Error("Steamm bank b type not supported");
      if (r10.extendedDetails.steammLendingMarket == null)
        throw new Error("Steamm lending market not supported");
      if (r10.extendedDetails.steammLendingMarketType == null)
        throw new Error("Steamm lending market type not supported");
      if (r10.extendedDetails.steammBCoinAType == null)
        throw new Error("Steamm b coin a type not supported");
      if (r10.extendedDetails.steammBCoinBType == null)
        throw new Error("Steamm b coin b type not supported");
      if (r10.extendedDetails.steammLPToken == null)
        throw new Error("Steamm lp token not supported");
      const d6 = [
        t10.object(r10.id),
        t10.object(r10.extendedDetails.steammBankA),
        t10.object(r10.extendedDetails.steammBankB),
        t10.object(r10.extendedDetails.steammLendingMarket),
        n10,
        t10.object(Tr)
      ], p = f0(e10.publishedAtV2Extend2(), i10);
      return t10.moveCall({
        target: `${p}::steamm_cpmm::${c}`,
        typeArguments: [
          r10.extendedDetails.steammLendingMarketType,
          l10,
          u10,
          r10.extendedDetails.steammBCoinAType,
          r10.extendedDetails.steammBCoinBType,
          r10.extendedDetails.steammLPToken
        ],
        arguments: d6
      });
    });
  }
};
var D_ = class {
  constructor(e10, t10) {
    if (e10 !== 0)
      throw new Error("Steamm only supported on mainnet");
    this.pythPriceIDs = t10, this.oraclePackageId = "0xe84b649199654d18c38e727212f5d8dacfc3cf78d60d0a7fc85fd589f280eb2b";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10;
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported");
      if (r10.extendedDetails.steammBankA == null)
        throw new Error("Steamm bank a type not supported");
      if (r10.extendedDetails.steammBankB == null)
        throw new Error("Steamm bank b type not supported");
      if (r10.extendedDetails.steammLendingMarket == null)
        throw new Error("Steamm lending market not supported");
      if (r10.extendedDetails.steammLendingMarketType == null)
        throw new Error("Steamm lending market type not supported");
      if (r10.extendedDetails.steammBCoinAType == null)
        throw new Error("Steamm b coin a type not supported");
      if (r10.extendedDetails.steammBCoinBType == null)
        throw new Error("Steamm b coin b type not supported");
      if (r10.extendedDetails.steammLPToken == null)
        throw new Error("Steamm lp token not supported");
      if (r10.extendedDetails.steammOracleRegistryId == null)
        throw new Error("Steamm oracle registry id not supported");
      if (r10.extendedDetails.steammOracleIndexA == null)
        throw new Error("Steamm oracle index a not supported");
      if (r10.extendedDetails.steammOracleIndexB == null)
        throw new Error("Steamm oracle index b not supported");
      if (r10.extendedDetails.steammOraclePythPriceSeedA == null)
        throw new Error("Steamm oracle pyth price seed a not supported");
      if (r10.extendedDetails.steammOraclePythPriceSeedB == null)
        throw new Error("Steamm oracle pyth price seed b not supported");
      const [c, l10, u10] = o10 ? ["swap_a2b_v2", s10, a10] : ["swap_b2a_v2", a10, s10], d6 = r10.extendedDetails.steammOraclePythPriceSeedA, p = r10.extendedDetails.steammOraclePythPriceSeedB, y = this.pythPriceIDs.get(d6), x = this.pythPriceIDs.get(p);
      if (!y || !x)
        throw new Error("Base price info object id or quote price info object id not found");
      const b = t10.moveCall({
        target: `${this.oraclePackageId}::oracles::get_pyth_price`,
        typeArguments: [],
        arguments: [
          t10.object(r10.extendedDetails.steammOracleRegistryId),
          t10.object(y),
          t10.pure.u64(r10.extendedDetails.steammOracleIndexA),
          t10.object(Tr)
        ]
      }), M = t10.moveCall({
        target: `${this.oraclePackageId}::oracles::get_pyth_price`,
        typeArguments: [],
        arguments: [
          t10.object(r10.extendedDetails.steammOracleRegistryId),
          t10.object(x),
          t10.pure.u64(r10.extendedDetails.steammOracleIndexB),
          t10.object(Tr)
        ]
      }), O = [
        t10.object(r10.id),
        t10.object(r10.extendedDetails.steammBankA),
        t10.object(r10.extendedDetails.steammBankB),
        t10.object(r10.extendedDetails.steammLendingMarket),
        b,
        M,
        n10,
        t10.object(Tr)
      ], P = f0(e10.publishedAtV2Extend2(), i10);
      return t10.moveCall({
        target: `${P}::steamm_omm::${c}`,
        typeArguments: [
          r10.extendedDetails.steammLendingMarketType,
          l10,
          u10,
          r10.extendedDetails.steammBCoinAType,
          r10.extendedDetails.steammBCoinBType,
          r10.extendedDetails.steammLPToken
        ],
        arguments: O
      });
    });
  }
};
var L_ = "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI";
var B_ = "0xe44df51c0b21a27ab915fa1fe2ca610cd3eaa6d9666fe5e62b988bf7f0bd8722::musd::MUSD";
var U_ = "0xccd628c2334c5ed33e6c47d6c21bb664f8b6307b2ac32c2462a61f69a31ebcee::meth::METH";
var F_ = class {
  constructor(e10, t10) {
    if (e10 !== 0)
      throw new Error("Metastable only supported on mainnet");
    this.versionID = "0x4696559327b35ff2ab26904e7426a1646312e9c836d5c6cff6709a5ccc30915c", this.pythPriceIDs = t10;
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10, d6] = o10 ? ["swap_a2b", "create_deposit_cap", s10, a10] : ["swap_b2a", "create_withdraw_cap", a10, s10];
      let p = "", y = "pyth", x = "";
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported metastable");
      if (!r10.extendedDetails.metastableCreateCapPkgId || !r10.extendedDetails.metastableCreateCapModule || !r10.extendedDetails.metastableRegistryId || !r10.extendedDetails.metastableWhitelistedAppId)
        throw new Error("CreateCapPkgId or CreateCapModule or RegistryId or WhitelistedAppId or CreateCapAllTypeParams not supported");
      p = r10.extendedDetails.metastableCreateCapPkgId, y = r10.extendedDetails.metastableCreateCapModule, x = r10.extendedDetails.metastableWhitelistedAppId;
      const b = [
        d6
      ];
      r10.extendedDetails.metastableCreateCapAllTypeParams && b.push(u10);
      const M = [
        t10.object(x),
        t10.object(r10.id)
      ];
      switch (d6) {
        case L_: {
          if (!r10.extendedDetails.metastableRegistryId)
            throw new Error("Not found registry id for super sui");
          M.push(t10.object(r10.extendedDetails.metastableRegistryId));
          break;
        }
        case B_: {
          if (r10.extendedDetails.metastablePriceSeed != null) {
            const B = this.pythPriceIDs.get(r10.extendedDetails.metastablePriceSeed);
            if (B == null)
              throw new Error("Invalid Pyth price feed: " + r10.extendedDetails.metastablePriceSeed);
            M.push(t10.object(B));
          }
          if (r10.extendedDetails.metastableETHPriceSeed != null) {
            const B = this.pythPriceIDs.get(r10.extendedDetails.metastableETHPriceSeed);
            if (B == null)
              throw new Error("Invalid Pyth price feed: " + r10.extendedDetails.metastableETHPriceSeed);
            M.push(t10.object(B));
          }
          M.push(t10.object(Tr));
          break;
        }
        case U_: {
          if (r10.extendedDetails.metastablePriceSeed != null) {
            const B = this.pythPriceIDs.get(r10.extendedDetails.metastablePriceSeed);
            if (B == null)
              throw new Error("Invalid Pyth price feed: " + r10.extendedDetails.metastablePriceSeed);
            M.push(t10.object(B));
          }
          if (r10.extendedDetails.metastableETHPriceSeed != null) {
            const B = this.pythPriceIDs.get(r10.extendedDetails.metastableETHPriceSeed);
            if (B == null)
              throw new Error("Invalid Pyth price feed: " + r10.extendedDetails.metastableETHPriceSeed);
            M.push(t10.object(B));
          }
          M.push(t10.object(Tr));
          break;
        }
        default:
          throw new Error("Invalid Metacoin: " + d6);
      }
      const O = t10.moveCall({
        target: `${p}::${y}::${l10}`,
        typeArguments: b,
        arguments: M
      }), P = [
        t10.object(r10.id),
        t10.object(this.versionID),
        O,
        n10
      ], j = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${j}::metastable::${c}`,
        typeArguments: [
          u10,
          d6
        ],
        arguments: P
      });
    });
  }
};
var $_ = class {
  constructor(e10, t10) {
    if (e10 === 1)
      throw new Error("Obric is not supported on testnet");
    this.pythPriceIDs = t10, this.pythStateObjectId = "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10];
      let d6, p, y, x;
      if (r10.extendedDetails == null)
        throw new Error("Extended details not supported in obric");
      if (r10.extendedDetails.obricCoinAPriceSeed && r10.extendedDetails.obricCoinBPriceSeed)
        d6 = r10.extendedDetails.obricCoinAPriceSeed, y = this.pythPriceIDs.get(d6), p = r10.extendedDetails.obricCoinBPriceSeed, x = this.pythPriceIDs.get(p);
      else {
        if (!r10.extendedDetails.obricCoinAPriceId || !r10.extendedDetails.obricCoinBPriceId)
          throw new Error("Base price id or quote price id not supported");
        y = r10.extendedDetails.obricCoinAPriceId, x = r10.extendedDetails.obricCoinBPriceId;
      }
      if (!y || !x)
        throw new Error(
          "Base price info object id or quote price info object id not found"
        );
      const b = [
        t10.object(r10.id),
        n10,
        t10.object(this.pythStateObjectId),
        t10.object(y),
        t10.object(x),
        t10.object(Tr)
      ], M = Ln(
        e10.publishedAtV2Extend(),
        i10
      );
      return t10.moveCall({
        target: `${M}::obric::${c}`,
        typeArguments: [l10, u10],
        arguments: b
      });
    });
  }
};
var V_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("HaWAL only supported on mainnet");
    this.staking = e10 === 0 ? "0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904" : "0x0", this.validator = e10 === 0 ? "0x7b3ba6de2ae58283f60d5b8dc04bb9e90e4796b3b2e0dea75569f491275242e7" : "0x0";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10 } = r10, s10 = o10 ? "swap_a2b" : "swap_b2a", a10 = [
        t10.object(this.staking),
        t10.object(r10.id),
        n10,
        t10.object(this.validator)
      ], c = Ln(e10.publishedAtV2Extend(), i10);
      return t10.moveCall({
        target: `${c}::hawal::${s10}`,
        typeArguments: [],
        arguments: a10
      });
    });
  }
};
var z_ = class {
  constructor(e10) {
    if (e10 !== 0)
      throw new Error("Momentum only supported on mainnet");
    this.version = "0x2375a0b1ec12010aaea3b2545acfa2ad34cfbba03ce4b59f4c39e1e25eed1b2a";
  }
  swap(e10, t10, r10, n10, i10) {
    return at(this, null, function* () {
      const { direction: o10, from: s10, target: a10 } = r10, [c, l10, u10] = o10 ? ["swap_a2b", s10, a10] : ["swap_b2a", a10, s10], d6 = [
        t10.object(r10.id),
        n10,
        t10.object(this.version),
        t10.object(Tr)
      ], p = f0(e10.publishedAtV2Extend2(), i10);
      return t10.moveCall({
        target: `${p}::momentum::${c}`,
        typeArguments: [l10, u10],
        arguments: d6
      });
    });
  }
};
var Qv = "CETUS";
var q_ = "DEEPBOOK";
var H_ = "KRIYA";
var W_ = "FLOWX";
var G_ = "FLOWXV3";
var K_ = "KRIYAV3";
var eb = "TURBOS";
var qf = "AFTERMATH";
var Y_ = "HAEDAL";
var X_ = "VOLO";
var J_ = "AFSUI";
var Z_ = "BLUEMOVE";
var tb = "DEEPBOOKV3";
var rb = "SCALLOP";
var Q_ = "SUILEND";
var eE = "BLUEFIN";
var a0 = "HAEDALPMM";
var tE = "ALPHAFI";
var rE = "SPRINGSUI";
var nb = "STEAMM";
var c0 = "METASTABLE";
var l0 = "OBRIC";
var nE = "HAWAL";
var u0 = "STEAMM_OMM";
var iE = "MOMENTUM";
var oE = "https://api-sui.cetus.zone/router_v2";
function qu(e10) {
  return Array.isArray(e10.routers);
}
function Hu(e10) {
  return Array.isArray(e10.routers);
}
var ib = class ob {
  constructor(t10) {
    var r10, n10;
    this.endpoint = t10.endpoint ? uE(t10.endpoint) : oE, this.client = t10.client || new bs({ url: og("mainnet") }), this.signer = t10.signer || "", this.env = t10.env || 0, this.allCoins = /* @__PURE__ */ new Map();
    const i10 = ob.CONFIG[this.env];
    if (this.pythConnections = this.newPythClients((r10 = t10.pythUrls) != null ? r10 : []), this.pythClient = new Mf.SuiPythClient(
      this.client,
      i10.pythStateId,
      i10.wormholeStateId
    ), this.apiKey = t10.apiKey || "", this.partner = t10.partner, t10.overlayFeeRate)
      if (t10.overlayFeeRate > 0 && t10.overlayFeeRate <= 0.01)
        this.overlayFeeRate = t10.overlayFeeRate * 1e6;
      else
        throw new Error("Overlay fee rate must be between 0 and 0.01");
    else
      this.overlayFeeRate = 0;
    this.overlayFeeReceiver = (n10 = t10.overlayFeeReceiver) != null ? n10 : "0x0";
  }
  newPythClients(t10) {
    return t10.includes("https://hermes.pyth.network") || t10.push("https://hermes.pyth.network"), t10.map((n10) => new Mf.SuiPriceServiceConnection(n10, { timeout: 3e3 }));
  }
  getCoins(t10, r10 = true) {
    return at(this, null, function* () {
      if (this.signer === "")
        throw new Error("Signer is required, but not provided.");
      let n10 = null, i10 = 50;
      if (!r10) {
        const s10 = this.allCoins.get(t10);
        if (s10)
          return s10;
      }
      const o10 = [];
      for (; ; )
        try {
          const s10 = yield this.client.getCoins({
            owner: this.signer,
            coinType: t10,
            cursor: n10,
            limit: i10
          });
          for (const a10 of s10.data)
            o10.push({
              coinAddress: jn(a10.coinType).source_address,
              coinObjectId: a10.coinObjectId,
              balance: BigInt(a10.balance)
            });
          if (!s10.hasNextPage)
            break;
          n10 = s10.nextCursor;
        } catch (s10) {
          console.error("getCoins error:", s10);
          break;
        }
      return this.allCoins.set(t10, o10), o10;
    });
  }
  findRouters(t10) {
    return at(this, null, function* () {
      return fE(this.endpoint, this.apiKey, t10, this.overlayFeeRate, this.overlayFeeReceiver);
    });
  }
  executeFlexibleInputSwap(t10, r10, n10, i10, o10, s10, a10, c, l10) {
    return at(this, null, function* () {
      if (n10.length === 0)
        throw new Error("No router found");
      const u10 = n10[0].path[n10[0].path.length - 1].target, d6 = [];
      for (let b = 0; b < n10.length - 1; b++) {
        if (n10[b].path.length === 0)
          throw new Error("Empty path");
        let O = t10.splitCoins(r10, [n10[b].amountIn.toString()])[0];
        for (const P of n10[b].path)
          O = yield this.newDex(P.provider, s10, a10).swap(
            this,
            t10,
            P,
            O,
            l10,
            c
          );
        d6.push(O);
      }
      if (n10[n10.length - 1].path.length === 0)
        throw new Error("Empty path");
      let p = r10;
      for (const b of n10[n10.length - 1].path)
        p = yield this.newDex(b.provider, s10, a10).swap(
          this,
          t10,
          b,
          p,
          l10,
          c
        );
      d6.push(p);
      const y = Ln(
        this.publishedAtV2Extend(),
        l10
      );
      return this.checkCoinThresholdAndMergeCoin(
        t10,
        d6,
        u10,
        i10,
        o10,
        y
      );
    });
  }
  expectInputSwap(t10, r10, n10, i10, o10, s10, a10, c, l10) {
    return at(this, null, function* () {
      if (n10.length === 0)
        throw new Error("No router found");
      const u10 = n10.map((P) => P.amountIn.toString()), d6 = n10[0].path[0].from, p = n10[0].path[n10[0].path.length - 1].target, y = t10.splitCoins(r10, u10), x = [];
      for (let P = 0; P < n10.length; P++) {
        if (n10[P].path.length === 0)
          throw new Error("Empty path");
        let j = y[P];
        for (const F of n10[P].path)
          j = yield this.newDex(F.provider, s10, a10).swap(
            this,
            t10,
            F,
            j,
            l10,
            c
          );
        x.push(j);
      }
      const b = Er(
        this.publishedAtV2(),
        l10
      ), M = Ln(
        this.publishedAtV2Extend(),
        l10
      );
      return this.transferOrDestoryCoin(
        t10,
        r10,
        d6,
        b
      ), this.checkCoinThresholdAndMergeCoin(
        t10,
        x,
        p,
        i10,
        o10,
        M
      );
    });
  }
  expectOutputSwap(t10, r10, n10, i10, o10) {
    return at(this, null, function* () {
      const s10 = [], a10 = [], c = [], l10 = new sp(this.env, i10), u10 = Er(
        this.publishedAtV2(),
        o10
      );
      for (let p = 0; p < n10.length; p++) {
        const y = n10[p];
        for (let b = y.path.length - 1; b >= 0; b--) {
          const M = y.path[b], O = l10.flash_swap(this, t10, M, false);
          s10.unshift(O.targetCoin), a10.unshift(O.flashReceipt);
        }
        let x = r10;
        for (let b = 0; b < y.path.length; b++) {
          const M = y.path[b], O = l10.repay_flash_swap(
            this,
            t10,
            M,
            x,
            a10[b]
          );
          x = s10[b], b === 0 ? r10 = O : this.transferOrDestoryCoin(
            t10,
            O,
            M.from,
            u10
          ), b === y.path.length - 1 && c.push(x);
        }
      }
      const d6 = n10[0].path[0].from;
      if (this.transferOrDestoryCoin(
        t10,
        r10,
        d6,
        u10
      ), c.length > 1) {
        const p = t10.makeMoveVec({ elements: c.slice(1) });
        t10.moveCall({
          target: `${ma}::pay::join_vec`,
          typeArguments: [n10[0].path[n10[0].path.length - 1].target],
          arguments: [c[0], p]
        });
      }
      return c[0];
    });
  }
  swapInPools(t10) {
    return at(this, null, function* () {
      let r10;
      try {
        r10 = yield C_(this.client, t10, this.signer, this.env);
      } catch (n10) {
        return console.error("swapInPools error:", n10), null;
      }
      return r10;
    });
  }
  routerSwap(t10) {
    return at(this, null, function* () {
      const { routers: r10, inputCoin: n10, slippage: i10, txb: o10, deepbookv3DeepFee: s10, partner: a10 } = t10;
      if (i10 > 1 || i10 < 0)
        throw new Error("Invalid slippage value. Must be between 0 and 1 (e.g., 0.01 represents 1% slippage)");
      const c = Array.isArray(r10) ? r10 : r10.routes, l10 = qu(t10) ? t10.byAmountIn : t10.routers.byAmountIn, u10 = c.reduce(
        (z, G) => z.add(G.amountIn),
        new Gt.default(0)
      ), d6 = c.reduce(
        (z, G) => z.add(G.amountOut),
        new Gt.default(0)
      );
      let p = new Gt.default(0);
      this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0" && (l10 ? p = d6.mul(new Gt.default(this.overlayFeeRate)).div(new Gt.default(1e6)) : p = u10.mul(new Gt.default(this.overlayFeeRate)).div(new Gt.default(1e6)));
      const y = l10 ? d6.sub(p) : d6, x = l10 ? u10 : u10.add(p), b = up(
        l10 ? y : x,
        l10,
        i10
      ), M = qu(t10) ? void 0 : t10.routers.packages, O = Er(
        this.publishedAtV2(),
        M
      ), P = dp(c), j = P.length > 0 ? yield this.updatePythPriceIDs(P, o10) : /* @__PURE__ */ new Map();
      if (l10)
        return yield this.expectInputSwap(
          o10,
          n10,
          c,
          d6.toString(),
          b.toString(),
          j,
          a10 ?? this.partner,
          s10,
          M
        );
      const F = o10.splitCoins(n10, [
        p.toString()
      ]);
      this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0" && o10.transferObjects([F], this.overlayFeeReceiver);
      const B = o10.splitCoins(n10, [
        b.sub(p).toString()
      ]);
      return this.transferOrDestoryCoin(
        o10,
        n10,
        c[0].path[0].from,
        O
      ), yield this.expectOutputSwap(
        o10,
        B[0],
        c,
        a10 ?? this.partner
      );
    });
  }
  fixableRouterSwap(t10) {
    return at(this, null, function* () {
      const { routers: r10, inputCoin: n10, slippage: i10, txb: o10, deepbookv3DeepFee: s10, partner: a10 } = t10, c = Array.isArray(r10) ? r10 : r10.routes, l10 = t10.routers.byAmountIn, u10 = c.reduce(
        (F, B) => F.add(B.amountIn),
        new Gt.default(0)
      ), d6 = c.reduce(
        (F, B) => F.add(B.amountOut),
        new Gt.default(0)
      );
      let p = 0;
      this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0" && (l10 ? p = Number(d6.mul(new Gt.default(this.overlayFeeRate)).div(new Gt.default(1e6)).toString()) : p = Number(u10.mul(new Gt.default(this.overlayFeeRate)).div(new Gt.default(1e6)).toString()));
      const y = l10 ? d6.sub(new Gt.default(p)) : d6, x = l10 ? u10 : u10.add(new Gt.default(p)), b = up(
        l10 ? y : x,
        l10,
        i10
      ), M = qu(t10) ? void 0 : t10.routers.packages, O = dp(c), P = O.length > 0 ? yield this.updatePythPriceIDs(O, o10) : /* @__PURE__ */ new Map();
      return l10 ? yield this.executeFlexibleInputSwap(
        o10,
        n10,
        c,
        y.toString(),
        b.toString(),
        P,
        a10 ?? this.partner,
        s10,
        M
      ) : yield this.expectOutputSwap(
        o10,
        n10,
        c,
        a10 ?? this.partner
      );
    });
  }
  // auto build input coin
  // auto merge, transfer or destory target coin.
  fastRouterSwap(t10) {
    return at(this, null, function* () {
      const {
        routers: r10,
        slippage: n10,
        txb: i10,
        partner: o10,
        refreshAllCoins: s10,
        payDeepFeeAmount: a10
      } = t10, c = Array.isArray(r10) ? r10 : r10.routes, l10 = c[0].path[0].from;
      let u10 = yield this.getCoins(l10, s10);
      const d6 = c[0].path[c[0].path.length - 1].target, p = c.reduce(
        (G, re) => G.add(re.amountIn),
        new Gt.default(0)
      ), y = c.reduce(
        (G, re) => G.add(re.amountOut),
        new Gt.default(0)
      ), x = Hu(t10) ? t10.byAmountIn : t10.routers.byAmountIn;
      let b = 0;
      this.overlayFeeRate > 0 && this.overlayFeeReceiver !== "0x0" && (x ? b = Number(y.mul(new Gt.default(this.overlayFeeRate)).div(new Gt.default(1e6)).toString()) : b = Number(p.mul(new Gt.default(this.overlayFeeRate)).div(new Gt.default(1e6)).toString()));
      const M = x ? y.sub(new Gt.default(b)) : y, O = x ? p : p.add(new Gt.default(b)), P = __(
        x ? M : O,
        x,
        n10
      ), F = zu(
        i10,
        u10,
        BigInt((x ? O : P).toString()),
        l10
      );
      let B;
      if (a10 && a10 > 0) {
        let G = yield this.getCoins(this.deepbookv3DeepFeeType());
        B = zu(
          i10,
          G,
          BigInt(a10),
          this.deepbookv3DeepFeeType()
        ).targetCoin;
      }
      const W = Hu(t10) ? {
        routers: c,
        inputCoin: F.targetCoin,
        slippage: n10,
        byAmountIn: x,
        txb: i10,
        partner: o10 ?? this.partner,
        deepbookv3DeepFee: B
      } : {
        routers: t10.routers,
        inputCoin: F.targetCoin,
        slippage: n10,
        byAmountIn: x,
        txb: i10,
        partner: o10 ?? this.partner,
        deepbookv3DeepFee: B
      }, z = yield this.routerSwap(W);
      if (Gn.isSuiCoin(d6))
        i10.mergeCoins(i10.gas, [z]);
      else {
        let G = yield this.getCoins(d6, s10);
        const re = zu(
          i10,
          G,
          BigInt(0),
          d6
        ), ie = Hu(t10) ? void 0 : t10.routers.packages, oe = Er(
          this.publishedAtV2(),
          ie
        );
        i10.mergeCoins(re.targetCoin, [z]), re.isMintZeroCoin && this.transferOrDestoryCoin(
          i10,
          re.targetCoin,
          d6,
          oe
        );
      }
    });
  }
  // Include cetus、deepbookv2、flowxv2 & v3、kriyav2 & v3、turbos、aftermath、haedal、afsui、volo、bluemove
  publishedAtV2() {
    return this.env === 0 ? "0x3864c7c59a4889fec05d1aae4bc9dba5a0e0940594b424fbed44cb3f6ac4c032" : "0x52eae33adeb44de55cfb3f281d4cc9e02d976181c0952f5323648b5717b33934";
  }
  // Include deepbookv3, scallop, bluefin
  publishedAtV2Extend() {
    return this.env === 0 ? "0x39402d188b7231036e52266ebafad14413b4bf3daea4ac17115989444e6cd516" : "0xabb6a81c8a216828e317719e06125de5bb2cb0fe8f9916ff8c023ca5be224c78";
  }
  publishedAtV2Extend2() {
    return this.env === 0 ? "0x0018f7bbbece22f4272ed2281b290f745e5aa69d870f599810a30b4eeffc1a5e" : "0x0";
  }
  deepbookv3DeepFeeType() {
    return this.env === 0 ? "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP" : "0x36dbef866a1d62bf7328989a10fb2f07d769f4ee587c0de4a0a256e57e0a58a8::deep::DEEP";
  }
  transferOrDestoryCoin(t10, r10, n10, i10) {
    t10.moveCall({
      target: `${i10}::utils::transfer_or_destroy_coin`,
      typeArguments: [n10],
      arguments: [r10]
    });
  }
  checkCoinThresholdAndMergeCoin(t10, r10, n10, i10, o10, s10) {
    let a10 = r10[0];
    if (r10.length > 1) {
      let c = t10.makeMoveVec({ elements: r10.slice(1) });
      t10.moveCall({
        target: `${ma}::pay::join_vec`,
        typeArguments: [n10],
        arguments: [r10[0], c]
      }), a10 = r10[0];
    }
    return this.overlayFeeRate === 0 || this.overlayFeeReceiver === "0x0" ? t10.moveCall({
      target: `${s10}::utils::check_coin_threshold_v1`,
      typeArguments: [n10],
      arguments: [
        a10,
        t10.pure.u64(i10),
        t10.pure.u64(o10)
      ]
    }) : t10.moveCall({
      target: `${s10}::utils::check_coin_threshold_v2`,
      typeArguments: [n10],
      arguments: [
        a10,
        t10.pure.u64(i10),
        t10.pure.u64(o10),
        t10.pure.u64(this.overlayFeeRate),
        t10.pure.address(this.overlayFeeReceiver)
      ]
    }), a10;
  }
  newDex(t10, r10, n10) {
    switch (t10) {
      case Qv:
        return new sp(this.env, n10);
      case q_:
        return new u_(this.env);
      case tb:
        return new O_(this.env);
      case H_:
        return new f_(this.env);
      case K_:
        return new d_(this.env);
      case W_:
        return new h_(this.env);
      case G_:
        return new p_(this.env);
      case eb:
        return new m_(this.env);
      case qf:
        return new l_(this.env);
      case Y_:
        return new T_(this.env);
      case J_:
        return new A_(this.env);
      case X_:
        return new M_(this.env);
      case Z_:
        return new I_(this.env);
      case rb:
        return new R_(this.env);
      case Q_:
        return new fp(this.env);
      case rE:
        return new fp(this.env);
      case eE:
        return new P_(this.env);
      case a0:
        return new N_(this.env, r10);
      case tE:
        return new j_(this.env);
      case nb:
        return new k_(this.env);
      case u0:
        return new D_(this.env, r10);
      case c0:
        return new F_(this.env, r10);
      case l0:
        return new $_(this.env, r10);
      case nE:
        return new V_(this.env);
      case iE:
        return new z_(this.env);
      default:
        throw new Error(`Unsupported dex ${t10}`);
    }
  }
  signAndExecuteTransaction(t10, r10) {
    return at(this, null, function* () {
      return yield this.client.signAndExecuteTransaction({
        transaction: t10,
        signer: r10,
        options: {
          showEffects: true,
          showEvents: true,
          showInput: true,
          showBalanceChanges: true
        }
      });
    });
  }
  devInspectTransactionBlock(t10) {
    return at(this, null, function* () {
      return yield this.client.devInspectTransactionBlock({
        transactionBlock: t10,
        sender: this.signer
      });
    });
  }
  sendTransaction(t10, r10) {
    return at(this, null, function* () {
      return yield this.client.signAndExecuteTransaction({
        transaction: t10,
        signer: r10
      });
    });
  }
  getDeepbookV3Config() {
    return at(this, null, function* () {
      const t10 = yield pE(this.endpoint);
      return t10 ? t10.data : null;
    });
  }
  updatePythPriceIDs(t10, r10) {
    return at(this, null, function* () {
      let n10 = null, i10 = null;
      for (const a10 of this.pythConnections)
        try {
          n10 = yield a10.getPriceFeedsUpdateData(t10);
          break;
        } catch (c) {
          i10 = c;
          continue;
        }
      if (n10 == null)
        throw new Error(
          `All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes. Detailed error: ${i10 == null ? void 0 : i10.message}`
        );
      let o10 = [];
      try {
        o10 = yield this.pythClient.updatePriceFeeds(
          r10,
          n10,
          t10
        );
      } catch (a10) {
        throw new Error(`All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes in the pythUrls parameter when initializing AggregatorClient, for example: new AggregatorClient({ pythUrls: ["https://your-pyth-node-url"] }). Detailed error: ${a10}`);
      }
      let s10 = /* @__PURE__ */ new Map();
      for (let a10 = 0; a10 < t10.length; a10++)
        s10.set(t10[a10], o10[a10]);
      return s10;
    });
  }
};
ib.CONFIG = {
  1: {
    wormholeStateId: "0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790",
    pythStateId: "0x243759059f4c3111179da5878c12f68d612c21a8d54d85edc86164bb18be1c7c"
  },
  0: {
    wormholeStateId: "0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c",
    pythStateId: "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8"
  }
};
var sb = ib;
function dp(e10) {
  const t10 = /* @__PURE__ */ new Set();
  for (const r10 of e10)
    for (const n10 of r10.path)
      n10.provider === a0 && n10.extendedDetails && n10.extendedDetails.haedalPmmBasePriceSeed && n10.extendedDetails.haedalPmmQuotePriceSeed && (t10.add(n10.extendedDetails.haedalPmmBasePriceSeed), t10.add(n10.extendedDetails.haedalPmmQuotePriceSeed)), n10.provider === c0 && (n10.extendedDetails && n10.extendedDetails.metastablePriceSeed && t10.add(n10.extendedDetails.metastablePriceSeed), n10.extendedDetails && n10.extendedDetails.metastableETHPriceSeed && t10.add(n10.extendedDetails.metastableETHPriceSeed)), n10.provider === l0 && (n10.extendedDetails && n10.extendedDetails.obricCoinAPriceSeed && t10.add(n10.extendedDetails.obricCoinAPriceSeed), n10.extendedDetails && n10.extendedDetails.obricCoinBPriceSeed && t10.add(n10.extendedDetails.obricCoinBPriceSeed)), n10.provider === u0 && (n10.extendedDetails && n10.extendedDetails.steammOraclePythPriceSeedA && t10.add(n10.extendedDetails.steammOraclePythPriceSeedA), n10.extendedDetails && n10.extendedDetails.steammOraclePythPriceSeedB && t10.add(n10.extendedDetails.steammOraclePythPriceSeedB));
  return Array.from(t10);
}
function sE(e10, t10) {
  let r10 = 0;
  for (const o10 of e10.routes)
    for (const s10 of o10.path)
      s10.extended_details && s10.extended_details.deepbookv3_deep_fee && (r10 += Number(s10.extended_details.deepbookv3_deep_fee));
  let n10;
  if (e10.packages != null) {
    n10 = /* @__PURE__ */ new Map();
    for (const [o10, s10] of Object.entries(e10.packages))
      n10.set(o10, s10);
  }
  return {
    amountIn: new Gt.default(e10.amount_in.toString()),
    amountOut: new Gt.default(e10.amount_out.toString()),
    byAmountIn: t10,
    insufficientLiquidity: false,
    routes: e10.routes.map((o10) => ({
      path: o10.path.map((s10) => {
        var a10, c, l10, u10, d6, p, y, x, b, M, O, P, j, F, B, W, z, G, re, ie, oe, q, L, h, f, m, S, T, E, I;
        let C;
        s10.provider === qf && (C = s10.extended_details.aftermath_pool_flatness === 0 ? "v2" : "v3");
        let g;
        return (s10.provider === eb || s10.provider === qf || s10.provider === Qv || s10.provider === tb || s10.provider === rb || s10.provider === a0 || s10.provider === c0 || s10.provider === l0 || s10.provider === nb || s10.provider === u0) && (g = {
          aftermathLpSupplyType: (a10 = s10.extended_details) == null ? void 0 : a10.aftermath_lp_supply_type,
          turbosFeeType: (c = s10.extended_details) == null ? void 0 : c.turbos_fee_type,
          afterSqrtPrice: (l10 = s10.extended_details) == null ? void 0 : l10.after_sqrt_price,
          deepbookv3DeepFee: (u10 = s10.extended_details) == null ? void 0 : u10.deepbookv3_deep_fee,
          scallopScoinTreasury: (d6 = s10.extended_details) == null ? void 0 : d6.scallop_scoin_treasury,
          haedalPmmBasePriceSeed: (p = s10.extended_details) == null ? void 0 : p.haedal_pmm_base_price_seed,
          haedalPmmQuotePriceSeed: (y = s10.extended_details) == null ? void 0 : y.haedal_pmm_quote_price_seed,
          steammBankA: (x = s10.extended_details) == null ? void 0 : x.steamm_bank_a,
          steammBankB: (b = s10.extended_details) == null ? void 0 : b.steamm_bank_b,
          steammLendingMarket: (M = s10.extended_details) == null ? void 0 : M.steamm_lending_market,
          steammLendingMarketType: (O = s10.extended_details) == null ? void 0 : O.steamm_lending_market_type,
          steammBCoinAType: (P = s10.extended_details) == null ? void 0 : P.steamm_btoken_a_type,
          steammBCoinBType: (j = s10.extended_details) == null ? void 0 : j.steamm_btoken_b_type,
          steammLPToken: (F = s10.extended_details) == null ? void 0 : F.steamm_lp_token_type,
          steammOracleRegistryId: (B = s10.extended_details) == null ? void 0 : B.steamm_oracle_registry_id,
          steammOracleIndexA: (W = s10.extended_details) == null ? void 0 : W.steamm_oracle_index_a,
          steammOracleIndexB: (z = s10.extended_details) == null ? void 0 : z.steamm_oracle_index_b,
          steammOraclePythPriceSeedA: (G = s10.extended_details) == null ? void 0 : G.steamm_oracle_pyth_price_seed_a,
          steammOraclePythPriceSeedB: (re = s10.extended_details) == null ? void 0 : re.steamm_oracle_pyth_price_seed_b,
          metastablePriceSeed: (ie = s10.extended_details) == null ? void 0 : ie.metastable_price_seed,
          metastableETHPriceSeed: (oe = s10.extended_details) == null ? void 0 : oe.metastable_eth_price_seed,
          metastableWhitelistedAppId: (q = s10.extended_details) == null ? void 0 : q.metastable_whitelisted_app_id,
          metastableCreateCapPkgId: (L = s10.extended_details) == null ? void 0 : L.metastable_create_cap_pkg_id,
          metastableCreateCapModule: (h = s10.extended_details) == null ? void 0 : h.metastable_create_cap_module,
          metastableCreateCapAllTypeParams: (f = s10.extended_details) == null ? void 0 : f.metastable_create_cap_all_type_params,
          metastableRegistryId: (m = s10.extended_details) == null ? void 0 : m.metastable_registry_id,
          obricCoinAPriceSeed: (S = s10.extended_details) == null ? void 0 : S.obric_coin_a_price_seed,
          obricCoinBPriceSeed: (T = s10.extended_details) == null ? void 0 : T.obric_coin_b_price_seed,
          obricCoinAPriceId: (E = s10.extended_details) == null ? void 0 : E.obric_coin_a_price_id,
          obricCoinBPriceId: (I = s10.extended_details) == null ? void 0 : I.obric_coin_b_price_id
        }), {
          id: s10.id,
          direction: s10.direction,
          provider: s10.provider,
          from: s10.from,
          target: s10.target,
          feeRate: s10.fee_rate,
          amountIn: s10.amount_in,
          amountOut: s10.amount_out,
          extendedDetails: g,
          version: C
        };
      }),
      amountIn: new Gt.default(o10.amount_in.toString()),
      amountOut: new Gt.default(o10.amount_out.toString()),
      initialPrice: new wc(o10.initial_price.toString())
    })),
    totalDeepFee: r10,
    packages: n10
  };
}
var Tr = o1;
var aE = "aggregator_v2";
var cE = "aggregator_v2_extend";
var lE = "aggregator_v2_extend2";
function Er(e10, t10) {
  var r10;
  return t10 instanceof Map && (r10 = t10.get(aE)) != null ? r10 : e10;
}
function Ln(e10, t10) {
  var r10;
  return t10 instanceof Map && (r10 = t10.get(cE)) != null ? r10 : e10;
}
function f0(e10, t10) {
  var r10;
  return t10 instanceof Map && (r10 = t10.get(lE)) != null ? r10 : e10;
}
zo(qo());
function uE(e10) {
  return e10.endsWith("/find_routes") ? e10.replace("/find_routes", "") : e10;
}
var Za = zo(qo());
var ab = 1000800;
function fE(e10, t10, r10, n10, i10) {
  return at(this, null, function* () {
    let o10;
    if (r10.liquidityChanges && r10.liquidityChanges.length > 0 ? o10 = yield hE(e10, r10) : o10 = yield dE(e10, t10, r10), !o10)
      return null;
    if (!o10.ok) {
      let c = 10001;
      return o10.status === 429 && (c = 10005), {
        amountIn: xi,
        amountOut: xi,
        routes: [],
        byAmountIn: r10.byAmountIn,
        insufficientLiquidity: false,
        error: {
          code: c,
          msg: Vu(c)
        }
      };
    }
    const s10 = yield o10.json(), a10 = s10.msg === "liquidity is not enough";
    if (s10.msg && s10.msg.indexOf("HoneyPot scam") > -1)
      return {
        amountIn: xi,
        amountOut: xi,
        routes: [],
        byAmountIn: r10.byAmountIn,
        insufficientLiquidity: a10,
        error: {
          code: 10004,
          msg: Vu(
            10004
            /* HoneyPot */
          )
        }
      };
    if (s10.data != null) {
      const c = sE(s10.data, r10.byAmountIn);
      if (n10 > 0 && i10 !== "0x0")
        if (r10.byAmountIn) {
          const l10 = c.amountOut.mul(new Za.default(n10)).div(new Za.default(1e6));
          c.overlayFee = Number(l10.toString()), c.amountOut = c.amountOut.sub(l10);
        } else {
          const l10 = c.amountIn.mul(new Za.default(n10)).div(new Za.default(1e6));
          c.overlayFee = Number(l10.toString()), c.amountIn = c.amountIn.add(l10);
        }
      return c;
    }
    return {
      amountIn: xi,
      amountOut: xi,
      routes: [],
      insufficientLiquidity: a10,
      byAmountIn: r10.byAmountIn,
      error: {
        code: 10003,
        msg: Vu(
          10003
          /* InsufficientLiquidity */
        )
      }
    };
  });
}
function dE(e10, t10, r10) {
  return at(this, null, function* () {
    try {
      const {
        from: n10,
        target: i10,
        amount: o10,
        byAmountIn: s10,
        depth: a10,
        splitAlgorithm: c,
        splitFactor: l10,
        splitCount: u10,
        providers: d6
      } = r10, p = eo(n10), y = eo(i10);
      let x = `${e10}/find_routes?from=${p}&target=${y}&amount=${o10.toString()}&by_amount_in=${s10}`;
      return a10 && (x += `&depth=${a10}`), c && (x += `&split_algorithm=${c}`), l10 && (x += `&split_factor=${l10}`), u10 && (x += `&split_count=${u10}`), d6 && d6.length > 0 && (x += `&providers=${d6.join(",")}`), t10.length > 0 && (x += `&apiKey=${t10}`), x += `&v=${ab}`, yield fetch(x);
    } catch (n10) {
      return console.error(n10), null;
    }
  });
}
function hE(e10, t10) {
  return at(this, null, function* () {
    const {
      from: r10,
      target: n10,
      amount: i10,
      byAmountIn: o10,
      depth: s10,
      splitAlgorithm: a10,
      splitFactor: c,
      splitCount: l10,
      providers: u10,
      liquidityChanges: d6
    } = t10, p = eo(r10), y = eo(n10), x = `${e10}/find_routes`, b = u10 == null ? void 0 : u10.join(","), M = {
      from: p,
      target: y,
      amount: Number(i10.toString()),
      by_amount_in: o10,
      depth: s10,
      split_algorithm: a10,
      split_factor: c,
      split_count: l10,
      providers: b,
      liquidity_changes: d6.map((O) => ({
        pool: O.poolID,
        tick_lower: O.ticklower,
        tick_upper: O.tickUpper,
        delta_liquidity: O.deltaLiquidity
      })),
      v: ab
    };
    try {
      return yield fetch(x, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(M)
      });
    } catch (O) {
      return console.error("Error:", O), null;
    }
  });
}
function pE(e10) {
  return at(this, null, function* () {
    const t10 = `${e10}/deepbookv3_config`;
    try {
      return (yield fetch(t10)).json();
    } catch (r10) {
      return console.error("Error:", r10), null;
    }
  });
}
var d0 = ((e10) => (e10[e10.Mainnet = 0] = "Mainnet", e10[e10.Testnet = 1] = "Testnet", e10))(d0 || {});
var cb = "0x2::sui::SUI";
var mE = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
function lb(e10) {
  return Br(e10).full_address === cb;
}
function hp(e10, ...t10) {
  const r10 = Array.isArray(t10[t10.length - 1]) ? t10.pop() : [];
  let i10 = [e10, ...t10].filter(Boolean).join("::");
  return r10 && r10.length && (i10 += `<${r10.join(", ")}>`), i10;
}
function Br(e10) {
  var t10;
  try {
    let r10 = e10.replace(/\s/g, "");
    const n10 = r10.match(/(<.+>)$/), i10 = (t10 = n10 == null ? void 0 : n10[0]) == null ? void 0 : t10.match(
      /(\w+::\w+::\w+)(?:<.*?>(?!>))?/g
    );
    if (i10) {
      r10 = r10.slice(0, r10.indexOf("<"));
      const l10 = {
        ...Br(r10),
        type_arguments: i10.map(
          (u10) => Br(u10).source_address
        )
      };
      return l10.type_arguments = l10.type_arguments.map((u10) => lb(u10) ? u10 : Br(u10).source_address), l10.source_address = hp(
        l10.full_address,
        l10.type_arguments
      ), l10;
    }
    const o10 = r10.split("::"), a10 = {
      full_address: r10,
      address: r10 === cb || r10 === mE ? "0x2" : en(o10[0]),
      module: o10[1],
      name: o10[2],
      type_arguments: [],
      source_address: ""
    };
    return a10.full_address = `${a10.address}::${a10.module}::${a10.name}`, a10.source_address = hp(
      a10.full_address,
      a10.type_arguments
    ), a10;
  } catch {
    return {
      full_address: e10,
      address: "",
      module: "",
      name: "",
      type_arguments: [],
      source_address: e10
    };
  }
}
function gE(e10) {
  return e10.startsWith("0x") ? `${e10.slice(2)}` : e10;
}
var Oi = (e10, t10 = true) => {
  const r10 = e10.split("::"), n10 = r10.shift();
  let i10 = en(n10);
  return t10 && (i10 = gE(i10)), `${i10}::${r10.join("::")}`;
};
var ls = 9e15;
var co = 1e9;
var Hf = "0123456789abcdef";
var Wc = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var Gc = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var Wf = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -ls,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: ls,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var ub;
var Ci;
var st = true;
var Pl = "[DecimalError] ";
var to = Pl + "Invalid argument: ";
var fb = Pl + "Precision limit exceeded";
var db = Pl + "crypto unavailable";
var hb = "[object Decimal]";
var Fr = Math.floor;
var yr = Math.pow;
var vE = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var bE = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var yE = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var pb = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var kn = 1e7;
var Ye = 7;
var wE = 9007199254740991;
var xE = Wc.length - 1;
var Gf = Gc.length - 1;
var ge = { toStringTag: hb };
ge.absoluteValue = ge.abs = function() {
  var e10 = new this.constructor(this);
  return e10.s < 0 && (e10.s = 1), He(e10);
};
ge.ceil = function() {
  return He(new this.constructor(this), this.e + 1, 2);
};
ge.clampedTo = ge.clamp = function(e10, t10) {
  var r10, n10 = this, i10 = n10.constructor;
  if (e10 = new i10(e10), t10 = new i10(t10), !e10.s || !t10.s)
    return new i10(NaN);
  if (e10.gt(t10))
    throw Error(to + t10);
  return r10 = n10.cmp(e10), r10 < 0 ? e10 : n10.cmp(t10) > 0 ? t10 : new i10(n10);
};
ge.comparedTo = ge.cmp = function(e10) {
  var t10, r10, n10, i10, o10 = this, s10 = o10.d, a10 = (e10 = new o10.constructor(e10)).d, c = o10.s, l10 = e10.s;
  if (!s10 || !a10)
    return !c || !l10 ? NaN : c !== l10 ? c : s10 === a10 ? 0 : !s10 ^ c < 0 ? 1 : -1;
  if (!s10[0] || !a10[0])
    return s10[0] ? c : a10[0] ? -l10 : 0;
  if (c !== l10)
    return c;
  if (o10.e !== e10.e)
    return o10.e > e10.e ^ c < 0 ? 1 : -1;
  for (n10 = s10.length, i10 = a10.length, t10 = 0, r10 = n10 < i10 ? n10 : i10; t10 < r10; ++t10)
    if (s10[t10] !== a10[t10])
      return s10[t10] > a10[t10] ^ c < 0 ? 1 : -1;
  return n10 === i10 ? 0 : n10 > i10 ^ c < 0 ? 1 : -1;
};
ge.cosine = ge.cos = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.d ? r10.d[0] ? (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + Math.max(r10.e, r10.sd()) + Ye, n10.rounding = 1, r10 = SE(n10, yb(n10, r10)), n10.precision = e10, n10.rounding = t10, He(Ci == 2 || Ci == 3 ? r10.neg() : r10, e10, t10, true)) : new n10(1) : new n10(NaN);
};
ge.cubeRoot = ge.cbrt = function() {
  var e10, t10, r10, n10, i10, o10, s10, a10, c, l10, u10 = this, d6 = u10.constructor;
  if (!u10.isFinite() || u10.isZero())
    return new d6(u10);
  for (st = false, o10 = u10.s * yr(u10.s * u10, 1 / 3), !o10 || Math.abs(o10) == 1 / 0 ? (r10 = Nr(u10.d), e10 = u10.e, (o10 = (e10 - r10.length + 1) % 3) && (r10 += o10 == 1 || o10 == -2 ? "0" : "00"), o10 = yr(r10, 1 / 3), e10 = Fr((e10 + 1) / 3) - (e10 % 3 == (e10 < 0 ? -1 : 2)), o10 == 1 / 0 ? r10 = "5e" + e10 : (r10 = o10.toExponential(), r10 = r10.slice(0, r10.indexOf("e") + 1) + e10), n10 = new d6(r10), n10.s = u10.s) : n10 = new d6(o10.toString()), s10 = (e10 = d6.precision) + 3; ; )
    if (a10 = n10, c = a10.times(a10).times(a10), l10 = c.plus(u10), n10 = Xt(l10.plus(u10).times(a10), l10.plus(c), s10 + 2, 1), Nr(a10.d).slice(0, s10) === (r10 = Nr(n10.d)).slice(0, s10))
      if (r10 = r10.slice(s10 - 3, s10 + 1), r10 == "9999" || !i10 && r10 == "4999") {
        if (!i10 && (He(a10, e10 + 1, 0), a10.times(a10).times(a10).eq(u10))) {
          n10 = a10;
          break;
        }
        s10 += 4, i10 = 1;
      } else {
        (!+r10 || !+r10.slice(1) && r10.charAt(0) == "5") && (He(n10, e10 + 1, 1), t10 = !n10.times(n10).times(n10).eq(u10));
        break;
      }
  return st = true, He(n10, e10, d6.rounding, t10);
};
ge.decimalPlaces = ge.dp = function() {
  var e10, t10 = this.d, r10 = NaN;
  if (t10) {
    if (e10 = t10.length - 1, r10 = (e10 - Fr(this.e / Ye)) * Ye, e10 = t10[e10], e10)
      for (; e10 % 10 == 0; e10 /= 10)
        r10--;
    r10 < 0 && (r10 = 0);
  }
  return r10;
};
ge.dividedBy = ge.div = function(e10) {
  return Xt(this, new this.constructor(e10));
};
ge.dividedToIntegerBy = ge.divToInt = function(e10) {
  var t10 = this, r10 = t10.constructor;
  return He(Xt(t10, new r10(e10), 0, 1, 1), r10.precision, r10.rounding);
};
ge.equals = ge.eq = function(e10) {
  return this.cmp(e10) === 0;
};
ge.floor = function() {
  return He(new this.constructor(this), this.e + 1, 3);
};
ge.greaterThan = ge.gt = function(e10) {
  return this.cmp(e10) > 0;
};
ge.greaterThanOrEqualTo = ge.gte = function(e10) {
  var t10 = this.cmp(e10);
  return t10 == 1 || t10 === 0;
};
ge.hyperbolicCosine = ge.cosh = function() {
  var e10, t10, r10, n10, i10, o10 = this, s10 = o10.constructor, a10 = new s10(1);
  if (!o10.isFinite())
    return new s10(o10.s ? 1 / 0 : NaN);
  if (o10.isZero())
    return a10;
  r10 = s10.precision, n10 = s10.rounding, s10.precision = r10 + Math.max(o10.e, o10.sd()) + 4, s10.rounding = 1, i10 = o10.d.length, i10 < 32 ? (e10 = Math.ceil(i10 / 3), t10 = (1 / jl(4, e10)).toString()) : (e10 = 16, t10 = "2.3283064365386962890625e-10"), o10 = xs(s10, 1, o10.times(t10), new s10(1), true);
  for (var c, l10 = e10, u10 = new s10(8); l10--; )
    c = o10.times(o10), o10 = a10.minus(c.times(u10.minus(c.times(u10))));
  return He(o10, s10.precision = r10, s10.rounding = n10, true);
};
ge.hyperbolicSine = ge.sinh = function() {
  var e10, t10, r10, n10, i10 = this, o10 = i10.constructor;
  if (!i10.isFinite() || i10.isZero())
    return new o10(i10);
  if (t10 = o10.precision, r10 = o10.rounding, o10.precision = t10 + Math.max(i10.e, i10.sd()) + 4, o10.rounding = 1, n10 = i10.d.length, n10 < 3)
    i10 = xs(o10, 2, i10, i10, true);
  else {
    e10 = 1.4 * Math.sqrt(n10), e10 = e10 > 16 ? 16 : e10 | 0, i10 = i10.times(1 / jl(5, e10)), i10 = xs(o10, 2, i10, i10, true);
    for (var s10, a10 = new o10(5), c = new o10(16), l10 = new o10(20); e10--; )
      s10 = i10.times(i10), i10 = i10.times(a10.plus(s10.times(c.times(s10).plus(l10))));
  }
  return o10.precision = t10, o10.rounding = r10, He(i10, t10, r10, true);
};
ge.hyperbolicTangent = ge.tanh = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.isFinite() ? r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + 7, n10.rounding = 1, Xt(r10.sinh(), r10.cosh(), n10.precision = e10, n10.rounding = t10)) : new n10(r10.s);
};
ge.inverseCosine = ge.acos = function() {
  var e10 = this, t10 = e10.constructor, r10 = e10.abs().cmp(1), n10 = t10.precision, i10 = t10.rounding;
  return r10 !== -1 ? r10 === 0 ? e10.isNeg() ? Zn(t10, n10, i10) : new t10(0) : new t10(NaN) : e10.isZero() ? Zn(t10, n10 + 4, i10).times(0.5) : (t10.precision = n10 + 6, t10.rounding = 1, e10 = new t10(1).minus(e10).div(e10.plus(1)).sqrt().atan(), t10.precision = n10, t10.rounding = i10, e10.times(2));
};
ge.inverseHyperbolicCosine = ge.acosh = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.lte(1) ? new n10(r10.eq(1) ? 0 : NaN) : r10.isFinite() ? (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + Math.max(Math.abs(r10.e), r10.sd()) + 4, n10.rounding = 1, st = false, r10 = r10.times(r10).minus(1).sqrt().plus(r10), st = true, n10.precision = e10, n10.rounding = t10, r10.ln()) : new n10(r10);
};
ge.inverseHyperbolicSine = ge.asinh = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return !r10.isFinite() || r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + 2 * Math.max(Math.abs(r10.e), r10.sd()) + 6, n10.rounding = 1, st = false, r10 = r10.times(r10).plus(1).sqrt().plus(r10), st = true, n10.precision = e10, n10.rounding = t10, r10.ln());
};
ge.inverseHyperbolicTangent = ge.atanh = function() {
  var e10, t10, r10, n10, i10 = this, o10 = i10.constructor;
  return i10.isFinite() ? i10.e >= 0 ? new o10(i10.abs().eq(1) ? i10.s / 0 : i10.isZero() ? i10 : NaN) : (e10 = o10.precision, t10 = o10.rounding, n10 = i10.sd(), Math.max(n10, e10) < 2 * -i10.e - 1 ? He(new o10(i10), e10, t10, true) : (o10.precision = r10 = n10 - i10.e, i10 = Xt(i10.plus(1), new o10(1).minus(i10), r10 + e10, 1), o10.precision = e10 + 4, o10.rounding = 1, i10 = i10.ln(), o10.precision = e10, o10.rounding = t10, i10.times(0.5))) : new o10(NaN);
};
ge.inverseSine = ge.asin = function() {
  var e10, t10, r10, n10, i10 = this, o10 = i10.constructor;
  return i10.isZero() ? new o10(i10) : (t10 = i10.abs().cmp(1), r10 = o10.precision, n10 = o10.rounding, t10 !== -1 ? t10 === 0 ? (e10 = Zn(o10, r10 + 4, n10).times(0.5), e10.s = i10.s, e10) : new o10(NaN) : (o10.precision = r10 + 6, o10.rounding = 1, i10 = i10.div(new o10(1).minus(i10.times(i10)).sqrt().plus(1)).atan(), o10.precision = r10, o10.rounding = n10, i10.times(2)));
};
ge.inverseTangent = ge.atan = function() {
  var e10, t10, r10, n10, i10, o10, s10, a10, c, l10 = this, u10 = l10.constructor, d6 = u10.precision, p = u10.rounding;
  if (l10.isFinite()) {
    if (l10.isZero())
      return new u10(l10);
    if (l10.abs().eq(1) && d6 + 4 <= Gf)
      return s10 = Zn(u10, d6 + 4, p).times(0.25), s10.s = l10.s, s10;
  } else {
    if (!l10.s)
      return new u10(NaN);
    if (d6 + 4 <= Gf)
      return s10 = Zn(u10, d6 + 4, p).times(0.5), s10.s = l10.s, s10;
  }
  for (u10.precision = a10 = d6 + 10, u10.rounding = 1, r10 = Math.min(28, a10 / Ye + 2 | 0), e10 = r10; e10; --e10)
    l10 = l10.div(l10.times(l10).plus(1).sqrt().plus(1));
  for (st = false, t10 = Math.ceil(a10 / Ye), n10 = 1, c = l10.times(l10), s10 = new u10(l10), i10 = l10; e10 !== -1; )
    if (i10 = i10.times(c), o10 = s10.minus(i10.div(n10 += 2)), i10 = i10.times(c), s10 = o10.plus(i10.div(n10 += 2)), s10.d[t10] !== void 0)
      for (e10 = t10; s10.d[e10] === o10.d[e10] && e10--; )
        ;
  return r10 && (s10 = s10.times(2 << r10 - 1)), st = true, He(s10, u10.precision = d6, u10.rounding = p, true);
};
ge.isFinite = function() {
  return !!this.d;
};
ge.isInteger = ge.isInt = function() {
  return !!this.d && Fr(this.e / Ye) > this.d.length - 2;
};
ge.isNaN = function() {
  return !this.s;
};
ge.isNegative = ge.isNeg = function() {
  return this.s < 0;
};
ge.isPositive = ge.isPos = function() {
  return this.s > 0;
};
ge.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
ge.lessThan = ge.lt = function(e10) {
  return this.cmp(e10) < 0;
};
ge.lessThanOrEqualTo = ge.lte = function(e10) {
  return this.cmp(e10) < 1;
};
ge.logarithm = ge.log = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10 = this, u10 = l10.constructor, d6 = u10.precision, p = u10.rounding, y = 5;
  if (e10 == null)
    e10 = new u10(10), t10 = true;
  else {
    if (e10 = new u10(e10), r10 = e10.d, e10.s < 0 || !r10 || !r10[0] || e10.eq(1))
      return new u10(NaN);
    t10 = e10.eq(10);
  }
  if (r10 = l10.d, l10.s < 0 || !r10 || !r10[0] || l10.eq(1))
    return new u10(r10 && !r10[0] ? -1 / 0 : l10.s != 1 ? NaN : r10 ? 0 : 1 / 0);
  if (t10)
    if (r10.length > 1)
      o10 = true;
    else {
      for (i10 = r10[0]; i10 % 10 === 0; )
        i10 /= 10;
      o10 = i10 !== 1;
    }
  if (st = false, a10 = d6 + y, s10 = Xi(l10, a10), n10 = t10 ? Kc(u10, a10 + 10) : Xi(e10, a10), c = Xt(s10, n10, a10, 1), ba(c.d, i10 = d6, p))
    do
      if (a10 += 10, s10 = Xi(l10, a10), n10 = t10 ? Kc(u10, a10 + 10) : Xi(e10, a10), c = Xt(s10, n10, a10, 1), !o10) {
        +Nr(c.d).slice(i10 + 1, i10 + 15) + 1 == 1e14 && (c = He(c, d6 + 1, 0));
        break;
      }
    while (ba(c.d, i10 += 10, p));
  return st = true, He(c, d6, p);
};
ge.minus = ge.sub = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y = this, x = y.constructor;
  if (e10 = new x(e10), !y.d || !e10.d)
    return !y.s || !e10.s ? e10 = new x(NaN) : y.d ? e10.s = -e10.s : e10 = new x(e10.d || y.s !== e10.s ? y : NaN), e10;
  if (y.s != e10.s)
    return e10.s = -e10.s, y.plus(e10);
  if (l10 = y.d, p = e10.d, a10 = x.precision, c = x.rounding, !l10[0] || !p[0]) {
    if (p[0])
      e10.s = -e10.s;
    else if (l10[0])
      e10 = new x(y);
    else
      return new x(c === 3 ? -0 : 0);
    return st ? He(e10, a10, c) : e10;
  }
  if (r10 = Fr(e10.e / Ye), u10 = Fr(y.e / Ye), l10 = l10.slice(), o10 = u10 - r10, o10) {
    for (d6 = o10 < 0, d6 ? (t10 = l10, o10 = -o10, s10 = p.length) : (t10 = p, r10 = u10, s10 = l10.length), n10 = Math.max(Math.ceil(a10 / Ye), s10) + 2, o10 > n10 && (o10 = n10, t10.length = 1), t10.reverse(), n10 = o10; n10--; )
      t10.push(0);
    t10.reverse();
  } else {
    for (n10 = l10.length, s10 = p.length, d6 = n10 < s10, d6 && (s10 = n10), n10 = 0; n10 < s10; n10++)
      if (l10[n10] != p[n10]) {
        d6 = l10[n10] < p[n10];
        break;
      }
    o10 = 0;
  }
  for (d6 && (t10 = l10, l10 = p, p = t10, e10.s = -e10.s), s10 = l10.length, n10 = p.length - s10; n10 > 0; --n10)
    l10[s10++] = 0;
  for (n10 = p.length; n10 > o10; ) {
    if (l10[--n10] < p[n10]) {
      for (i10 = n10; i10 && l10[--i10] === 0; )
        l10[i10] = kn - 1;
      --l10[i10], l10[n10] += kn;
    }
    l10[n10] -= p[n10];
  }
  for (; l10[--s10] === 0; )
    l10.pop();
  for (; l10[0] === 0; l10.shift())
    --r10;
  return l10[0] ? (e10.d = l10, e10.e = Nl(l10, r10), st ? He(e10, a10, c) : e10) : new x(c === 3 ? -0 : 0);
};
ge.modulo = ge.mod = function(e10) {
  var t10, r10 = this, n10 = r10.constructor;
  return e10 = new n10(e10), !r10.d || !e10.s || e10.d && !e10.d[0] ? new n10(NaN) : !e10.d || r10.d && !r10.d[0] ? He(new n10(r10), n10.precision, n10.rounding) : (st = false, n10.modulo == 9 ? (t10 = Xt(r10, e10.abs(), 0, 3, 1), t10.s *= e10.s) : t10 = Xt(r10, e10, 0, n10.modulo, 1), t10 = t10.times(e10), st = true, r10.minus(t10));
};
ge.naturalExponential = ge.exp = function() {
  return Kf(this);
};
ge.naturalLogarithm = ge.ln = function() {
  return Xi(this);
};
ge.negated = ge.neg = function() {
  var e10 = new this.constructor(this);
  return e10.s = -e10.s, He(e10);
};
ge.plus = ge.add = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6 = this, p = d6.constructor;
  if (e10 = new p(e10), !d6.d || !e10.d)
    return !d6.s || !e10.s ? e10 = new p(NaN) : d6.d || (e10 = new p(e10.d || d6.s === e10.s ? d6 : NaN)), e10;
  if (d6.s != e10.s)
    return e10.s = -e10.s, d6.minus(e10);
  if (l10 = d6.d, u10 = e10.d, a10 = p.precision, c = p.rounding, !l10[0] || !u10[0])
    return u10[0] || (e10 = new p(d6)), st ? He(e10, a10, c) : e10;
  if (o10 = Fr(d6.e / Ye), n10 = Fr(e10.e / Ye), l10 = l10.slice(), i10 = o10 - n10, i10) {
    for (i10 < 0 ? (r10 = l10, i10 = -i10, s10 = u10.length) : (r10 = u10, n10 = o10, s10 = l10.length), o10 = Math.ceil(a10 / Ye), s10 = o10 > s10 ? o10 + 1 : s10 + 1, i10 > s10 && (i10 = s10, r10.length = 1), r10.reverse(); i10--; )
      r10.push(0);
    r10.reverse();
  }
  for (s10 = l10.length, i10 = u10.length, s10 - i10 < 0 && (i10 = s10, r10 = u10, u10 = l10, l10 = r10), t10 = 0; i10; )
    t10 = (l10[--i10] = l10[i10] + u10[i10] + t10) / kn | 0, l10[i10] %= kn;
  for (t10 && (l10.unshift(t10), ++n10), s10 = l10.length; l10[--s10] == 0; )
    l10.pop();
  return e10.d = l10, e10.e = Nl(l10, n10), st ? He(e10, a10, c) : e10;
};
ge.precision = ge.sd = function(e10) {
  var t10, r10 = this;
  if (e10 !== void 0 && e10 !== !!e10 && e10 !== 1 && e10 !== 0)
    throw Error(to + e10);
  return r10.d ? (t10 = mb(r10.d), e10 && r10.e + 1 > t10 && (t10 = r10.e + 1)) : t10 = NaN, t10;
};
ge.round = function() {
  var e10 = this, t10 = e10.constructor;
  return He(new t10(e10), e10.e + 1, t10.rounding);
};
ge.sine = ge.sin = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.isFinite() ? r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + Math.max(r10.e, r10.sd()) + Ye, n10.rounding = 1, r10 = EE(n10, yb(n10, r10)), n10.precision = e10, n10.rounding = t10, He(Ci > 2 ? r10.neg() : r10, e10, t10, true)) : new n10(NaN);
};
ge.squareRoot = ge.sqrt = function() {
  var e10, t10, r10, n10, i10, o10, s10 = this, a10 = s10.d, c = s10.e, l10 = s10.s, u10 = s10.constructor;
  if (l10 !== 1 || !a10 || !a10[0])
    return new u10(!l10 || l10 < 0 && (!a10 || a10[0]) ? NaN : a10 ? s10 : 1 / 0);
  for (st = false, l10 = Math.sqrt(+s10), l10 == 0 || l10 == 1 / 0 ? (t10 = Nr(a10), (t10.length + c) % 2 == 0 && (t10 += "0"), l10 = Math.sqrt(t10), c = Fr((c + 1) / 2) - (c < 0 || c % 2), l10 == 1 / 0 ? t10 = "5e" + c : (t10 = l10.toExponential(), t10 = t10.slice(0, t10.indexOf("e") + 1) + c), n10 = new u10(t10)) : n10 = new u10(l10.toString()), r10 = (c = u10.precision) + 3; ; )
    if (o10 = n10, n10 = o10.plus(Xt(s10, o10, r10 + 2, 1)).times(0.5), Nr(o10.d).slice(0, r10) === (t10 = Nr(n10.d)).slice(0, r10))
      if (t10 = t10.slice(r10 - 3, r10 + 1), t10 == "9999" || !i10 && t10 == "4999") {
        if (!i10 && (He(o10, c + 1, 0), o10.times(o10).eq(s10))) {
          n10 = o10;
          break;
        }
        r10 += 4, i10 = 1;
      } else {
        (!+t10 || !+t10.slice(1) && t10.charAt(0) == "5") && (He(n10, c + 1, 1), e10 = !n10.times(n10).eq(s10));
        break;
      }
  return st = true, He(n10, c, u10.rounding, e10);
};
ge.tangent = ge.tan = function() {
  var e10, t10, r10 = this, n10 = r10.constructor;
  return r10.isFinite() ? r10.isZero() ? new n10(r10) : (e10 = n10.precision, t10 = n10.rounding, n10.precision = e10 + 10, n10.rounding = 1, r10 = r10.sin(), r10.s = 1, r10 = Xt(r10, new n10(1).minus(r10.times(r10)).sqrt(), e10 + 10, 0), n10.precision = e10, n10.rounding = t10, He(Ci == 2 || Ci == 4 ? r10.neg() : r10, e10, t10, true)) : new n10(NaN);
};
ge.times = ge.mul = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10 = this, d6 = u10.constructor, p = u10.d, y = (e10 = new d6(e10)).d;
  if (e10.s *= u10.s, !p || !p[0] || !y || !y[0])
    return new d6(!e10.s || p && !p[0] && !y || y && !y[0] && !p ? NaN : !p || !y ? e10.s / 0 : e10.s * 0);
  for (r10 = Fr(u10.e / Ye) + Fr(e10.e / Ye), c = p.length, l10 = y.length, c < l10 && (o10 = p, p = y, y = o10, s10 = c, c = l10, l10 = s10), o10 = [], s10 = c + l10, n10 = s10; n10--; )
    o10.push(0);
  for (n10 = l10; --n10 >= 0; ) {
    for (t10 = 0, i10 = c + n10; i10 > n10; )
      a10 = o10[i10] + y[n10] * p[i10 - n10 - 1] + t10, o10[i10--] = a10 % kn | 0, t10 = a10 / kn | 0;
    o10[i10] = (o10[i10] + t10) % kn | 0;
  }
  for (; !o10[--s10]; )
    o10.pop();
  return t10 ? ++r10 : o10.shift(), e10.d = o10, e10.e = Nl(o10, r10), st ? He(e10, d6.precision, d6.rounding) : e10;
};
ge.toBinary = function(e10, t10) {
  return h0(this, 2, e10, t10);
};
ge.toDecimalPlaces = ge.toDP = function(e10, t10) {
  var r10 = this, n10 = r10.constructor;
  return r10 = new n10(r10), e10 === void 0 ? r10 : (Yr(e10, 0, co), t10 === void 0 ? t10 = n10.rounding : Yr(t10, 0, 8), He(r10, e10 + r10.e + 1, t10));
};
ge.toExponential = function(e10, t10) {
  var r10, n10 = this, i10 = n10.constructor;
  return e10 === void 0 ? r10 = ri(n10, true) : (Yr(e10, 0, co), t10 === void 0 ? t10 = i10.rounding : Yr(t10, 0, 8), n10 = He(new i10(n10), e10 + 1, t10), r10 = ri(n10, true, e10 + 1)), n10.isNeg() && !n10.isZero() ? "-" + r10 : r10;
};
ge.toFixed = function(e10, t10) {
  var r10, n10, i10 = this, o10 = i10.constructor;
  return e10 === void 0 ? r10 = ri(i10) : (Yr(e10, 0, co), t10 === void 0 ? t10 = o10.rounding : Yr(t10, 0, 8), n10 = He(new o10(i10), e10 + i10.e + 1, t10), r10 = ri(n10, false, e10 + n10.e + 1)), i10.isNeg() && !i10.isZero() ? "-" + r10 : r10;
};
ge.toFraction = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y = this, x = y.d, b = y.constructor;
  if (!x)
    return new b(y);
  if (l10 = r10 = new b(1), n10 = c = new b(0), t10 = new b(n10), o10 = t10.e = mb(x) - y.e - 1, s10 = o10 % Ye, t10.d[0] = yr(10, s10 < 0 ? Ye + s10 : s10), e10 == null)
    e10 = o10 > 0 ? t10 : l10;
  else {
    if (a10 = new b(e10), !a10.isInt() || a10.lt(l10))
      throw Error(to + a10);
    e10 = a10.gt(t10) ? o10 > 0 ? t10 : l10 : a10;
  }
  for (st = false, a10 = new b(Nr(x)), u10 = b.precision, b.precision = o10 = x.length * Ye * 2; d6 = Xt(a10, t10, 0, 1, 1), i10 = r10.plus(d6.times(n10)), i10.cmp(e10) != 1; )
    r10 = n10, n10 = i10, i10 = l10, l10 = c.plus(d6.times(i10)), c = i10, i10 = t10, t10 = a10.minus(d6.times(i10)), a10 = i10;
  return i10 = Xt(e10.minus(r10), n10, 0, 1, 1), c = c.plus(i10.times(l10)), r10 = r10.plus(i10.times(n10)), c.s = l10.s = y.s, p = Xt(l10, n10, o10, 1).minus(y).abs().cmp(Xt(c, r10, o10, 1).minus(y).abs()) < 1 ? [l10, n10] : [c, r10], b.precision = u10, st = true, p;
};
ge.toHexadecimal = ge.toHex = function(e10, t10) {
  return h0(this, 16, e10, t10);
};
ge.toNearest = function(e10, t10) {
  var r10 = this, n10 = r10.constructor;
  if (r10 = new n10(r10), e10 == null) {
    if (!r10.d)
      return r10;
    e10 = new n10(1), t10 = n10.rounding;
  } else {
    if (e10 = new n10(e10), t10 === void 0 ? t10 = n10.rounding : Yr(t10, 0, 8), !r10.d)
      return e10.s ? r10 : e10;
    if (!e10.d)
      return e10.s && (e10.s = r10.s), e10;
  }
  return e10.d[0] ? (st = false, r10 = Xt(r10, e10, 0, t10, 1).times(e10), st = true, He(r10)) : (e10.s = r10.s, r10 = e10), r10;
};
ge.toNumber = function() {
  return +this;
};
ge.toOctal = function(e10, t10) {
  return h0(this, 8, e10, t10);
};
ge.toPower = ge.pow = function(e10) {
  var t10, r10, n10, i10, o10, s10, a10 = this, c = a10.constructor, l10 = +(e10 = new c(e10));
  if (!a10.d || !e10.d || !a10.d[0] || !e10.d[0])
    return new c(yr(+a10, l10));
  if (a10 = new c(a10), a10.eq(1))
    return a10;
  if (n10 = c.precision, o10 = c.rounding, e10.eq(1))
    return He(a10, n10, o10);
  if (t10 = Fr(e10.e / Ye), t10 >= e10.d.length - 1 && (r10 = l10 < 0 ? -l10 : l10) <= wE)
    return i10 = gb(c, a10, r10, n10), e10.s < 0 ? new c(1).div(i10) : He(i10, n10, o10);
  if (s10 = a10.s, s10 < 0) {
    if (t10 < e10.d.length - 1)
      return new c(NaN);
    if (e10.d[t10] & 1 || (s10 = 1), a10.e == 0 && a10.d[0] == 1 && a10.d.length == 1)
      return a10.s = s10, a10;
  }
  return r10 = yr(+a10, l10), t10 = r10 == 0 || !isFinite(r10) ? Fr(l10 * (Math.log("0." + Nr(a10.d)) / Math.LN10 + a10.e + 1)) : new c(r10 + "").e, t10 > c.maxE + 1 || t10 < c.minE - 1 ? new c(t10 > 0 ? s10 / 0 : 0) : (st = false, c.rounding = a10.s = 1, r10 = Math.min(12, (t10 + "").length), i10 = Kf(e10.times(Xi(a10, n10 + r10)), n10), i10.d && (i10 = He(i10, n10 + 5, 1), ba(i10.d, n10, o10) && (t10 = n10 + 10, i10 = He(Kf(e10.times(Xi(a10, t10 + r10)), t10), t10 + 5, 1), +Nr(i10.d).slice(n10 + 1, n10 + 15) + 1 == 1e14 && (i10 = He(i10, n10 + 1, 0)))), i10.s = s10, st = true, c.rounding = o10, He(i10, n10, o10));
};
ge.toPrecision = function(e10, t10) {
  var r10, n10 = this, i10 = n10.constructor;
  return e10 === void 0 ? r10 = ri(n10, n10.e <= i10.toExpNeg || n10.e >= i10.toExpPos) : (Yr(e10, 1, co), t10 === void 0 ? t10 = i10.rounding : Yr(t10, 0, 8), n10 = He(new i10(n10), e10, t10), r10 = ri(n10, e10 <= n10.e || n10.e <= i10.toExpNeg, e10)), n10.isNeg() && !n10.isZero() ? "-" + r10 : r10;
};
ge.toSignificantDigits = ge.toSD = function(e10, t10) {
  var r10 = this, n10 = r10.constructor;
  return e10 === void 0 ? (e10 = n10.precision, t10 = n10.rounding) : (Yr(e10, 1, co), t10 === void 0 ? t10 = n10.rounding : Yr(t10, 0, 8)), He(new n10(r10), e10, t10);
};
ge.toString = function() {
  var e10 = this, t10 = e10.constructor, r10 = ri(e10, e10.e <= t10.toExpNeg || e10.e >= t10.toExpPos);
  return e10.isNeg() && !e10.isZero() ? "-" + r10 : r10;
};
ge.truncated = ge.trunc = function() {
  return He(new this.constructor(this), this.e + 1, 1);
};
ge.valueOf = ge.toJSON = function() {
  var e10 = this, t10 = e10.constructor, r10 = ri(e10, e10.e <= t10.toExpNeg || e10.e >= t10.toExpPos);
  return e10.isNeg() ? "-" + r10 : r10;
};
function Nr(e10) {
  var t10, r10, n10, i10 = e10.length - 1, o10 = "", s10 = e10[0];
  if (i10 > 0) {
    for (o10 += s10, t10 = 1; t10 < i10; t10++)
      n10 = e10[t10] + "", r10 = Ye - n10.length, r10 && (o10 += Hi(r10)), o10 += n10;
    s10 = e10[t10], n10 = s10 + "", r10 = Ye - n10.length, r10 && (o10 += Hi(r10));
  } else if (s10 === 0)
    return "0";
  for (; s10 % 10 === 0; )
    s10 /= 10;
  return o10 + s10;
}
function Yr(e10, t10, r10) {
  if (e10 !== ~~e10 || e10 < t10 || e10 > r10)
    throw Error(to + e10);
}
function ba(e10, t10, r10, n10) {
  var i10, o10, s10, a10;
  for (o10 = e10[0]; o10 >= 10; o10 /= 10)
    --t10;
  return --t10 < 0 ? (t10 += Ye, i10 = 0) : (i10 = Math.ceil((t10 + 1) / Ye), t10 %= Ye), o10 = yr(10, Ye - t10), a10 = e10[i10] % o10 | 0, n10 == null ? t10 < 3 ? (t10 == 0 ? a10 = a10 / 100 | 0 : t10 == 1 && (a10 = a10 / 10 | 0), s10 = r10 < 4 && a10 == 99999 || r10 > 3 && a10 == 49999 || a10 == 5e4 || a10 == 0) : s10 = (r10 < 4 && a10 + 1 == o10 || r10 > 3 && a10 + 1 == o10 / 2) && (e10[i10 + 1] / o10 / 100 | 0) == yr(10, t10 - 2) - 1 || (a10 == o10 / 2 || a10 == 0) && (e10[i10 + 1] / o10 / 100 | 0) == 0 : t10 < 4 ? (t10 == 0 ? a10 = a10 / 1e3 | 0 : t10 == 1 ? a10 = a10 / 100 | 0 : t10 == 2 && (a10 = a10 / 10 | 0), s10 = (n10 || r10 < 4) && a10 == 9999 || !n10 && r10 > 3 && a10 == 4999) : s10 = ((n10 || r10 < 4) && a10 + 1 == o10 || !n10 && r10 > 3 && a10 + 1 == o10 / 2) && (e10[i10 + 1] / o10 / 1e3 | 0) == yr(10, t10 - 3) - 1, s10;
}
function xc(e10, t10, r10) {
  for (var n10, i10 = [0], o10, s10 = 0, a10 = e10.length; s10 < a10; ) {
    for (o10 = i10.length; o10--; )
      i10[o10] *= t10;
    for (i10[0] += Hf.indexOf(e10.charAt(s10++)), n10 = 0; n10 < i10.length; n10++)
      i10[n10] > r10 - 1 && (i10[n10 + 1] === void 0 && (i10[n10 + 1] = 0), i10[n10 + 1] += i10[n10] / r10 | 0, i10[n10] %= r10);
  }
  return i10.reverse();
}
function SE(e10, t10) {
  var r10, n10, i10;
  if (t10.isZero())
    return t10;
  n10 = t10.d.length, n10 < 32 ? (r10 = Math.ceil(n10 / 3), i10 = (1 / jl(4, r10)).toString()) : (r10 = 16, i10 = "2.3283064365386962890625e-10"), e10.precision += r10, t10 = xs(e10, 1, t10.times(i10), new e10(1));
  for (var o10 = r10; o10--; ) {
    var s10 = t10.times(t10);
    t10 = s10.times(s10).minus(s10).times(8).plus(1);
  }
  return e10.precision -= r10, t10;
}
var Xt = /* @__PURE__ */ function() {
  function e10(n10, i10, o10) {
    var s10, a10 = 0, c = n10.length;
    for (n10 = n10.slice(); c--; )
      s10 = n10[c] * i10 + a10, n10[c] = s10 % o10 | 0, a10 = s10 / o10 | 0;
    return a10 && n10.unshift(a10), n10;
  }
  function t10(n10, i10, o10, s10) {
    var a10, c;
    if (o10 != s10)
      c = o10 > s10 ? 1 : -1;
    else
      for (a10 = c = 0; a10 < o10; a10++)
        if (n10[a10] != i10[a10]) {
          c = n10[a10] > i10[a10] ? 1 : -1;
          break;
        }
    return c;
  }
  function r10(n10, i10, o10, s10) {
    for (var a10 = 0; o10--; )
      n10[o10] -= a10, a10 = n10[o10] < i10[o10] ? 1 : 0, n10[o10] = a10 * s10 + n10[o10] - i10[o10];
    for (; !n10[0] && n10.length > 1; )
      n10.shift();
  }
  return function(n10, i10, o10, s10, a10, c) {
    var l10, u10, d6, p, y, x, b, M, O, P, j, F, B, W, z, G, re, ie, oe, q, L = n10.constructor, h = n10.s == i10.s ? 1 : -1, f = n10.d, m = i10.d;
    if (!f || !f[0] || !m || !m[0])
      return new L(
        // Return NaN if either NaN, or both Infinity or 0.
        !n10.s || !i10.s || (f ? m && f[0] == m[0] : !m) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          f && f[0] == 0 || !m ? h * 0 : h / 0
        )
      );
    for (c ? (y = 1, u10 = n10.e - i10.e) : (c = kn, y = Ye, u10 = Fr(n10.e / y) - Fr(i10.e / y)), oe = m.length, re = f.length, O = new L(h), P = O.d = [], d6 = 0; m[d6] == (f[d6] || 0); d6++)
      ;
    if (m[d6] > (f[d6] || 0) && u10--, o10 == null ? (W = o10 = L.precision, s10 = L.rounding) : a10 ? W = o10 + (n10.e - i10.e) + 1 : W = o10, W < 0)
      P.push(1), x = true;
    else {
      if (W = W / y + 2 | 0, d6 = 0, oe == 1) {
        for (p = 0, m = m[0], W++; (d6 < re || p) && W--; d6++)
          z = p * c + (f[d6] || 0), P[d6] = z / m | 0, p = z % m | 0;
        x = p || d6 < re;
      } else {
        for (p = c / (m[0] + 1) | 0, p > 1 && (m = e10(m, p, c), f = e10(f, p, c), oe = m.length, re = f.length), G = oe, j = f.slice(0, oe), F = j.length; F < oe; )
          j[F++] = 0;
        q = m.slice(), q.unshift(0), ie = m[0], m[1] >= c / 2 && ++ie;
        do
          p = 0, l10 = t10(m, j, oe, F), l10 < 0 ? (B = j[0], oe != F && (B = B * c + (j[1] || 0)), p = B / ie | 0, p > 1 ? (p >= c && (p = c - 1), b = e10(m, p, c), M = b.length, F = j.length, l10 = t10(b, j, M, F), l10 == 1 && (p--, r10(b, oe < M ? q : m, M, c))) : (p == 0 && (l10 = p = 1), b = m.slice()), M = b.length, M < F && b.unshift(0), r10(j, b, F, c), l10 == -1 && (F = j.length, l10 = t10(m, j, oe, F), l10 < 1 && (p++, r10(j, oe < F ? q : m, F, c))), F = j.length) : l10 === 0 && (p++, j = [0]), P[d6++] = p, l10 && j[0] ? j[F++] = f[G] || 0 : (j = [f[G]], F = 1);
        while ((G++ < re || j[0] !== void 0) && W--);
        x = j[0] !== void 0;
      }
      P[0] || P.shift();
    }
    if (y == 1)
      O.e = u10, ub = x;
    else {
      for (d6 = 1, p = P[0]; p >= 10; p /= 10)
        d6++;
      O.e = d6 + u10 * y - 1, He(O, a10 ? o10 + O.e + 1 : o10, s10, x);
    }
    return O;
  };
}();
function He(e10, t10, r10, n10) {
  var i10, o10, s10, a10, c, l10, u10, d6, p, y = e10.constructor;
  e:
    if (t10 != null) {
      if (d6 = e10.d, !d6)
        return e10;
      for (i10 = 1, a10 = d6[0]; a10 >= 10; a10 /= 10)
        i10++;
      if (o10 = t10 - i10, o10 < 0)
        o10 += Ye, s10 = t10, u10 = d6[p = 0], c = u10 / yr(10, i10 - s10 - 1) % 10 | 0;
      else if (p = Math.ceil((o10 + 1) / Ye), a10 = d6.length, p >= a10)
        if (n10) {
          for (; a10++ <= p; )
            d6.push(0);
          u10 = c = 0, i10 = 1, o10 %= Ye, s10 = o10 - Ye + 1;
        } else
          break e;
      else {
        for (u10 = a10 = d6[p], i10 = 1; a10 >= 10; a10 /= 10)
          i10++;
        o10 %= Ye, s10 = o10 - Ye + i10, c = s10 < 0 ? 0 : u10 / yr(10, i10 - s10 - 1) % 10 | 0;
      }
      if (n10 = n10 || t10 < 0 || d6[p + 1] !== void 0 || (s10 < 0 ? u10 : u10 % yr(10, i10 - s10 - 1)), l10 = r10 < 4 ? (c || n10) && (r10 == 0 || r10 == (e10.s < 0 ? 3 : 2)) : c > 5 || c == 5 && (r10 == 4 || n10 || r10 == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (o10 > 0 ? s10 > 0 ? u10 / yr(10, i10 - s10) : 0 : d6[p - 1]) % 10 & 1 || r10 == (e10.s < 0 ? 8 : 7)), t10 < 1 || !d6[0])
        return d6.length = 0, l10 ? (t10 -= e10.e + 1, d6[0] = yr(10, (Ye - t10 % Ye) % Ye), e10.e = -t10 || 0) : d6[0] = e10.e = 0, e10;
      if (o10 == 0 ? (d6.length = p, a10 = 1, p--) : (d6.length = p + 1, a10 = yr(10, Ye - o10), d6[p] = s10 > 0 ? (u10 / yr(10, i10 - s10) % yr(10, s10) | 0) * a10 : 0), l10)
        for (; ; )
          if (p == 0) {
            for (o10 = 1, s10 = d6[0]; s10 >= 10; s10 /= 10)
              o10++;
            for (s10 = d6[0] += a10, a10 = 1; s10 >= 10; s10 /= 10)
              a10++;
            o10 != a10 && (e10.e++, d6[0] == kn && (d6[0] = 1));
            break;
          } else {
            if (d6[p] += a10, d6[p] != kn)
              break;
            d6[p--] = 0, a10 = 1;
          }
      for (o10 = d6.length; d6[--o10] === 0; )
        d6.pop();
    }
  return st && (e10.e > y.maxE ? (e10.d = null, e10.e = NaN) : e10.e < y.minE && (e10.e = 0, e10.d = [0])), e10;
}
function ri(e10, t10, r10) {
  if (!e10.isFinite())
    return bb(e10);
  var n10, i10 = e10.e, o10 = Nr(e10.d), s10 = o10.length;
  return t10 ? (r10 && (n10 = r10 - s10) > 0 ? o10 = o10.charAt(0) + "." + o10.slice(1) + Hi(n10) : s10 > 1 && (o10 = o10.charAt(0) + "." + o10.slice(1)), o10 = o10 + (e10.e < 0 ? "e" : "e+") + e10.e) : i10 < 0 ? (o10 = "0." + Hi(-i10 - 1) + o10, r10 && (n10 = r10 - s10) > 0 && (o10 += Hi(n10))) : i10 >= s10 ? (o10 += Hi(i10 + 1 - s10), r10 && (n10 = r10 - i10 - 1) > 0 && (o10 = o10 + "." + Hi(n10))) : ((n10 = i10 + 1) < s10 && (o10 = o10.slice(0, n10) + "." + o10.slice(n10)), r10 && (n10 = r10 - s10) > 0 && (i10 + 1 === s10 && (o10 += "."), o10 += Hi(n10))), o10;
}
function Nl(e10, t10) {
  var r10 = e10[0];
  for (t10 *= Ye; r10 >= 10; r10 /= 10)
    t10++;
  return t10;
}
function Kc(e10, t10, r10) {
  if (t10 > xE)
    throw st = true, r10 && (e10.precision = r10), Error(fb);
  return He(new e10(Wc), t10, 1, true);
}
function Zn(e10, t10, r10) {
  if (t10 > Gf)
    throw Error(fb);
  return He(new e10(Gc), t10, r10, true);
}
function mb(e10) {
  var t10 = e10.length - 1, r10 = t10 * Ye + 1;
  if (t10 = e10[t10], t10) {
    for (; t10 % 10 == 0; t10 /= 10)
      r10--;
    for (t10 = e10[0]; t10 >= 10; t10 /= 10)
      r10++;
  }
  return r10;
}
function Hi(e10) {
  for (var t10 = ""; e10--; )
    t10 += "0";
  return t10;
}
function gb(e10, t10, r10, n10) {
  var i10, o10 = new e10(1), s10 = Math.ceil(n10 / Ye + 4);
  for (st = false; ; ) {
    if (r10 % 2 && (o10 = o10.times(t10), mp(o10.d, s10) && (i10 = true)), r10 = Fr(r10 / 2), r10 === 0) {
      r10 = o10.d.length - 1, i10 && o10.d[r10] === 0 && ++o10.d[r10];
      break;
    }
    t10 = t10.times(t10), mp(t10.d, s10);
  }
  return st = true, o10;
}
function pp(e10) {
  return e10.d[e10.d.length - 1] & 1;
}
function vb(e10, t10, r10) {
  for (var n10, i10, o10 = new e10(t10[0]), s10 = 0; ++s10 < t10.length; ) {
    if (i10 = new e10(t10[s10]), !i10.s) {
      o10 = i10;
      break;
    }
    n10 = o10.cmp(i10), (n10 === r10 || n10 === 0 && o10.s === r10) && (o10 = i10);
  }
  return o10;
}
function Kf(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c, l10 = 0, u10 = 0, d6 = 0, p = e10.constructor, y = p.rounding, x = p.precision;
  if (!e10.d || !e10.d[0] || e10.e > 17)
    return new p(e10.d ? e10.d[0] ? e10.s < 0 ? 0 : 1 / 0 : 1 : e10.s ? e10.s < 0 ? 0 : e10 : 0 / 0);
  for (t10 == null ? (st = false, c = x) : c = t10, a10 = new p(0.03125); e10.e > -2; )
    e10 = e10.times(a10), d6 += 5;
  for (n10 = Math.log(yr(2, d6)) / Math.LN10 * 2 + 5 | 0, c += n10, r10 = o10 = s10 = new p(1), p.precision = c; ; ) {
    if (o10 = He(o10.times(e10), c, 1), r10 = r10.times(++u10), a10 = s10.plus(Xt(o10, r10, c, 1)), Nr(a10.d).slice(0, c) === Nr(s10.d).slice(0, c)) {
      for (i10 = d6; i10--; )
        s10 = He(s10.times(s10), c, 1);
      if (t10 == null)
        if (l10 < 3 && ba(s10.d, c - n10, y, l10))
          p.precision = c += 10, r10 = o10 = a10 = new p(1), u10 = 0, l10++;
        else
          return He(s10, p.precision = x, y, st = true);
      else
        return p.precision = x, s10;
    }
    s10 = a10;
  }
}
function Xi(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c, l10, u10, d6, p, y = 1, x = 10, b = e10, M = b.d, O = b.constructor, P = O.rounding, j = O.precision;
  if (b.s < 0 || !M || !M[0] || !b.e && M[0] == 1 && M.length == 1)
    return new O(M && !M[0] ? -1 / 0 : b.s != 1 ? NaN : M ? 0 : b);
  if (t10 == null ? (st = false, u10 = j) : u10 = t10, O.precision = u10 += x, r10 = Nr(M), n10 = r10.charAt(0), Math.abs(o10 = b.e) < 15e14) {
    for (; n10 < 7 && n10 != 1 || n10 == 1 && r10.charAt(1) > 3; )
      b = b.times(e10), r10 = Nr(b.d), n10 = r10.charAt(0), y++;
    o10 = b.e, n10 > 1 ? (b = new O("0." + r10), o10++) : b = new O(n10 + "." + r10.slice(1));
  } else
    return l10 = Kc(O, u10 + 2, j).times(o10 + ""), b = Xi(new O(n10 + "." + r10.slice(1)), u10 - x).plus(l10), O.precision = j, t10 == null ? He(b, j, P, st = true) : b;
  for (d6 = b, c = s10 = b = Xt(b.minus(1), b.plus(1), u10, 1), p = He(b.times(b), u10, 1), i10 = 3; ; ) {
    if (s10 = He(s10.times(p), u10, 1), l10 = c.plus(Xt(s10, new O(i10), u10, 1)), Nr(l10.d).slice(0, u10) === Nr(c.d).slice(0, u10))
      if (c = c.times(2), o10 !== 0 && (c = c.plus(Kc(O, u10 + 2, j).times(o10 + ""))), c = Xt(c, new O(y), u10, 1), t10 == null)
        if (ba(c.d, u10 - x, P, a10))
          O.precision = u10 += x, l10 = s10 = b = Xt(d6.minus(1), d6.plus(1), u10, 1), p = He(b.times(b), u10, 1), i10 = a10 = 1;
        else
          return He(c, O.precision = j, P, st = true);
      else
        return O.precision = j, c;
    c = l10, i10 += 2;
  }
}
function bb(e10) {
  return String(e10.s * e10.s / 0);
}
function Sc(e10, t10) {
  var r10, n10, i10;
  for ((r10 = t10.indexOf(".")) > -1 && (t10 = t10.replace(".", "")), (n10 = t10.search(/e/i)) > 0 ? (r10 < 0 && (r10 = n10), r10 += +t10.slice(n10 + 1), t10 = t10.substring(0, n10)) : r10 < 0 && (r10 = t10.length), n10 = 0; t10.charCodeAt(n10) === 48; n10++)
    ;
  for (i10 = t10.length; t10.charCodeAt(i10 - 1) === 48; --i10)
    ;
  if (t10 = t10.slice(n10, i10), t10) {
    if (i10 -= n10, e10.e = r10 = r10 - n10 - 1, e10.d = [], n10 = (r10 + 1) % Ye, r10 < 0 && (n10 += Ye), n10 < i10) {
      for (n10 && e10.d.push(+t10.slice(0, n10)), i10 -= Ye; n10 < i10; )
        e10.d.push(+t10.slice(n10, n10 += Ye));
      t10 = t10.slice(n10), n10 = Ye - t10.length;
    } else
      n10 -= i10;
    for (; n10--; )
      t10 += "0";
    e10.d.push(+t10), st && (e10.e > e10.constructor.maxE ? (e10.d = null, e10.e = NaN) : e10.e < e10.constructor.minE && (e10.e = 0, e10.d = [0]));
  } else
    e10.e = 0, e10.d = [0];
  return e10;
}
function _E(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c, l10, u10;
  if (t10.indexOf("_") > -1) {
    if (t10 = t10.replace(/(\d)_(?=\d)/g, "$1"), pb.test(t10))
      return Sc(e10, t10);
  } else if (t10 === "Infinity" || t10 === "NaN")
    return +t10 || (e10.s = NaN), e10.e = NaN, e10.d = null, e10;
  if (bE.test(t10))
    r10 = 16, t10 = t10.toLowerCase();
  else if (vE.test(t10))
    r10 = 2;
  else if (yE.test(t10))
    r10 = 8;
  else
    throw Error(to + t10);
  for (o10 = t10.search(/p/i), o10 > 0 ? (c = +t10.slice(o10 + 1), t10 = t10.substring(2, o10)) : t10 = t10.slice(2), o10 = t10.indexOf("."), s10 = o10 >= 0, n10 = e10.constructor, s10 && (t10 = t10.replace(".", ""), a10 = t10.length, o10 = a10 - o10, i10 = gb(n10, new n10(r10), o10, o10 * 2)), l10 = xc(t10, r10, kn), u10 = l10.length - 1, o10 = u10; l10[o10] === 0; --o10)
    l10.pop();
  return o10 < 0 ? new n10(e10.s * 0) : (e10.e = Nl(l10, u10), e10.d = l10, st = false, s10 && (e10 = Xt(e10, i10, a10 * 4)), c && (e10 = e10.times(Math.abs(c) < 54 ? yr(2, c) : qr.pow(2, c))), st = true, e10);
}
function EE(e10, t10) {
  var r10, n10 = t10.d.length;
  if (n10 < 3)
    return t10.isZero() ? t10 : xs(e10, 2, t10, t10);
  r10 = 1.4 * Math.sqrt(n10), r10 = r10 > 16 ? 16 : r10 | 0, t10 = t10.times(1 / jl(5, r10)), t10 = xs(e10, 2, t10, t10);
  for (var i10, o10 = new e10(5), s10 = new e10(16), a10 = new e10(20); r10--; )
    i10 = t10.times(t10), t10 = t10.times(o10.plus(i10.times(s10.times(i10).minus(a10))));
  return t10;
}
function xs(e10, t10, r10, n10, i10) {
  var o10, s10, a10, c, l10 = e10.precision, u10 = Math.ceil(l10 / Ye);
  for (st = false, c = r10.times(r10), a10 = new e10(n10); ; ) {
    if (s10 = Xt(a10.times(c), new e10(t10++ * t10++), l10, 1), a10 = i10 ? n10.plus(s10) : n10.minus(s10), n10 = Xt(s10.times(c), new e10(t10++ * t10++), l10, 1), s10 = a10.plus(n10), s10.d[u10] !== void 0) {
      for (o10 = u10; s10.d[o10] === a10.d[o10] && o10--; )
        ;
      if (o10 == -1)
        break;
    }
    o10 = a10, a10 = n10, n10 = s10, s10 = o10;
  }
  return st = true, s10.d.length = u10 + 1, s10;
}
function jl(e10, t10) {
  for (var r10 = e10; --t10; )
    r10 *= e10;
  return r10;
}
function yb(e10, t10) {
  var r10, n10 = t10.s < 0, i10 = Zn(e10, e10.precision, 1), o10 = i10.times(0.5);
  if (t10 = t10.abs(), t10.lte(o10))
    return Ci = n10 ? 4 : 1, t10;
  if (r10 = t10.divToInt(i10), r10.isZero())
    Ci = n10 ? 3 : 2;
  else {
    if (t10 = t10.minus(r10.times(i10)), t10.lte(o10))
      return Ci = pp(r10) ? n10 ? 2 : 3 : n10 ? 4 : 1, t10;
    Ci = pp(r10) ? n10 ? 1 : 4 : n10 ? 3 : 2;
  }
  return t10.minus(i10).abs();
}
function h0(e10, t10, r10, n10) {
  var i10, o10, s10, a10, c, l10, u10, d6, p, y = e10.constructor, x = r10 !== void 0;
  if (x ? (Yr(r10, 1, co), n10 === void 0 ? n10 = y.rounding : Yr(n10, 0, 8)) : (r10 = y.precision, n10 = y.rounding), !e10.isFinite())
    u10 = bb(e10);
  else {
    for (u10 = ri(e10), s10 = u10.indexOf("."), x ? (i10 = 2, t10 == 16 ? r10 = r10 * 4 - 3 : t10 == 8 && (r10 = r10 * 3 - 2)) : i10 = t10, s10 >= 0 && (u10 = u10.replace(".", ""), p = new y(1), p.e = u10.length - s10, p.d = xc(ri(p), 10, i10), p.e = p.d.length), d6 = xc(u10, 10, i10), o10 = c = d6.length; d6[--c] == 0; )
      d6.pop();
    if (!d6[0])
      u10 = x ? "0p+0" : "0";
    else {
      if (s10 < 0 ? o10-- : (e10 = new y(e10), e10.d = d6, e10.e = o10, e10 = Xt(e10, p, r10, n10, 0, i10), d6 = e10.d, o10 = e10.e, l10 = ub), s10 = d6[r10], a10 = i10 / 2, l10 = l10 || d6[r10 + 1] !== void 0, l10 = n10 < 4 ? (s10 !== void 0 || l10) && (n10 === 0 || n10 === (e10.s < 0 ? 3 : 2)) : s10 > a10 || s10 === a10 && (n10 === 4 || l10 || n10 === 6 && d6[r10 - 1] & 1 || n10 === (e10.s < 0 ? 8 : 7)), d6.length = r10, l10)
        for (; ++d6[--r10] > i10 - 1; )
          d6[r10] = 0, r10 || (++o10, d6.unshift(1));
      for (c = d6.length; !d6[c - 1]; --c)
        ;
      for (s10 = 0, u10 = ""; s10 < c; s10++)
        u10 += Hf.charAt(d6[s10]);
      if (x) {
        if (c > 1)
          if (t10 == 16 || t10 == 8) {
            for (s10 = t10 == 16 ? 4 : 3, --c; c % s10; c++)
              u10 += "0";
            for (d6 = xc(u10, i10, t10), c = d6.length; !d6[c - 1]; --c)
              ;
            for (s10 = 1, u10 = "1."; s10 < c; s10++)
              u10 += Hf.charAt(d6[s10]);
          } else
            u10 = u10.charAt(0) + "." + u10.slice(1);
        u10 = u10 + (o10 < 0 ? "p" : "p+") + o10;
      } else if (o10 < 0) {
        for (; ++o10; )
          u10 = "0" + u10;
        u10 = "0." + u10;
      } else if (++o10 > c)
        for (o10 -= c; o10--; )
          u10 += "0";
      else
        o10 < c && (u10 = u10.slice(0, o10) + "." + u10.slice(o10));
    }
    u10 = (t10 == 16 ? "0x" : t10 == 2 ? "0b" : t10 == 8 ? "0o" : "") + u10;
  }
  return e10.s < 0 ? "-" + u10 : u10;
}
function mp(e10, t10) {
  if (e10.length > t10)
    return e10.length = t10, true;
}
function CE(e10) {
  return new this(e10).abs();
}
function TE(e10) {
  return new this(e10).acos();
}
function AE(e10) {
  return new this(e10).acosh();
}
function ME(e10, t10) {
  return new this(e10).plus(t10);
}
function IE(e10) {
  return new this(e10).asin();
}
function OE(e10) {
  return new this(e10).asinh();
}
function RE(e10) {
  return new this(e10).atan();
}
function PE(e10) {
  return new this(e10).atanh();
}
function NE(e10, t10) {
  e10 = new this(e10), t10 = new this(t10);
  var r10, n10 = this.precision, i10 = this.rounding, o10 = n10 + 4;
  return !e10.s || !t10.s ? r10 = new this(NaN) : !e10.d && !t10.d ? (r10 = Zn(this, o10, 1).times(t10.s > 0 ? 0.25 : 0.75), r10.s = e10.s) : !t10.d || e10.isZero() ? (r10 = t10.s < 0 ? Zn(this, n10, i10) : new this(0), r10.s = e10.s) : !e10.d || t10.isZero() ? (r10 = Zn(this, o10, 1).times(0.5), r10.s = e10.s) : t10.s < 0 ? (this.precision = o10, this.rounding = 1, r10 = this.atan(Xt(e10, t10, o10, 1)), t10 = Zn(this, o10, 1), this.precision = n10, this.rounding = i10, r10 = e10.s < 0 ? r10.minus(t10) : r10.plus(t10)) : r10 = this.atan(Xt(e10, t10, o10, 1)), r10;
}
function jE(e10) {
  return new this(e10).cbrt();
}
function kE(e10) {
  return He(e10 = new this(e10), e10.e + 1, 2);
}
function DE(e10, t10, r10) {
  return new this(e10).clamp(t10, r10);
}
function LE(e10) {
  if (!e10 || typeof e10 != "object")
    throw Error(Pl + "Object expected");
  var t10, r10, n10, i10 = e10.defaults === true, o10 = [
    "precision",
    1,
    co,
    "rounding",
    0,
    8,
    "toExpNeg",
    -ls,
    0,
    "toExpPos",
    0,
    ls,
    "maxE",
    0,
    ls,
    "minE",
    -ls,
    0,
    "modulo",
    0,
    9
  ];
  for (t10 = 0; t10 < o10.length; t10 += 3)
    if (r10 = o10[t10], i10 && (this[r10] = Wf[r10]), (n10 = e10[r10]) !== void 0)
      if (Fr(n10) === n10 && n10 >= o10[t10 + 1] && n10 <= o10[t10 + 2])
        this[r10] = n10;
      else
        throw Error(to + r10 + ": " + n10);
  if (r10 = "crypto", i10 && (this[r10] = Wf[r10]), (n10 = e10[r10]) !== void 0)
    if (n10 === true || n10 === false || n10 === 0 || n10 === 1)
      if (n10)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r10] = true;
        else
          throw Error(db);
      else
        this[r10] = false;
    else
      throw Error(to + r10 + ": " + n10);
  return this;
}
function BE(e10) {
  return new this(e10).cos();
}
function UE(e10) {
  return new this(e10).cosh();
}
function wb(e10) {
  var t10, r10, n10;
  function i10(o10) {
    var s10, a10, c, l10 = this;
    if (!(l10 instanceof i10))
      return new i10(o10);
    if (l10.constructor = i10, gp(o10)) {
      l10.s = o10.s, st ? !o10.d || o10.e > i10.maxE ? (l10.e = NaN, l10.d = null) : o10.e < i10.minE ? (l10.e = 0, l10.d = [0]) : (l10.e = o10.e, l10.d = o10.d.slice()) : (l10.e = o10.e, l10.d = o10.d ? o10.d.slice() : o10.d);
      return;
    }
    if (c = typeof o10, c === "number") {
      if (o10 === 0) {
        l10.s = 1 / o10 < 0 ? -1 : 1, l10.e = 0, l10.d = [0];
        return;
      }
      if (o10 < 0 ? (o10 = -o10, l10.s = -1) : l10.s = 1, o10 === ~~o10 && o10 < 1e7) {
        for (s10 = 0, a10 = o10; a10 >= 10; a10 /= 10)
          s10++;
        st ? s10 > i10.maxE ? (l10.e = NaN, l10.d = null) : s10 < i10.minE ? (l10.e = 0, l10.d = [0]) : (l10.e = s10, l10.d = [o10]) : (l10.e = s10, l10.d = [o10]);
        return;
      }
      if (o10 * 0 !== 0) {
        o10 || (l10.s = NaN), l10.e = NaN, l10.d = null;
        return;
      }
      return Sc(l10, o10.toString());
    }
    if (c === "string")
      return (a10 = o10.charCodeAt(0)) === 45 ? (o10 = o10.slice(1), l10.s = -1) : (a10 === 43 && (o10 = o10.slice(1)), l10.s = 1), pb.test(o10) ? Sc(l10, o10) : _E(l10, o10);
    if (c === "bigint")
      return o10 < 0 ? (o10 = -o10, l10.s = -1) : l10.s = 1, Sc(l10, o10.toString());
    throw Error(to + o10);
  }
  if (i10.prototype = ge, i10.ROUND_UP = 0, i10.ROUND_DOWN = 1, i10.ROUND_CEIL = 2, i10.ROUND_FLOOR = 3, i10.ROUND_HALF_UP = 4, i10.ROUND_HALF_DOWN = 5, i10.ROUND_HALF_EVEN = 6, i10.ROUND_HALF_CEIL = 7, i10.ROUND_HALF_FLOOR = 8, i10.EUCLID = 9, i10.config = i10.set = LE, i10.clone = wb, i10.isDecimal = gp, i10.abs = CE, i10.acos = TE, i10.acosh = AE, i10.add = ME, i10.asin = IE, i10.asinh = OE, i10.atan = RE, i10.atanh = PE, i10.atan2 = NE, i10.cbrt = jE, i10.ceil = kE, i10.clamp = DE, i10.cos = BE, i10.cosh = UE, i10.div = FE, i10.exp = $E, i10.floor = VE, i10.hypot = zE, i10.ln = qE, i10.log = HE, i10.log10 = GE, i10.log2 = WE, i10.max = KE, i10.min = YE, i10.mod = XE, i10.mul = JE, i10.pow = ZE, i10.random = QE, i10.round = eC, i10.sign = tC, i10.sin = rC, i10.sinh = nC, i10.sqrt = iC, i10.sub = oC, i10.sum = sC, i10.tan = aC, i10.tanh = cC, i10.trunc = lC, e10 === void 0 && (e10 = {}), e10 && e10.defaults !== true)
    for (n10 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t10 = 0; t10 < n10.length; )
      e10.hasOwnProperty(r10 = n10[t10++]) || (e10[r10] = this[r10]);
  return i10.config(e10), i10;
}
function FE(e10, t10) {
  return new this(e10).div(t10);
}
function $E(e10) {
  return new this(e10).exp();
}
function VE(e10) {
  return He(e10 = new this(e10), e10.e + 1, 3);
}
function zE() {
  var e10, t10, r10 = new this(0);
  for (st = false, e10 = 0; e10 < arguments.length; )
    if (t10 = new this(arguments[e10++]), t10.d)
      r10.d && (r10 = r10.plus(t10.times(t10)));
    else {
      if (t10.s)
        return st = true, new this(1 / 0);
      r10 = t10;
    }
  return st = true, r10.sqrt();
}
function gp(e10) {
  return e10 instanceof qr || e10 && e10.toStringTag === hb || false;
}
function qE(e10) {
  return new this(e10).ln();
}
function HE(e10, t10) {
  return new this(e10).log(t10);
}
function WE(e10) {
  return new this(e10).log(2);
}
function GE(e10) {
  return new this(e10).log(10);
}
function KE() {
  return vb(this, arguments, -1);
}
function YE() {
  return vb(this, arguments, 1);
}
function XE(e10, t10) {
  return new this(e10).mod(t10);
}
function JE(e10, t10) {
  return new this(e10).mul(t10);
}
function ZE(e10, t10) {
  return new this(e10).pow(t10);
}
function QE(e10) {
  var t10, r10, n10, i10, o10 = 0, s10 = new this(1), a10 = [];
  if (e10 === void 0 ? e10 = this.precision : Yr(e10, 1, co), n10 = Math.ceil(e10 / Ye), this.crypto)
    if (crypto.getRandomValues)
      for (t10 = crypto.getRandomValues(new Uint32Array(n10)); o10 < n10; )
        i10 = t10[o10], i10 >= 429e7 ? t10[o10] = crypto.getRandomValues(new Uint32Array(1))[0] : a10[o10++] = i10 % 1e7;
    else if (crypto.randomBytes) {
      for (t10 = crypto.randomBytes(n10 *= 4); o10 < n10; )
        i10 = t10[o10] + (t10[o10 + 1] << 8) + (t10[o10 + 2] << 16) + ((t10[o10 + 3] & 127) << 24), i10 >= 214e7 ? crypto.randomBytes(4).copy(t10, o10) : (a10.push(i10 % 1e7), o10 += 4);
      o10 = n10 / 4;
    } else
      throw Error(db);
  else
    for (; o10 < n10; )
      a10[o10++] = Math.random() * 1e7 | 0;
  for (n10 = a10[--o10], e10 %= Ye, n10 && e10 && (i10 = yr(10, Ye - e10), a10[o10] = (n10 / i10 | 0) * i10); a10[o10] === 0; o10--)
    a10.pop();
  if (o10 < 0)
    r10 = 0, a10 = [0];
  else {
    for (r10 = -1; a10[0] === 0; r10 -= Ye)
      a10.shift();
    for (n10 = 1, i10 = a10[0]; i10 >= 10; i10 /= 10)
      n10++;
    n10 < Ye && (r10 -= Ye - n10);
  }
  return s10.e = r10, s10.d = a10, s10;
}
function eC(e10) {
  return He(e10 = new this(e10), e10.e + 1, this.rounding);
}
function tC(e10) {
  return e10 = new this(e10), e10.d ? e10.d[0] ? e10.s : 0 * e10.s : e10.s || NaN;
}
function rC(e10) {
  return new this(e10).sin();
}
function nC(e10) {
  return new this(e10).sinh();
}
function iC(e10) {
  return new this(e10).sqrt();
}
function oC(e10, t10) {
  return new this(e10).sub(t10);
}
function sC() {
  var e10 = 0, t10 = arguments, r10 = new this(t10[e10]);
  for (st = false; r10.s && ++e10 < t10.length; )
    r10 = r10.plus(t10[e10]);
  return st = true, He(r10, this.precision, this.rounding);
}
function aC(e10) {
  return new this(e10).tan();
}
function cC(e10) {
  return new this(e10).tanh();
}
function lC(e10) {
  return He(e10 = new this(e10), e10.e + 1, 1);
}
ge[Symbol.for("nodejs.util.inspect.custom")] = ge.toString;
ge[Symbol.toStringTag] = "Decimal";
var qr = ge.constructor = wb(Wf);
Wc = new qr(Wc);
Gc = new qr(Gc);
qr.config({
  precision: 256,
  rounding: qr.ROUND_DOWN,
  toExpNeg: -256,
  toExpPos: 256
});
var Lr = (e10, t10, r10, n10 = qr.ROUND_HALF_DOWN) => {
  if (e10 === "∞")
    return "∞";
  if (e10 !== "0" && !e10 || Le(e10).equals(0))
    return "0";
  if (t10 !== void 0) {
    const l10 = vo(e10, t10, n10);
    if (!Le(l10).equals(0))
      return r10 ? l10 : Ss(l10);
  }
  const i10 = Le(e10).toString(), o10 = i10.split("."), s10 = o10[0], a10 = o10[1];
  let c;
  if (Le(s10).gt(0))
    !a10 || Le(s10.length).gte(9) ? c = vo(i10, 0, n10) : Le(s10.length).gte(4) ? c = vo(i10, 2, n10) : c = vo(i10, 4, n10);
  else {
    vo(i10, 6, n10);
    const l10 = dC(a10);
    if (l10 < 6)
      c = vo(i10, l10 + 6, n10);
    else {
      if (l10 > 30)
        return "0";
      c = vo(i10, 9 + (l10 - 6), n10);
    }
  }
  return r10 || Le(s10).lt(1) ? c : Ss(c);
};
var xb = (e10, t10, r10, n10) => {
  try {
    if (e10 === void 0 || e10 === "--")
      return "$--";
    const i10 = Lr(
      e10,
      t10,
      true,
      qr.ROUND_DOWN
    ).toString();
    if (Le(i10).equals(0))
      return "$0";
    const o10 = i10.startsWith("-");
    let s10 = n10 ? i10 : Ss(i10).toString();
    return s10.includes("e") && (s10 = n10 ? i10 : Ss(i10).toString()), !r10 && Number(i10) < Math.pow(10, -t10) ? o10 ? `-$${s10.slice(1)}` : `<$${Math.pow(10, -t10).toFixed(t10)}` : o10 ? `-$${s10.slice(1)}` : `$${s10}`;
  } catch {
    return "$--";
  }
};
var uC = (e10, t10, r10 = true) => {
  if (`${e10}` == "0")
    return !parseFloat(t10) || !r10 ? "0" : "0.".padEnd(t10 + 2, "0");
  if (!e10)
    return "--";
  const n10 = parseFloat(e10), i10 = e10.toString(), o10 = n10 < 0;
  let s10 = i10;
  if (i10.toLowerCase().includes("e")) {
    const a10 = i10.match(/(\d+?)(?:\.(\d*))?e([+-])(\d+)/), c = a10[1], l10 = a10[2], u10 = a10[3], d6 = a10[4];
    let p = "", y = l10 ? l10.substr(d6) : "";
    if (y && (y = `.${y}`), u10 !== "-") {
      for (let x = 0; x < d6; x += 1) {
        const b = l10[x] || "0";
        p += b;
      }
      s10 = c + p + y;
    } else {
      let x = "0";
      for (let b = 0; b < d6; b += 1)
        p = (c[c.length - b - 1] || "0") + p;
      c.length > d6 && (x = c.substr(0, c.length - d6)), s10 = `${x}.${p}${l10}`;
    }
  }
  if (t10 && r10) {
    let a10 = `${s10.split(".")[0]}.`;
    const c = s10.split(".")[1] || "";
    for (let l10 = 0; l10 < t10; l10 += 1)
      a10 += c[l10] || "0";
    s10 = a10;
  }
  if (s10.length > 14) {
    const a10 = s10.split(".");
    a10[0].length > 14 ? s10 = `${a10[0].slice(0, 14)}+` : (s10 = s10.slice(0, 13), s10.indexOf(".") === 12 && (s10 = s10.slice(0, 12)));
  }
  return `${o10 ? "-" : ""}${s10}`;
};
var Le = (e10) => qr.isDecimal(e10) ? e10 : new qr(
  typeof e10 > "u" || e10 === "undefined" || !e10 ? 0 : e10
);
function fC(e10, t10) {
  return t10 === void 0 ? "" : Le(e10 == null ? void 0 : e10.toString()).div(Math.pow(10, t10)).toString();
}
var vo = (e10, t10, r10) => Le(e10).toDP(t10, r10).toString();
var Ss = (e10) => {
  const [t10, r10] = e10.split(".");
  let n10 = "";
  for (let i10 = t10.length - 1, o10 = 0; i10 >= 0; i10--, o10++)
    n10 = t10[i10] + n10, o10 % 3 === 2 && i10 !== 0 && (n10 = "," + n10);
  return r10 ? `${n10}.${r10}` : n10;
};
function dC(e10) {
  let t10 = 0;
  if (e10)
    for (; t10 < e10.length; ) {
      if (Le(e10[t10]).gt(0))
        return t10 + 1;
      t10++;
    }
  return 0;
}
function hC(e10, t10) {
  const r10 = Sb(Le(t10));
  return Number(Le(e10).mul(r10));
}
function pC(e10, t10) {
  const r10 = Sb(Le(t10));
  return Number(Le(e10).div(r10));
}
function Sb(e10) {
  return Le(10).pow(Le(e10).abs());
}
function Yf(e10, t10) {
  const r10 = pC(e10, t10);
  return mC(r10.toString(), Number(t10));
}
function mC(e10, t10 = 9) {
  if (e10 === void 0)
    return "";
  const r10 = e10.toLowerCase();
  if (r10.includes("e")) {
    if (r10.includes("+"))
      return uC(r10, t10);
    const [n10, i10] = r10.split("e");
    let o10 = n10;
    const s10 = Math.abs(parseInt(i10, 10));
    let a10 = "", c = o10.length;
    if (n10.includes(".")) {
      const [l10, u10] = n10.split(".");
      o10 = l10 + u10, c = l10.length;
    }
    for (let l10 = 0; l10 < s10 - c; l10++)
      a10 += "0";
    return `0.${a10}${o10}`.slice(0, t10 + 2);
  }
  return e10;
}
function kl(e10) {
  e10.stopPropagation(), e10.nativeEvent.stopImmediatePropagation();
}
var Do = (e10, t10 = "") => t10 == "long" ? e10 && e10.length > 40 ? e10.substring(0, 40) + "..." : e10 && e10.length < 40 ? e10 : "" : e10 ? e10.substring(0, 6) + "..." + e10.substring(e10.length - 4) : "";
var p0 = (e10, t10) => {
  if (e10 === t10)
    return true;
  if (typeof e10 != "object" || e10 === null || typeof t10 != "object" || t10 === null)
    return false;
  const r10 = Object.keys(e10), n10 = Object.keys(t10);
  if (r10.length !== n10.length)
    return false;
  for (const i10 of r10)
    if (!p0(e10[i10], t10[i10]))
      return false;
  return true;
};
function vp(e10) {
  return !e10 || Object.keys(e10).length === 0;
}
function _b2(e10) {
  var t10;
  return ((t10 = e10.split("::")) == null ? void 0 : t10.length) === 3;
}
var bp = async (e10) => new Promise((t10) => {
  setTimeout(() => {
    t10(1);
  }, e10);
});
function gC(e10, t10, r10 = false) {
  var a10;
  const n10 = e10.balanceChanges, i10 = (a10 = e10.effects) == null ? void 0 : a10.gasUsed, o10 = {};
  let s10 = "0";
  return i10 && (s10 = Le(i10.computationCost).add(i10.storageCost).sub(i10.storageRebate).mul(-1).toFixed(0)), n10 && n10.forEach((c) => {
    const l10 = jn(c.coinType).full_address;
    if (c.owner.AddressOwner === t10) {
      const u10 = l10 === pl;
      let d6 = c.amount;
      u10 && (d6 = r10 ? d6 : Le(d6).sub(s10).toFixed(0));
      const p = {
        coinType: l10,
        amount: d6
      };
      o10[l10] = p;
    }
  }), o10;
}
function yp(e10, t10) {
  if (t10) {
    const r10 = e10[jn(t10.coin_type).full_address];
    if (r10)
      return Yf(
        Le(r10.amount).abs().toFixed(0),
        t10.decimals
      );
  }
}
function At(e10) {
  return `https://archive.cetus.zone/assets/terminal${e10}`;
}
var mn = (e10, t10 = 10) => e10 && (e10 == null ? void 0 : e10.length) > t10 && Le(t10).gt(0) ? `${e10.slice(0, t10)}...` : e10;
var Qa = (e10, t10) => Oi(e10 || "") === Oi(t10 || "");
var vC = (e10) => e10 === null || typeof e10 != "object" || Array.isArray(e10) ? false : Object.keys(e10).length > 0;
var bC = async function(e10, t10, r10 = 3e4) {
  const n10 = [];
  let i10 = "";
  if (t10) {
    for (const c in t10) {
      const l10 = `${c}=${t10[c]}`;
      n10.push(l10);
    }
    const a10 = n10.join("&");
    i10 = `${e10}?${a10}`;
  } else
    i10 = e10;
  const o10 = new AbortController(), s10 = setTimeout(() => {
    o10.abort();
  }, r10);
  try {
    const a10 = await fetch(i10, { signal: o10.signal });
    if (clearTimeout(s10), !a10.ok)
      throw new Error("Request failed");
    const c = await a10.json();
    return (c == null ? void 0 : c.data) || c;
  } catch (a10) {
    throw clearTimeout(s10), a10.name === "AbortError" ? new Error("request time out") : a10;
  }
};
var yC = async function(e10, t10, r10 = 3e4) {
  const n10 = new AbortController(), i10 = setTimeout(() => {
    n10.abort();
  }, r10);
  try {
    const o10 = await fetch(e10, {
      body: JSON.stringify(t10),
      method: "POST",
      signal: n10.signal
    });
    if (clearTimeout(i10), !o10.ok)
      throw new Error("Request failed");
    return o10.json();
  } catch (o10) {
    throw clearTimeout(i10), o10.name === "AbortError" ? new Error("request time out") : o10;
  }
};
var Xf = "tokenMap";
var Eb = "trustedTokenList";
var Cb = "collectTokenMap";
var Tb = "importTokenList";
function ec(e10) {
  throw new Error('Could not dynamically require "' + e10 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Ab = { exports: {} };
(function(e10, t10) {
  (function(r10) {
    e10.exports = r10();
  })(function() {
    return function r10(n10, i10, o10) {
      function s10(l10, u10) {
        if (!i10[l10]) {
          if (!n10[l10]) {
            var d6 = typeof ec == "function" && ec;
            if (!u10 && d6)
              return d6(l10, true);
            if (a10)
              return a10(l10, true);
            var p = new Error("Cannot find module '" + l10 + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var y = i10[l10] = { exports: {} };
          n10[l10][0].call(y.exports, function(x) {
            var b = n10[l10][1][x];
            return s10(b || x);
          }, y, y.exports, r10, n10, i10, o10);
        }
        return i10[l10].exports;
      }
      for (var a10 = typeof ec == "function" && ec, c = 0; c < o10.length; c++)
        s10(o10[c]);
      return s10;
    }({ 1: [function(r10, n10, i10) {
      (function(o10) {
        var s10 = o10.MutationObserver || o10.WebKitMutationObserver, a10;
        if (s10) {
          var c = 0, l10 = new s10(x), u10 = o10.document.createTextNode("");
          l10.observe(u10, {
            characterData: true
          }), a10 = function() {
            u10.data = c = ++c % 2;
          };
        } else if (!o10.setImmediate && typeof o10.MessageChannel < "u") {
          var d6 = new o10.MessageChannel();
          d6.port1.onmessage = x, a10 = function() {
            d6.port2.postMessage(0);
          };
        } else
          "document" in o10 && "onreadystatechange" in o10.document.createElement("script") ? a10 = function() {
            var M = o10.document.createElement("script");
            M.onreadystatechange = function() {
              x(), M.onreadystatechange = null, M.parentNode.removeChild(M), M = null;
            }, o10.document.documentElement.appendChild(M);
          } : a10 = function() {
            setTimeout(x, 0);
          };
        var p, y = [];
        function x() {
          p = true;
          for (var M, O, P = y.length; P; ) {
            for (O = y, y = [], M = -1; ++M < P; )
              O[M]();
            P = y.length;
          }
          p = false;
        }
        n10.exports = b;
        function b(M) {
          y.push(M) === 1 && !p && a10();
        }
      }).call(this, typeof Rr < "u" ? Rr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 2: [function(r10, n10, i10) {
      var o10 = r10(1);
      function s10() {
      }
      var a10 = {}, c = ["REJECTED"], l10 = ["FULFILLED"], u10 = ["PENDING"];
      n10.exports = d6;
      function d6(B) {
        if (typeof B != "function")
          throw new TypeError("resolver must be a function");
        this.state = u10, this.queue = [], this.outcome = void 0, B !== s10 && b(this, B);
      }
      d6.prototype.catch = function(B) {
        return this.then(null, B);
      }, d6.prototype.then = function(B, W) {
        if (typeof B != "function" && this.state === l10 || typeof W != "function" && this.state === c)
          return this;
        var z = new this.constructor(s10);
        if (this.state !== u10) {
          var G = this.state === l10 ? B : W;
          y(z, G, this.outcome);
        } else
          this.queue.push(new p(z, B, W));
        return z;
      };
      function p(B, W, z) {
        this.promise = B, typeof W == "function" && (this.onFulfilled = W, this.callFulfilled = this.otherCallFulfilled), typeof z == "function" && (this.onRejected = z, this.callRejected = this.otherCallRejected);
      }
      p.prototype.callFulfilled = function(B) {
        a10.resolve(this.promise, B);
      }, p.prototype.otherCallFulfilled = function(B) {
        y(this.promise, this.onFulfilled, B);
      }, p.prototype.callRejected = function(B) {
        a10.reject(this.promise, B);
      }, p.prototype.otherCallRejected = function(B) {
        y(this.promise, this.onRejected, B);
      };
      function y(B, W, z) {
        o10(function() {
          var G;
          try {
            G = W(z);
          } catch (re) {
            return a10.reject(B, re);
          }
          G === B ? a10.reject(B, new TypeError("Cannot resolve promise with itself")) : a10.resolve(B, G);
        });
      }
      a10.resolve = function(B, W) {
        var z = M(x, W);
        if (z.status === "error")
          return a10.reject(B, z.value);
        var G = z.value;
        if (G)
          b(B, G);
        else {
          B.state = l10, B.outcome = W;
          for (var re = -1, ie = B.queue.length; ++re < ie; )
            B.queue[re].callFulfilled(W);
        }
        return B;
      }, a10.reject = function(B, W) {
        B.state = c, B.outcome = W;
        for (var z = -1, G = B.queue.length; ++z < G; )
          B.queue[z].callRejected(W);
        return B;
      };
      function x(B) {
        var W = B && B.then;
        if (B && (typeof B == "object" || typeof B == "function") && typeof W == "function")
          return function() {
            W.apply(B, arguments);
          };
      }
      function b(B, W) {
        var z = false;
        function G(q) {
          z || (z = true, a10.reject(B, q));
        }
        function re(q) {
          z || (z = true, a10.resolve(B, q));
        }
        function ie() {
          W(re, G);
        }
        var oe = M(ie);
        oe.status === "error" && G(oe.value);
      }
      function M(B, W) {
        var z = {};
        try {
          z.value = B(W), z.status = "success";
        } catch (G) {
          z.status = "error", z.value = G;
        }
        return z;
      }
      d6.resolve = O;
      function O(B) {
        return B instanceof this ? B : a10.resolve(new this(s10), B);
      }
      d6.reject = P;
      function P(B) {
        var W = new this(s10);
        return a10.reject(W, B);
      }
      d6.all = j;
      function j(B) {
        var W = this;
        if (Object.prototype.toString.call(B) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var z = B.length, G = false;
        if (!z)
          return this.resolve([]);
        for (var re = new Array(z), ie = 0, oe = -1, q = new this(s10); ++oe < z; )
          L(B[oe], oe);
        return q;
        function L(h, f) {
          W.resolve(h).then(m, function(S) {
            G || (G = true, a10.reject(q, S));
          });
          function m(S) {
            re[f] = S, ++ie === z && !G && (G = true, a10.resolve(q, re));
          }
        }
      }
      d6.race = F;
      function F(B) {
        var W = this;
        if (Object.prototype.toString.call(B) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var z = B.length, G = false;
        if (!z)
          return this.resolve([]);
        for (var re = -1, ie = new this(s10); ++re < z; )
          oe(B[re]);
        return ie;
        function oe(q) {
          W.resolve(q).then(function(L) {
            G || (G = true, a10.resolve(ie, L));
          }, function(L) {
            G || (G = true, a10.reject(ie, L));
          });
        }
      }
    }, { 1: 1 }], 3: [function(r10, n10, i10) {
      (function(o10) {
        typeof o10.Promise != "function" && (o10.Promise = r10(2));
      }).call(this, typeof Rr < "u" ? Rr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { 2: 2 }], 4: [function(r10, n10, i10) {
      var o10 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
        return typeof D;
      } : function(D) {
        return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
      };
      function s10(D, K) {
        if (!(D instanceof K))
          throw new TypeError("Cannot call a class as a function");
      }
      function a10() {
        try {
          if (typeof indexedDB < "u")
            return indexedDB;
          if (typeof webkitIndexedDB < "u")
            return webkitIndexedDB;
          if (typeof mozIndexedDB < "u")
            return mozIndexedDB;
          if (typeof OIndexedDB < "u")
            return OIndexedDB;
          if (typeof msIndexedDB < "u")
            return msIndexedDB;
        } catch {
          return;
        }
      }
      var c = a10();
      function l10() {
        try {
          if (!c || !c.open)
            return false;
          var D = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), K = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!D || K) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange < "u";
        } catch {
          return false;
        }
      }
      function u10(D, K) {
        D = D || [], K = K || {};
        try {
          return new Blob(D, K);
        } catch (X) {
          if (X.name !== "TypeError")
            throw X;
          for (var $ = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, J = new $(), te = 0; te < D.length; te += 1)
            J.append(D[te]);
          return J.getBlob(K.type);
        }
      }
      typeof Promise > "u" && r10(3);
      var d6 = Promise;
      function p(D, K) {
        K && D.then(function($) {
          K(null, $);
        }, function($) {
          K($);
        });
      }
      function y(D, K, $) {
        typeof K == "function" && D.then(K), typeof $ == "function" && D.catch($);
      }
      function x(D) {
        return typeof D != "string" && (console.warn(D + " used as a key, but it is not a string."), D = String(D)), D;
      }
      function b() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var M = "local-forage-detect-blob-support", O = void 0, P = {}, j = Object.prototype.toString, F = "readonly", B = "readwrite";
      function W(D) {
        for (var K = D.length, $ = new ArrayBuffer(K), J = new Uint8Array($), te = 0; te < K; te++)
          J[te] = D.charCodeAt(te);
        return $;
      }
      function z(D) {
        return new d6(function(K) {
          var $ = D.transaction(M, B), J = u10([""]);
          $.objectStore(M).put(J, "key"), $.onabort = function(te) {
            te.preventDefault(), te.stopPropagation(), K(false);
          }, $.oncomplete = function() {
            var te = navigator.userAgent.match(/Chrome\/(\d+)/), X = navigator.userAgent.match(/Edge\//);
            K(X || !te || parseInt(te[1], 10) >= 43);
          };
        }).catch(function() {
          return false;
        });
      }
      function G(D) {
        return typeof O == "boolean" ? d6.resolve(O) : z(D).then(function(K) {
          return O = K, O;
        });
      }
      function re(D) {
        var K = P[D.name], $ = {};
        $.promise = new d6(function(J, te) {
          $.resolve = J, $.reject = te;
        }), K.deferredOperations.push($), K.dbReady ? K.dbReady = K.dbReady.then(function() {
          return $.promise;
        }) : K.dbReady = $.promise;
      }
      function ie(D) {
        var K = P[D.name], $ = K.deferredOperations.pop();
        if ($)
          return $.resolve(), $.promise;
      }
      function oe(D, K) {
        var $ = P[D.name], J = $.deferredOperations.pop();
        if (J)
          return J.reject(K), J.promise;
      }
      function q(D, K) {
        return new d6(function($, J) {
          if (P[D.name] = P[D.name] || g(), D.db)
            if (K)
              re(D), D.db.close();
            else
              return $(D.db);
          var te = [D.name];
          K && te.push(D.version);
          var X = c.open.apply(c, te);
          K && (X.onupgradeneeded = function(fe) {
            var be = X.result;
            try {
              be.createObjectStore(D.storeName), fe.oldVersion <= 1 && be.createObjectStore(M);
            } catch (xe) {
              if (xe.name === "ConstraintError")
                console.warn('The database "' + D.name + '" has been upgraded from version ' + fe.oldVersion + " to version " + fe.newVersion + ', but the storage "' + D.storeName + '" already exists.');
              else
                throw xe;
            }
          }), X.onerror = function(fe) {
            fe.preventDefault(), J(X.error);
          }, X.onsuccess = function() {
            var fe = X.result;
            fe.onversionchange = function(be) {
              be.target.close();
            }, $(fe), ie(D);
          };
        });
      }
      function L(D) {
        return q(D, false);
      }
      function h(D) {
        return q(D, true);
      }
      function f(D, K) {
        if (!D.db)
          return true;
        var $ = !D.db.objectStoreNames.contains(D.storeName), J = D.version < D.db.version, te = D.version > D.db.version;
        if (J && (D.version !== K && console.warn('The database "' + D.name + `" can't be downgraded from version ` + D.db.version + " to version " + D.version + "."), D.version = D.db.version), te || $) {
          if ($) {
            var X = D.db.version + 1;
            X > D.version && (D.version = X);
          }
          return true;
        }
        return false;
      }
      function m(D) {
        return new d6(function(K, $) {
          var J = new FileReader();
          J.onerror = $, J.onloadend = function(te) {
            var X = btoa(te.target.result || "");
            K({
              __local_forage_encoded_blob: true,
              data: X,
              type: D.type
            });
          }, J.readAsBinaryString(D);
        });
      }
      function S(D) {
        var K = W(atob(D.data));
        return u10([K], { type: D.type });
      }
      function T(D) {
        return D && D.__local_forage_encoded_blob;
      }
      function E(D) {
        var K = this, $ = K._initReady().then(function() {
          var J = P[K._dbInfo.name];
          if (J && J.dbReady)
            return J.dbReady;
        });
        return y($, D, D), $;
      }
      function I(D) {
        re(D);
        for (var K = P[D.name], $ = K.forages, J = 0; J < $.length; J++) {
          var te = $[J];
          te._dbInfo.db && (te._dbInfo.db.close(), te._dbInfo.db = null);
        }
        return D.db = null, L(D).then(function(X) {
          return D.db = X, f(D) ? h(D) : X;
        }).then(function(X) {
          D.db = K.db = X;
          for (var fe = 0; fe < $.length; fe++)
            $[fe]._dbInfo.db = X;
        }).catch(function(X) {
          throw oe(D, X), X;
        });
      }
      function C(D, K, $, J) {
        J === void 0 && (J = 1);
        try {
          var te = D.db.transaction(D.storeName, K);
          $(null, te);
        } catch (X) {
          if (J > 0 && (!D.db || X.name === "InvalidStateError" || X.name === "NotFoundError"))
            return d6.resolve().then(function() {
              if (!D.db || X.name === "NotFoundError" && !D.db.objectStoreNames.contains(D.storeName) && D.version <= D.db.version)
                return D.db && (D.version = D.db.version + 1), h(D);
            }).then(function() {
              return I(D).then(function() {
                C(D, K, $, J - 1);
              });
            }).catch($);
          $(X);
        }
      }
      function g() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function v10(D) {
        var K = this, $ = {
          db: null
        };
        if (D)
          for (var J in D)
            $[J] = D[J];
        var te = P[$.name];
        te || (te = g(), P[$.name] = te), te.forages.push(K), K._initReady || (K._initReady = K.ready, K.ready = E);
        var X = [];
        function fe() {
          return d6.resolve();
        }
        for (var be = 0; be < te.forages.length; be++) {
          var xe = te.forages[be];
          xe !== K && X.push(xe._initReady().catch(fe));
        }
        var Se = te.forages.slice(0);
        return d6.all(X).then(function() {
          return $.db = te.db, L($);
        }).then(function(_e) {
          return $.db = _e, f($, K._defaultConfig.version) ? h($) : _e;
        }).then(function(_e) {
          $.db = te.db = _e, K._dbInfo = $;
          for (var Fe = 0; Fe < Se.length; Fe++) {
            var vt = Se[Fe];
            vt !== K && (vt._dbInfo.db = $.db, vt._dbInfo.version = $.version);
          }
        });
      }
      function k(D, K) {
        var $ = this;
        D = x(D);
        var J = new d6(function(te, X) {
          $.ready().then(function() {
            C($._dbInfo, F, function(fe, be) {
              if (fe)
                return X(fe);
              try {
                var xe = be.objectStore($._dbInfo.storeName), Se = xe.get(D);
                Se.onsuccess = function() {
                  var _e = Se.result;
                  _e === void 0 && (_e = null), T(_e) && (_e = S(_e)), te(_e);
                }, Se.onerror = function() {
                  X(Se.error);
                };
              } catch (_e) {
                X(_e);
              }
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function Q(D, K) {
        var $ = this, J = new d6(function(te, X) {
          $.ready().then(function() {
            C($._dbInfo, F, function(fe, be) {
              if (fe)
                return X(fe);
              try {
                var xe = be.objectStore($._dbInfo.storeName), Se = xe.openCursor(), _e = 1;
                Se.onsuccess = function() {
                  var Fe = Se.result;
                  if (Fe) {
                    var vt = Fe.value;
                    T(vt) && (vt = S(vt));
                    var zt = D(vt, Fe.key, _e++);
                    zt !== void 0 ? te(zt) : Fe.continue();
                  } else
                    te();
                }, Se.onerror = function() {
                  X(Se.error);
                };
              } catch (Fe) {
                X(Fe);
              }
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function Z(D, K, $) {
        var J = this;
        D = x(D);
        var te = new d6(function(X, fe) {
          var be;
          J.ready().then(function() {
            return be = J._dbInfo, j.call(K) === "[object Blob]" ? G(be.db).then(function(xe) {
              return xe ? K : m(K);
            }) : K;
          }).then(function(xe) {
            C(J._dbInfo, B, function(Se, _e) {
              if (Se)
                return fe(Se);
              try {
                var Fe = _e.objectStore(J._dbInfo.storeName);
                xe === null && (xe = void 0);
                var vt = Fe.put(xe, D);
                _e.oncomplete = function() {
                  xe === void 0 && (xe = null), X(xe);
                }, _e.onabort = _e.onerror = function() {
                  var zt = vt.error ? vt.error : vt.transaction.error;
                  fe(zt);
                };
              } catch (zt) {
                fe(zt);
              }
            });
          }).catch(fe);
        });
        return p(te, $), te;
      }
      function ae(D, K) {
        var $ = this;
        D = x(D);
        var J = new d6(function(te, X) {
          $.ready().then(function() {
            C($._dbInfo, B, function(fe, be) {
              if (fe)
                return X(fe);
              try {
                var xe = be.objectStore($._dbInfo.storeName), Se = xe.delete(D);
                be.oncomplete = function() {
                  te();
                }, be.onerror = function() {
                  X(Se.error);
                }, be.onabort = function() {
                  var _e = Se.error ? Se.error : Se.transaction.error;
                  X(_e);
                };
              } catch (_e) {
                X(_e);
              }
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function ve(D) {
        var K = this, $ = new d6(function(J, te) {
          K.ready().then(function() {
            C(K._dbInfo, B, function(X, fe) {
              if (X)
                return te(X);
              try {
                var be = fe.objectStore(K._dbInfo.storeName), xe = be.clear();
                fe.oncomplete = function() {
                  J();
                }, fe.onabort = fe.onerror = function() {
                  var Se = xe.error ? xe.error : xe.transaction.error;
                  te(Se);
                };
              } catch (Se) {
                te(Se);
              }
            });
          }).catch(te);
        });
        return p($, D), $;
      }
      function we(D) {
        var K = this, $ = new d6(function(J, te) {
          K.ready().then(function() {
            C(K._dbInfo, F, function(X, fe) {
              if (X)
                return te(X);
              try {
                var be = fe.objectStore(K._dbInfo.storeName), xe = be.count();
                xe.onsuccess = function() {
                  J(xe.result);
                }, xe.onerror = function() {
                  te(xe.error);
                };
              } catch (Se) {
                te(Se);
              }
            });
          }).catch(te);
        });
        return p($, D), $;
      }
      function he(D, K) {
        var $ = this, J = new d6(function(te, X) {
          if (D < 0) {
            te(null);
            return;
          }
          $.ready().then(function() {
            C($._dbInfo, F, function(fe, be) {
              if (fe)
                return X(fe);
              try {
                var xe = be.objectStore($._dbInfo.storeName), Se = false, _e = xe.openKeyCursor();
                _e.onsuccess = function() {
                  var Fe = _e.result;
                  if (!Fe) {
                    te(null);
                    return;
                  }
                  D === 0 || Se ? te(Fe.key) : (Se = true, Fe.advance(D));
                }, _e.onerror = function() {
                  X(_e.error);
                };
              } catch (Fe) {
                X(Fe);
              }
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function De(D) {
        var K = this, $ = new d6(function(J, te) {
          K.ready().then(function() {
            C(K._dbInfo, F, function(X, fe) {
              if (X)
                return te(X);
              try {
                var be = fe.objectStore(K._dbInfo.storeName), xe = be.openKeyCursor(), Se = [];
                xe.onsuccess = function() {
                  var _e = xe.result;
                  if (!_e) {
                    J(Se);
                    return;
                  }
                  Se.push(_e.key), _e.continue();
                }, xe.onerror = function() {
                  te(xe.error);
                };
              } catch (_e) {
                te(_e);
              }
            });
          }).catch(te);
        });
        return p($, D), $;
      }
      function Te(D, K) {
        K = b.apply(this, arguments);
        var $ = this.config();
        D = typeof D != "function" && D || {}, D.name || (D.name = D.name || $.name, D.storeName = D.storeName || $.storeName);
        var J = this, te;
        if (!D.name)
          te = d6.reject("Invalid arguments");
        else {
          var X = D.name === $.name && J._dbInfo.db, fe = X ? d6.resolve(J._dbInfo.db) : L(D).then(function(be) {
            var xe = P[D.name], Se = xe.forages;
            xe.db = be;
            for (var _e = 0; _e < Se.length; _e++)
              Se[_e]._dbInfo.db = be;
            return be;
          });
          D.storeName ? te = fe.then(function(be) {
            if (be.objectStoreNames.contains(D.storeName)) {
              var xe = be.version + 1;
              re(D);
              var Se = P[D.name], _e = Se.forages;
              be.close();
              for (var Fe = 0; Fe < _e.length; Fe++) {
                var vt = _e[Fe];
                vt._dbInfo.db = null, vt._dbInfo.version = xe;
              }
              var zt = new d6(function(Wt, mr) {
                var hr = c.open(D.name, xe);
                hr.onerror = function(cn) {
                  var $s = hr.result;
                  $s.close(), mr(cn);
                }, hr.onupgradeneeded = function() {
                  var cn = hr.result;
                  cn.deleteObjectStore(D.storeName);
                }, hr.onsuccess = function() {
                  var cn = hr.result;
                  cn.close(), Wt(cn);
                };
              });
              return zt.then(function(Wt) {
                Se.db = Wt;
                for (var mr = 0; mr < _e.length; mr++) {
                  var hr = _e[mr];
                  hr._dbInfo.db = Wt, ie(hr._dbInfo);
                }
              }).catch(function(Wt) {
                throw (oe(D, Wt) || d6.resolve()).catch(function() {
                }), Wt;
              });
            }
          }) : te = fe.then(function(be) {
            re(D);
            var xe = P[D.name], Se = xe.forages;
            be.close();
            for (var _e = 0; _e < Se.length; _e++) {
              var Fe = Se[_e];
              Fe._dbInfo.db = null;
            }
            var vt = new d6(function(zt, Wt) {
              var mr = c.deleteDatabase(D.name);
              mr.onerror = function() {
                var hr = mr.result;
                hr && hr.close(), Wt(mr.error);
              }, mr.onblocked = function() {
                console.warn('dropInstance blocked for database "' + D.name + '" until all open connections are closed');
              }, mr.onsuccess = function() {
                var hr = mr.result;
                hr && hr.close(), zt(hr);
              };
            });
            return vt.then(function(zt) {
              xe.db = zt;
              for (var Wt = 0; Wt < Se.length; Wt++) {
                var mr = Se[Wt];
                ie(mr._dbInfo);
              }
            }).catch(function(zt) {
              throw (oe(D, zt) || d6.resolve()).catch(function() {
              }), zt;
            });
          });
        }
        return p(te, K), te;
      }
      var Xe = {
        _driver: "asyncStorage",
        _initStorage: v10,
        _support: l10(),
        iterate: Q,
        getItem: k,
        setItem: Z,
        removeItem: ae,
        clear: ve,
        length: we,
        key: he,
        keys: De,
        dropInstance: Te
      };
      function ft() {
        return typeof openDatabase == "function";
      }
      var je = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ht = "~~local_forage_type~", ye = /^~~local_forage_type~([^~]+)~/, de = "__lfsc__:", Ee = de.length, $e = "arbf", Ne = "blob", Ce = "si08", Ae = "ui08", Be = "uic8", lt = "si16", ut = "si32", Ve = "ur16", kt = "ui32", _t = "fl32", Ge = "fl64", Ot = Ee + $e.length, $t = Object.prototype.toString;
      function Qe(D) {
        var K = D.length * 0.75, $ = D.length, J, te = 0, X, fe, be, xe;
        D[D.length - 1] === "=" && (K--, D[D.length - 2] === "=" && K--);
        var Se = new ArrayBuffer(K), _e = new Uint8Array(Se);
        for (J = 0; J < $; J += 4)
          X = je.indexOf(D[J]), fe = je.indexOf(D[J + 1]), be = je.indexOf(D[J + 2]), xe = je.indexOf(D[J + 3]), _e[te++] = X << 2 | fe >> 4, _e[te++] = (fe & 15) << 4 | be >> 2, _e[te++] = (be & 3) << 6 | xe & 63;
        return Se;
      }
      function Et(D) {
        var K = new Uint8Array(D), $ = "", J;
        for (J = 0; J < K.length; J += 3)
          $ += je[K[J] >> 2], $ += je[(K[J] & 3) << 4 | K[J + 1] >> 4], $ += je[(K[J + 1] & 15) << 2 | K[J + 2] >> 6], $ += je[K[J + 2] & 63];
        return K.length % 3 === 2 ? $ = $.substring(0, $.length - 1) + "=" : K.length % 3 === 1 && ($ = $.substring(0, $.length - 2) + "=="), $;
      }
      function Rt(D, K) {
        var $ = "";
        if (D && ($ = $t.call(D)), D && ($ === "[object ArrayBuffer]" || D.buffer && $t.call(D.buffer) === "[object ArrayBuffer]")) {
          var J, te = de;
          D instanceof ArrayBuffer ? (J = D, te += $e) : (J = D.buffer, $ === "[object Int8Array]" ? te += Ce : $ === "[object Uint8Array]" ? te += Ae : $ === "[object Uint8ClampedArray]" ? te += Be : $ === "[object Int16Array]" ? te += lt : $ === "[object Uint16Array]" ? te += Ve : $ === "[object Int32Array]" ? te += ut : $ === "[object Uint32Array]" ? te += kt : $ === "[object Float32Array]" ? te += _t : $ === "[object Float64Array]" ? te += Ge : K(new Error("Failed to get type for BinaryArray"))), K(te + Et(J));
        } else if ($ === "[object Blob]") {
          var X = new FileReader();
          X.onload = function() {
            var fe = ht + D.type + "~" + Et(this.result);
            K(de + Ne + fe);
          }, X.readAsArrayBuffer(D);
        } else
          try {
            K(JSON.stringify(D));
          } catch (fe) {
            console.error("Couldn't convert value into a JSON string: ", D), K(null, fe);
          }
      }
      function rt(D) {
        if (D.substring(0, Ee) !== de)
          return JSON.parse(D);
        var K = D.substring(Ot), $ = D.substring(Ee, Ot), J;
        if ($ === Ne && ye.test(K)) {
          var te = K.match(ye);
          J = te[1], K = K.substring(te[0].length);
        }
        var X = Qe(K);
        switch ($) {
          case $e:
            return X;
          case Ne:
            return u10([X], { type: J });
          case Ce:
            return new Int8Array(X);
          case Ae:
            return new Uint8Array(X);
          case Be:
            return new Uint8ClampedArray(X);
          case lt:
            return new Int16Array(X);
          case Ve:
            return new Uint16Array(X);
          case ut:
            return new Int32Array(X);
          case kt:
            return new Uint32Array(X);
          case _t:
            return new Float32Array(X);
          case Ge:
            return new Float64Array(X);
          default:
            throw new Error("Unkown type: " + $);
        }
      }
      var Dt = {
        serialize: Rt,
        deserialize: rt,
        stringToBuffer: Qe,
        bufferToString: Et
      };
      function Nt(D, K, $, J) {
        D.executeSql("CREATE TABLE IF NOT EXISTS " + K.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], $, J);
      }
      function et(D) {
        var K = this, $ = {
          db: null
        };
        if (D)
          for (var J in D)
            $[J] = typeof D[J] != "string" ? D[J].toString() : D[J];
        var te = new d6(function(X, fe) {
          try {
            $.db = openDatabase($.name, String($.version), $.description, $.size);
          } catch (be) {
            return fe(be);
          }
          $.db.transaction(function(be) {
            Nt(be, $, function() {
              K._dbInfo = $, X();
            }, function(xe, Se) {
              fe(Se);
            });
          }, fe);
        });
        return $.serializer = Dt, te;
      }
      function wt(D, K, $, J, te, X) {
        D.executeSql($, J, te, function(fe, be) {
          be.code === be.SYNTAX_ERR ? fe.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [K.storeName], function(xe, Se) {
            Se.rows.length ? X(xe, be) : Nt(xe, K, function() {
              xe.executeSql($, J, te, X);
            }, X);
          }, X) : X(fe, be);
        }, X);
      }
      function Ct(D, K) {
        var $ = this;
        D = x(D);
        var J = new d6(function(te, X) {
          $.ready().then(function() {
            var fe = $._dbInfo;
            fe.db.transaction(function(be) {
              wt(be, fe, "SELECT * FROM " + fe.storeName + " WHERE key = ? LIMIT 1", [D], function(xe, Se) {
                var _e = Se.rows.length ? Se.rows.item(0).value : null;
                _e && (_e = fe.serializer.deserialize(_e)), te(_e);
              }, function(xe, Se) {
                X(Se);
              });
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function We(D, K) {
        var $ = this, J = new d6(function(te, X) {
          $.ready().then(function() {
            var fe = $._dbInfo;
            fe.db.transaction(function(be) {
              wt(be, fe, "SELECT * FROM " + fe.storeName, [], function(xe, Se) {
                for (var _e = Se.rows, Fe = _e.length, vt = 0; vt < Fe; vt++) {
                  var zt = _e.item(vt), Wt = zt.value;
                  if (Wt && (Wt = fe.serializer.deserialize(Wt)), Wt = D(Wt, zt.key, vt + 1), Wt !== void 0) {
                    te(Wt);
                    return;
                  }
                }
                te();
              }, function(xe, Se) {
                X(Se);
              });
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function pt(D, K, $, J) {
        var te = this;
        D = x(D);
        var X = new d6(function(fe, be) {
          te.ready().then(function() {
            K === void 0 && (K = null);
            var xe = K, Se = te._dbInfo;
            Se.serializer.serialize(K, function(_e, Fe) {
              Fe ? be(Fe) : Se.db.transaction(function(vt) {
                wt(vt, Se, "INSERT OR REPLACE INTO " + Se.storeName + " (key, value) VALUES (?, ?)", [D, _e], function() {
                  fe(xe);
                }, function(zt, Wt) {
                  be(Wt);
                });
              }, function(vt) {
                if (vt.code === vt.QUOTA_ERR) {
                  if (J > 0) {
                    fe(pt.apply(te, [D, xe, $, J - 1]));
                    return;
                  }
                  be(vt);
                }
              });
            });
          }).catch(be);
        });
        return p(X, $), X;
      }
      function jt(D, K, $) {
        return pt.apply(this, [D, K, $, 1]);
      }
      function nt(D, K) {
        var $ = this;
        D = x(D);
        var J = new d6(function(te, X) {
          $.ready().then(function() {
            var fe = $._dbInfo;
            fe.db.transaction(function(be) {
              wt(be, fe, "DELETE FROM " + fe.storeName + " WHERE key = ?", [D], function() {
                te();
              }, function(xe, Se) {
                X(Se);
              });
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function xt(D) {
        var K = this, $ = new d6(function(J, te) {
          K.ready().then(function() {
            var X = K._dbInfo;
            X.db.transaction(function(fe) {
              wt(fe, X, "DELETE FROM " + X.storeName, [], function() {
                J();
              }, function(be, xe) {
                te(xe);
              });
            });
          }).catch(te);
        });
        return p($, D), $;
      }
      function Ht(D) {
        var K = this, $ = new d6(function(J, te) {
          K.ready().then(function() {
            var X = K._dbInfo;
            X.db.transaction(function(fe) {
              wt(fe, X, "SELECT COUNT(key) as c FROM " + X.storeName, [], function(be, xe) {
                var Se = xe.rows.item(0).c;
                J(Se);
              }, function(be, xe) {
                te(xe);
              });
            });
          }).catch(te);
        });
        return p($, D), $;
      }
      function N(D, K) {
        var $ = this, J = new d6(function(te, X) {
          $.ready().then(function() {
            var fe = $._dbInfo;
            fe.db.transaction(function(be) {
              wt(be, fe, "SELECT key FROM " + fe.storeName + " WHERE id = ? LIMIT 1", [D + 1], function(xe, Se) {
                var _e = Se.rows.length ? Se.rows.item(0).key : null;
                te(_e);
              }, function(xe, Se) {
                X(Se);
              });
            });
          }).catch(X);
        });
        return p(J, K), J;
      }
      function _(D) {
        var K = this, $ = new d6(function(J, te) {
          K.ready().then(function() {
            var X = K._dbInfo;
            X.db.transaction(function(fe) {
              wt(fe, X, "SELECT key FROM " + X.storeName, [], function(be, xe) {
                for (var Se = [], _e = 0; _e < xe.rows.length; _e++)
                  Se.push(xe.rows.item(_e).key);
                J(Se);
              }, function(be, xe) {
                te(xe);
              });
            });
          }).catch(te);
        });
        return p($, D), $;
      }
      function A(D) {
        return new d6(function(K, $) {
          D.transaction(function(J) {
            J.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(te, X) {
              for (var fe = [], be = 0; be < X.rows.length; be++)
                fe.push(X.rows.item(be).name);
              K({
                db: D,
                storeNames: fe
              });
            }, function(te, X) {
              $(X);
            });
          }, function(J) {
            $(J);
          });
        });
      }
      function U(D, K) {
        K = b.apply(this, arguments);
        var $ = this.config();
        D = typeof D != "function" && D || {}, D.name || (D.name = D.name || $.name, D.storeName = D.storeName || $.storeName);
        var J = this, te;
        return D.name ? te = new d6(function(X) {
          var fe;
          D.name === $.name ? fe = J._dbInfo.db : fe = openDatabase(D.name, "", "", 0), D.storeName ? X({
            db: fe,
            storeNames: [D.storeName]
          }) : X(A(fe));
        }).then(function(X) {
          return new d6(function(fe, be) {
            X.db.transaction(function(xe) {
              function Se(zt) {
                return new d6(function(Wt, mr) {
                  xe.executeSql("DROP TABLE IF EXISTS " + zt, [], function() {
                    Wt();
                  }, function(hr, cn) {
                    mr(cn);
                  });
                });
              }
              for (var _e = [], Fe = 0, vt = X.storeNames.length; Fe < vt; Fe++)
                _e.push(Se(X.storeNames[Fe]));
              d6.all(_e).then(function() {
                fe();
              }).catch(function(zt) {
                be(zt);
              });
            }, function(xe) {
              be(xe);
            });
          });
        }) : te = d6.reject("Invalid arguments"), p(te, K), te;
      }
      var Y = {
        _driver: "webSQLStorage",
        _initStorage: et,
        _support: ft(),
        iterate: We,
        getItem: Ct,
        setItem: jt,
        removeItem: nt,
        clear: xt,
        length: Ht,
        key: N,
        keys: _,
        dropInstance: U
      };
      function ee() {
        try {
          return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch {
          return false;
        }
      }
      function ne(D, K) {
        var $ = D.name + "/";
        return D.storeName !== K.storeName && ($ += D.storeName + "/"), $;
      }
      function ke() {
        var D = "_localforage_support_test";
        try {
          return localStorage.setItem(D, true), localStorage.removeItem(D), false;
        } catch {
          return true;
        }
      }
      function Je() {
        return !ke() || localStorage.length > 0;
      }
      function Pe(D) {
        var K = this, $ = {};
        if (D)
          for (var J in D)
            $[J] = D[J];
        return $.keyPrefix = ne(D, K._defaultConfig), Je() ? (K._dbInfo = $, $.serializer = Dt, d6.resolve()) : d6.reject();
      }
      function V(D) {
        var K = this, $ = K.ready().then(function() {
          for (var J = K._dbInfo.keyPrefix, te = localStorage.length - 1; te >= 0; te--) {
            var X = localStorage.key(te);
            X.indexOf(J) === 0 && localStorage.removeItem(X);
          }
        });
        return p($, D), $;
      }
      function se(D, K) {
        var $ = this;
        D = x(D);
        var J = $.ready().then(function() {
          var te = $._dbInfo, X = localStorage.getItem(te.keyPrefix + D);
          return X && (X = te.serializer.deserialize(X)), X;
        });
        return p(J, K), J;
      }
      function ue(D, K) {
        var $ = this, J = $.ready().then(function() {
          for (var te = $._dbInfo, X = te.keyPrefix, fe = X.length, be = localStorage.length, xe = 1, Se = 0; Se < be; Se++) {
            var _e = localStorage.key(Se);
            if (_e.indexOf(X) === 0) {
              var Fe = localStorage.getItem(_e);
              if (Fe && (Fe = te.serializer.deserialize(Fe)), Fe = D(Fe, _e.substring(fe), xe++), Fe !== void 0)
                return Fe;
            }
          }
        });
        return p(J, K), J;
      }
      function Oe(D, K) {
        var $ = this, J = $.ready().then(function() {
          var te = $._dbInfo, X;
          try {
            X = localStorage.key(D);
          } catch {
            X = null;
          }
          return X && (X = X.substring(te.keyPrefix.length)), X;
        });
        return p(J, K), J;
      }
      function ze(D) {
        var K = this, $ = K.ready().then(function() {
          for (var J = K._dbInfo, te = localStorage.length, X = [], fe = 0; fe < te; fe++) {
            var be = localStorage.key(fe);
            be.indexOf(J.keyPrefix) === 0 && X.push(be.substring(J.keyPrefix.length));
          }
          return X;
        });
        return p($, D), $;
      }
      function Re(D) {
        var K = this, $ = K.keys().then(function(J) {
          return J.length;
        });
        return p($, D), $;
      }
      function Ue(D, K) {
        var $ = this;
        D = x(D);
        var J = $.ready().then(function() {
          var te = $._dbInfo;
          localStorage.removeItem(te.keyPrefix + D);
        });
        return p(J, K), J;
      }
      function it(D, K, $) {
        var J = this;
        D = x(D);
        var te = J.ready().then(function() {
          K === void 0 && (K = null);
          var X = K;
          return new d6(function(fe, be) {
            var xe = J._dbInfo;
            xe.serializer.serialize(K, function(Se, _e) {
              if (_e)
                be(_e);
              else
                try {
                  localStorage.setItem(xe.keyPrefix + D, Se), fe(X);
                } catch (Fe) {
                  (Fe.name === "QuotaExceededError" || Fe.name === "NS_ERROR_DOM_QUOTA_REACHED") && be(Fe), be(Fe);
                }
            });
          });
        });
        return p(te, $), te;
      }
      function Qt(D, K) {
        if (K = b.apply(this, arguments), D = typeof D != "function" && D || {}, !D.name) {
          var $ = this.config();
          D.name = D.name || $.name, D.storeName = D.storeName || $.storeName;
        }
        var J = this, te;
        return D.name ? te = new d6(function(X) {
          D.storeName ? X(ne(D, J._defaultConfig)) : X(D.name + "/");
        }).then(function(X) {
          for (var fe = localStorage.length - 1; fe >= 0; fe--) {
            var be = localStorage.key(fe);
            be.indexOf(X) === 0 && localStorage.removeItem(be);
          }
        }) : te = d6.reject("Invalid arguments"), p(te, K), te;
      }
      var Lt = {
        _driver: "localStorageWrapper",
        _initStorage: Pe,
        _support: ee(),
        iterate: ue,
        getItem: se,
        setItem: it,
        removeItem: Ue,
        clear: V,
        length: Re,
        key: Oe,
        keys: ze,
        dropInstance: Qt
      }, Vt = function(K, $) {
        return K === $ || typeof K == "number" && typeof $ == "number" && isNaN(K) && isNaN($);
      }, cr = function(K, $) {
        for (var J = K.length, te = 0; te < J; ) {
          if (Vt(K[te], $))
            return true;
          te++;
        }
        return false;
      }, Ar = Array.isArray || function(D) {
        return Object.prototype.toString.call(D) === "[object Array]";
      }, dr = {}, er = {}, _r = {
        INDEXEDDB: Xe,
        WEBSQL: Y,
        LOCALSTORAGE: Lt
      }, wn = [_r.INDEXEDDB._driver, _r.WEBSQL._driver, _r.LOCALSTORAGE._driver], Wr = ["dropInstance"], xn = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Wr), ci = {
        description: "",
        driver: wn.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function li(D, K) {
        D[K] = function() {
          var $ = arguments;
          return D.ready().then(function() {
            return D[K].apply(D, $);
          });
        };
      }
      function Sn() {
        for (var D = 1; D < arguments.length; D++) {
          var K = arguments[D];
          if (K)
            for (var $ in K)
              K.hasOwnProperty($) && (Ar(K[$]) ? arguments[0][$] = K[$].slice() : arguments[0][$] = K[$]);
        }
        return arguments[0];
      }
      var ui = function() {
        function D(K) {
          s10(this, D);
          for (var $ in _r)
            if (_r.hasOwnProperty($)) {
              var J = _r[$], te = J._driver;
              this[$] = te, dr[te] || this.defineDriver(J);
            }
          this._defaultConfig = Sn({}, ci), this._config = Sn({}, this._defaultConfig, K), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return D.prototype.config = function($) {
          if ((typeof $ > "u" ? "undefined" : o10($)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var J in $) {
              if (J === "storeName" && ($[J] = $[J].replace(/\W/g, "_")), J === "version" && typeof $[J] != "number")
                return new Error("Database version must be a number.");
              this._config[J] = $[J];
            }
            return "driver" in $ && $.driver ? this.setDriver(this._config.driver) : true;
          } else
            return typeof $ == "string" ? this._config[$] : this._config;
        }, D.prototype.defineDriver = function($, J, te) {
          var X = new d6(function(fe, be) {
            try {
              var xe = $._driver, Se = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!$._driver) {
                be(Se);
                return;
              }
              for (var _e = xn.concat("_initStorage"), Fe = 0, vt = _e.length; Fe < vt; Fe++) {
                var zt = _e[Fe], Wt = !cr(Wr, zt);
                if ((Wt || $[zt]) && typeof $[zt] != "function") {
                  be(Se);
                  return;
                }
              }
              var mr = function() {
                for (var $s = function(h6) {
                  return function() {
                    var p6 = new Error("Method " + h6 + " is not implemented by the current driver"), ch = d6.reject(p6);
                    return p(ch, arguments[arguments.length - 1]), ch;
                  };
                }, fu = 0, d62 = Wr.length; fu < d62; fu++) {
                  var du = Wr[fu];
                  $[du] || ($[du] = $s(du));
                }
              };
              mr();
              var hr = function($s) {
                dr[xe] && console.info("Redefining LocalForage driver: " + xe), dr[xe] = $, er[xe] = $s, fe();
              };
              "_support" in $ ? $._support && typeof $._support == "function" ? $._support().then(hr, be) : hr(!!$._support) : hr(true);
            } catch (cn) {
              be(cn);
            }
          });
          return y(X, J, te), X;
        }, D.prototype.driver = function() {
          return this._driver || null;
        }, D.prototype.getDriver = function($, J, te) {
          var X = dr[$] ? d6.resolve(dr[$]) : d6.reject(new Error("Driver not found."));
          return y(X, J, te), X;
        }, D.prototype.getSerializer = function($) {
          var J = d6.resolve(Dt);
          return y(J, $), J;
        }, D.prototype.ready = function($) {
          var J = this, te = J._driverSet.then(function() {
            return J._ready === null && (J._ready = J._initDriver()), J._ready;
          });
          return y(te, $, $), te;
        }, D.prototype.setDriver = function($, J, te) {
          var X = this;
          Ar($) || ($ = [$]);
          var fe = this._getSupportedDrivers($);
          function be() {
            X._config.driver = X.driver();
          }
          function xe(Fe) {
            return X._extend(Fe), be(), X._ready = X._initStorage(X._config), X._ready;
          }
          function Se(Fe) {
            return function() {
              var vt = 0;
              function zt() {
                for (; vt < Fe.length; ) {
                  var Wt = Fe[vt];
                  return vt++, X._dbInfo = null, X._ready = null, X.getDriver(Wt).then(xe).catch(zt);
                }
                be();
                var mr = new Error("No available storage method found.");
                return X._driverSet = d6.reject(mr), X._driverSet;
              }
              return zt();
            };
          }
          var _e = this._driverSet !== null ? this._driverSet.catch(function() {
            return d6.resolve();
          }) : d6.resolve();
          return this._driverSet = _e.then(function() {
            var Fe = fe[0];
            return X._dbInfo = null, X._ready = null, X.getDriver(Fe).then(function(vt) {
              X._driver = vt._driver, be(), X._wrapLibraryMethodsWithReady(), X._initDriver = Se(fe);
            });
          }).catch(function() {
            be();
            var Fe = new Error("No available storage method found.");
            return X._driverSet = d6.reject(Fe), X._driverSet;
          }), y(this._driverSet, J, te), this._driverSet;
        }, D.prototype.supports = function($) {
          return !!er[$];
        }, D.prototype._extend = function($) {
          Sn(this, $);
        }, D.prototype._getSupportedDrivers = function($) {
          for (var J = [], te = 0, X = $.length; te < X; te++) {
            var fe = $[te];
            this.supports(fe) && J.push(fe);
          }
          return J;
        }, D.prototype._wrapLibraryMethodsWithReady = function() {
          for (var $ = 0, J = xn.length; $ < J; $++)
            li(this, xn[$]);
        }, D.prototype.createInstance = function($) {
          return new D($);
        }, D;
      }(), fi = new ui();
      n10.exports = fi;
    }, { 3: 3 }] }, {}, [4])(4);
  });
})(Ab);
var wC = Ab.exports;
var ra = Oa(wC);
ra.config({
  name: "CetusSite",
  storeName: "tokens"
});
var Ti = class {
  // 设置数据
  static async setItem(t10, r10) {
    try {
      await ra.setItem(t10, r10);
    } catch (n10) {
      console.error(`Failed to set item with key "${t10}"`, n10);
    }
  }
  // 获取数据
  static async getItem(t10) {
    try {
      return await ra.getItem(t10);
    } catch (r10) {
      return console.error(`Failed to get item with key "${t10}"`, r10), null;
    }
  }
  // 删除数据
  static async removeItem(t10) {
    try {
      await ra.removeItem(t10);
    } catch (r10) {
      console.error(`Failed to remove item with key "${t10}"`, r10);
    }
  }
  // 清空存储
  static async clear() {
    try {
      await ra.clear();
    } catch (t10) {
      console.error("Failed to clear storage", t10);
    }
  }
};
var Dl = [
  {
    name: "SuiVision",
    link: "https://suivision.xyz",
    img: At("/images/logo_suivision@2x.png"),
    isCustom: false
  },
  {
    name: "Suiscan",
    link: "https://suiscan.xyz/mainnet",
    img: At("/images/logo_suiscan@2x.png"),
    isCustom: false
  }
];
var Yc = [
  {
    name: "Sui Fullnode",
    link: "https://fullnode.mainnet.sui.io",
    isCustom: false
  },
  // {
  //   name: "Suiet",
  //   link: "https://mainnet.suiet.app:443",
  //   isCustom: false,
  // },
  {
    name: "Custom RPC URL",
    link: "",
    isCustom: true
  }
];
var xC = [
  {
    display: "0.1",
    value: "0.001"
  },
  {
    display: "0.5",
    value: "0.005"
  },
  {
    display: "1",
    value: "0.01"
  }
];
var SC = "mainnet";
var _C = {
  mainnet: {
    env: "mainnet",
    fullRpcUrl: "https://fullnode.mainnet.sui.io",
    simulationAccount: "0x326ce9894f08dcaa337fa232641cc34db957aec9ff6614c1186bc9a7508df0bb",
    api: "https://api-sui.cetus.zone",
    aggregatorUrl: "https://api-sui.cetus.zone/router_v2"
  }
};
var hs = _C[SC];
var EC = "0x45f3c0814d7be4aa5fbd32d7e3c40f3c062a2b63eaf5ec4f8c1539b5987b11af";
var CC = At("/images/birdeye-logo.png");
var TC = At("/images/img-logo@2x.png");
var AC2 = At("/images/logo_CoinGecko@2x.png");
var MC = At("/images/logo_pyth.png");
var ua = ((e10) => (e10.CETUS = "CETUS", e10.KRIYA = "KRIYA", e10.KRIYAV3 = "KRIYAV3", e10.FLOWX = "FLOWX", e10.FLOWXV3 = "FLOWXV3", e10.AFTERMATH = "AFTERMATH", e10.HAEDAL = "HAEDAL", e10.VOLO = "VOLO", e10.AFSUI = "AFSUI", e10.DEEPBOOKV3 = "DEEPBOOKV3", e10.SCALLOP = "SCALLOP", e10.BLUEMOVE = "BLUEMOVE", e10.TURBOS = "TURBOS", e10.SPRINGSUI = "SPRINGSUI", e10.BLUEFIN = "BLUEFIN", e10.HAEDALPMM = "HAEDALPMM", e10.ALPHAFI = "ALPHAFI", e10.STEAMM = "STEAMM", e10.STEAMM_OMM = "STEAMM_OMM", e10.OBRIC = "OBRIC", e10.METASTABLE = "METASTABLE", e10.MOMENTUM = "MOMENTUM", e10))(ua || {});
var Mb = {
  pyth: "Pyth Network",
  coingecko: "CoinGecko",
  birdeye: "Birdeye",
  Cetus: "Cetus"
};
var IC = {
  pyth: MC,
  coingecko: AC2,
  birdeye: CC,
  Cetus: TC
};
var nr = {
  CETUS: At("/images/aggregator-source/cetus.png"),
  // DEEPBOOK: '/images/aggregator-source/deepbook.png',
  KRIYA: At("/images/aggregator-source/kriya.png"),
  FLOWX: At("/images/aggregator-source/flowx.png"),
  AFTERMATH: At("/images/aggregator-source/aftermath.png"),
  TURBOS: At("/images/aggregator-source/turbos.png"),
  HAEDAL: At("/images/aggregator-source/haedal.png"),
  VOLO: At("/images/aggregator-source/volo.png"),
  AFSUI: At("/images/aggregator-source/aftermath.png"),
  BLUEMOVE: At("/images/aggregator-source/bluemove.png"),
  KRIYAV3: At("/images/aggregator-source/kriya.png"),
  FLOWXV3: At("/images/aggregator-source/flowx.png"),
  DEEPBOOKV3: At("/images/aggregator-source/deepbook.png"),
  SCALLOP: At("/images/aggregator-source/scallop.png"),
  SPRINGSUI: At("/images/aggregator-source/suilend.png"),
  BLUEFIN: At("/images/aggregator-source/bluefin.png"),
  HAEDALPMM: At("/images/aggregator-source/haedal.png"),
  ALPHAFI: At("/images/aggregator-source/stSui.png"),
  STEAMM: At("/images/aggregator-source/steamm.png"),
  OBRIC: At("/images/aggregator-source/obric.png"),
  METASTABLE: At("/images/aggregator-source/metastable.png"),
  MOMENTUM: At("/images/aggregator-source/momentum.png"),
  STEAMM_OMM: At("/images/aggregator-source/steamm.png")
};
var Ib = {
  CETUS: {
    name: "Cetus",
    id: "CETUS",
    logo: nr.CETUS,
    type: "dex",
    sort: 100
  },
  // DeepBook: {
  //   name: 'DeepBook',
  //   id: AggregatorProvider.DEEPBOOK,
  //   logo: AggregatorSourceImg['DEEPBOOK'],
  //   type: 'dex',
  //   sort: 99
  // },
  DEEPBOOKV3: {
    name: "DeepBook V3",
    id: "DEEPBOOKV3",
    logo: nr.DEEPBOOKV3,
    type: "dex",
    sort: 99
  },
  KRIYA: {
    name: "Kriya V2",
    id: "KRIYA",
    logo: nr.KRIYA,
    type: "dex",
    sort: 98
  },
  KRIYAV3: {
    name: "Kriya V3",
    id: "KRIYAV3",
    logo: nr.KRIYA,
    type: "dex",
    sort: 97
  },
  FLOWX: {
    name: "FlowX V2",
    id: "FLOWX",
    logo: nr.FLOWX,
    type: "dex",
    sort: 96
  },
  FLOWXV3: {
    name: "FlowX V3",
    id: "FLOWXV3",
    logo: nr.FLOWX,
    type: "dex",
    sort: 95
  },
  AFTERMATH: {
    name: "Aftermath",
    id: "AFTERMATH",
    logo: nr.AFTERMATH,
    type: "dex",
    sort: 94
  },
  TURBOS: {
    name: "Turbos",
    id: "TURBOS",
    logo: nr.TURBOS,
    type: "dex",
    sort: 93
  },
  HAEDAL: {
    name: "Haedal LSD",
    id: "HAEDAL",
    logo: nr.HAEDAL,
    type: "other",
    sort: 92
  },
  HAEDALPMM: {
    name: "Haedal HMM",
    id: "HAEDALPMM",
    logo: nr.HAEDALPMM,
    type: "other",
    sort: 92
  },
  VOLO: {
    name: "Volo",
    id: "VOLO",
    logo: nr.VOLO,
    type: "other",
    sort: 91
  },
  AFSUI: {
    name: "Aftermath LSD",
    id: "AFSUI",
    logo: nr.AFTERMATH,
    type: "other",
    sort: 90
  },
  BLUEMOVE: {
    name: "BlueMove",
    id: "BLUEMOVE",
    logo: nr.BLUEMOVE,
    type: "dex",
    sort: 80
  },
  BLUEFIN: {
    name: "Bluefin",
    id: "BLUEFIN",
    logo: nr.BLUEFIN,
    sort: 79,
    type: "dex"
  },
  MOMENTUM: {
    name: "Momentum",
    id: "MOMENTUM",
    logo: nr.MOMENTUM,
    sort: 68,
    type: "dex"
  },
  SCALLOP: {
    name: "Scallop",
    id: "SCALLOP",
    logo: nr.SCALLOP,
    type: "other",
    sort: 70
  },
  SPRINGSUI: {
    name: "SpringSui",
    id: "SPRINGSUI",
    logo: nr.SPRINGSUI,
    type: "other",
    sort: 60
  },
  ALPHAFI: {
    name: "stSUI",
    id: "ALPHAFI",
    logo: nr.ALPHAFI,
    type: "other",
    sort: 50
  },
  STEAMM: {
    name: "STEAMM CPMM",
    id: "STEAMM",
    logo: nr.STEAMM,
    sort: 76,
    type: "dex"
  },
  STEAMM_OMM: {
    name: "STEAMM OMM",
    id: "STEAMM_OMM",
    logo: nr.STEAMM_OMM,
    sort: 75,
    type: "dex"
  },
  METASTABLE: {
    name: "Metastable",
    id: "METASTABLE",
    logo: nr.METASTABLE,
    sort: 77,
    type: "dex"
  },
  OBRIC: {
    name: "Obric",
    id: "OBRIC",
    logo: nr.OBRIC,
    sort: 76,
    type: "dex"
  }
};
var wp = (e10) => {
  let t10;
  const r10 = /* @__PURE__ */ new Set(), n10 = (l10, u10) => {
    const d6 = typeof l10 == "function" ? l10(t10) : l10;
    if (!Object.is(d6, t10)) {
      const p = t10;
      t10 = u10 ?? (typeof d6 != "object" || d6 === null) ? d6 : Object.assign({}, t10, d6), r10.forEach((y) => y(t10, p));
    }
  }, i10 = () => t10, a10 = { setState: n10, getState: i10, getInitialState: () => c, subscribe: (l10) => (r10.add(l10), () => r10.delete(l10)) }, c = t10 = e10(n10, i10, a10);
  return a10;
};
var OC = (e10) => e10 ? wp(e10) : wp;
var RC = (e10) => e10;
function PC(e10, t10 = RC) {
  const r10 = import_react25.default.useSyncExternalStore(
    e10.subscribe,
    () => t10(e10.getState()),
    () => t10(e10.getInitialState())
  );
  return import_react25.default.useDebugValue(r10), r10;
}
var xp = (e10) => {
  const t10 = OC(e10), r10 = (n10) => PC(t10, n10);
  return Object.assign(r10, t10), r10;
};
var ki = (e10) => e10 ? xp(e10) : xp;
function NC(e10, t10) {
  let r10;
  try {
    r10 = e10();
  } catch {
    return;
  }
  return {
    getItem: (i10) => {
      var o10;
      const s10 = (c) => c === null ? null : JSON.parse(c, t10 == null ? void 0 : t10.reviver), a10 = (o10 = r10.getItem(i10)) != null ? o10 : null;
      return a10 instanceof Promise ? a10.then(s10) : s10(a10);
    },
    setItem: (i10, o10) => r10.setItem(
      i10,
      JSON.stringify(o10, t10 == null ? void 0 : t10.replacer)
    ),
    removeItem: (i10) => r10.removeItem(i10)
  };
}
var Jf = (e10) => (t10) => {
  try {
    const r10 = e10(t10);
    return r10 instanceof Promise ? r10 : {
      then(n10) {
        return Jf(n10)(r10);
      },
      catch(n10) {
        return this;
      }
    };
  } catch (r10) {
    return {
      then(n10) {
        return this;
      },
      catch(n10) {
        return Jf(n10)(r10);
      }
    };
  }
};
var jC = (e10, t10) => (r10, n10, i10) => {
  let o10 = {
    storage: NC(() => localStorage),
    partialize: (b) => b,
    version: 0,
    merge: (b, M) => ({
      ...M,
      ...b
    }),
    ...t10
  }, s10 = false;
  const a10 = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  let l10 = o10.storage;
  if (!l10)
    return e10(
      (...b) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o10.name}', the given storage is currently unavailable.`
        ), r10(...b);
      },
      n10,
      i10
    );
  const u10 = () => {
    const b = o10.partialize({ ...n10() });
    return l10.setItem(o10.name, {
      state: b,
      version: o10.version
    });
  }, d6 = i10.setState;
  i10.setState = (b, M) => {
    d6(b, M), u10();
  };
  const p = e10(
    (...b) => {
      r10(...b), u10();
    },
    n10,
    i10
  );
  i10.getInitialState = () => p;
  let y;
  const x = () => {
    var b, M;
    if (!l10)
      return;
    s10 = false, a10.forEach((P) => {
      var j;
      return P((j = n10()) != null ? j : p);
    });
    const O = ((M = o10.onRehydrateStorage) == null ? void 0 : M.call(o10, (b = n10()) != null ? b : p)) || void 0;
    return Jf(l10.getItem.bind(l10))(o10.name).then((P) => {
      if (P)
        if (typeof P.version == "number" && P.version !== o10.version) {
          if (o10.migrate) {
            const j = o10.migrate(
              P.state,
              P.version
            );
            return j instanceof Promise ? j.then((F) => [true, F]) : [true, j];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [false, P.state];
      return [false, void 0];
    }).then((P) => {
      var j;
      const [F, B] = P;
      if (y = o10.merge(
        B,
        (j = n10()) != null ? j : p
      ), r10(y, true), F)
        return u10();
    }).then(() => {
      O == null || O(y, void 0), y = n10(), s10 = true, c.forEach((P) => P(y));
    }).catch((P) => {
      O == null || O(void 0, P);
    });
  };
  return i10.persist = {
    setOptions: (b) => {
      o10 = {
        ...o10,
        ...b
      }, b.storage && (l10 = b.storage);
    },
    clearStorage: () => {
      l10 == null || l10.removeItem(o10.name);
    },
    getOptions: () => o10,
    rehydrate: () => x(),
    hasHydrated: () => s10,
    onHydrate: (b) => (a10.add(b), () => {
      a10.delete(b);
    }),
    onFinishHydration: (b) => (c.add(b), () => {
      c.delete(b);
    })
  }, o10.skipHydration || x(), y || p;
};
var kC = jC;
var DC = (e10, t10) => ({
  ignoreWarnTokenMap: {},
  currentExplorer: Dl[0].link,
  setCurrentExplorer: (r10) => {
    e10(() => ({
      currentExplorer: r10
    }));
  },
  rpcList: Yc,
  setRpcList: (r10) => {
    e10(() => ({
      rpcList: [...r10]
    }));
  },
  currentRpc: Yc[0],
  customRpc: "",
  setCurrentRpc: (r10) => {
    e10(() => ({
      currentRpc: r10
    }));
  },
  setCustomRpc: (r10) => {
    e10(() => ({
      customRpc: r10
    }));
  },
  slippage: "0.5",
  setSlippage: (r10) => {
    e10(() => ({
      slippage: r10
    }));
  },
  isOpenSlippageDialog: false,
  setIsOpenSlippageDialog: (r10) => {
    e10(() => ({
      isOpenSlippageDialog: r10
    }));
  },
  providers: Object.values(ua),
  setProviders: (r10) => {
    e10(() => ({
      providers: r10
    }));
  },
  poolApiMap: {},
  setPoolApiMap: (r10, n10) => {
    const i10 = t10().poolApiMap;
    i10[r10] = n10, e10(() => ({
      poolApiMap: { ...i10 }
    }));
  },
  mevProtect: true,
  setMevProtect: (r10) => {
    e10(() => ({
      mevProtect: r10
    }));
  },
  setIgnoreWarnToken: (r10) => {
    const n10 = t10().ignoreWarnTokenMap;
    n10[Oi(r10)] = true, e10(() => ({
      ignoreWarnTokenMap: { ...n10 }
    }));
  }
});
var Hr = ki(
  kC(DC, {
    name: "useGlobalStore",
    partialize: (e10) => {
      const {
        currentExplorer: t10,
        currentRpc: r10,
        slippage: n10,
        customRpc: i10,
        providers: o10,
        mevProtect: s10,
        ignoreWarnTokenMap: a10
      } = e10;
      return {
        currentExplorer: t10,
        currentRpc: r10,
        slippage: n10,
        customRpc: i10,
        providers: o10,
        mevProtect: s10,
        ignoreWarnTokenMap: a10
      };
    }
  })
);
function Rs() {
  const { currentExplorer: e10 } = Hr();
  return { getExplorerUrl: (r10, n10 = "account", i10 = e10) => {
    let o10;
    return i10.includes("suivision") ? o10 = `${i10}/${BC(n10)}/${r10}` : o10 = `${i10}/${LC(n10)}/${r10}`, o10;
  } };
}
var LC = (e10) => {
  switch (e10) {
    case "account":
      return "address";
    case "token":
      return "object";
    case "tx":
      return "tx";
    case "poolAddress":
      return "object";
    case "nftAddress":
      return "object";
    case "coin":
      return "coin";
  }
};
var BC = (e10) => {
  switch (e10) {
    case "account":
      return "account";
    case "token":
      return "object";
    case "tx":
      return "txblock";
    case "poolAddress":
      return "object";
    case "nftAddress":
      return "object";
    case "coin":
      return "coin";
  }
};
function Ob(e10) {
  const {
    text: t10,
    keywords: r10,
    onKeywordClick: n10,
    text_highlight_color: i10 = "var(--cs-primary)",
    text_size: o10 = "12px",
    text_color: s10 = "var(--cs-btn-disabled-text)"
  } = e10, a10 = new RegExp(`(${r10.join("|")})`, "gi"), c = t10.split(a10);
  return w.jsx(
    "span",
    {
      style: { display: "inline", whiteSpace: "normal", textAlign: "start" },
      children: c.map((l10, u10) => {
        const d6 = r10.includes(l10);
        return w.jsx(
          "span",
          {
            style: {
              lineHeight: "20px",
              fontSize: o10,
              color: d6 ? i10 : s10,
              cursor: "pointer",
              whiteSpace: "inherit"
            },
            onClick: () => n10(l10),
            children: l10
          },
          u10
        );
      })
    }
  );
}
var Rb = { exports: {} };
(function(e10) {
  (function() {
    var t10 = {}.hasOwnProperty;
    function r10() {
      for (var o10 = "", s10 = 0; s10 < arguments.length; s10++) {
        var a10 = arguments[s10];
        a10 && (o10 = i10(o10, n10(a10)));
      }
      return o10;
    }
    function n10(o10) {
      if (typeof o10 == "string" || typeof o10 == "number")
        return o10;
      if (typeof o10 != "object")
        return "";
      if (Array.isArray(o10))
        return r10.apply(null, o10);
      if (o10.toString !== Object.prototype.toString && !o10.toString.toString().includes("[native code]"))
        return o10.toString();
      var s10 = "";
      for (var a10 in o10)
        t10.call(o10, a10) && o10[a10] && (s10 = i10(s10, a10));
      return s10;
    }
    function i10(o10, s10) {
      return s10 ? o10 ? o10 + " " + s10 : o10 + s10 : o10;
    }
    e10.exports ? (r10.default = r10, e10.exports = r10) : window.classNames = r10;
  })();
})(Rb);
var UC = Rb.exports;
var rr = Oa(UC);
function Ze(e10, t10, { checkForDefaultPrevented: r10 = true } = {}) {
  return function(i10) {
    if (e10 == null || e10(i10), r10 === false || !i10.defaultPrevented)
      return t10 == null ? void 0 : t10(i10);
  };
}
function Sp(e10, t10) {
  if (typeof e10 == "function")
    return e10(t10);
  e10 != null && (e10.current = t10);
}
function Ll(...e10) {
  return (t10) => {
    let r10 = false;
    const n10 = e10.map((i10) => {
      const o10 = Sp(i10, t10);
      return !r10 && typeof o10 == "function" && (r10 = true), o10;
    });
    if (r10)
      return () => {
        for (let i10 = 0; i10 < n10.length; i10++) {
          const o10 = n10[i10];
          typeof o10 == "function" ? o10() : Sp(e10[i10], null);
        }
      };
  };
}
function sr(...e10) {
  return R.useCallback(Ll(...e10), e10);
}
function Di(e10, t10 = []) {
  let r10 = [];
  function n10(o10, s10) {
    const a10 = R.createContext(s10), c = r10.length;
    r10 = [...r10, s10];
    const l10 = (d6) => {
      var O;
      const { scope: p, children: y, ...x } = d6, b = ((O = p == null ? void 0 : p[e10]) == null ? void 0 : O[c]) || a10, M = R.useMemo(() => x, Object.values(x));
      return w.jsx(b.Provider, { value: M, children: y });
    };
    l10.displayName = o10 + "Provider";
    function u10(d6, p) {
      var b;
      const y = ((b = p == null ? void 0 : p[e10]) == null ? void 0 : b[c]) || a10, x = R.useContext(y);
      if (x)
        return x;
      if (s10 !== void 0)
        return s10;
      throw new Error(`\`${d6}\` must be used within \`${o10}\``);
    }
    return [l10, u10];
  }
  const i10 = () => {
    const o10 = r10.map((s10) => R.createContext(s10));
    return function(a10) {
      const c = (a10 == null ? void 0 : a10[e10]) || o10;
      return R.useMemo(
        () => ({ [`__scope${e10}`]: { ...a10, [e10]: c } }),
        [a10, c]
      );
    };
  };
  return i10.scopeName = e10, [n10, FC(i10, ...t10)];
}
function FC(...e10) {
  const t10 = e10[0];
  if (e10.length === 1)
    return t10;
  const r10 = () => {
    const n10 = e10.map((i10) => ({
      useScope: i10(),
      scopeName: i10.scopeName
    }));
    return function(o10) {
      const s10 = n10.reduce((a10, { useScope: c, scopeName: l10 }) => {
        const d6 = c(o10)[`__scope${l10}`];
        return { ...a10, ...d6 };
      }, {});
      return R.useMemo(() => ({ [`__scope${t10.scopeName}`]: s10 }), [s10]);
    };
  };
  return r10.scopeName = t10.scopeName, r10;
}
var Ri = R.forwardRef((e10, t10) => {
  const { children: r10, ...n10 } = e10, i10 = R.Children.toArray(r10), o10 = i10.find($C);
  if (o10) {
    const s10 = o10.props.children, a10 = i10.map((c) => c === o10 ? R.Children.count(s10) > 1 ? R.Children.only(null) : R.isValidElement(s10) ? s10.props.children : null : c);
    return w.jsx(Zf, { ...n10, ref: t10, children: R.isValidElement(s10) ? R.cloneElement(s10, void 0, a10) : null });
  }
  return w.jsx(Zf, { ...n10, ref: t10, children: r10 });
});
Ri.displayName = "Slot";
var Zf = R.forwardRef((e10, t10) => {
  const { children: r10, ...n10 } = e10;
  if (R.isValidElement(r10)) {
    const i10 = zC(r10), o10 = VC(n10, r10.props);
    return r10.type !== R.Fragment && (o10.ref = t10 ? Ll(t10, i10) : i10), R.cloneElement(r10, o10);
  }
  return R.Children.count(r10) > 1 ? R.Children.only(null) : null;
});
Zf.displayName = "SlotClone";
var Ps = ({ children: e10 }) => w.jsx(w.Fragment, { children: e10 });
function $C(e10) {
  return R.isValidElement(e10) && e10.type === Ps;
}
function VC(e10, t10) {
  const r10 = { ...t10 };
  for (const n10 in t10) {
    const i10 = e10[n10], o10 = t10[n10];
    /^on[A-Z]/.test(n10) ? i10 && o10 ? r10[n10] = (...a10) => {
      o10(...a10), i10(...a10);
    } : i10 && (r10[n10] = i10) : n10 === "style" ? r10[n10] = { ...i10, ...o10 } : n10 === "className" && (r10[n10] = [i10, o10].filter(Boolean).join(" "));
  }
  return { ...e10, ...r10 };
}
function zC(e10) {
  var n10, i10;
  let t10 = (n10 = Object.getOwnPropertyDescriptor(e10.props, "ref")) == null ? void 0 : n10.get, r10 = t10 && "isReactWarning" in t10 && t10.isReactWarning;
  return r10 ? e10.ref : (t10 = (i10 = Object.getOwnPropertyDescriptor(e10, "ref")) == null ? void 0 : i10.get, r10 = t10 && "isReactWarning" in t10 && t10.isReactWarning, r10 ? e10.props.ref : e10.props.ref || e10.ref);
}
var qC = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Zt = qC.reduce((e10, t10) => {
  const r10 = R.forwardRef((n10, i10) => {
    const { asChild: o10, ...s10 } = n10, a10 = o10 ? Ri : t10;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = true), w.jsx(a10, { ...s10, ref: i10 });
  });
  return r10.displayName = `Primitive.${t10}`, { ...e10, [t10]: r10 };
}, {});
function Pb(e10, t10) {
  e10 && zm.flushSync(() => e10.dispatchEvent(t10));
}
function wr(e10) {
  const t10 = R.useRef(e10);
  return R.useEffect(() => {
    t10.current = e10;
  }), R.useMemo(() => (...r10) => {
    var n10;
    return (n10 = t10.current) == null ? void 0 : n10.call(t10, ...r10);
  }, []);
}
function HC(e10, t10 = globalThis == null ? void 0 : globalThis.document) {
  const r10 = wr(e10);
  R.useEffect(() => {
    const n10 = (i10) => {
      i10.key === "Escape" && r10(i10);
    };
    return t10.addEventListener("keydown", n10, { capture: true }), () => t10.removeEventListener("keydown", n10, { capture: true });
  }, [r10, t10]);
}
var WC = "DismissableLayer";
var Qf = "dismissableLayer.update";
var GC = "dismissableLayer.pointerDownOutside";
var KC = "dismissableLayer.focusOutside";
var _p;
var Nb = R.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var m0 = R.forwardRef(
  (e10, t10) => {
    const {
      disableOutsidePointerEvents: r10 = false,
      onEscapeKeyDown: n10,
      onPointerDownOutside: i10,
      onFocusOutside: o10,
      onInteractOutside: s10,
      onDismiss: a10,
      ...c
    } = e10, l10 = R.useContext(Nb), [u10, d6] = R.useState(null), p = (u10 == null ? void 0 : u10.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, y] = R.useState({}), x = sr(t10, (z) => d6(z)), b = Array.from(l10.layers), [M] = [...l10.layersWithOutsidePointerEventsDisabled].slice(-1), O = b.indexOf(M), P = u10 ? b.indexOf(u10) : -1, j = l10.layersWithOutsidePointerEventsDisabled.size > 0, F = P >= O, B = JC((z) => {
      const G = z.target, re = [...l10.branches].some((ie) => ie.contains(G));
      !F || re || (i10 == null || i10(z), s10 == null || s10(z), z.defaultPrevented || a10 == null || a10());
    }, p), W = ZC((z) => {
      const G = z.target;
      [...l10.branches].some((ie) => ie.contains(G)) || (o10 == null || o10(z), s10 == null || s10(z), z.defaultPrevented || a10 == null || a10());
    }, p);
    return HC((z) => {
      P === l10.layers.size - 1 && (n10 == null || n10(z), !z.defaultPrevented && a10 && (z.preventDefault(), a10()));
    }, p), R.useEffect(() => {
      if (u10)
        return r10 && (l10.layersWithOutsidePointerEventsDisabled.size === 0 && (_p = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), l10.layersWithOutsidePointerEventsDisabled.add(u10)), l10.layers.add(u10), Ep(), () => {
          r10 && l10.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = _p);
        };
    }, [u10, p, r10, l10]), R.useEffect(() => () => {
      u10 && (l10.layers.delete(u10), l10.layersWithOutsidePointerEventsDisabled.delete(u10), Ep());
    }, [u10, l10]), R.useEffect(() => {
      const z = () => y({});
      return document.addEventListener(Qf, z), () => document.removeEventListener(Qf, z);
    }, []), w.jsx(
      Zt.div,
      {
        ...c,
        ref: x,
        style: {
          pointerEvents: j ? F ? "auto" : "none" : void 0,
          ...e10.style
        },
        onFocusCapture: Ze(e10.onFocusCapture, W.onFocusCapture),
        onBlurCapture: Ze(e10.onBlurCapture, W.onBlurCapture),
        onPointerDownCapture: Ze(
          e10.onPointerDownCapture,
          B.onPointerDownCapture
        )
      }
    );
  }
);
m0.displayName = WC;
var YC = "DismissableLayerBranch";
var XC = R.forwardRef((e10, t10) => {
  const r10 = R.useContext(Nb), n10 = R.useRef(null), i10 = sr(t10, n10);
  return R.useEffect(() => {
    const o10 = n10.current;
    if (o10)
      return r10.branches.add(o10), () => {
        r10.branches.delete(o10);
      };
  }, [r10.branches]), w.jsx(Zt.div, { ...e10, ref: i10 });
});
XC.displayName = YC;
function JC(e10, t10 = globalThis == null ? void 0 : globalThis.document) {
  const r10 = wr(e10), n10 = R.useRef(false), i10 = R.useRef(() => {
  });
  return R.useEffect(() => {
    const o10 = (a10) => {
      if (a10.target && !n10.current) {
        let c = function() {
          jb(
            GC,
            r10,
            l10,
            { discrete: true }
          );
        };
        const l10 = { originalEvent: a10 };
        a10.pointerType === "touch" ? (t10.removeEventListener("click", i10.current), i10.current = c, t10.addEventListener("click", i10.current, { once: true })) : c();
      } else
        t10.removeEventListener("click", i10.current);
      n10.current = false;
    }, s10 = window.setTimeout(() => {
      t10.addEventListener("pointerdown", o10);
    }, 0);
    return () => {
      window.clearTimeout(s10), t10.removeEventListener("pointerdown", o10), t10.removeEventListener("click", i10.current);
    };
  }, [t10, r10]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => n10.current = true
  };
}
function ZC(e10, t10 = globalThis == null ? void 0 : globalThis.document) {
  const r10 = wr(e10), n10 = R.useRef(false);
  return R.useEffect(() => {
    const i10 = (o10) => {
      o10.target && !n10.current && jb(KC, r10, { originalEvent: o10 }, {
        discrete: false
      });
    };
    return t10.addEventListener("focusin", i10), () => t10.removeEventListener("focusin", i10);
  }, [t10, r10]), {
    onFocusCapture: () => n10.current = true,
    onBlurCapture: () => n10.current = false
  };
}
function Ep() {
  const e10 = new CustomEvent(Qf);
  document.dispatchEvent(e10);
}
function jb(e10, t10, r10, { discrete: n10 }) {
  const i10 = r10.originalEvent.target, o10 = new CustomEvent(e10, { bubbles: false, cancelable: true, detail: r10 });
  t10 && i10.addEventListener(e10, t10, { once: true }), n10 ? Pb(i10, o10) : i10.dispatchEvent(o10);
}
var ro = globalThis != null && globalThis.document ? R.useLayoutEffect : () => {
};
var QC = R["useId".toString()] || (() => {
});
var eT = 0;
function ya(e10) {
  const [t10, r10] = R.useState(QC());
  return ro(() => {
    e10 || r10((n10) => n10 ?? String(eT++));
  }, [e10]), e10 || (t10 ? `radix-${t10}` : "");
}
var tT = ["top", "right", "bottom", "left"];
var no = Math.min;
var Qr = Math.max;
var Xc = Math.round;
var tc = Math.floor;
var Qn = (e10) => ({
  x: e10,
  y: e10
});
var rT = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var nT = {
  start: "end",
  end: "start"
};
function ed(e10, t10, r10) {
  return Qr(e10, no(t10, r10));
}
function Pi(e10, t10) {
  return typeof e10 == "function" ? e10(t10) : e10;
}
function Ni(e10) {
  return e10.split("-")[0];
}
function Ns(e10) {
  return e10.split("-")[1];
}
function g0(e10) {
  return e10 === "x" ? "y" : "x";
}
function v0(e10) {
  return e10 === "y" ? "height" : "width";
}
function io(e10) {
  return ["top", "bottom"].includes(Ni(e10)) ? "y" : "x";
}
function b0(e10) {
  return g0(io(e10));
}
function iT(e10, t10, r10) {
  r10 === void 0 && (r10 = false);
  const n10 = Ns(e10), i10 = b0(e10), o10 = v0(i10);
  let s10 = i10 === "x" ? n10 === (r10 ? "end" : "start") ? "right" : "left" : n10 === "start" ? "bottom" : "top";
  return t10.reference[o10] > t10.floating[o10] && (s10 = Jc(s10)), [s10, Jc(s10)];
}
function oT(e10) {
  const t10 = Jc(e10);
  return [td(e10), t10, td(t10)];
}
function td(e10) {
  return e10.replace(/start|end/g, (t10) => nT[t10]);
}
function sT(e10, t10, r10) {
  const n10 = ["left", "right"], i10 = ["right", "left"], o10 = ["top", "bottom"], s10 = ["bottom", "top"];
  switch (e10) {
    case "top":
    case "bottom":
      return r10 ? t10 ? i10 : n10 : t10 ? n10 : i10;
    case "left":
    case "right":
      return t10 ? o10 : s10;
    default:
      return [];
  }
}
function aT(e10, t10, r10, n10) {
  const i10 = Ns(e10);
  let o10 = sT(Ni(e10), r10 === "start", n10);
  return i10 && (o10 = o10.map((s10) => s10 + "-" + i10), t10 && (o10 = o10.concat(o10.map(td)))), o10;
}
function Jc(e10) {
  return e10.replace(/left|right|bottom|top/g, (t10) => rT[t10]);
}
function cT(e10) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e10
  };
}
function kb(e10) {
  return typeof e10 != "number" ? cT(e10) : {
    top: e10,
    right: e10,
    bottom: e10,
    left: e10
  };
}
function Zc(e10) {
  const {
    x: t10,
    y: r10,
    width: n10,
    height: i10
  } = e10;
  return {
    width: n10,
    height: i10,
    top: r10,
    left: t10,
    right: t10 + n10,
    bottom: r10 + i10,
    x: t10,
    y: r10
  };
}
function Cp(e10, t10, r10) {
  let {
    reference: n10,
    floating: i10
  } = e10;
  const o10 = io(t10), s10 = b0(t10), a10 = v0(s10), c = Ni(t10), l10 = o10 === "y", u10 = n10.x + n10.width / 2 - i10.width / 2, d6 = n10.y + n10.height / 2 - i10.height / 2, p = n10[a10] / 2 - i10[a10] / 2;
  let y;
  switch (c) {
    case "top":
      y = {
        x: u10,
        y: n10.y - i10.height
      };
      break;
    case "bottom":
      y = {
        x: u10,
        y: n10.y + n10.height
      };
      break;
    case "right":
      y = {
        x: n10.x + n10.width,
        y: d6
      };
      break;
    case "left":
      y = {
        x: n10.x - i10.width,
        y: d6
      };
      break;
    default:
      y = {
        x: n10.x,
        y: n10.y
      };
  }
  switch (Ns(t10)) {
    case "start":
      y[s10] -= p * (r10 && l10 ? -1 : 1);
      break;
    case "end":
      y[s10] += p * (r10 && l10 ? -1 : 1);
      break;
  }
  return y;
}
var lT = async (e10, t10, r10) => {
  const {
    placement: n10 = "bottom",
    strategy: i10 = "absolute",
    middleware: o10 = [],
    platform: s10
  } = r10, a10 = o10.filter(Boolean), c = await (s10.isRTL == null ? void 0 : s10.isRTL(t10));
  let l10 = await s10.getElementRects({
    reference: e10,
    floating: t10,
    strategy: i10
  }), {
    x: u10,
    y: d6
  } = Cp(l10, n10, c), p = n10, y = {}, x = 0;
  for (let b = 0; b < a10.length; b++) {
    const {
      name: M,
      fn: O
    } = a10[b], {
      x: P,
      y: j,
      data: F,
      reset: B
    } = await O({
      x: u10,
      y: d6,
      initialPlacement: n10,
      placement: p,
      strategy: i10,
      middlewareData: y,
      rects: l10,
      platform: s10,
      elements: {
        reference: e10,
        floating: t10
      }
    });
    u10 = P ?? u10, d6 = j ?? d6, y = {
      ...y,
      [M]: {
        ...y[M],
        ...F
      }
    }, B && x <= 50 && (x++, typeof B == "object" && (B.placement && (p = B.placement), B.rects && (l10 = B.rects === true ? await s10.getElementRects({
      reference: e10,
      floating: t10,
      strategy: i10
    }) : B.rects), {
      x: u10,
      y: d6
    } = Cp(l10, p, c)), b = -1);
  }
  return {
    x: u10,
    y: d6,
    placement: p,
    strategy: i10,
    middlewareData: y
  };
};
async function wa(e10, t10) {
  var r10;
  t10 === void 0 && (t10 = {});
  const {
    x: n10,
    y: i10,
    platform: o10,
    rects: s10,
    elements: a10,
    strategy: c
  } = e10, {
    boundary: l10 = "clippingAncestors",
    rootBoundary: u10 = "viewport",
    elementContext: d6 = "floating",
    altBoundary: p = false,
    padding: y = 0
  } = Pi(t10, e10), x = kb(y), M = a10[p ? d6 === "floating" ? "reference" : "floating" : d6], O = Zc(await o10.getClippingRect({
    element: (r10 = await (o10.isElement == null ? void 0 : o10.isElement(M))) == null || r10 ? M : M.contextElement || await (o10.getDocumentElement == null ? void 0 : o10.getDocumentElement(a10.floating)),
    boundary: l10,
    rootBoundary: u10,
    strategy: c
  })), P = d6 === "floating" ? {
    x: n10,
    y: i10,
    width: s10.floating.width,
    height: s10.floating.height
  } : s10.reference, j = await (o10.getOffsetParent == null ? void 0 : o10.getOffsetParent(a10.floating)), F = await (o10.isElement == null ? void 0 : o10.isElement(j)) ? await (o10.getScale == null ? void 0 : o10.getScale(j)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = Zc(o10.convertOffsetParentRelativeRectToViewportRelativeRect ? await o10.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a10,
    rect: P,
    offsetParent: j,
    strategy: c
  }) : P);
  return {
    top: (O.top - B.top + x.top) / F.y,
    bottom: (B.bottom - O.bottom + x.bottom) / F.y,
    left: (O.left - B.left + x.left) / F.x,
    right: (B.right - O.right + x.right) / F.x
  };
}
var uT = (e10) => ({
  name: "arrow",
  options: e10,
  async fn(t10) {
    const {
      x: r10,
      y: n10,
      placement: i10,
      rects: o10,
      platform: s10,
      elements: a10,
      middlewareData: c
    } = t10, {
      element: l10,
      padding: u10 = 0
    } = Pi(e10, t10) || {};
    if (l10 == null)
      return {};
    const d6 = kb(u10), p = {
      x: r10,
      y: n10
    }, y = b0(i10), x = v0(y), b = await s10.getDimensions(l10), M = y === "y", O = M ? "top" : "left", P = M ? "bottom" : "right", j = M ? "clientHeight" : "clientWidth", F = o10.reference[x] + o10.reference[y] - p[y] - o10.floating[x], B = p[y] - o10.reference[y], W = await (s10.getOffsetParent == null ? void 0 : s10.getOffsetParent(l10));
    let z = W ? W[j] : 0;
    (!z || !await (s10.isElement == null ? void 0 : s10.isElement(W))) && (z = a10.floating[j] || o10.floating[x]);
    const G = F / 2 - B / 2, re = z / 2 - b[x] / 2 - 1, ie = no(d6[O], re), oe = no(d6[P], re), q = ie, L = z - b[x] - oe, h = z / 2 - b[x] / 2 + G, f = ed(q, h, L), m = !c.arrow && Ns(i10) != null && h !== f && o10.reference[x] / 2 - (h < q ? ie : oe) - b[x] / 2 < 0, S = m ? h < q ? h - q : h - L : 0;
    return {
      [y]: p[y] + S,
      data: {
        [y]: f,
        centerOffset: h - f - S,
        ...m && {
          alignmentOffset: S
        }
      },
      reset: m
    };
  }
});
var fT = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    name: "flip",
    options: e10,
    async fn(t10) {
      var r10, n10;
      const {
        placement: i10,
        middlewareData: o10,
        rects: s10,
        initialPlacement: a10,
        platform: c,
        elements: l10
      } = t10, {
        mainAxis: u10 = true,
        crossAxis: d6 = true,
        fallbackPlacements: p,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: x = "none",
        flipAlignment: b = true,
        ...M
      } = Pi(e10, t10);
      if ((r10 = o10.arrow) != null && r10.alignmentOffset)
        return {};
      const O = Ni(i10), P = io(a10), j = Ni(a10) === a10, F = await (c.isRTL == null ? void 0 : c.isRTL(l10.floating)), B = p || (j || !b ? [Jc(a10)] : oT(a10)), W = x !== "none";
      !p && W && B.push(...aT(a10, b, x, F));
      const z = [a10, ...B], G = await wa(t10, M), re = [];
      let ie = ((n10 = o10.flip) == null ? void 0 : n10.overflows) || [];
      if (u10 && re.push(G[O]), d6) {
        const h = iT(i10, s10, F);
        re.push(G[h[0]], G[h[1]]);
      }
      if (ie = [...ie, {
        placement: i10,
        overflows: re
      }], !re.every((h) => h <= 0)) {
        var oe, q;
        const h = (((oe = o10.flip) == null ? void 0 : oe.index) || 0) + 1, f = z[h];
        if (f)
          return {
            data: {
              index: h,
              overflows: ie
            },
            reset: {
              placement: f
            }
          };
        let m = (q = ie.filter((S) => S.overflows[0] <= 0).sort((S, T) => S.overflows[1] - T.overflows[1])[0]) == null ? void 0 : q.placement;
        if (!m)
          switch (y) {
            case "bestFit": {
              var L;
              const S = (L = ie.filter((T) => {
                if (W) {
                  const E = io(T.placement);
                  return E === P || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  E === "y";
                }
                return true;
              }).map((T) => [T.placement, T.overflows.filter((E) => E > 0).reduce((E, I) => E + I, 0)]).sort((T, E) => T[1] - E[1])[0]) == null ? void 0 : L[0];
              S && (m = S);
              break;
            }
            case "initialPlacement":
              m = a10;
              break;
          }
        if (i10 !== m)
          return {
            reset: {
              placement: m
            }
          };
      }
      return {};
    }
  };
};
function Tp(e10, t10) {
  return {
    top: e10.top - t10.height,
    right: e10.right - t10.width,
    bottom: e10.bottom - t10.height,
    left: e10.left - t10.width
  };
}
function Ap(e10) {
  return tT.some((t10) => e10[t10] >= 0);
}
var dT = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    name: "hide",
    options: e10,
    async fn(t10) {
      const {
        rects: r10
      } = t10, {
        strategy: n10 = "referenceHidden",
        ...i10
      } = Pi(e10, t10);
      switch (n10) {
        case "referenceHidden": {
          const o10 = await wa(t10, {
            ...i10,
            elementContext: "reference"
          }), s10 = Tp(o10, r10.reference);
          return {
            data: {
              referenceHiddenOffsets: s10,
              referenceHidden: Ap(s10)
            }
          };
        }
        case "escaped": {
          const o10 = await wa(t10, {
            ...i10,
            altBoundary: true
          }), s10 = Tp(o10, r10.floating);
          return {
            data: {
              escapedOffsets: s10,
              escaped: Ap(s10)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function hT(e10, t10) {
  const {
    placement: r10,
    platform: n10,
    elements: i10
  } = e10, o10 = await (n10.isRTL == null ? void 0 : n10.isRTL(i10.floating)), s10 = Ni(r10), a10 = Ns(r10), c = io(r10) === "y", l10 = ["left", "top"].includes(s10) ? -1 : 1, u10 = o10 && c ? -1 : 1, d6 = Pi(t10, e10);
  let {
    mainAxis: p,
    crossAxis: y,
    alignmentAxis: x
  } = typeof d6 == "number" ? {
    mainAxis: d6,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d6.mainAxis || 0,
    crossAxis: d6.crossAxis || 0,
    alignmentAxis: d6.alignmentAxis
  };
  return a10 && typeof x == "number" && (y = a10 === "end" ? x * -1 : x), c ? {
    x: y * u10,
    y: p * l10
  } : {
    x: p * l10,
    y: y * u10
  };
}
var pT = function(e10) {
  return e10 === void 0 && (e10 = 0), {
    name: "offset",
    options: e10,
    async fn(t10) {
      var r10, n10;
      const {
        x: i10,
        y: o10,
        placement: s10,
        middlewareData: a10
      } = t10, c = await hT(t10, e10);
      return s10 === ((r10 = a10.offset) == null ? void 0 : r10.placement) && (n10 = a10.arrow) != null && n10.alignmentOffset ? {} : {
        x: i10 + c.x,
        y: o10 + c.y,
        data: {
          ...c,
          placement: s10
        }
      };
    }
  };
};
var mT = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    name: "shift",
    options: e10,
    async fn(t10) {
      const {
        x: r10,
        y: n10,
        placement: i10
      } = t10, {
        mainAxis: o10 = true,
        crossAxis: s10 = false,
        limiter: a10 = {
          fn: (M) => {
            let {
              x: O,
              y: P
            } = M;
            return {
              x: O,
              y: P
            };
          }
        },
        ...c
      } = Pi(e10, t10), l10 = {
        x: r10,
        y: n10
      }, u10 = await wa(t10, c), d6 = io(Ni(i10)), p = g0(d6);
      let y = l10[p], x = l10[d6];
      if (o10) {
        const M = p === "y" ? "top" : "left", O = p === "y" ? "bottom" : "right", P = y + u10[M], j = y - u10[O];
        y = ed(P, y, j);
      }
      if (s10) {
        const M = d6 === "y" ? "top" : "left", O = d6 === "y" ? "bottom" : "right", P = x + u10[M], j = x - u10[O];
        x = ed(P, x, j);
      }
      const b = a10.fn({
        ...t10,
        [p]: y,
        [d6]: x
      });
      return {
        ...b,
        data: {
          x: b.x - r10,
          y: b.y - n10,
          enabled: {
            [p]: o10,
            [d6]: s10
          }
        }
      };
    }
  };
};
var gT = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    options: e10,
    fn(t10) {
      const {
        x: r10,
        y: n10,
        placement: i10,
        rects: o10,
        middlewareData: s10
      } = t10, {
        offset: a10 = 0,
        mainAxis: c = true,
        crossAxis: l10 = true
      } = Pi(e10, t10), u10 = {
        x: r10,
        y: n10
      }, d6 = io(i10), p = g0(d6);
      let y = u10[p], x = u10[d6];
      const b = Pi(a10, t10), M = typeof b == "number" ? {
        mainAxis: b,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...b
      };
      if (c) {
        const j = p === "y" ? "height" : "width", F = o10.reference[p] - o10.floating[j] + M.mainAxis, B = o10.reference[p] + o10.reference[j] - M.mainAxis;
        y < F ? y = F : y > B && (y = B);
      }
      if (l10) {
        var O, P;
        const j = p === "y" ? "width" : "height", F = ["top", "left"].includes(Ni(i10)), B = o10.reference[d6] - o10.floating[j] + (F && ((O = s10.offset) == null ? void 0 : O[d6]) || 0) + (F ? 0 : M.crossAxis), W = o10.reference[d6] + o10.reference[j] + (F ? 0 : ((P = s10.offset) == null ? void 0 : P[d6]) || 0) - (F ? M.crossAxis : 0);
        x < B ? x = B : x > W && (x = W);
      }
      return {
        [p]: y,
        [d6]: x
      };
    }
  };
};
var vT = function(e10) {
  return e10 === void 0 && (e10 = {}), {
    name: "size",
    options: e10,
    async fn(t10) {
      var r10, n10;
      const {
        placement: i10,
        rects: o10,
        platform: s10,
        elements: a10
      } = t10, {
        apply: c = () => {
        },
        ...l10
      } = Pi(e10, t10), u10 = await wa(t10, l10), d6 = Ni(i10), p = Ns(i10), y = io(i10) === "y", {
        width: x,
        height: b
      } = o10.floating;
      let M, O;
      d6 === "top" || d6 === "bottom" ? (M = d6, O = p === (await (s10.isRTL == null ? void 0 : s10.isRTL(a10.floating)) ? "start" : "end") ? "left" : "right") : (O = d6, M = p === "end" ? "top" : "bottom");
      const P = b - u10.top - u10.bottom, j = x - u10.left - u10.right, F = no(b - u10[M], P), B = no(x - u10[O], j), W = !t10.middlewareData.shift;
      let z = F, G = B;
      if ((r10 = t10.middlewareData.shift) != null && r10.enabled.x && (G = j), (n10 = t10.middlewareData.shift) != null && n10.enabled.y && (z = P), W && !p) {
        const ie = Qr(u10.left, 0), oe = Qr(u10.right, 0), q = Qr(u10.top, 0), L = Qr(u10.bottom, 0);
        y ? G = x - 2 * (ie !== 0 || oe !== 0 ? ie + oe : Qr(u10.left, u10.right)) : z = b - 2 * (q !== 0 || L !== 0 ? q + L : Qr(u10.top, u10.bottom));
      }
      await c({
        ...t10,
        availableWidth: G,
        availableHeight: z
      });
      const re = await s10.getDimensions(a10.floating);
      return x !== re.width || b !== re.height ? {
        reset: {
          rects: true
        }
      } : {};
    }
  };
};
function Bl() {
  return typeof window < "u";
}
function js(e10) {
  return Db(e10) ? (e10.nodeName || "").toLowerCase() : "#document";
}
function nn(e10) {
  var t10;
  return (e10 == null || (t10 = e10.ownerDocument) == null ? void 0 : t10.defaultView) || window;
}
function oi(e10) {
  var t10;
  return (t10 = (Db(e10) ? e10.ownerDocument : e10.document) || window.document) == null ? void 0 : t10.documentElement;
}
function Db(e10) {
  return Bl() ? e10 instanceof Node || e10 instanceof nn(e10).Node : false;
}
function Bn(e10) {
  return Bl() ? e10 instanceof Element || e10 instanceof nn(e10).Element : false;
}
function ni(e10) {
  return Bl() ? e10 instanceof HTMLElement || e10 instanceof nn(e10).HTMLElement : false;
}
function Mp(e10) {
  return !Bl() || typeof ShadowRoot > "u" ? false : e10 instanceof ShadowRoot || e10 instanceof nn(e10).ShadowRoot;
}
function Ua(e10) {
  const {
    overflow: t10,
    overflowX: r10,
    overflowY: n10,
    display: i10
  } = Un(e10);
  return /auto|scroll|overlay|hidden|clip/.test(t10 + n10 + r10) && !["inline", "contents"].includes(i10);
}
function bT(e10) {
  return ["table", "td", "th"].includes(js(e10));
}
function Ul(e10) {
  return [":popover-open", ":modal"].some((t10) => {
    try {
      return e10.matches(t10);
    } catch {
      return false;
    }
  });
}
function y0(e10) {
  const t10 = w0(), r10 = Bn(e10) ? Un(e10) : e10;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((n10) => r10[n10] ? r10[n10] !== "none" : false) || (r10.containerType ? r10.containerType !== "normal" : false) || !t10 && (r10.backdropFilter ? r10.backdropFilter !== "none" : false) || !t10 && (r10.filter ? r10.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((n10) => (r10.willChange || "").includes(n10)) || ["paint", "layout", "strict", "content"].some((n10) => (r10.contain || "").includes(n10));
}
function yT(e10) {
  let t10 = oo(e10);
  for (; ni(t10) && !_s(t10); ) {
    if (y0(t10))
      return t10;
    if (Ul(t10))
      return null;
    t10 = oo(t10);
  }
  return null;
}
function w0() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function _s(e10) {
  return ["html", "body", "#document"].includes(js(e10));
}
function Un(e10) {
  return nn(e10).getComputedStyle(e10);
}
function Fl(e10) {
  return Bn(e10) ? {
    scrollLeft: e10.scrollLeft,
    scrollTop: e10.scrollTop
  } : {
    scrollLeft: e10.scrollX,
    scrollTop: e10.scrollY
  };
}
function oo(e10) {
  if (js(e10) === "html")
    return e10;
  const t10 = (
    // Step into the shadow DOM of the parent of a slotted node.
    e10.assignedSlot || // DOM Element detected.
    e10.parentNode || // ShadowRoot detected.
    Mp(e10) && e10.host || // Fallback.
    oi(e10)
  );
  return Mp(t10) ? t10.host : t10;
}
function Lb(e10) {
  const t10 = oo(e10);
  return _s(t10) ? e10.ownerDocument ? e10.ownerDocument.body : e10.body : ni(t10) && Ua(t10) ? t10 : Lb(t10);
}
function xa(e10, t10, r10) {
  var n10;
  t10 === void 0 && (t10 = []), r10 === void 0 && (r10 = true);
  const i10 = Lb(e10), o10 = i10 === ((n10 = e10.ownerDocument) == null ? void 0 : n10.body), s10 = nn(i10);
  if (o10) {
    const a10 = rd(s10);
    return t10.concat(s10, s10.visualViewport || [], Ua(i10) ? i10 : [], a10 && r10 ? xa(a10) : []);
  }
  return t10.concat(i10, xa(i10, [], r10));
}
function rd(e10) {
  return e10.parent && Object.getPrototypeOf(e10.parent) ? e10.frameElement : null;
}
function Bb(e10) {
  const t10 = Un(e10);
  let r10 = parseFloat(t10.width) || 0, n10 = parseFloat(t10.height) || 0;
  const i10 = ni(e10), o10 = i10 ? e10.offsetWidth : r10, s10 = i10 ? e10.offsetHeight : n10, a10 = Xc(r10) !== o10 || Xc(n10) !== s10;
  return a10 && (r10 = o10, n10 = s10), {
    width: r10,
    height: n10,
    $: a10
  };
}
function x0(e10) {
  return Bn(e10) ? e10 : e10.contextElement;
}
function ps(e10) {
  const t10 = x0(e10);
  if (!ni(t10))
    return Qn(1);
  const r10 = t10.getBoundingClientRect(), {
    width: n10,
    height: i10,
    $: o10
  } = Bb(t10);
  let s10 = (o10 ? Xc(r10.width) : r10.width) / n10, a10 = (o10 ? Xc(r10.height) : r10.height) / i10;
  return (!s10 || !Number.isFinite(s10)) && (s10 = 1), (!a10 || !Number.isFinite(a10)) && (a10 = 1), {
    x: s10,
    y: a10
  };
}
var wT = Qn(0);
function Ub(e10) {
  const t10 = nn(e10);
  return !w0() || !t10.visualViewport ? wT : {
    x: t10.visualViewport.offsetLeft,
    y: t10.visualViewport.offsetTop
  };
}
function xT(e10, t10, r10) {
  return t10 === void 0 && (t10 = false), !r10 || t10 && r10 !== nn(e10) ? false : t10;
}
function Lo(e10, t10, r10, n10) {
  t10 === void 0 && (t10 = false), r10 === void 0 && (r10 = false);
  const i10 = e10.getBoundingClientRect(), o10 = x0(e10);
  let s10 = Qn(1);
  t10 && (n10 ? Bn(n10) && (s10 = ps(n10)) : s10 = ps(e10));
  const a10 = xT(o10, r10, n10) ? Ub(o10) : Qn(0);
  let c = (i10.left + a10.x) / s10.x, l10 = (i10.top + a10.y) / s10.y, u10 = i10.width / s10.x, d6 = i10.height / s10.y;
  if (o10) {
    const p = nn(o10), y = n10 && Bn(n10) ? nn(n10) : n10;
    let x = p, b = rd(x);
    for (; b && n10 && y !== x; ) {
      const M = ps(b), O = b.getBoundingClientRect(), P = Un(b), j = O.left + (b.clientLeft + parseFloat(P.paddingLeft)) * M.x, F = O.top + (b.clientTop + parseFloat(P.paddingTop)) * M.y;
      c *= M.x, l10 *= M.y, u10 *= M.x, d6 *= M.y, c += j, l10 += F, x = nn(b), b = rd(x);
    }
  }
  return Zc({
    width: u10,
    height: d6,
    x: c,
    y: l10
  });
}
function S0(e10, t10) {
  const r10 = Fl(e10).scrollLeft;
  return t10 ? t10.left + r10 : Lo(oi(e10)).left + r10;
}
function Fb(e10, t10, r10) {
  r10 === void 0 && (r10 = false);
  const n10 = e10.getBoundingClientRect(), i10 = n10.left + t10.scrollLeft - (r10 ? 0 : (
    // RTL <body> scrollbar.
    S0(e10, n10)
  )), o10 = n10.top + t10.scrollTop;
  return {
    x: i10,
    y: o10
  };
}
function ST(e10) {
  let {
    elements: t10,
    rect: r10,
    offsetParent: n10,
    strategy: i10
  } = e10;
  const o10 = i10 === "fixed", s10 = oi(n10), a10 = t10 ? Ul(t10.floating) : false;
  if (n10 === s10 || a10 && o10)
    return r10;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, l10 = Qn(1);
  const u10 = Qn(0), d6 = ni(n10);
  if ((d6 || !d6 && !o10) && ((js(n10) !== "body" || Ua(s10)) && (c = Fl(n10)), ni(n10))) {
    const y = Lo(n10);
    l10 = ps(n10), u10.x = y.x + n10.clientLeft, u10.y = y.y + n10.clientTop;
  }
  const p = s10 && !d6 && !o10 ? Fb(s10, c, true) : Qn(0);
  return {
    width: r10.width * l10.x,
    height: r10.height * l10.y,
    x: r10.x * l10.x - c.scrollLeft * l10.x + u10.x + p.x,
    y: r10.y * l10.y - c.scrollTop * l10.y + u10.y + p.y
  };
}
function _T(e10) {
  return Array.from(e10.getClientRects());
}
function ET(e10) {
  const t10 = oi(e10), r10 = Fl(e10), n10 = e10.ownerDocument.body, i10 = Qr(t10.scrollWidth, t10.clientWidth, n10.scrollWidth, n10.clientWidth), o10 = Qr(t10.scrollHeight, t10.clientHeight, n10.scrollHeight, n10.clientHeight);
  let s10 = -r10.scrollLeft + S0(e10);
  const a10 = -r10.scrollTop;
  return Un(n10).direction === "rtl" && (s10 += Qr(t10.clientWidth, n10.clientWidth) - i10), {
    width: i10,
    height: o10,
    x: s10,
    y: a10
  };
}
function CT(e10, t10) {
  const r10 = nn(e10), n10 = oi(e10), i10 = r10.visualViewport;
  let o10 = n10.clientWidth, s10 = n10.clientHeight, a10 = 0, c = 0;
  if (i10) {
    o10 = i10.width, s10 = i10.height;
    const l10 = w0();
    (!l10 || l10 && t10 === "fixed") && (a10 = i10.offsetLeft, c = i10.offsetTop);
  }
  return {
    width: o10,
    height: s10,
    x: a10,
    y: c
  };
}
function TT(e10, t10) {
  const r10 = Lo(e10, true, t10 === "fixed"), n10 = r10.top + e10.clientTop, i10 = r10.left + e10.clientLeft, o10 = ni(e10) ? ps(e10) : Qn(1), s10 = e10.clientWidth * o10.x, a10 = e10.clientHeight * o10.y, c = i10 * o10.x, l10 = n10 * o10.y;
  return {
    width: s10,
    height: a10,
    x: c,
    y: l10
  };
}
function Ip(e10, t10, r10) {
  let n10;
  if (t10 === "viewport")
    n10 = CT(e10, r10);
  else if (t10 === "document")
    n10 = ET(oi(e10));
  else if (Bn(t10))
    n10 = TT(t10, r10);
  else {
    const i10 = Ub(e10);
    n10 = {
      x: t10.x - i10.x,
      y: t10.y - i10.y,
      width: t10.width,
      height: t10.height
    };
  }
  return Zc(n10);
}
function $b(e10, t10) {
  const r10 = oo(e10);
  return r10 === t10 || !Bn(r10) || _s(r10) ? false : Un(r10).position === "fixed" || $b(r10, t10);
}
function AT(e10, t10) {
  const r10 = t10.get(e10);
  if (r10)
    return r10;
  let n10 = xa(e10, [], false).filter((a10) => Bn(a10) && js(a10) !== "body"), i10 = null;
  const o10 = Un(e10).position === "fixed";
  let s10 = o10 ? oo(e10) : e10;
  for (; Bn(s10) && !_s(s10); ) {
    const a10 = Un(s10), c = y0(s10);
    !c && a10.position === "fixed" && (i10 = null), (o10 ? !c && !i10 : !c && a10.position === "static" && !!i10 && ["absolute", "fixed"].includes(i10.position) || Ua(s10) && !c && $b(e10, s10)) ? n10 = n10.filter((u10) => u10 !== s10) : i10 = a10, s10 = oo(s10);
  }
  return t10.set(e10, n10), n10;
}
function MT(e10) {
  let {
    element: t10,
    boundary: r10,
    rootBoundary: n10,
    strategy: i10
  } = e10;
  const s10 = [...r10 === "clippingAncestors" ? Ul(t10) ? [] : AT(t10, this._c) : [].concat(r10), n10], a10 = s10[0], c = s10.reduce((l10, u10) => {
    const d6 = Ip(t10, u10, i10);
    return l10.top = Qr(d6.top, l10.top), l10.right = no(d6.right, l10.right), l10.bottom = no(d6.bottom, l10.bottom), l10.left = Qr(d6.left, l10.left), l10;
  }, Ip(t10, a10, i10));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function IT(e10) {
  const {
    width: t10,
    height: r10
  } = Bb(e10);
  return {
    width: t10,
    height: r10
  };
}
function OT(e10, t10, r10) {
  const n10 = ni(t10), i10 = oi(t10), o10 = r10 === "fixed", s10 = Lo(e10, true, o10, t10);
  let a10 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Qn(0);
  if (n10 || !n10 && !o10)
    if ((js(t10) !== "body" || Ua(i10)) && (a10 = Fl(t10)), n10) {
      const p = Lo(t10, true, o10, t10);
      c.x = p.x + t10.clientLeft, c.y = p.y + t10.clientTop;
    } else
      i10 && (c.x = S0(i10));
  const l10 = i10 && !n10 && !o10 ? Fb(i10, a10) : Qn(0), u10 = s10.left + a10.scrollLeft - c.x - l10.x, d6 = s10.top + a10.scrollTop - c.y - l10.y;
  return {
    x: u10,
    y: d6,
    width: s10.width,
    height: s10.height
  };
}
function Wu(e10) {
  return Un(e10).position === "static";
}
function Op(e10, t10) {
  if (!ni(e10) || Un(e10).position === "fixed")
    return null;
  if (t10)
    return t10(e10);
  let r10 = e10.offsetParent;
  return oi(e10) === r10 && (r10 = r10.ownerDocument.body), r10;
}
function Vb(e10, t10) {
  const r10 = nn(e10);
  if (Ul(e10))
    return r10;
  if (!ni(e10)) {
    let i10 = oo(e10);
    for (; i10 && !_s(i10); ) {
      if (Bn(i10) && !Wu(i10))
        return i10;
      i10 = oo(i10);
    }
    return r10;
  }
  let n10 = Op(e10, t10);
  for (; n10 && bT(n10) && Wu(n10); )
    n10 = Op(n10, t10);
  return n10 && _s(n10) && Wu(n10) && !y0(n10) ? r10 : n10 || yT(e10) || r10;
}
var RT = async function(e10) {
  const t10 = this.getOffsetParent || Vb, r10 = this.getDimensions, n10 = await r10(e10.floating);
  return {
    reference: OT(e10.reference, await t10(e10.floating), e10.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n10.width,
      height: n10.height
    }
  };
};
function PT(e10) {
  return Un(e10).direction === "rtl";
}
var NT = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ST,
  getDocumentElement: oi,
  getClippingRect: MT,
  getOffsetParent: Vb,
  getElementRects: RT,
  getClientRects: _T,
  getDimensions: IT,
  getScale: ps,
  isElement: Bn,
  isRTL: PT
};
function zb(e10, t10) {
  return e10.x === t10.x && e10.y === t10.y && e10.width === t10.width && e10.height === t10.height;
}
function jT(e10, t10) {
  let r10 = null, n10;
  const i10 = oi(e10);
  function o10() {
    var a10;
    clearTimeout(n10), (a10 = r10) == null || a10.disconnect(), r10 = null;
  }
  function s10(a10, c) {
    a10 === void 0 && (a10 = false), c === void 0 && (c = 1), o10();
    const l10 = e10.getBoundingClientRect(), {
      left: u10,
      top: d6,
      width: p,
      height: y
    } = l10;
    if (a10 || t10(), !p || !y)
      return;
    const x = tc(d6), b = tc(i10.clientWidth - (u10 + p)), M = tc(i10.clientHeight - (d6 + y)), O = tc(u10), j = {
      rootMargin: -x + "px " + -b + "px " + -M + "px " + -O + "px",
      threshold: Qr(0, no(1, c)) || 1
    };
    let F = true;
    function B(W) {
      const z = W[0].intersectionRatio;
      if (z !== c) {
        if (!F)
          return s10();
        z ? s10(false, z) : n10 = setTimeout(() => {
          s10(false, 1e-7);
        }, 1e3);
      }
      z === 1 && !zb(l10, e10.getBoundingClientRect()) && s10(), F = false;
    }
    try {
      r10 = new IntersectionObserver(B, {
        ...j,
        // Handle <iframe>s
        root: i10.ownerDocument
      });
    } catch {
      r10 = new IntersectionObserver(B, j);
    }
    r10.observe(e10);
  }
  return s10(true), o10;
}
function kT(e10, t10, r10, n10) {
  n10 === void 0 && (n10 = {});
  const {
    ancestorScroll: i10 = true,
    ancestorResize: o10 = true,
    elementResize: s10 = typeof ResizeObserver == "function",
    layoutShift: a10 = typeof IntersectionObserver == "function",
    animationFrame: c = false
  } = n10, l10 = x0(e10), u10 = i10 || o10 ? [...l10 ? xa(l10) : [], ...xa(t10)] : [];
  u10.forEach((O) => {
    i10 && O.addEventListener("scroll", r10, {
      passive: true
    }), o10 && O.addEventListener("resize", r10);
  });
  const d6 = l10 && a10 ? jT(l10, r10) : null;
  let p = -1, y = null;
  s10 && (y = new ResizeObserver((O) => {
    let [P] = O;
    P && P.target === l10 && y && (y.unobserve(t10), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var j;
      (j = y) == null || j.observe(t10);
    })), r10();
  }), l10 && !c && y.observe(l10), y.observe(t10));
  let x, b = c ? Lo(e10) : null;
  c && M();
  function M() {
    const O = Lo(e10);
    b && !zb(b, O) && r10(), b = O, x = requestAnimationFrame(M);
  }
  return r10(), () => {
    var O;
    u10.forEach((P) => {
      i10 && P.removeEventListener("scroll", r10), o10 && P.removeEventListener("resize", r10);
    }), d6 == null || d6(), (O = y) == null || O.disconnect(), y = null, c && cancelAnimationFrame(x);
  };
}
var DT = pT;
var LT = mT;
var BT = fT;
var UT = vT;
var FT = dT;
var Rp = uT;
var $T = gT;
var VT = (e10, t10, r10) => {
  const n10 = /* @__PURE__ */ new Map(), i10 = {
    platform: NT,
    ...r10
  }, o10 = {
    ...i10.platform,
    _c: n10
  };
  return lT(e10, t10, {
    ...i10,
    platform: o10
  });
};
var _c = typeof document < "u" ? import_react25.useLayoutEffect : import_react25.useEffect;
function Qc(e10, t10) {
  if (e10 === t10)
    return true;
  if (typeof e10 != typeof t10)
    return false;
  if (typeof e10 == "function" && e10.toString() === t10.toString())
    return true;
  let r10, n10, i10;
  if (e10 && t10 && typeof e10 == "object") {
    if (Array.isArray(e10)) {
      if (r10 = e10.length, r10 !== t10.length)
        return false;
      for (n10 = r10; n10-- !== 0; )
        if (!Qc(e10[n10], t10[n10]))
          return false;
      return true;
    }
    if (i10 = Object.keys(e10), r10 = i10.length, r10 !== Object.keys(t10).length)
      return false;
    for (n10 = r10; n10-- !== 0; )
      if (!{}.hasOwnProperty.call(t10, i10[n10]))
        return false;
    for (n10 = r10; n10-- !== 0; ) {
      const o10 = i10[n10];
      if (!(o10 === "_owner" && e10.$$typeof) && !Qc(e10[o10], t10[o10]))
        return false;
    }
    return true;
  }
  return e10 !== e10 && t10 !== t10;
}
function qb(e10) {
  return typeof window > "u" ? 1 : (e10.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Pp(e10, t10) {
  const r10 = qb(e10);
  return Math.round(t10 * r10) / r10;
}
function Gu(e10) {
  const t10 = R.useRef(e10);
  return _c(() => {
    t10.current = e10;
  }), t10;
}
function zT(e10) {
  e10 === void 0 && (e10 = {});
  const {
    placement: t10 = "bottom",
    strategy: r10 = "absolute",
    middleware: n10 = [],
    platform: i10,
    elements: {
      reference: o10,
      floating: s10
    } = {},
    transform: a10 = true,
    whileElementsMounted: c,
    open: l10
  } = e10, [u10, d6] = R.useState({
    x: 0,
    y: 0,
    strategy: r10,
    placement: t10,
    middlewareData: {},
    isPositioned: false
  }), [p, y] = R.useState(n10);
  Qc(p, n10) || y(n10);
  const [x, b] = R.useState(null), [M, O] = R.useState(null), P = R.useCallback((T) => {
    T !== W.current && (W.current = T, b(T));
  }, []), j = R.useCallback((T) => {
    T !== z.current && (z.current = T, O(T));
  }, []), F = o10 || x, B = s10 || M, W = R.useRef(null), z = R.useRef(null), G = R.useRef(u10), re = c != null, ie = Gu(c), oe = Gu(i10), q = Gu(l10), L = R.useCallback(() => {
    if (!W.current || !z.current)
      return;
    const T = {
      placement: t10,
      strategy: r10,
      middleware: p
    };
    oe.current && (T.platform = oe.current), VT(W.current, z.current, T).then((E) => {
      const I = {
        ...E,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: q.current !== false
      };
      h.current && !Qc(G.current, I) && (G.current = I, zm.flushSync(() => {
        d6(I);
      }));
    });
  }, [p, t10, r10, oe, q]);
  _c(() => {
    l10 === false && G.current.isPositioned && (G.current.isPositioned = false, d6((T) => ({
      ...T,
      isPositioned: false
    })));
  }, [l10]);
  const h = R.useRef(false);
  _c(() => (h.current = true, () => {
    h.current = false;
  }), []), _c(() => {
    if (F && (W.current = F), B && (z.current = B), F && B) {
      if (ie.current)
        return ie.current(F, B, L);
      L();
    }
  }, [F, B, L, ie, re]);
  const f = R.useMemo(() => ({
    reference: W,
    floating: z,
    setReference: P,
    setFloating: j
  }), [P, j]), m = R.useMemo(() => ({
    reference: F,
    floating: B
  }), [F, B]), S = R.useMemo(() => {
    const T = {
      position: r10,
      left: 0,
      top: 0
    };
    if (!m.floating)
      return T;
    const E = Pp(m.floating, u10.x), I = Pp(m.floating, u10.y);
    return a10 ? {
      ...T,
      transform: "translate(" + E + "px, " + I + "px)",
      ...qb(m.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: r10,
      left: E,
      top: I
    };
  }, [r10, a10, m.floating, u10.x, u10.y]);
  return R.useMemo(() => ({
    ...u10,
    update: L,
    refs: f,
    elements: m,
    floatingStyles: S
  }), [u10, L, f, m, S]);
}
var qT = (e10) => {
  function t10(r10) {
    return {}.hasOwnProperty.call(r10, "current");
  }
  return {
    name: "arrow",
    options: e10,
    fn(r10) {
      const {
        element: n10,
        padding: i10
      } = typeof e10 == "function" ? e10(r10) : e10;
      return n10 && t10(n10) ? n10.current != null ? Rp({
        element: n10.current,
        padding: i10
      }).fn(r10) : {} : n10 ? Rp({
        element: n10,
        padding: i10
      }).fn(r10) : {};
    }
  };
};
var HT = (e10, t10) => ({
  ...DT(e10),
  options: [e10, t10]
});
var WT = (e10, t10) => ({
  ...LT(e10),
  options: [e10, t10]
});
var GT = (e10, t10) => ({
  ...$T(e10),
  options: [e10, t10]
});
var KT = (e10, t10) => ({
  ...BT(e10),
  options: [e10, t10]
});
var YT = (e10, t10) => ({
  ...UT(e10),
  options: [e10, t10]
});
var XT = (e10, t10) => ({
  ...FT(e10),
  options: [e10, t10]
});
var JT = (e10, t10) => ({
  ...qT(e10),
  options: [e10, t10]
});
var ZT = "Arrow";
var Hb = R.forwardRef((e10, t10) => {
  const { children: r10, width: n10 = 10, height: i10 = 5, ...o10 } = e10;
  return w.jsx(
    Zt.svg,
    {
      ...o10,
      ref: t10,
      width: n10,
      height: i10,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e10.asChild ? r10 : w.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Hb.displayName = ZT;
var QT = Hb;
function _0(e10) {
  const [t10, r10] = R.useState(void 0);
  return ro(() => {
    if (e10) {
      r10({ width: e10.offsetWidth, height: e10.offsetHeight });
      const n10 = new ResizeObserver((i10) => {
        if (!Array.isArray(i10) || !i10.length)
          return;
        const o10 = i10[0];
        let s10, a10;
        if ("borderBoxSize" in o10) {
          const c = o10.borderBoxSize, l10 = Array.isArray(c) ? c[0] : c;
          s10 = l10.inlineSize, a10 = l10.blockSize;
        } else
          s10 = e10.offsetWidth, a10 = e10.offsetHeight;
        r10({ width: s10, height: a10 });
      });
      return n10.observe(e10, { box: "border-box" }), () => n10.unobserve(e10);
    } else
      r10(void 0);
  }, [e10]), t10;
}
var E0 = "Popper";
var [Wb, $l] = Di(E0);
var [eA, Gb] = Wb(E0);
var Kb = (e10) => {
  const { __scopePopper: t10, children: r10 } = e10, [n10, i10] = R.useState(null);
  return w.jsx(eA, { scope: t10, anchor: n10, onAnchorChange: i10, children: r10 });
};
Kb.displayName = E0;
var Yb = "PopperAnchor";
var Xb = R.forwardRef(
  (e10, t10) => {
    const { __scopePopper: r10, virtualRef: n10, ...i10 } = e10, o10 = Gb(Yb, r10), s10 = R.useRef(null), a10 = sr(t10, s10);
    return R.useEffect(() => {
      o10.onAnchorChange((n10 == null ? void 0 : n10.current) || s10.current);
    }), n10 ? null : w.jsx(Zt.div, { ...i10, ref: a10 });
  }
);
Xb.displayName = Yb;
var C0 = "PopperContent";
var [tA, rA] = Wb(C0);
var Jb = R.forwardRef(
  (e10, t10) => {
    var ae, ve, we, he, De, Te;
    const {
      __scopePopper: r10,
      side: n10 = "bottom",
      sideOffset: i10 = 0,
      align: o10 = "center",
      alignOffset: s10 = 0,
      arrowPadding: a10 = 0,
      avoidCollisions: c = true,
      collisionBoundary: l10 = [],
      collisionPadding: u10 = 0,
      sticky: d6 = "partial",
      hideWhenDetached: p = false,
      updatePositionStrategy: y = "optimized",
      onPlaced: x,
      ...b
    } = e10, M = Gb(C0, r10), [O, P] = R.useState(null), j = sr(t10, (Xe) => P(Xe)), [F, B] = R.useState(null), W = _0(F), z = (W == null ? void 0 : W.width) ?? 0, G = (W == null ? void 0 : W.height) ?? 0, re = n10 + (o10 !== "center" ? "-" + o10 : ""), ie = typeof u10 == "number" ? u10 : { top: 0, right: 0, bottom: 0, left: 0, ...u10 }, oe = Array.isArray(l10) ? l10 : [l10], q = oe.length > 0, L = {
      padding: ie,
      boundary: oe.filter(iA),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: q
    }, { refs: h, floatingStyles: f, placement: m, isPositioned: S, middlewareData: T } = zT({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: re,
      whileElementsMounted: (...Xe) => kT(...Xe, {
        animationFrame: y === "always"
      }),
      elements: {
        reference: M.anchor
      },
      middleware: [
        HT({ mainAxis: i10 + G, alignmentAxis: s10 }),
        c && WT({
          mainAxis: true,
          crossAxis: false,
          limiter: d6 === "partial" ? GT() : void 0,
          ...L
        }),
        c && KT({ ...L }),
        YT({
          ...L,
          apply: ({ elements: Xe, rects: ft, availableWidth: je, availableHeight: ht }) => {
            const { width: ye, height: de } = ft.reference, Ee = Xe.floating.style;
            Ee.setProperty("--radix-popper-available-width", `${je}px`), Ee.setProperty("--radix-popper-available-height", `${ht}px`), Ee.setProperty("--radix-popper-anchor-width", `${ye}px`), Ee.setProperty("--radix-popper-anchor-height", `${de}px`);
          }
        }),
        F && JT({ element: F, padding: a10 }),
        oA({ arrowWidth: z, arrowHeight: G }),
        p && XT({ strategy: "referenceHidden", ...L })
      ]
    }), [E, I] = ey(m), C = wr(x);
    ro(() => {
      S && (C == null || C());
    }, [S, C]);
    const g = (ae = T.arrow) == null ? void 0 : ae.x, v10 = (ve = T.arrow) == null ? void 0 : ve.y, k = ((we = T.arrow) == null ? void 0 : we.centerOffset) !== 0, [Q, Z] = R.useState();
    return ro(() => {
      O && Z(window.getComputedStyle(O).zIndex);
    }, [O]), w.jsx(
      "div",
      {
        ref: h.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...f,
          transform: S ? f.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Q,
          "--radix-popper-transform-origin": [
            (he = T.transformOrigin) == null ? void 0 : he.x,
            (De = T.transformOrigin) == null ? void 0 : De.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((Te = T.hide) == null ? void 0 : Te.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e10.dir,
        children: w.jsx(
          tA,
          {
            scope: r10,
            placedSide: E,
            onArrowChange: B,
            arrowX: g,
            arrowY: v10,
            shouldHideArrow: k,
            children: w.jsx(
              Zt.div,
              {
                "data-side": E,
                "data-align": I,
                ...b,
                ref: j,
                style: {
                  ...b.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: S ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
Jb.displayName = C0;
var Zb = "PopperArrow";
var nA = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var Qb = R.forwardRef(function(t10, r10) {
  const { __scopePopper: n10, ...i10 } = t10, o10 = rA(Zb, n10), s10 = nA[o10.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    w.jsx(
      "span",
      {
        ref: o10.onArrowChange,
        style: {
          position: "absolute",
          left: o10.arrowX,
          top: o10.arrowY,
          [s10]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o10.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o10.placedSide],
          visibility: o10.shouldHideArrow ? "hidden" : void 0
        },
        children: w.jsx(
          QT,
          {
            ...i10,
            ref: r10,
            style: {
              ...i10.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
Qb.displayName = Zb;
function iA(e10) {
  return e10 !== null;
}
var oA = (e10) => ({
  name: "transformOrigin",
  options: e10,
  fn(t10) {
    var M, O, P;
    const { placement: r10, rects: n10, middlewareData: i10 } = t10, s10 = ((M = i10.arrow) == null ? void 0 : M.centerOffset) !== 0, a10 = s10 ? 0 : e10.arrowWidth, c = s10 ? 0 : e10.arrowHeight, [l10, u10] = ey(r10), d6 = { start: "0%", center: "50%", end: "100%" }[u10], p = (((O = i10.arrow) == null ? void 0 : O.x) ?? 0) + a10 / 2, y = (((P = i10.arrow) == null ? void 0 : P.y) ?? 0) + c / 2;
    let x = "", b = "";
    return l10 === "bottom" ? (x = s10 ? d6 : `${p}px`, b = `${-c}px`) : l10 === "top" ? (x = s10 ? d6 : `${p}px`, b = `${n10.floating.height + c}px`) : l10 === "right" ? (x = `${-c}px`, b = s10 ? d6 : `${y}px`) : l10 === "left" && (x = `${n10.floating.width + c}px`, b = s10 ? d6 : `${y}px`), { data: { x, y: b } };
  }
});
function ey(e10) {
  const [t10, r10 = "center"] = e10.split("-");
  return [t10, r10];
}
var ty = Kb;
var ry = Xb;
var ny = Jb;
var iy = Qb;
var sA = "Portal";
var oy = R.forwardRef((e10, t10) => {
  var a10;
  const { container: r10, ...n10 } = e10, [i10, o10] = R.useState(false);
  ro(() => o10(true), []);
  const s10 = r10 || i10 && ((a10 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a10.body);
  return s10 ? import_react_dom3.default.createPortal(w.jsx(Zt.div, { ...n10, ref: t10 }), s10) : null;
});
oy.displayName = sA;
function aA(e10, t10) {
  return R.useReducer((r10, n10) => t10[r10][n10] ?? r10, e10);
}
var $n = (e10) => {
  const { present: t10, children: r10 } = e10, n10 = cA(t10), i10 = typeof r10 == "function" ? r10({ present: n10.isPresent }) : R.Children.only(r10), o10 = sr(n10.ref, lA(i10));
  return typeof r10 == "function" || n10.isPresent ? R.cloneElement(i10, { ref: o10 }) : null;
};
$n.displayName = "Presence";
function cA(e10) {
  const [t10, r10] = R.useState(), n10 = R.useRef({}), i10 = R.useRef(e10), o10 = R.useRef("none"), s10 = e10 ? "mounted" : "unmounted", [a10, c] = aA(s10, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return R.useEffect(() => {
    const l10 = rc(n10.current);
    o10.current = a10 === "mounted" ? l10 : "none";
  }, [a10]), ro(() => {
    const l10 = n10.current, u10 = i10.current;
    if (u10 !== e10) {
      const p = o10.current, y = rc(l10);
      e10 ? c("MOUNT") : y === "none" || (l10 == null ? void 0 : l10.display) === "none" ? c("UNMOUNT") : c(u10 && p !== y ? "ANIMATION_OUT" : "UNMOUNT"), i10.current = e10;
    }
  }, [e10, c]), ro(() => {
    if (t10) {
      let l10;
      const u10 = t10.ownerDocument.defaultView ?? window, d6 = (y) => {
        const b = rc(n10.current).includes(y.animationName);
        if (y.target === t10 && b && (c("ANIMATION_END"), !i10.current)) {
          const M = t10.style.animationFillMode;
          t10.style.animationFillMode = "forwards", l10 = u10.setTimeout(() => {
            t10.style.animationFillMode === "forwards" && (t10.style.animationFillMode = M);
          });
        }
      }, p = (y) => {
        y.target === t10 && (o10.current = rc(n10.current));
      };
      return t10.addEventListener("animationstart", p), t10.addEventListener("animationcancel", d6), t10.addEventListener("animationend", d6), () => {
        u10.clearTimeout(l10), t10.removeEventListener("animationstart", p), t10.removeEventListener("animationcancel", d6), t10.removeEventListener("animationend", d6);
      };
    } else
      c("ANIMATION_END");
  }, [t10, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a10),
    ref: R.useCallback((l10) => {
      l10 && (n10.current = getComputedStyle(l10)), r10(l10);
    }, [])
  };
}
function rc(e10) {
  return (e10 == null ? void 0 : e10.animationName) || "none";
}
function lA(e10) {
  var n10, i10;
  let t10 = (n10 = Object.getOwnPropertyDescriptor(e10.props, "ref")) == null ? void 0 : n10.get, r10 = t10 && "isReactWarning" in t10 && t10.isReactWarning;
  return r10 ? e10.ref : (t10 = (i10 = Object.getOwnPropertyDescriptor(e10, "ref")) == null ? void 0 : i10.get, r10 = t10 && "isReactWarning" in t10 && t10.isReactWarning, r10 ? e10.props.ref : e10.props.ref || e10.ref);
}
function Fa({
  prop: e10,
  defaultProp: t10,
  onChange: r10 = () => {
  }
}) {
  const [n10, i10] = uA({ defaultProp: t10, onChange: r10 }), o10 = e10 !== void 0, s10 = o10 ? e10 : n10, a10 = wr(r10), c = R.useCallback(
    (l10) => {
      if (o10) {
        const d6 = typeof l10 == "function" ? l10(e10) : l10;
        d6 !== e10 && a10(d6);
      } else
        i10(l10);
    },
    [o10, e10, i10, a10]
  );
  return [s10, c];
}
function uA({
  defaultProp: e10,
  onChange: t10
}) {
  const r10 = R.useState(e10), [n10] = r10, i10 = R.useRef(n10), o10 = wr(t10);
  return R.useEffect(() => {
    i10.current !== n10 && (o10(n10), i10.current = n10);
  }, [n10, i10, o10]), r10;
}
var fA = "VisuallyHidden";
var sy = R.forwardRef(
  (e10, t10) => w.jsx(
    Zt.span,
    {
      ...e10,
      ref: t10,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e10.style
      }
    }
  )
);
sy.displayName = fA;
var dA = sy;
var [Vl, bU] = Di("Tooltip", [
  $l
]);
var T0 = $l();
var ay = "TooltipProvider";
var hA = 700;
var Np = "tooltip.open";
var [pA, cy] = Vl(ay);
var ly = (e10) => {
  const {
    __scopeTooltip: t10,
    delayDuration: r10 = hA,
    skipDelayDuration: n10 = 300,
    disableHoverableContent: i10 = false,
    children: o10
  } = e10, [s10, a10] = R.useState(true), c = R.useRef(false), l10 = R.useRef(0);
  return R.useEffect(() => {
    const u10 = l10.current;
    return () => window.clearTimeout(u10);
  }, []), w.jsx(
    pA,
    {
      scope: t10,
      isOpenDelayed: s10,
      delayDuration: r10,
      onOpen: R.useCallback(() => {
        window.clearTimeout(l10.current), a10(false);
      }, []),
      onClose: R.useCallback(() => {
        window.clearTimeout(l10.current), l10.current = window.setTimeout(
          () => a10(true),
          n10
        );
      }, [n10]),
      isPointerInTransitRef: c,
      onPointerInTransitChange: R.useCallback((u10) => {
        c.current = u10;
      }, []),
      disableHoverableContent: i10,
      children: o10
    }
  );
};
ly.displayName = ay;
var uy = "Tooltip";
var [yU, zl] = Vl(uy);
var nd = "TooltipTrigger";
var mA = R.forwardRef(
  (e10, t10) => {
    const { __scopeTooltip: r10, ...n10 } = e10, i10 = zl(nd, r10), o10 = cy(nd, r10), s10 = T0(r10), a10 = R.useRef(null), c = sr(t10, a10, i10.onTriggerChange), l10 = R.useRef(false), u10 = R.useRef(false), d6 = R.useCallback(() => l10.current = false, []);
    return R.useEffect(() => () => document.removeEventListener("pointerup", d6), [d6]), w.jsx(ry, { asChild: true, ...s10, children: w.jsx(
      Zt.button,
      {
        "aria-describedby": i10.open ? i10.contentId : void 0,
        "data-state": i10.stateAttribute,
        ...n10,
        ref: c,
        onPointerMove: Ze(e10.onPointerMove, (p) => {
          p.pointerType !== "touch" && !u10.current && !o10.isPointerInTransitRef.current && (i10.onTriggerEnter(), u10.current = true);
        }),
        onPointerLeave: Ze(e10.onPointerLeave, () => {
          i10.onTriggerLeave(), u10.current = false;
        }),
        onPointerDown: Ze(e10.onPointerDown, () => {
          l10.current = true, document.addEventListener("pointerup", d6, { once: true });
        }),
        onFocus: Ze(e10.onFocus, () => {
          l10.current || i10.onOpen();
        }),
        onBlur: Ze(e10.onBlur, i10.onClose),
        onClick: Ze(e10.onClick, i10.onClose)
      }
    ) });
  }
);
mA.displayName = nd;
var gA = "TooltipPortal";
var [wU, vA] = Vl(gA, {
  forceMount: void 0
});
var Es = "TooltipContent";
var bA = R.forwardRef(
  (e10, t10) => {
    const r10 = vA(Es, e10.__scopeTooltip), { forceMount: n10 = r10.forceMount, side: i10 = "top", ...o10 } = e10, s10 = zl(Es, e10.__scopeTooltip);
    return w.jsx($n, { present: n10 || s10.open, children: s10.disableHoverableContent ? w.jsx(fy, { side: i10, ...o10, ref: t10 }) : w.jsx(yA, { side: i10, ...o10, ref: t10 }) });
  }
);
var yA = R.forwardRef((e10, t10) => {
  const r10 = zl(Es, e10.__scopeTooltip), n10 = cy(Es, e10.__scopeTooltip), i10 = R.useRef(null), o10 = sr(t10, i10), [s10, a10] = R.useState(null), { trigger: c, onClose: l10 } = r10, u10 = i10.current, { onPointerInTransitChange: d6 } = n10, p = R.useCallback(() => {
    a10(null), d6(false);
  }, [d6]), y = R.useCallback(
    (x, b) => {
      const M = x.currentTarget, O = { x: x.clientX, y: x.clientY }, P = _A(O, M.getBoundingClientRect()), j = EA(O, P), F = CA(b.getBoundingClientRect()), B = AA([...j, ...F]);
      a10(B), d6(true);
    },
    [d6]
  );
  return R.useEffect(() => () => p(), [p]), R.useEffect(() => {
    if (c && u10) {
      const x = (M) => y(M, u10), b = (M) => y(M, c);
      return c.addEventListener("pointerleave", x), u10.addEventListener("pointerleave", b), () => {
        c.removeEventListener("pointerleave", x), u10.removeEventListener("pointerleave", b);
      };
    }
  }, [c, u10, y, p]), R.useEffect(() => {
    if (s10) {
      const x = (b) => {
        const M = b.target, O = { x: b.clientX, y: b.clientY }, P = (c == null ? void 0 : c.contains(M)) || (u10 == null ? void 0 : u10.contains(M)), j = !TA(O, s10);
        P ? p() : j && (p(), l10());
      };
      return document.addEventListener("pointermove", x), () => document.removeEventListener("pointermove", x);
    }
  }, [c, u10, s10, l10, p]), w.jsx(fy, { ...e10, ref: o10 });
});
var [wA, xA] = Vl(uy, { isInside: false });
var fy = R.forwardRef(
  (e10, t10) => {
    const {
      __scopeTooltip: r10,
      children: n10,
      "aria-label": i10,
      onEscapeKeyDown: o10,
      onPointerDownOutside: s10,
      ...a10
    } = e10, c = zl(Es, r10), l10 = T0(r10), { onClose: u10 } = c;
    return R.useEffect(() => (document.addEventListener(Np, u10), () => document.removeEventListener(Np, u10)), [u10]), R.useEffect(() => {
      if (c.trigger) {
        const d6 = (p) => {
          const y = p.target;
          y != null && y.contains(c.trigger) && u10();
        };
        return window.addEventListener("scroll", d6, { capture: true }), () => window.removeEventListener("scroll", d6, { capture: true });
      }
    }, [c.trigger, u10]), w.jsx(
      m0,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown: o10,
        onPointerDownOutside: s10,
        onFocusOutside: (d6) => d6.preventDefault(),
        onDismiss: u10,
        children: w.jsxs(
          ny,
          {
            "data-state": c.stateAttribute,
            ...l10,
            ...a10,
            ref: t10,
            style: {
              ...a10.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              w.jsx(Ps, { children: n10 }),
              w.jsx(wA, { scope: r10, isInside: true, children: w.jsx(dA, { id: c.contentId, role: "tooltip", children: i10 || n10 }) })
            ]
          }
        )
      }
    );
  }
);
bA.displayName = Es;
var dy = "TooltipArrow";
var SA = R.forwardRef(
  (e10, t10) => {
    const { __scopeTooltip: r10, ...n10 } = e10, i10 = T0(r10);
    return xA(
      dy,
      r10
    ).isInside ? null : w.jsx(iy, { ...i10, ...n10, ref: t10 });
  }
);
SA.displayName = dy;
function _A(e10, t10) {
  const r10 = Math.abs(t10.top - e10.y), n10 = Math.abs(t10.bottom - e10.y), i10 = Math.abs(t10.right - e10.x), o10 = Math.abs(t10.left - e10.x);
  switch (Math.min(r10, n10, i10, o10)) {
    case o10:
      return "left";
    case i10:
      return "right";
    case r10:
      return "top";
    case n10:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function EA(e10, t10, r10 = 5) {
  const n10 = [];
  switch (t10) {
    case "top":
      n10.push(
        { x: e10.x - r10, y: e10.y + r10 },
        { x: e10.x + r10, y: e10.y + r10 }
      );
      break;
    case "bottom":
      n10.push(
        { x: e10.x - r10, y: e10.y - r10 },
        { x: e10.x + r10, y: e10.y - r10 }
      );
      break;
    case "left":
      n10.push(
        { x: e10.x + r10, y: e10.y - r10 },
        { x: e10.x + r10, y: e10.y + r10 }
      );
      break;
    case "right":
      n10.push(
        { x: e10.x - r10, y: e10.y - r10 },
        { x: e10.x - r10, y: e10.y + r10 }
      );
      break;
  }
  return n10;
}
function CA(e10) {
  const { top: t10, right: r10, bottom: n10, left: i10 } = e10;
  return [
    { x: i10, y: t10 },
    { x: r10, y: t10 },
    { x: r10, y: n10 },
    { x: i10, y: n10 }
  ];
}
function TA(e10, t10) {
  const { x: r10, y: n10 } = e10;
  let i10 = false;
  for (let o10 = 0, s10 = t10.length - 1; o10 < t10.length; s10 = o10++) {
    const a10 = t10[o10].x, c = t10[o10].y, l10 = t10[s10].x, u10 = t10[s10].y;
    c > n10 != u10 > n10 && r10 < (l10 - a10) * (n10 - c) / (u10 - c) + a10 && (i10 = !i10);
  }
  return i10;
}
function AA(e10) {
  const t10 = e10.slice();
  return t10.sort((r10, n10) => r10.x < n10.x ? -1 : r10.x > n10.x ? 1 : r10.y < n10.y ? -1 : r10.y > n10.y ? 1 : 0), MA(t10);
}
function MA(e10) {
  if (e10.length <= 1)
    return e10.slice();
  const t10 = [];
  for (let n10 = 0; n10 < e10.length; n10++) {
    const i10 = e10[n10];
    for (; t10.length >= 2; ) {
      const o10 = t10[t10.length - 1], s10 = t10[t10.length - 2];
      if ((o10.x - s10.x) * (i10.y - s10.y) >= (o10.y - s10.y) * (i10.x - s10.x))
        t10.pop();
      else
        break;
    }
    t10.push(i10);
  }
  t10.pop();
  const r10 = [];
  for (let n10 = e10.length - 1; n10 >= 0; n10--) {
    const i10 = e10[n10];
    for (; r10.length >= 2; ) {
      const o10 = r10[r10.length - 1], s10 = r10[r10.length - 2];
      if ((o10.x - s10.x) * (i10.y - s10.y) >= (o10.y - s10.y) * (i10.x - s10.x))
        r10.pop();
      else
        break;
    }
    r10.push(i10);
  }
  return r10.pop(), t10.length === 1 && r10.length === 1 && t10[0].x === r10[0].x && t10[0].y === r10[0].y ? t10 : t10.concat(r10);
}
var IA = ly;
var hy = R.createContext(void 0);
var OA = (e10) => {
  const { dir: t10, children: r10 } = e10;
  return w.jsx(hy.Provider, { value: t10, children: r10 });
};
function A0(e10) {
  const t10 = R.useContext(hy);
  return e10 || t10 || "ltr";
}
var RA = ["tomato", "red", "ruby", "crimson", "pink", "plum", "purple", "violet", "iris", "indigo", "blue", "cyan", "teal", "jade", "green", "grass", "brown", "orange"];
var PA = ["sky", "mint", "lime", "yellow", "amber"];
var NA = ["gold", "bronze"];
var jA = [...RA, ...PA, ...NA];
var kA = "gray";
var DA = ["mauve", "slate", "sage", "olive", "sand"];
var LA = [kA, ...DA];
function BA(e10) {
  switch (e10) {
    case "tomato":
    case "red":
    case "ruby":
    case "crimson":
    case "pink":
    case "plum":
    case "purple":
    case "violet":
      return "mauve";
    case "iris":
    case "indigo":
    case "blue":
    case "sky":
    case "cyan":
      return "slate";
    case "teal":
    case "jade":
    case "mint":
    case "green":
      return "sage";
    case "grass":
    case "lime":
      return "olive";
    case "yellow":
    case "amber":
    case "orange":
    case "brown":
    case "gold":
    case "bronze":
      return "sand";
  }
}
var UA = ["inherit", "light", "dark"];
var FA = [...jA, "gray"];
var $A = [...LA, "auto"];
var VA = ["solid", "translucent"];
var zA = ["none", "small", "medium", "large", "full"];
var qA = ["90%", "95%", "100%", "105%", "110%"];
var zr = {
  hasBackground: { type: "boolean", default: true },
  appearance: { type: "enum", values: UA, default: "inherit" },
  accentColor: { type: "enum", values: FA, default: "indigo" },
  grayColor: { type: "enum", values: $A, default: "auto" },
  panelBackground: { type: "enum", values: VA, default: "translucent" },
  radius: { type: "enum", values: zA, default: "medium" },
  scaling: { type: "enum", values: qA, default: "100%" }
};
function py(e10) {
  return e10 === "gray" ? "gray" : BA(e10);
}
var Jo = () => {
};
var el = R.createContext(void 0);
function HA() {
  const e10 = R.useContext(el);
  if (e10 === void 0)
    throw new Error("`useThemeContext` must be used within a `Theme`");
  return e10;
}
var ql = R.forwardRef((e10, t10) => R.useContext(el) === void 0 ? R.createElement(
  IA,
  null,
  R.createElement(
    OA,
    { dir: "ltr" },
    R.createElement(my, { ...e10, ref: t10 })
  )
) : R.createElement(M0, { ...e10, ref: t10 }));
ql.displayName = "Theme";
var my = R.forwardRef((e10, t10) => {
  const { appearance: r10 = zr.appearance.default, accentColor: n10 = zr.accentColor.default, grayColor: i10 = zr.grayColor.default, panelBackground: o10 = zr.panelBackground.default, radius: s10 = zr.radius.default, scaling: a10 = zr.scaling.default, hasBackground: c = zr.hasBackground.default, ...l10 } = e10, [u10, d6] = R.useState(r10);
  R.useEffect(() => d6(r10), [r10]);
  const [p, y] = R.useState(n10);
  R.useEffect(() => y(n10), [n10]);
  const [x, b] = R.useState(i10);
  R.useEffect(() => b(i10), [i10]);
  const [M, O] = R.useState(o10);
  R.useEffect(() => O(o10), [o10]);
  const [P, j] = R.useState(s10);
  R.useEffect(() => j(s10), [s10]);
  const [F, B] = R.useState(a10);
  R.useEffect(() => B(a10), [a10]);
  const W = R.memo(
    ({ appearance: G }) => R.createElement("script", { dangerouslySetInnerHTML: {
      __html: `!(function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');d.style.colorScheme='${G}';c.add('${G}');}catch(e){}})();`
    } }),
    () => true
    // Never re-render
  );
  W.displayName = "ExplicitRootAppearanceScript", R.useEffect(() => WA(r10), [r10]);
  const z = x === "auto" ? py(p) : x;
  return R.createElement(
    R.Fragment,
    null,
    u10 !== "inherit" && R.createElement(W, { appearance: u10 }),
    c && R.createElement("style", { dangerouslySetInnerHTML: {
      __html: `
:root, .light, .light-theme { --color-page-background: white; }
.dark, .dark-theme { --color-page-background: var(--${z}-1); }
body { background-color: var(--color-page-background); }
`
    } }),
    R.createElement(M0, {
      ...l10,
      ref: t10,
      isRoot: true,
      hasBackground: c,
      //
      appearance: u10,
      accentColor: p,
      grayColor: x,
      panelBackground: M,
      radius: P,
      scaling: F,
      //
      onAppearanceChange: d6,
      onAccentColorChange: y,
      onGrayColorChange: b,
      onPanelBackgroundChange: O,
      onRadiusChange: j,
      onScalingChange: B
    })
  );
});
my.displayName = "ThemeRoot";
var M0 = R.forwardRef((e10, t10) => {
  var r10, n10, i10, o10, s10, a10;
  const c = R.useContext(el), {
    asChild: l10,
    isRoot: u10,
    hasBackground: d6,
    //
    appearance: p = (r10 = c == null ? void 0 : c.appearance) !== null && r10 !== void 0 ? r10 : zr.appearance.default,
    accentColor: y = (n10 = c == null ? void 0 : c.accentColor) !== null && n10 !== void 0 ? n10 : zr.accentColor.default,
    grayColor: x = (i10 = c == null ? void 0 : c.resolvedGrayColor) !== null && i10 !== void 0 ? i10 : zr.grayColor.default,
    panelBackground: b = (o10 = c == null ? void 0 : c.panelBackground) !== null && o10 !== void 0 ? o10 : zr.panelBackground.default,
    radius: M = (s10 = c == null ? void 0 : c.radius) !== null && s10 !== void 0 ? s10 : zr.radius.default,
    scaling: O = (a10 = c == null ? void 0 : c.scaling) !== null && a10 !== void 0 ? a10 : zr.scaling.default,
    //
    onAppearanceChange: P = Jo,
    onAccentColorChange: j = Jo,
    onGrayColorChange: F = Jo,
    onPanelBackgroundChange: B = Jo,
    onRadiusChange: W = Jo,
    onScalingChange: z = Jo,
    //
    ...G
  } = e10, re = l10 ? Ri : "div", ie = x === "auto" ? py(y) : x, oe = e10.appearance !== void 0 && e10.appearance !== "inherit", q = e10.grayColor !== void 0, L = !u10 && (d6 === true || d6 !== false && (oe || q));
  return R.createElement(
    el.Provider,
    { value: R.useMemo(() => ({
      appearance: p,
      accentColor: y,
      grayColor: x,
      resolvedGrayColor: ie,
      panelBackground: b,
      radius: M,
      scaling: O,
      //
      onAppearanceChange: P,
      onAccentColorChange: j,
      onGrayColorChange: F,
      onPanelBackgroundChange: B,
      onRadiusChange: W,
      onScalingChange: z
    }), [
      p,
      y,
      x,
      ie,
      b,
      M,
      O,
      //
      P,
      j,
      F,
      B,
      W,
      z
    ]) },
    R.createElement(re, { "data-is-root-theme": u10 ? "true" : "false", "data-accent-color": y, "data-gray-color": ie, "data-has-background": L ? "true" : "false", "data-panel-background": b, "data-radius": M, "data-scaling": O, ref: t10, ...G, className: rr("radix-themes", {
      // Only apply theme class to nested `Theme` sections.
      //
      // If it's the root `Theme`, we either rely on
      // - something else setting the theme class when root `appearance` is `inherit`
      // - our script setting it when root `appearance` is explicit
      light: !u10 && p === "light",
      dark: !u10 && p === "dark"
    }, G.className) })
  );
});
M0.displayName = "ThemeImpl";
function WA(e10) {
  if (e10 === "inherit")
    return;
  const t10 = document.documentElement;
  (t10.classList.contains("light-theme") || t10.classList.contains("dark-theme")) && (t10.classList.remove("light-theme", "dark-theme"), t10.style.colorScheme = e10, t10.classList.add(`${e10}-theme`)), (t10.classList.contains("light") || t10.classList.contains("dark")) && (t10.classList.remove("light", "dark"), t10.style.colorScheme = e10, t10.classList.add(e10));
}
var $a = {
  type: "enum",
  values: zr.accentColor.values,
  default: void 0
};
var Hl = {
  type: "boolean",
  default: void 0
};
function St(e10, t10 = "", r10) {
  var n10, i10, o10, s10;
  const a10 = [];
  if (typeof e10 == "object") {
    for (const c of Object.keys(e10))
      if (c in e10) {
        const l10 = (n10 = e10[c]) === null || n10 === void 0 ? void 0 : n10.toString(), u10 = l10 == null ? void 0 : l10.startsWith("-"), d6 = t10 === "" ? "" : "-", p = u10 ? `-${t10}` : t10, y = u10 ? l10 == null ? void 0 : l10.substring(1) : l10;
        if (y === void 0)
          continue;
        const x = (i10 = r10 == null ? void 0 : r10[y]) !== null && i10 !== void 0 ? i10 : y, b = c === "initial" ? `${p}${d6}${x}` : `${c}:${p}${d6}${x}`;
        a10.push(b);
      }
  }
  if (typeof e10 == "string") {
    const c = e10.startsWith("-"), l10 = t10 === "" ? "" : "-", u10 = c ? `-${t10}` : t10, d6 = c ? e10.substring(1) : e10, p = (o10 = r10 == null ? void 0 : r10[d6]) !== null && o10 !== void 0 ? o10 : d6;
    a10.push(`${u10}${l10}${p}`);
  }
  if (typeof e10 == "boolean") {
    const c = t10 === "" ? "" : "-", l10 = e10.toString(), u10 = (s10 = r10 == null ? void 0 : r10[l10]) !== null && s10 !== void 0 ? s10 : l10;
    a10.push(`${t10}${c}${u10}`);
  }
  return a10.join(" ");
}
var bo = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var GA = {
  p: { type: "enum", values: bo, default: void 0, responsive: true },
  px: { type: "enum", values: bo, default: void 0, responsive: true },
  py: { type: "enum", values: bo, default: void 0, responsive: true },
  pt: { type: "enum", values: bo, default: void 0, responsive: true },
  pr: { type: "enum", values: bo, default: void 0, responsive: true },
  pb: { type: "enum", values: bo, default: void 0, responsive: true },
  pl: { type: "enum", values: bo, default: void 0, responsive: true }
};
function KA(e10) {
  const { p: t10 = Ir.p.default, px: r10 = Ir.px.default, py: n10 = Ir.py.default, pt: i10 = Ir.pt.default, pr: o10 = Ir.pr.default, pb: s10 = Ir.pb.default, pl: a10 = Ir.pl.default, ...c } = e10;
  return { p: t10, px: r10, py: n10, pt: i10, pr: o10, pb: s10, pl: a10, rest: c };
}
function YA(e10) {
  return [
    St(e10.p, "rt-r-p"),
    St(e10.px, "rt-r-px"),
    St(e10.py, "rt-r-py"),
    St(e10.pt, "rt-r-pt"),
    St(e10.pr, "rt-r-pr"),
    St(e10.pb, "rt-r-pb"),
    St(e10.pl, "rt-r-pl")
  ].filter(Boolean).join(" ");
}
var XA = ["static", "relative", "absolute", "fixed", "sticky"];
var Ks = ["auto", "0", "50%", "100%"];
var jp = ["auto", "min-content", "max-content", "100%", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var JA = ["0", "1"];
var ZA = ["0", "1"];
var Ir = {
  ...GA,
  position: { type: "enum", values: XA, default: void 0, responsive: true },
  inset: { type: "enum", values: Ks, default: void 0, responsive: true },
  top: { type: "enum", values: Ks, default: void 0, responsive: true },
  right: { type: "enum", values: Ks, default: void 0, responsive: true },
  bottom: { type: "enum", values: Ks, default: void 0, responsive: true },
  left: { type: "enum", values: Ks, default: void 0, responsive: true },
  width: { type: "enum", values: jp, default: void 0, responsive: true },
  height: { type: "enum", values: jp, default: void 0, responsive: true },
  shrink: { type: "enum", values: JA, default: void 0, responsive: true },
  grow: { type: "enum", values: ZA, default: void 0, responsive: true }
};
function QA(e10) {
  const { rest: t10, ...r10 } = KA(e10), { position: n10 = Ir.position.default, width: i10 = Ir.width.default, height: o10 = Ir.height.default, inset: s10 = Ir.inset.default, top: a10 = Ir.top.default, bottom: c = Ir.bottom.default, left: l10 = Ir.left.default, right: u10 = Ir.right.default, shrink: d6 = Ir.shrink.default, grow: p = Ir.grow.default, ...y } = t10;
  return {
    ...r10,
    position: n10,
    width: i10,
    height: o10,
    inset: s10,
    top: a10,
    bottom: c,
    left: l10,
    right: u10,
    shrink: d6,
    grow: p,
    rest: y
  };
}
function eM(e10) {
  return [
    YA(e10),
    St(e10.position, "rt-r-position"),
    St(e10.shrink, "rt-r-fs"),
    St(e10.grow, "rt-r-fg"),
    St(e10.width, "rt-r-w"),
    St(e10.height, "rt-r-h"),
    St(e10.inset, "rt-r-inset"),
    St(e10.top, "rt-r-top"),
    St(e10.bottom, "rt-r-bottom"),
    St(e10.left, "rt-r-left"),
    St(e10.right, "rt-r-right")
  ].filter(Boolean).join(" ");
}
var yo = ["auto", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"];
var wo = {
  m: { type: "enum", values: yo, default: void 0, responsive: true },
  mx: { type: "enum", values: yo, default: void 0, responsive: true },
  my: { type: "enum", values: yo, default: void 0, responsive: true },
  mt: { type: "enum", values: yo, default: void 0, responsive: true },
  mr: { type: "enum", values: yo, default: void 0, responsive: true },
  mb: { type: "enum", values: yo, default: void 0, responsive: true },
  ml: { type: "enum", values: yo, default: void 0, responsive: true }
};
function ks(e10) {
  const { m: t10 = wo.m.default, mx: r10 = wo.mx.default, my: n10 = wo.my.default, mt: i10 = wo.mt.default, mr: o10 = wo.mr.default, mb: s10 = wo.mb.default, ml: a10 = wo.ml.default, ...c } = e10;
  return { m: t10, mx: r10, my: n10, mt: i10, mr: o10, mb: s10, ml: a10, rest: c };
}
function Ds(e10) {
  return [
    St(e10.m, "rt-r-m"),
    St(e10.mx, "rt-r-mx"),
    St(e10.my, "rt-r-my"),
    St(e10.mt, "rt-r-mt"),
    St(e10.mr, "rt-r-mr"),
    St(e10.mb, "rt-r-mb"),
    St(e10.ml, "rt-r-ml")
  ].filter(Boolean).join(" ");
}
var I0 = {
  type: "enum",
  values: zr.radius.values,
  default: void 0
};
var tM = ["none", "inline-flex", "flex"];
var rM = ["row", "column", "row-reverse", "column-reverse"];
var nM = ["start", "center", "end", "baseline", "stretch"];
var iM = ["start", "center", "end", "between"];
var oM = ["nowrap", "wrap", "wrap-reverse"];
var sM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var Zo = {
  display: { type: "enum", values: tM, default: "flex", responsive: true },
  direction: { type: "enum", values: rM, default: void 0, responsive: true },
  align: { type: "enum", values: nM, default: void 0, responsive: true },
  justify: { type: "enum", values: iM, default: "start", responsive: true },
  wrap: { type: "enum", values: oM, default: void 0, responsive: true },
  gap: { type: "enum", values: sM, default: void 0, responsive: true }
};
var gy = R.forwardRef((e10, t10) => {
  const { rest: r10, ...n10 } = ks(e10), { rest: i10, ...o10 } = QA(r10), { className: s10, asChild: a10, display: c = Zo.display.default, direction: l10 = Zo.direction.default, align: u10 = Zo.align.default, justify: d6 = Zo.justify.default, wrap: p = Zo.wrap.default, gap: y = Zo.gap.default, ...x } = i10, b = a10 ? Ri : "div";
  return R.createElement(b, { ...x, ref: t10, className: rr("rt-Flex", s10, St(c, "rt-r-display"), St(l10, "rt-r-fd"), St(u10, "rt-r-ai"), St(d6, "rt-r-jc", { between: "space-between" }), St(p, "rt-r-fw"), St(y, "rt-r-gap"), eM(o10), Ds(n10)) });
});
gy.displayName = "Flex";
function vy(e10) {
  const t10 = R.useRef({ value: e10, previous: e10 });
  return R.useMemo(() => (t10.current.value !== e10 && (t10.current.previous = t10.current.value, t10.current.value = e10), t10.current.previous), [e10]);
}
var O0 = "Checkbox";
var [aM, xU] = Di(O0);
var [cM, lM] = aM(O0);
var by = R.forwardRef(
  (e10, t10) => {
    const {
      __scopeCheckbox: r10,
      name: n10,
      checked: i10,
      defaultChecked: o10,
      required: s10,
      disabled: a10,
      value: c = "on",
      onCheckedChange: l10,
      form: u10,
      ...d6
    } = e10, [p, y] = R.useState(null), x = sr(t10, (F) => y(F)), b = R.useRef(false), M = p ? u10 || !!p.closest("form") : true, [O = false, P] = Fa({
      prop: i10,
      defaultProp: o10,
      onChange: l10
    }), j = R.useRef(O);
    return R.useEffect(() => {
      const F = p == null ? void 0 : p.form;
      if (F) {
        const B = () => P(j.current);
        return F.addEventListener("reset", B), () => F.removeEventListener("reset", B);
      }
    }, [p, P]), w.jsxs(cM, { scope: r10, state: O, disabled: a10, children: [
      w.jsx(
        Zt.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": Ji(O) ? "mixed" : O,
          "aria-required": s10,
          "data-state": xy(O),
          "data-disabled": a10 ? "" : void 0,
          disabled: a10,
          value: c,
          ...d6,
          ref: x,
          onKeyDown: Ze(e10.onKeyDown, (F) => {
            F.key === "Enter" && F.preventDefault();
          }),
          onClick: Ze(e10.onClick, (F) => {
            P((B) => Ji(B) ? true : !B), M && (b.current = F.isPropagationStopped(), b.current || F.stopPropagation());
          })
        }
      ),
      M && w.jsx(
        uM,
        {
          control: p,
          bubbles: !b.current,
          name: n10,
          value: c,
          checked: O,
          required: s10,
          disabled: a10,
          form: u10,
          style: { transform: "translateX(-100%)" },
          defaultChecked: Ji(o10) ? false : o10
        }
      )
    ] });
  }
);
by.displayName = O0;
var yy = "CheckboxIndicator";
var wy = R.forwardRef(
  (e10, t10) => {
    const { __scopeCheckbox: r10, forceMount: n10, ...i10 } = e10, o10 = lM(yy, r10);
    return w.jsx($n, { present: n10 || Ji(o10.state) || o10.state === true, children: w.jsx(
      Zt.span,
      {
        "data-state": xy(o10.state),
        "data-disabled": o10.disabled ? "" : void 0,
        ...i10,
        ref: t10,
        style: { pointerEvents: "none", ...e10.style }
      }
    ) });
  }
);
wy.displayName = yy;
var uM = (e10) => {
  const { control: t10, checked: r10, bubbles: n10 = true, defaultChecked: i10, ...o10 } = e10, s10 = R.useRef(null), a10 = vy(r10), c = _0(t10);
  R.useEffect(() => {
    const u10 = s10.current, d6 = window.HTMLInputElement.prototype, y = Object.getOwnPropertyDescriptor(d6, "checked").set;
    if (a10 !== r10 && y) {
      const x = new Event("click", { bubbles: n10 });
      u10.indeterminate = Ji(r10), y.call(u10, Ji(r10) ? false : r10), u10.dispatchEvent(x);
    }
  }, [a10, r10, n10]);
  const l10 = R.useRef(Ji(r10) ? false : r10);
  return w.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: i10 ?? l10.current,
      ...o10,
      tabIndex: -1,
      ref: s10,
      style: {
        ...e10.style,
        ...c,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function Ji(e10) {
  return e10 === "indeterminate";
}
function xy(e10) {
  return Ji(e10) ? "indeterminate" : e10 ? "checked" : "unchecked";
}
var fM = by;
var dM = wy;
var hM = ["1", "2", "3"];
var pM = ["classic", "surface", "soft"];
var nc = {
  size: { type: "enum", values: hM, default: "2", responsive: true },
  variant: { type: "enum", values: pM, default: "surface" },
  color: $a,
  highContrast: Hl
};
var Wl = R.forwardRef(({ color: e10 = "currentColor", ...t10 }, r10) => R.createElement(
  "svg",
  { width: "9", height: "9", viewBox: "0 0 9 9", fill: e10, xmlns: "http://www.w3.org/2000/svg", ...t10, ref: r10 },
  R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.53547 0.62293C8.88226 0.849446 8.97976 1.3142 8.75325 1.66099L4.5083 8.1599C4.38833 8.34356 4.19397 8.4655 3.9764 8.49358C3.75883 8.52167 3.53987 8.45309 3.3772 8.30591L0.616113 5.80777C0.308959 5.52987 0.285246 5.05559 0.563148 4.74844C0.84105 4.44128 1.31533 4.41757 1.62249 4.69547L3.73256 6.60459L7.49741 0.840706C7.72393 0.493916 8.18868 0.396414 8.53547 0.62293Z" })
));
Wl.displayName = "ThickCheckIcon";
var mM = R.forwardRef(({ color: e10 = "currentColor", ...t10 }, r10) => R.createElement(
  "svg",
  { width: "9", height: "9", viewBox: "0 0 9 9", fill: e10, xmlns: "http://www.w3.org/2000/svg", ...t10, ref: r10 },
  R.createElement("path", { d: "M0.135232 3.15803C0.324102 2.95657 0.640521 2.94637 0.841971 3.13523L4.5 6.56464L8.158 3.13523C8.3595 2.94637 8.6759 2.95657 8.8648 3.15803C9.0536 3.35949 9.0434 3.67591 8.842 3.86477L4.84197 7.6148C4.64964 7.7951 4.35036 7.7951 4.15803 7.6148L0.158031 3.86477C-0.0434285 3.67591 -0.0536285 3.35949 0.135232 3.15803Z" })
));
mM.displayName = "ChevronDownIcon";
var Sy = R.forwardRef(({ color: e10 = "currentColor", ...t10 }, r10) => R.createElement(
  "svg",
  { width: "9", height: "9", viewBox: "0 0 9 9", fill: e10, xmlns: "http://www.w3.org/2000/svg", ...t10, ref: r10 },
  R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.23826 0.201711C3.54108 -0.0809141 4.01567 -0.0645489 4.29829 0.238264L7.79829 3.98826C8.06724 4.27642 8.06724 4.72359 7.79829 5.01174L4.29829 8.76174C4.01567 9.06455 3.54108 9.08092 3.23826 8.79829C2.93545 8.51567 2.91909 8.04108 3.20171 7.73826L6.22409 4.5L3.20171 1.26174C2.91909 0.958928 2.93545 0.484337 3.23826 0.201711Z" })
));
Sy.displayName = "ThickChevronRightIcon";
var gM = R.forwardRef(({ color: e10 = "currentColor", ...t10 }, r10) => R.createElement(
  "svg",
  { width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...t10, ref: r10 },
  R.createElement("path", { d: "M7.49991 0.876892C3.84222 0.876892 0.877075 3.84204 0.877075 7.49972C0.877075 11.1574 3.84222 14.1226 7.49991 14.1226C11.1576 14.1226 14.1227 11.1574 14.1227 7.49972C14.1227 3.84204 11.1576 0.876892 7.49991 0.876892ZM1.82707 7.49972C1.82707 4.36671 4.36689 1.82689 7.49991 1.82689C10.6329 1.82689 13.1727 4.36671 13.1727 7.49972C13.1727 10.6327 10.6329 13.1726 7.49991 13.1726C4.36689 13.1726 1.82707 10.6327 1.82707 7.49972ZM8.24992 4.49999C8.24992 4.9142 7.91413 5.24999 7.49992 5.24999C7.08571 5.24999 6.74992 4.9142 6.74992 4.49999C6.74992 4.08577 7.08571 3.74999 7.49992 3.74999C7.91413 3.74999 8.24992 4.08577 8.24992 4.49999ZM6.00003 5.99999H6.50003H7.50003C7.77618 5.99999 8.00003 6.22384 8.00003 6.49999V9.99999H8.50003H9.00003V11H8.50003H7.50003H6.50003H6.00003V9.99999H6.50003H7.00003V6.99999H6.50003H6.00003V5.99999Z", fill: e10, fillRule: "evenodd", clipRule: "evenodd" })
));
gM.displayName = "InfoCircledIcon";
var Gl = R.forwardRef((e10, t10) => {
  const { rest: r10, ...n10 } = ks(e10), { className: i10, style: o10, size: s10 = nc.size.default, variant: a10 = nc.variant.default, color: c = nc.color.default, highContrast: l10 = nc.highContrast.default, ...u10 } = r10;
  return R.createElement(
    "span",
    { className: rr("rt-CheckboxRoot", i10, St(s10, "rt-r-size"), Ds(n10)), style: o10 },
    R.createElement(
      fM,
      { "data-accent-color": c, ...u10, ref: t10, className: rr("rt-reset", "rt-CheckboxButton", `rt-variant-${a10}`, {
        "rt-high-contrast": l10
      }) },
      R.createElement(
        dM,
        { className: "rt-CheckboxIndicator" },
        R.createElement(Wl, { className: "rt-CheckboxIndicatorIcon" })
      )
    )
  );
});
Gl.displayName = "Checkbox";
function _y(e10) {
  const t10 = e10 + "CollectionProvider", [r10, n10] = Di(t10), [i10, o10] = r10(
    t10,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s10 = (y) => {
    const { scope: x, children: b } = y, M = import_react25.default.useRef(null), O = import_react25.default.useRef(/* @__PURE__ */ new Map()).current;
    return w.jsx(i10, { scope: x, itemMap: O, collectionRef: M, children: b });
  };
  s10.displayName = t10;
  const a10 = e10 + "CollectionSlot", c = import_react25.default.forwardRef(
    (y, x) => {
      const { scope: b, children: M } = y, O = o10(a10, b), P = sr(x, O.collectionRef);
      return w.jsx(Ri, { ref: P, children: M });
    }
  );
  c.displayName = a10;
  const l10 = e10 + "CollectionItemSlot", u10 = "data-radix-collection-item", d6 = import_react25.default.forwardRef(
    (y, x) => {
      const { scope: b, children: M, ...O } = y, P = import_react25.default.useRef(null), j = sr(x, P), F = o10(l10, b);
      return import_react25.default.useEffect(() => (F.itemMap.set(P, { ref: P, ...O }), () => void F.itemMap.delete(P))), w.jsx(Ri, { [u10]: "", ref: j, children: M });
    }
  );
  d6.displayName = l10;
  function p(y) {
    const x = o10(e10 + "CollectionConsumer", y);
    return import_react25.default.useCallback(() => {
      const M = x.collectionRef.current;
      if (!M)
        return [];
      const O = Array.from(M.querySelectorAll(`[${u10}]`));
      return Array.from(x.itemMap.values()).sort(
        (F, B) => O.indexOf(F.ref.current) - O.indexOf(B.ref.current)
      );
    }, [x.collectionRef, x.itemMap]);
  }
  return [
    { Provider: s10, Slot: c, ItemSlot: d6 },
    p,
    n10
  ];
}
var Ku = "rovingFocusGroup.onEntryFocus";
var vM = { bubbles: false, cancelable: true };
var Kl = "RovingFocusGroup";
var [id, Ey, bM] = _y(Kl);
var [yM, Cy] = Di(
  Kl,
  [bM]
);
var [wM, xM] = yM(Kl);
var Ty = R.forwardRef(
  (e10, t10) => w.jsx(id.Provider, { scope: e10.__scopeRovingFocusGroup, children: w.jsx(id.Slot, { scope: e10.__scopeRovingFocusGroup, children: w.jsx(SM, { ...e10, ref: t10 }) }) })
);
Ty.displayName = Kl;
var SM = R.forwardRef((e10, t10) => {
  const {
    __scopeRovingFocusGroup: r10,
    orientation: n10,
    loop: i10 = false,
    dir: o10,
    currentTabStopId: s10,
    defaultCurrentTabStopId: a10,
    onCurrentTabStopIdChange: c,
    onEntryFocus: l10,
    preventScrollOnEntryFocus: u10 = false,
    ...d6
  } = e10, p = R.useRef(null), y = sr(t10, p), x = A0(o10), [b = null, M] = Fa({
    prop: s10,
    defaultProp: a10,
    onChange: c
  }), [O, P] = R.useState(false), j = wr(l10), F = Ey(r10), B = R.useRef(false), [W, z] = R.useState(0);
  return R.useEffect(() => {
    const G = p.current;
    if (G)
      return G.addEventListener(Ku, j), () => G.removeEventListener(Ku, j);
  }, [j]), w.jsx(
    wM,
    {
      scope: r10,
      orientation: n10,
      dir: x,
      loop: i10,
      currentTabStopId: b,
      onItemFocus: R.useCallback(
        (G) => M(G),
        [M]
      ),
      onItemShiftTab: R.useCallback(() => P(true), []),
      onFocusableItemAdd: R.useCallback(
        () => z((G) => G + 1),
        []
      ),
      onFocusableItemRemove: R.useCallback(
        () => z((G) => G - 1),
        []
      ),
      children: w.jsx(
        Zt.div,
        {
          tabIndex: O || W === 0 ? -1 : 0,
          "data-orientation": n10,
          ...d6,
          ref: y,
          style: { outline: "none", ...e10.style },
          onMouseDown: Ze(e10.onMouseDown, () => {
            B.current = true;
          }),
          onFocus: Ze(e10.onFocus, (G) => {
            const re = !B.current;
            if (G.target === G.currentTarget && re && !O) {
              const ie = new CustomEvent(Ku, vM);
              if (G.currentTarget.dispatchEvent(ie), !ie.defaultPrevented) {
                const oe = F().filter((m) => m.focusable), q = oe.find((m) => m.active), L = oe.find((m) => m.id === b), f = [q, L, ...oe].filter(
                  Boolean
                ).map((m) => m.ref.current);
                Iy(f, u10);
              }
            }
            B.current = false;
          }),
          onBlur: Ze(e10.onBlur, () => P(false))
        }
      )
    }
  );
});
var Ay = "RovingFocusGroupItem";
var My = R.forwardRef(
  (e10, t10) => {
    const {
      __scopeRovingFocusGroup: r10,
      focusable: n10 = true,
      active: i10 = false,
      tabStopId: o10,
      ...s10
    } = e10, a10 = ya(), c = o10 || a10, l10 = xM(Ay, r10), u10 = l10.currentTabStopId === c, d6 = Ey(r10), { onFocusableItemAdd: p, onFocusableItemRemove: y } = l10;
    return R.useEffect(() => {
      if (n10)
        return p(), () => y();
    }, [n10, p, y]), w.jsx(
      id.ItemSlot,
      {
        scope: r10,
        id: c,
        focusable: n10,
        active: i10,
        children: w.jsx(
          Zt.span,
          {
            tabIndex: u10 ? 0 : -1,
            "data-orientation": l10.orientation,
            ...s10,
            ref: t10,
            onMouseDown: Ze(e10.onMouseDown, (x) => {
              n10 ? l10.onItemFocus(c) : x.preventDefault();
            }),
            onFocus: Ze(e10.onFocus, () => l10.onItemFocus(c)),
            onKeyDown: Ze(e10.onKeyDown, (x) => {
              if (x.key === "Tab" && x.shiftKey) {
                l10.onItemShiftTab();
                return;
              }
              if (x.target !== x.currentTarget)
                return;
              const b = CM(x, l10.orientation, l10.dir);
              if (b !== void 0) {
                if (x.metaKey || x.ctrlKey || x.altKey || x.shiftKey)
                  return;
                x.preventDefault();
                let O = d6().filter((P) => P.focusable).map((P) => P.ref.current);
                if (b === "last")
                  O.reverse();
                else if (b === "prev" || b === "next") {
                  b === "prev" && O.reverse();
                  const P = O.indexOf(x.currentTarget);
                  O = l10.loop ? TM(O, P + 1) : O.slice(P + 1);
                }
                setTimeout(() => Iy(O));
              }
            })
          }
        )
      }
    );
  }
);
My.displayName = Ay;
var _M = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function EM(e10, t10) {
  return t10 !== "rtl" ? e10 : e10 === "ArrowLeft" ? "ArrowRight" : e10 === "ArrowRight" ? "ArrowLeft" : e10;
}
function CM(e10, t10, r10) {
  const n10 = EM(e10.key, r10);
  if (!(t10 === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n10)) && !(t10 === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n10)))
    return _M[n10];
}
function Iy(e10, t10 = false) {
  const r10 = document.activeElement;
  for (const n10 of e10)
    if (n10 === r10 || (n10.focus({ preventScroll: t10 }), document.activeElement !== r10))
      return;
}
function TM(e10, t10) {
  return e10.map((r10, n10) => e10[(t10 + n10) % e10.length]);
}
var AM = Ty;
var MM = My;
function IM(e10, [t10, r10]) {
  return Math.min(r10, Math.max(t10, e10));
}
var Yu = 0;
function OM() {
  R.useEffect(() => {
    const e10 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e10[0] ?? kp()), document.body.insertAdjacentElement("beforeend", e10[1] ?? kp()), Yu++, () => {
      Yu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t10) => t10.remove()), Yu--;
    };
  }, []);
}
function kp() {
  const e10 = document.createElement("span");
  return e10.setAttribute("data-radix-focus-guard", ""), e10.tabIndex = 0, e10.style.outline = "none", e10.style.opacity = "0", e10.style.position = "fixed", e10.style.pointerEvents = "none", e10;
}
var Xu = "focusScope.autoFocusOnMount";
var Ju = "focusScope.autoFocusOnUnmount";
var Dp = { bubbles: false, cancelable: true };
var RM = "FocusScope";
var Oy = R.forwardRef((e10, t10) => {
  const {
    loop: r10 = false,
    trapped: n10 = false,
    onMountAutoFocus: i10,
    onUnmountAutoFocus: o10,
    ...s10
  } = e10, [a10, c] = R.useState(null), l10 = wr(i10), u10 = wr(o10), d6 = R.useRef(null), p = sr(t10, (b) => c(b)), y = R.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  R.useEffect(() => {
    if (n10) {
      let b = function(j) {
        if (y.paused || !a10)
          return;
        const F = j.target;
        a10.contains(F) ? d6.current = F : zi(d6.current, { select: true });
      }, M = function(j) {
        if (y.paused || !a10)
          return;
        const F = j.relatedTarget;
        F !== null && (a10.contains(F) || zi(d6.current, { select: true }));
      }, O = function(j) {
        if (document.activeElement === document.body)
          for (const B of j)
            B.removedNodes.length > 0 && zi(a10);
      };
      document.addEventListener("focusin", b), document.addEventListener("focusout", M);
      const P = new MutationObserver(O);
      return a10 && P.observe(a10, { childList: true, subtree: true }), () => {
        document.removeEventListener("focusin", b), document.removeEventListener("focusout", M), P.disconnect();
      };
    }
  }, [n10, a10, y.paused]), R.useEffect(() => {
    if (a10) {
      Bp.add(y);
      const b = document.activeElement;
      if (!a10.contains(b)) {
        const O = new CustomEvent(Xu, Dp);
        a10.addEventListener(Xu, l10), a10.dispatchEvent(O), O.defaultPrevented || (PM(LM(Ry(a10)), { select: true }), document.activeElement === b && zi(a10));
      }
      return () => {
        a10.removeEventListener(Xu, l10), setTimeout(() => {
          const O = new CustomEvent(Ju, Dp);
          a10.addEventListener(Ju, u10), a10.dispatchEvent(O), O.defaultPrevented || zi(b ?? document.body, { select: true }), a10.removeEventListener(Ju, u10), Bp.remove(y);
        }, 0);
      };
    }
  }, [a10, l10, u10, y]);
  const x = R.useCallback(
    (b) => {
      if (!r10 && !n10 || y.paused)
        return;
      const M = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, O = document.activeElement;
      if (M && O) {
        const P = b.currentTarget, [j, F] = NM(P);
        j && F ? !b.shiftKey && O === F ? (b.preventDefault(), r10 && zi(j, { select: true })) : b.shiftKey && O === j && (b.preventDefault(), r10 && zi(F, { select: true })) : O === P && b.preventDefault();
      }
    },
    [r10, n10, y.paused]
  );
  return w.jsx(Zt.div, { tabIndex: -1, ...s10, ref: p, onKeyDown: x });
});
Oy.displayName = RM;
function PM(e10, { select: t10 = false } = {}) {
  const r10 = document.activeElement;
  for (const n10 of e10)
    if (zi(n10, { select: t10 }), document.activeElement !== r10)
      return;
}
function NM(e10) {
  const t10 = Ry(e10), r10 = Lp(t10, e10), n10 = Lp(t10.reverse(), e10);
  return [r10, n10];
}
function Ry(e10) {
  const t10 = [], r10 = document.createTreeWalker(e10, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n10) => {
      const i10 = n10.tagName === "INPUT" && n10.type === "hidden";
      return n10.disabled || n10.hidden || i10 ? NodeFilter.FILTER_SKIP : n10.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r10.nextNode(); )
    t10.push(r10.currentNode);
  return t10;
}
function Lp(e10, t10) {
  for (const r10 of e10)
    if (!jM(r10, { upTo: t10 }))
      return r10;
}
function jM(e10, { upTo: t10 }) {
  if (getComputedStyle(e10).visibility === "hidden")
    return true;
  for (; e10; ) {
    if (t10 !== void 0 && e10 === t10)
      return false;
    if (getComputedStyle(e10).display === "none")
      return true;
    e10 = e10.parentElement;
  }
  return false;
}
function kM(e10) {
  return e10 instanceof HTMLInputElement && "select" in e10;
}
function zi(e10, { select: t10 = false } = {}) {
  if (e10 && e10.focus) {
    const r10 = document.activeElement;
    e10.focus({ preventScroll: true }), e10 !== r10 && kM(e10) && t10 && e10.select();
  }
}
var Bp = DM();
function DM() {
  let e10 = [];
  return {
    add(t10) {
      const r10 = e10[0];
      t10 !== r10 && (r10 == null || r10.pause()), e10 = Up(e10, t10), e10.unshift(t10);
    },
    remove(t10) {
      var r10;
      e10 = Up(e10, t10), (r10 = e10[0]) == null || r10.resume();
    }
  };
}
function Up(e10, t10) {
  const r10 = [...e10], n10 = r10.indexOf(t10);
  return n10 !== -1 && r10.splice(n10, 1), r10;
}
function LM(e10) {
  return e10.filter((t10) => t10.tagName !== "A");
}
var BM = function(e10) {
  if (typeof document > "u")
    return null;
  var t10 = Array.isArray(e10) ? e10[0] : e10;
  return t10.ownerDocument.body;
};
var Qo = /* @__PURE__ */ new WeakMap();
var ic = /* @__PURE__ */ new WeakMap();
var oc = {};
var Zu = 0;
var Py = function(e10) {
  return e10 && (e10.host || Py(e10.parentNode));
};
var UM = function(e10, t10) {
  return t10.map(function(r10) {
    if (e10.contains(r10))
      return r10;
    var n10 = Py(r10);
    return n10 && e10.contains(n10) ? n10 : (console.error("aria-hidden", r10, "in not contained inside", e10, ". Doing nothing"), null);
  }).filter(function(r10) {
    return !!r10;
  });
};
var FM = function(e10, t10, r10, n10) {
  var i10 = UM(t10, Array.isArray(e10) ? e10 : [e10]);
  oc[r10] || (oc[r10] = /* @__PURE__ */ new WeakMap());
  var o10 = oc[r10], s10 = [], a10 = /* @__PURE__ */ new Set(), c = new Set(i10), l10 = function(d6) {
    !d6 || a10.has(d6) || (a10.add(d6), l10(d6.parentNode));
  };
  i10.forEach(l10);
  var u10 = function(d6) {
    !d6 || c.has(d6) || Array.prototype.forEach.call(d6.children, function(p) {
      if (a10.has(p))
        u10(p);
      else
        try {
          var y = p.getAttribute(n10), x = y !== null && y !== "false", b = (Qo.get(p) || 0) + 1, M = (o10.get(p) || 0) + 1;
          Qo.set(p, b), o10.set(p, M), s10.push(p), b === 1 && x && ic.set(p, true), M === 1 && p.setAttribute(r10, "true"), x || p.setAttribute(n10, "true");
        } catch (O) {
          console.error("aria-hidden: cannot operate on ", p, O);
        }
    });
  };
  return u10(t10), a10.clear(), Zu++, function() {
    s10.forEach(function(d6) {
      var p = Qo.get(d6) - 1, y = o10.get(d6) - 1;
      Qo.set(d6, p), o10.set(d6, y), p || (ic.has(d6) || d6.removeAttribute(n10), ic.delete(d6)), y || d6.removeAttribute(r10);
    }), Zu--, Zu || (Qo = /* @__PURE__ */ new WeakMap(), Qo = /* @__PURE__ */ new WeakMap(), ic = /* @__PURE__ */ new WeakMap(), oc = {});
  };
};
var $M = function(e10, t10, r10) {
  r10 === void 0 && (r10 = "data-aria-hidden");
  var n10 = Array.from(Array.isArray(e10) ? e10 : [e10]), i10 = t10 || BM(e10);
  return i10 ? (n10.push.apply(n10, Array.from(i10.querySelectorAll("[aria-live]"))), FM(n10, i10, r10, "aria-hidden")) : function() {
    return null;
  };
};
var Jn = function() {
  return Jn = Object.assign || function(t10) {
    for (var r10, n10 = 1, i10 = arguments.length; n10 < i10; n10++) {
      r10 = arguments[n10];
      for (var o10 in r10)
        Object.prototype.hasOwnProperty.call(r10, o10) && (t10[o10] = r10[o10]);
    }
    return t10;
  }, Jn.apply(this, arguments);
};
function Ny(e10, t10) {
  var r10 = {};
  for (var n10 in e10)
    Object.prototype.hasOwnProperty.call(e10, n10) && t10.indexOf(n10) < 0 && (r10[n10] = e10[n10]);
  if (e10 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i10 = 0, n10 = Object.getOwnPropertySymbols(e10); i10 < n10.length; i10++)
      t10.indexOf(n10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(e10, n10[i10]) && (r10[n10[i10]] = e10[n10[i10]]);
  return r10;
}
function VM(e10, t10, r10) {
  if (r10 || arguments.length === 2)
    for (var n10 = 0, i10 = t10.length, o10; n10 < i10; n10++)
      (o10 || !(n10 in t10)) && (o10 || (o10 = Array.prototype.slice.call(t10, 0, n10)), o10[n10] = t10[n10]);
  return e10.concat(o10 || Array.prototype.slice.call(t10));
}
var Ec = "right-scroll-bar-position";
var Cc = "width-before-scroll-bar";
var zM = "with-scroll-bars-hidden";
var qM = "--removed-body-scroll-bar-size";
function Qu(e10, t10) {
  return typeof e10 == "function" ? e10(t10) : e10 && (e10.current = t10), e10;
}
function HM(e10, t10) {
  var r10 = (0, import_react25.useState)(function() {
    return {
      // value
      value: e10,
      // last callback
      callback: t10,
      // "memoized" public interface
      facade: {
        get current() {
          return r10.value;
        },
        set current(n10) {
          var i10 = r10.value;
          i10 !== n10 && (r10.value = n10, r10.callback(n10, i10));
        }
      }
    };
  })[0];
  return r10.callback = t10, r10.facade;
}
var WM = typeof window < "u" ? R.useLayoutEffect : R.useEffect;
var Fp2 = /* @__PURE__ */ new WeakMap();
function GM(e10, t10) {
  var r10 = HM(t10 || null, function(n10) {
    return e10.forEach(function(i10) {
      return Qu(i10, n10);
    });
  });
  return WM(function() {
    var n10 = Fp2.get(r10);
    if (n10) {
      var i10 = new Set(n10), o10 = new Set(e10), s10 = r10.current;
      i10.forEach(function(a10) {
        o10.has(a10) || Qu(a10, null);
      }), o10.forEach(function(a10) {
        i10.has(a10) || Qu(a10, s10);
      });
    }
    Fp2.set(r10, e10);
  }, [e10]), r10;
}
function KM(e10) {
  return e10;
}
function YM(e10, t10) {
  t10 === void 0 && (t10 = KM);
  var r10 = [], n10 = false, i10 = {
    read: function() {
      if (n10)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return r10.length ? r10[r10.length - 1] : e10;
    },
    useMedium: function(o10) {
      var s10 = t10(o10, n10);
      return r10.push(s10), function() {
        r10 = r10.filter(function(a10) {
          return a10 !== s10;
        });
      };
    },
    assignSyncMedium: function(o10) {
      for (n10 = true; r10.length; ) {
        var s10 = r10;
        r10 = [], s10.forEach(o10);
      }
      r10 = {
        push: function(a10) {
          return o10(a10);
        },
        filter: function() {
          return r10;
        }
      };
    },
    assignMedium: function(o10) {
      n10 = true;
      var s10 = [];
      if (r10.length) {
        var a10 = r10;
        r10 = [], a10.forEach(o10), s10 = r10;
      }
      var c = function() {
        var u10 = s10;
        s10 = [], u10.forEach(o10);
      }, l10 = function() {
        return Promise.resolve().then(c);
      };
      l10(), r10 = {
        push: function(u10) {
          s10.push(u10), l10();
        },
        filter: function(u10) {
          return s10 = s10.filter(u10), r10;
        }
      };
    }
  };
  return i10;
}
function XM(e10) {
  e10 === void 0 && (e10 = {});
  var t10 = YM(null);
  return t10.options = Jn({ async: true, ssr: false }, e10), t10;
}
var jy = function(e10) {
  var t10 = e10.sideCar, r10 = Ny(e10, ["sideCar"]);
  if (!t10)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var n10 = t10.read();
  if (!n10)
    throw new Error("Sidecar medium not found");
  return R.createElement(n10, Jn({}, r10));
};
jy.isSideCarExport = true;
function JM(e10, t10) {
  return e10.useMedium(t10), jy;
}
var ky = XM();
var ef = function() {
};
var Yl = R.forwardRef(function(e10, t10) {
  var r10 = R.useRef(null), n10 = R.useState({
    onScrollCapture: ef,
    onWheelCapture: ef,
    onTouchMoveCapture: ef
  }), i10 = n10[0], o10 = n10[1], s10 = e10.forwardProps, a10 = e10.children, c = e10.className, l10 = e10.removeScrollBar, u10 = e10.enabled, d6 = e10.shards, p = e10.sideCar, y = e10.noIsolation, x = e10.inert, b = e10.allowPinchZoom, M = e10.as, O = M === void 0 ? "div" : M, P = e10.gapMode, j = Ny(e10, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), F = p, B = GM([r10, t10]), W = Jn(Jn({}, j), i10);
  return R.createElement(
    R.Fragment,
    null,
    u10 && R.createElement(F, { sideCar: ky, removeScrollBar: l10, shards: d6, noIsolation: y, inert: x, setCallbacks: o10, allowPinchZoom: !!b, lockRef: r10, gapMode: P }),
    s10 ? R.cloneElement(R.Children.only(a10), Jn(Jn({}, W), { ref: B })) : R.createElement(O, Jn({}, W, { className: c, ref: B }), a10)
  );
});
Yl.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
Yl.classNames = {
  fullWidth: Cc,
  zeroRight: Ec
};
var $p;
var ZM = function() {
  if ($p)
    return $p;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function QM() {
  if (!document)
    return null;
  var e10 = document.createElement("style");
  e10.type = "text/css";
  var t10 = ZM();
  return t10 && e10.setAttribute("nonce", t10), e10;
}
function eI(e10, t10) {
  e10.styleSheet ? e10.styleSheet.cssText = t10 : e10.appendChild(document.createTextNode(t10));
}
function tI(e10) {
  var t10 = document.head || document.getElementsByTagName("head")[0];
  t10.appendChild(e10);
}
var rI = function() {
  var e10 = 0, t10 = null;
  return {
    add: function(r10) {
      e10 == 0 && (t10 = QM()) && (eI(t10, r10), tI(t10)), e10++;
    },
    remove: function() {
      e10--, !e10 && t10 && (t10.parentNode && t10.parentNode.removeChild(t10), t10 = null);
    }
  };
};
var nI = function() {
  var e10 = rI();
  return function(t10, r10) {
    R.useEffect(function() {
      return e10.add(t10), function() {
        e10.remove();
      };
    }, [t10 && r10]);
  };
};
var Dy = function() {
  var e10 = nI(), t10 = function(r10) {
    var n10 = r10.styles, i10 = r10.dynamic;
    return e10(n10, i10), null;
  };
  return t10;
};
var iI = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var tf = function(e10) {
  return parseInt(e10 || "", 10) || 0;
};
var oI = function(e10) {
  var t10 = window.getComputedStyle(document.body), r10 = t10[e10 === "padding" ? "paddingLeft" : "marginLeft"], n10 = t10[e10 === "padding" ? "paddingTop" : "marginTop"], i10 = t10[e10 === "padding" ? "paddingRight" : "marginRight"];
  return [tf(r10), tf(n10), tf(i10)];
};
var sI = function(e10) {
  if (e10 === void 0 && (e10 = "margin"), typeof window > "u")
    return iI;
  var t10 = oI(e10), r10 = document.documentElement.clientWidth, n10 = window.innerWidth;
  return {
    left: t10[0],
    top: t10[1],
    right: t10[2],
    gap: Math.max(0, n10 - r10 + t10[2] - t10[0])
  };
};
var aI = Dy();
var ms = "data-scroll-locked";
var cI = function(e10, t10, r10, n10) {
  var i10 = e10.left, o10 = e10.top, s10 = e10.right, a10 = e10.gap;
  return r10 === void 0 && (r10 = "margin"), `
  .`.concat(zM, ` {
   overflow: hidden `).concat(n10, `;
   padding-right: `).concat(a10, "px ").concat(n10, `;
  }
  body[`).concat(ms, `] {
    overflow: hidden `).concat(n10, `;
    overscroll-behavior: contain;
    `).concat([
    t10 && "position: relative ".concat(n10, ";"),
    r10 === "margin" && `
    padding-left: `.concat(i10, `px;
    padding-top: `).concat(o10, `px;
    padding-right: `).concat(s10, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a10, "px ").concat(n10, `;
    `),
    r10 === "padding" && "padding-right: ".concat(a10, "px ").concat(n10, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Ec, ` {
    right: `).concat(a10, "px ").concat(n10, `;
  }
  
  .`).concat(Cc, ` {
    margin-right: `).concat(a10, "px ").concat(n10, `;
  }
  
  .`).concat(Ec, " .").concat(Ec, ` {
    right: 0 `).concat(n10, `;
  }
  
  .`).concat(Cc, " .").concat(Cc, ` {
    margin-right: 0 `).concat(n10, `;
  }
  
  body[`).concat(ms, `] {
    `).concat(qM, ": ").concat(a10, `px;
  }
`);
};
var Vp = function() {
  var e10 = parseInt(document.body.getAttribute(ms) || "0", 10);
  return isFinite(e10) ? e10 : 0;
};
var lI = function() {
  R.useEffect(function() {
    return document.body.setAttribute(ms, (Vp() + 1).toString()), function() {
      var e10 = Vp() - 1;
      e10 <= 0 ? document.body.removeAttribute(ms) : document.body.setAttribute(ms, e10.toString());
    };
  }, []);
};
var uI = function(e10) {
  var t10 = e10.noRelative, r10 = e10.noImportant, n10 = e10.gapMode, i10 = n10 === void 0 ? "margin" : n10;
  lI();
  var o10 = R.useMemo(function() {
    return sI(i10);
  }, [i10]);
  return R.createElement(aI, { styles: cI(o10, !t10, i10, r10 ? "" : "!important") });
};
var od = false;
if (typeof window < "u")
  try {
    sc = Object.defineProperty({}, "passive", {
      get: function() {
        return od = true, true;
      }
    });
    window.addEventListener("test", sc, sc), window.removeEventListener("test", sc, sc);
  } catch {
    od = false;
  }
var sc;
var es = od ? { passive: false } : false;
var fI = function(e10) {
  return e10.tagName === "TEXTAREA";
};
var Ly = function(e10, t10) {
  if (!(e10 instanceof Element))
    return false;
  var r10 = window.getComputedStyle(e10);
  return (
    // not-not-scrollable
    r10[t10] !== "hidden" && // contains scroll inside self
    !(r10.overflowY === r10.overflowX && !fI(e10) && r10[t10] === "visible")
  );
};
var dI = function(e10) {
  return Ly(e10, "overflowY");
};
var hI = function(e10) {
  return Ly(e10, "overflowX");
};
var zp = function(e10, t10) {
  var r10 = t10.ownerDocument, n10 = t10;
  do {
    typeof ShadowRoot < "u" && n10 instanceof ShadowRoot && (n10 = n10.host);
    var i10 = By(e10, n10);
    if (i10) {
      var o10 = Uy(e10, n10), s10 = o10[1], a10 = o10[2];
      if (s10 > a10)
        return true;
    }
    n10 = n10.parentNode;
  } while (n10 && n10 !== r10.body);
  return false;
};
var pI = function(e10) {
  var t10 = e10.scrollTop, r10 = e10.scrollHeight, n10 = e10.clientHeight;
  return [
    t10,
    r10,
    n10
  ];
};
var mI = function(e10) {
  var t10 = e10.scrollLeft, r10 = e10.scrollWidth, n10 = e10.clientWidth;
  return [
    t10,
    r10,
    n10
  ];
};
var By = function(e10, t10) {
  return e10 === "v" ? dI(t10) : hI(t10);
};
var Uy = function(e10, t10) {
  return e10 === "v" ? pI(t10) : mI(t10);
};
var gI = function(e10, t10) {
  return e10 === "h" && t10 === "rtl" ? -1 : 1;
};
var vI = function(e10, t10, r10, n10, i10) {
  var o10 = gI(e10, window.getComputedStyle(t10).direction), s10 = o10 * n10, a10 = r10.target, c = t10.contains(a10), l10 = false, u10 = s10 > 0, d6 = 0, p = 0;
  do {
    var y = Uy(e10, a10), x = y[0], b = y[1], M = y[2], O = b - M - o10 * x;
    (x || O) && By(e10, a10) && (d6 += O, p += x), a10 instanceof ShadowRoot ? a10 = a10.host : a10 = a10.parentNode;
  } while (
    // portaled content
    !c && a10 !== document.body || // self content
    c && (t10.contains(a10) || t10 === a10)
  );
  return (u10 && (i10 && Math.abs(d6) < 1 || !i10 && s10 > d6) || !u10 && (i10 && Math.abs(p) < 1 || !i10 && -s10 > p)) && (l10 = true), l10;
};
var ac = function(e10) {
  return "changedTouches" in e10 ? [e10.changedTouches[0].clientX, e10.changedTouches[0].clientY] : [0, 0];
};
var qp = function(e10) {
  return [e10.deltaX, e10.deltaY];
};
var Hp = function(e10) {
  return e10 && "current" in e10 ? e10.current : e10;
};
var bI = function(e10, t10) {
  return e10[0] === t10[0] && e10[1] === t10[1];
};
var yI = function(e10) {
  return `
  .block-interactivity-`.concat(e10, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e10, ` {pointer-events: all;}
`);
};
var wI = 0;
var ts = [];
function xI(e10) {
  var t10 = R.useRef([]), r10 = R.useRef([0, 0]), n10 = R.useRef(), i10 = R.useState(wI++)[0], o10 = R.useState(Dy)[0], s10 = R.useRef(e10);
  R.useEffect(function() {
    s10.current = e10;
  }, [e10]), R.useEffect(function() {
    if (e10.inert) {
      document.body.classList.add("block-interactivity-".concat(i10));
      var b = VM([e10.lockRef.current], (e10.shards || []).map(Hp), true).filter(Boolean);
      return b.forEach(function(M) {
        return M.classList.add("allow-interactivity-".concat(i10));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i10)), b.forEach(function(M) {
          return M.classList.remove("allow-interactivity-".concat(i10));
        });
      };
    }
  }, [e10.inert, e10.lockRef.current, e10.shards]);
  var a10 = R.useCallback(function(b, M) {
    if ("touches" in b && b.touches.length === 2 || b.type === "wheel" && b.ctrlKey)
      return !s10.current.allowPinchZoom;
    var O = ac(b), P = r10.current, j = "deltaX" in b ? b.deltaX : P[0] - O[0], F = "deltaY" in b ? b.deltaY : P[1] - O[1], B, W = b.target, z = Math.abs(j) > Math.abs(F) ? "h" : "v";
    if ("touches" in b && z === "h" && W.type === "range")
      return false;
    var G = zp(z, W);
    if (!G)
      return true;
    if (G ? B = z : (B = z === "v" ? "h" : "v", G = zp(z, W)), !G)
      return false;
    if (!n10.current && "changedTouches" in b && (j || F) && (n10.current = B), !B)
      return true;
    var re = n10.current || B;
    return vI(re, M, b, re === "h" ? j : F, true);
  }, []), c = R.useCallback(function(b) {
    var M = b;
    if (!(!ts.length || ts[ts.length - 1] !== o10)) {
      var O = "deltaY" in M ? qp(M) : ac(M), P = t10.current.filter(function(B) {
        return B.name === M.type && (B.target === M.target || M.target === B.shadowParent) && bI(B.delta, O);
      })[0];
      if (P && P.should) {
        M.cancelable && M.preventDefault();
        return;
      }
      if (!P) {
        var j = (s10.current.shards || []).map(Hp).filter(Boolean).filter(function(B) {
          return B.contains(M.target);
        }), F = j.length > 0 ? a10(M, j[0]) : !s10.current.noIsolation;
        F && M.cancelable && M.preventDefault();
      }
    }
  }, []), l10 = R.useCallback(function(b, M, O, P) {
    var j = { name: b, delta: M, target: O, should: P, shadowParent: SI(O) };
    t10.current.push(j), setTimeout(function() {
      t10.current = t10.current.filter(function(F) {
        return F !== j;
      });
    }, 1);
  }, []), u10 = R.useCallback(function(b) {
    r10.current = ac(b), n10.current = void 0;
  }, []), d6 = R.useCallback(function(b) {
    l10(b.type, qp(b), b.target, a10(b, e10.lockRef.current));
  }, []), p = R.useCallback(function(b) {
    l10(b.type, ac(b), b.target, a10(b, e10.lockRef.current));
  }, []);
  R.useEffect(function() {
    return ts.push(o10), e10.setCallbacks({
      onScrollCapture: d6,
      onWheelCapture: d6,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, es), document.addEventListener("touchmove", c, es), document.addEventListener("touchstart", u10, es), function() {
      ts = ts.filter(function(b) {
        return b !== o10;
      }), document.removeEventListener("wheel", c, es), document.removeEventListener("touchmove", c, es), document.removeEventListener("touchstart", u10, es);
    };
  }, []);
  var y = e10.removeScrollBar, x = e10.inert;
  return R.createElement(
    R.Fragment,
    null,
    x ? R.createElement(o10, { styles: yI(i10) }) : null,
    y ? R.createElement(uI, { gapMode: e10.gapMode }) : null
  );
}
function SI(e10) {
  for (var t10 = null; e10 !== null; )
    e10 instanceof ShadowRoot && (t10 = e10.host, e10 = e10.host), e10 = e10.parentNode;
  return t10;
}
var _I = JM(ky, xI);
var Fy = R.forwardRef(function(e10, t10) {
  return R.createElement(Yl, Jn({}, e10, { ref: t10, sideCar: _I }));
});
Fy.classNames = Yl.classNames;
var EI = Fy;
function CI(e10, t10) {
  return R.useReducer((r10, n10) => t10[r10][n10] ?? r10, e10);
}
var R0 = "ScrollArea";
var [$y, SU] = Di(R0);
var [TI, yn] = $y(R0);
var Vy = R.forwardRef(
  (e10, t10) => {
    const {
      __scopeScrollArea: r10,
      type: n10 = "hover",
      dir: i10,
      scrollHideDelay: o10 = 600,
      ...s10
    } = e10, [a10, c] = R.useState(null), [l10, u10] = R.useState(null), [d6, p] = R.useState(null), [y, x] = R.useState(null), [b, M] = R.useState(null), [O, P] = R.useState(0), [j, F] = R.useState(0), [B, W] = R.useState(false), [z, G] = R.useState(false), re = sr(t10, (oe) => c(oe)), ie = A0(i10);
    return w.jsx(
      TI,
      {
        scope: r10,
        type: n10,
        dir: ie,
        scrollHideDelay: o10,
        scrollArea: a10,
        viewport: l10,
        onViewportChange: u10,
        content: d6,
        onContentChange: p,
        scrollbarX: y,
        onScrollbarXChange: x,
        scrollbarXEnabled: B,
        onScrollbarXEnabledChange: W,
        scrollbarY: b,
        onScrollbarYChange: M,
        scrollbarYEnabled: z,
        onScrollbarYEnabledChange: G,
        onCornerWidthChange: P,
        onCornerHeightChange: F,
        children: w.jsx(
          Zt.div,
          {
            dir: ie,
            ...s10,
            ref: re,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": O + "px",
              "--radix-scroll-area-corner-height": j + "px",
              ...e10.style
            }
          }
        )
      }
    );
  }
);
Vy.displayName = R0;
var zy = "ScrollAreaViewport";
var qy = R.forwardRef(
  (e10, t10) => {
    const { __scopeScrollArea: r10, children: n10, nonce: i10, ...o10 } = e10, s10 = yn(zy, r10), a10 = R.useRef(null), c = sr(t10, a10, s10.onViewportChange);
    return w.jsxs(w.Fragment, { children: [
      w.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i10
        }
      ),
      w.jsx(
        Zt.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o10,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: s10.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: s10.scrollbarYEnabled ? "scroll" : "hidden",
            ...e10.style
          },
          children: w.jsx("div", { ref: s10.onContentChange, style: { minWidth: "100%", display: "table" }, children: n10 })
        }
      )
    ] });
  }
);
qy.displayName = zy;
var si = "ScrollAreaScrollbar";
var Hy = R.forwardRef(
  (e10, t10) => {
    const { forceMount: r10, ...n10 } = e10, i10 = yn(si, e10.__scopeScrollArea), { onScrollbarXEnabledChange: o10, onScrollbarYEnabledChange: s10 } = i10, a10 = e10.orientation === "horizontal";
    return R.useEffect(() => (a10 ? o10(true) : s10(true), () => {
      a10 ? o10(false) : s10(false);
    }), [a10, o10, s10]), i10.type === "hover" ? w.jsx(AI, { ...n10, ref: t10, forceMount: r10 }) : i10.type === "scroll" ? w.jsx(MI, { ...n10, ref: t10, forceMount: r10 }) : i10.type === "auto" ? w.jsx(Wy, { ...n10, ref: t10, forceMount: r10 }) : i10.type === "always" ? w.jsx(P0, { ...n10, ref: t10 }) : null;
  }
);
Hy.displayName = si;
var AI = R.forwardRef((e10, t10) => {
  const { forceMount: r10, ...n10 } = e10, i10 = yn(si, e10.__scopeScrollArea), [o10, s10] = R.useState(false);
  return R.useEffect(() => {
    const a10 = i10.scrollArea;
    let c = 0;
    if (a10) {
      const l10 = () => {
        window.clearTimeout(c), s10(true);
      }, u10 = () => {
        c = window.setTimeout(() => s10(false), i10.scrollHideDelay);
      };
      return a10.addEventListener("pointerenter", l10), a10.addEventListener("pointerleave", u10), () => {
        window.clearTimeout(c), a10.removeEventListener("pointerenter", l10), a10.removeEventListener("pointerleave", u10);
      };
    }
  }, [i10.scrollArea, i10.scrollHideDelay]), w.jsx($n, { present: r10 || o10, children: w.jsx(
    Wy,
    {
      "data-state": o10 ? "visible" : "hidden",
      ...n10,
      ref: t10
    }
  ) });
});
var MI = R.forwardRef((e10, t10) => {
  const { forceMount: r10, ...n10 } = e10, i10 = yn(si, e10.__scopeScrollArea), o10 = e10.orientation === "horizontal", s10 = Jl(() => c("SCROLL_END"), 100), [a10, c] = CI("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return R.useEffect(() => {
    if (a10 === "idle") {
      const l10 = window.setTimeout(() => c("HIDE"), i10.scrollHideDelay);
      return () => window.clearTimeout(l10);
    }
  }, [a10, i10.scrollHideDelay, c]), R.useEffect(() => {
    const l10 = i10.viewport, u10 = o10 ? "scrollLeft" : "scrollTop";
    if (l10) {
      let d6 = l10[u10];
      const p = () => {
        const y = l10[u10];
        d6 !== y && (c("SCROLL"), s10()), d6 = y;
      };
      return l10.addEventListener("scroll", p), () => l10.removeEventListener("scroll", p);
    }
  }, [i10.viewport, o10, c, s10]), w.jsx($n, { present: r10 || a10 !== "hidden", children: w.jsx(
    P0,
    {
      "data-state": a10 === "hidden" ? "hidden" : "visible",
      ...n10,
      ref: t10,
      onPointerEnter: Ze(e10.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: Ze(e10.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
});
var Wy = R.forwardRef((e10, t10) => {
  const r10 = yn(si, e10.__scopeScrollArea), { forceMount: n10, ...i10 } = e10, [o10, s10] = R.useState(false), a10 = e10.orientation === "horizontal", c = Jl(() => {
    if (r10.viewport) {
      const l10 = r10.viewport.offsetWidth < r10.viewport.scrollWidth, u10 = r10.viewport.offsetHeight < r10.viewport.scrollHeight;
      s10(a10 ? l10 : u10);
    }
  }, 10);
  return Cs(r10.viewport, c), Cs(r10.content, c), w.jsx($n, { present: n10 || o10, children: w.jsx(
    P0,
    {
      "data-state": o10 ? "visible" : "hidden",
      ...i10,
      ref: t10
    }
  ) });
});
var P0 = R.forwardRef((e10, t10) => {
  const { orientation: r10 = "vertical", ...n10 } = e10, i10 = yn(si, e10.__scopeScrollArea), o10 = R.useRef(null), s10 = R.useRef(0), [a10, c] = R.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), l10 = Jy(a10.viewport, a10.content), u10 = {
    ...n10,
    sizes: a10,
    onSizesChange: c,
    hasThumb: l10 > 0 && l10 < 1,
    onThumbChange: (p) => o10.current = p,
    onThumbPointerUp: () => s10.current = 0,
    onThumbPointerDown: (p) => s10.current = p
  };
  function d6(p, y) {
    return jI(p, s10.current, a10, y);
  }
  return r10 === "horizontal" ? w.jsx(
    II,
    {
      ...u10,
      ref: t10,
      onThumbPositionChange: () => {
        if (i10.viewport && o10.current) {
          const p = i10.viewport.scrollLeft, y = Wp(p, a10, i10.dir);
          o10.current.style.transform = `translate3d(${y}px, 0, 0)`;
        }
      },
      onWheelScroll: (p) => {
        i10.viewport && (i10.viewport.scrollLeft = p);
      },
      onDragScroll: (p) => {
        i10.viewport && (i10.viewport.scrollLeft = d6(p, i10.dir));
      }
    }
  ) : r10 === "vertical" ? w.jsx(
    OI,
    {
      ...u10,
      ref: t10,
      onThumbPositionChange: () => {
        if (i10.viewport && o10.current) {
          const p = i10.viewport.scrollTop, y = Wp(p, a10);
          o10.current.style.transform = `translate3d(0, ${y}px, 0)`;
        }
      },
      onWheelScroll: (p) => {
        i10.viewport && (i10.viewport.scrollTop = p);
      },
      onDragScroll: (p) => {
        i10.viewport && (i10.viewport.scrollTop = d6(p));
      }
    }
  ) : null;
});
var II = R.forwardRef((e10, t10) => {
  const { sizes: r10, onSizesChange: n10, ...i10 } = e10, o10 = yn(si, e10.__scopeScrollArea), [s10, a10] = R.useState(), c = R.useRef(null), l10 = sr(t10, c, o10.onScrollbarXChange);
  return R.useEffect(() => {
    c.current && a10(getComputedStyle(c.current));
  }, [c]), w.jsx(
    Ky,
    {
      "data-orientation": "horizontal",
      ...i10,
      ref: l10,
      sizes: r10,
      style: {
        bottom: 0,
        left: o10.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: o10.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Xl(r10) + "px",
        ...e10.style
      },
      onThumbPointerDown: (u10) => e10.onThumbPointerDown(u10.x),
      onDragScroll: (u10) => e10.onDragScroll(u10.x),
      onWheelScroll: (u10, d6) => {
        if (o10.viewport) {
          const p = o10.viewport.scrollLeft + u10.deltaX;
          e10.onWheelScroll(p), Qy(p, d6) && u10.preventDefault();
        }
      },
      onResize: () => {
        c.current && o10.viewport && s10 && n10({
          content: o10.viewport.scrollWidth,
          viewport: o10.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: rl(s10.paddingLeft),
            paddingEnd: rl(s10.paddingRight)
          }
        });
      }
    }
  );
});
var OI = R.forwardRef((e10, t10) => {
  const { sizes: r10, onSizesChange: n10, ...i10 } = e10, o10 = yn(si, e10.__scopeScrollArea), [s10, a10] = R.useState(), c = R.useRef(null), l10 = sr(t10, c, o10.onScrollbarYChange);
  return R.useEffect(() => {
    c.current && a10(getComputedStyle(c.current));
  }, [c]), w.jsx(
    Ky,
    {
      "data-orientation": "vertical",
      ...i10,
      ref: l10,
      sizes: r10,
      style: {
        top: 0,
        right: o10.dir === "ltr" ? 0 : void 0,
        left: o10.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Xl(r10) + "px",
        ...e10.style
      },
      onThumbPointerDown: (u10) => e10.onThumbPointerDown(u10.y),
      onDragScroll: (u10) => e10.onDragScroll(u10.y),
      onWheelScroll: (u10, d6) => {
        if (o10.viewport) {
          const p = o10.viewport.scrollTop + u10.deltaY;
          e10.onWheelScroll(p), Qy(p, d6) && u10.preventDefault();
        }
      },
      onResize: () => {
        c.current && o10.viewport && s10 && n10({
          content: o10.viewport.scrollHeight,
          viewport: o10.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: rl(s10.paddingTop),
            paddingEnd: rl(s10.paddingBottom)
          }
        });
      }
    }
  );
});
var [RI, Gy] = $y(si);
var Ky = R.forwardRef((e10, t10) => {
  const {
    __scopeScrollArea: r10,
    sizes: n10,
    hasThumb: i10,
    onThumbChange: o10,
    onThumbPointerUp: s10,
    onThumbPointerDown: a10,
    onThumbPositionChange: c,
    onDragScroll: l10,
    onWheelScroll: u10,
    onResize: d6,
    ...p
  } = e10, y = yn(si, r10), [x, b] = R.useState(null), M = sr(t10, (re) => b(re)), O = R.useRef(null), P = R.useRef(""), j = y.viewport, F = n10.content - n10.viewport, B = wr(u10), W = wr(c), z = Jl(d6, 10);
  function G(re) {
    if (O.current) {
      const ie = re.clientX - O.current.left, oe = re.clientY - O.current.top;
      l10({ x: ie, y: oe });
    }
  }
  return R.useEffect(() => {
    const re = (ie) => {
      const oe = ie.target;
      (x == null ? void 0 : x.contains(oe)) && B(ie, F);
    };
    return document.addEventListener("wheel", re, { passive: false }), () => document.removeEventListener("wheel", re, { passive: false });
  }, [j, x, F, B]), R.useEffect(W, [n10, W]), Cs(x, z), Cs(y.content, z), w.jsx(
    RI,
    {
      scope: r10,
      scrollbar: x,
      hasThumb: i10,
      onThumbChange: wr(o10),
      onThumbPointerUp: wr(s10),
      onThumbPositionChange: W,
      onThumbPointerDown: wr(a10),
      children: w.jsx(
        Zt.div,
        {
          ...p,
          ref: M,
          style: { position: "absolute", ...p.style },
          onPointerDown: Ze(e10.onPointerDown, (re) => {
            re.button === 0 && (re.target.setPointerCapture(re.pointerId), O.current = x.getBoundingClientRect(), P.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", y.viewport && (y.viewport.style.scrollBehavior = "auto"), G(re));
          }),
          onPointerMove: Ze(e10.onPointerMove, G),
          onPointerUp: Ze(e10.onPointerUp, (re) => {
            const ie = re.target;
            ie.hasPointerCapture(re.pointerId) && ie.releasePointerCapture(re.pointerId), document.body.style.webkitUserSelect = P.current, y.viewport && (y.viewport.style.scrollBehavior = ""), O.current = null;
          })
        }
      )
    }
  );
});
var tl = "ScrollAreaThumb";
var Yy = R.forwardRef(
  (e10, t10) => {
    const { forceMount: r10, ...n10 } = e10, i10 = Gy(tl, e10.__scopeScrollArea);
    return w.jsx($n, { present: r10 || i10.hasThumb, children: w.jsx(PI, { ref: t10, ...n10 }) });
  }
);
var PI = R.forwardRef(
  (e10, t10) => {
    const { __scopeScrollArea: r10, style: n10, ...i10 } = e10, o10 = yn(tl, r10), s10 = Gy(tl, r10), { onThumbPositionChange: a10 } = s10, c = sr(
      t10,
      (d6) => s10.onThumbChange(d6)
    ), l10 = R.useRef(void 0), u10 = Jl(() => {
      l10.current && (l10.current(), l10.current = void 0);
    }, 100);
    return R.useEffect(() => {
      const d6 = o10.viewport;
      if (d6) {
        const p = () => {
          if (u10(), !l10.current) {
            const y = kI(d6, a10);
            l10.current = y, a10();
          }
        };
        return a10(), d6.addEventListener("scroll", p), () => d6.removeEventListener("scroll", p);
      }
    }, [o10.viewport, u10, a10]), w.jsx(
      Zt.div,
      {
        "data-state": s10.hasThumb ? "visible" : "hidden",
        ...i10,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n10
        },
        onPointerDownCapture: Ze(e10.onPointerDownCapture, (d6) => {
          const y = d6.target.getBoundingClientRect(), x = d6.clientX - y.left, b = d6.clientY - y.top;
          s10.onThumbPointerDown({ x, y: b });
        }),
        onPointerUp: Ze(e10.onPointerUp, s10.onThumbPointerUp)
      }
    );
  }
);
Yy.displayName = tl;
var N0 = "ScrollAreaCorner";
var Xy = R.forwardRef(
  (e10, t10) => {
    const r10 = yn(N0, e10.__scopeScrollArea), n10 = !!(r10.scrollbarX && r10.scrollbarY);
    return r10.type !== "scroll" && n10 ? w.jsx(NI, { ...e10, ref: t10 }) : null;
  }
);
Xy.displayName = N0;
var NI = R.forwardRef((e10, t10) => {
  const { __scopeScrollArea: r10, ...n10 } = e10, i10 = yn(N0, r10), [o10, s10] = R.useState(0), [a10, c] = R.useState(0), l10 = !!(o10 && a10);
  return Cs(i10.scrollbarX, () => {
    var d6;
    const u10 = ((d6 = i10.scrollbarX) == null ? void 0 : d6.offsetHeight) || 0;
    i10.onCornerHeightChange(u10), c(u10);
  }), Cs(i10.scrollbarY, () => {
    var d6;
    const u10 = ((d6 = i10.scrollbarY) == null ? void 0 : d6.offsetWidth) || 0;
    i10.onCornerWidthChange(u10), s10(u10);
  }), l10 ? w.jsx(
    Zt.div,
    {
      ...n10,
      ref: t10,
      style: {
        width: o10,
        height: a10,
        position: "absolute",
        right: i10.dir === "ltr" ? 0 : void 0,
        left: i10.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e10.style
      }
    }
  ) : null;
});
function rl(e10) {
  return e10 ? parseInt(e10, 10) : 0;
}
function Jy(e10, t10) {
  const r10 = e10 / t10;
  return isNaN(r10) ? 0 : r10;
}
function Xl(e10) {
  const t10 = Jy(e10.viewport, e10.content), r10 = e10.scrollbar.paddingStart + e10.scrollbar.paddingEnd, n10 = (e10.scrollbar.size - r10) * t10;
  return Math.max(n10, 18);
}
function jI(e10, t10, r10, n10 = "ltr") {
  const i10 = Xl(r10), o10 = i10 / 2, s10 = t10 || o10, a10 = i10 - s10, c = r10.scrollbar.paddingStart + s10, l10 = r10.scrollbar.size - r10.scrollbar.paddingEnd - a10, u10 = r10.content - r10.viewport, d6 = n10 === "ltr" ? [0, u10] : [u10 * -1, 0];
  return Zy([c, l10], d6)(e10);
}
function Wp(e10, t10, r10 = "ltr") {
  const n10 = Xl(t10), i10 = t10.scrollbar.paddingStart + t10.scrollbar.paddingEnd, o10 = t10.scrollbar.size - i10, s10 = t10.content - t10.viewport, a10 = o10 - n10, c = r10 === "ltr" ? [0, s10] : [s10 * -1, 0], l10 = IM(e10, c);
  return Zy([0, s10], [0, a10])(l10);
}
function Zy(e10, t10) {
  return (r10) => {
    if (e10[0] === e10[1] || t10[0] === t10[1])
      return t10[0];
    const n10 = (t10[1] - t10[0]) / (e10[1] - e10[0]);
    return t10[0] + n10 * (r10 - e10[0]);
  };
}
function Qy(e10, t10) {
  return e10 > 0 && e10 < t10;
}
var kI = (e10, t10 = () => {
}) => {
  let r10 = { left: e10.scrollLeft, top: e10.scrollTop }, n10 = 0;
  return function i10() {
    const o10 = { left: e10.scrollLeft, top: e10.scrollTop }, s10 = r10.left !== o10.left, a10 = r10.top !== o10.top;
    (s10 || a10) && t10(), r10 = o10, n10 = window.requestAnimationFrame(i10);
  }(), () => window.cancelAnimationFrame(n10);
};
function Jl(e10, t10) {
  const r10 = wr(e10), n10 = R.useRef(0);
  return R.useEffect(() => () => window.clearTimeout(n10.current), []), R.useCallback(() => {
    window.clearTimeout(n10.current), n10.current = window.setTimeout(r10, t10);
  }, [r10, t10]);
}
function Cs(e10, t10) {
  const r10 = wr(t10);
  ro(() => {
    let n10 = 0;
    if (e10) {
      const i10 = new ResizeObserver(() => {
        cancelAnimationFrame(n10), n10 = window.requestAnimationFrame(r10);
      });
      return i10.observe(e10), () => {
        window.cancelAnimationFrame(n10), i10.unobserve(e10);
      };
    }
  }, [e10, r10]);
}
var DI = Vy;
var LI = qy;
var Gp = Hy;
var Kp = Yy;
var BI = Xy;
var j0 = "Switch";
var [UI, _U] = Di(j0);
var [FI, $I] = UI(j0);
var e22 = R.forwardRef(
  (e10, t10) => {
    const {
      __scopeSwitch: r10,
      name: n10,
      checked: i10,
      defaultChecked: o10,
      required: s10,
      disabled: a10,
      value: c = "on",
      onCheckedChange: l10,
      form: u10,
      ...d6
    } = e10, [p, y] = R.useState(null), x = sr(t10, (j) => y(j)), b = R.useRef(false), M = p ? u10 || !!p.closest("form") : true, [O = false, P] = Fa({
      prop: i10,
      defaultProp: o10,
      onChange: l10
    });
    return w.jsxs(FI, { scope: r10, checked: O, disabled: a10, children: [
      w.jsx(
        Zt.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": O,
          "aria-required": s10,
          "data-state": n2(O),
          "data-disabled": a10 ? "" : void 0,
          disabled: a10,
          value: c,
          ...d6,
          ref: x,
          onClick: Ze(e10.onClick, (j) => {
            P((F) => !F), M && (b.current = j.isPropagationStopped(), b.current || j.stopPropagation());
          })
        }
      ),
      M && w.jsx(
        VI,
        {
          control: p,
          bubbles: !b.current,
          name: n10,
          value: c,
          checked: O,
          required: s10,
          disabled: a10,
          form: u10,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
e22.displayName = j0;
var t22 = "SwitchThumb";
var r2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeSwitch: r10, ...n10 } = e10, i10 = $I(t22, r10);
    return w.jsx(
      Zt.span,
      {
        "data-state": n2(i10.checked),
        "data-disabled": i10.disabled ? "" : void 0,
        ...n10,
        ref: t10
      }
    );
  }
);
r2.displayName = t22;
var VI = (e10) => {
  const { control: t10, checked: r10, bubbles: n10 = true, ...i10 } = e10, o10 = R.useRef(null), s10 = vy(r10), a10 = _0(t10);
  return R.useEffect(() => {
    const c = o10.current, l10 = window.HTMLInputElement.prototype, d6 = Object.getOwnPropertyDescriptor(l10, "checked").set;
    if (s10 !== r10 && d6) {
      const p = new Event("click", { bubbles: n10 });
      d6.call(c, r10), c.dispatchEvent(p);
    }
  }, [s10, r10, n10]), w.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: r10,
      ...i10,
      tabIndex: -1,
      ref: o10,
      style: {
        ...e10.style,
        ...a10,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function n2(e10) {
  return e10 ? "checked" : "unchecked";
}
var zI = e22;
var qI = r2;
var HI = ["1", "2", "3"];
var WI = ["classic", "surface", "soft"];
var Ys = {
  size: { type: "enum", values: HI, default: "2", responsive: true },
  variant: { type: "enum", values: WI, default: "surface" },
  color: $a,
  highContrast: Hl,
  radius: I0
};
var i2 = R.forwardRef((e10, t10) => {
  const { rest: r10, ...n10 } = ks(e10), { className: i10, style: o10, size: s10 = Ys.size.default, variant: a10 = Ys.variant.default, color: c = Ys.color.default, highContrast: l10 = Ys.highContrast.default, radius: u10 = Ys.radius.default, ...d6 } = r10;
  return R.createElement(
    "span",
    { "data-radius": u10, className: rr("rt-SwitchRoot", i10, St(s10, "rt-r-size"), `rt-variant-${a10}`, { "rt-high-contrast": l10 }, Ds(n10)), style: o10 },
    R.createElement(
      zI,
      { "data-accent-color": c, ...d6, ref: t10, className: rr("rt-reset", "rt-SwitchButton", {
        "rt-high-contrast": l10
      }) },
      R.createElement(qI, { className: rr("rt-SwitchThumb", { "rt-high-contrast": l10 }) })
    )
  );
});
i2.displayName = "Switch";
var sd = ["Enter", " "];
var GI = ["ArrowDown", "PageUp", "Home"];
var o2 = ["ArrowUp", "PageDown", "End"];
var KI = [...GI, ...o2];
var YI = {
  ltr: [...sd, "ArrowRight"],
  rtl: [...sd, "ArrowLeft"]
};
var XI = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var Va = "Menu";
var [Sa, JI, ZI] = _y(Va);
var [Ho, s2] = Di(Va, [
  ZI,
  $l,
  Cy
]);
var za = $l();
var a22 = Cy();
var [c2, lo] = Ho(Va);
var [QI, qa] = Ho(Va);
var l2 = (e10) => {
  const { __scopeMenu: t10, open: r10 = false, children: n10, dir: i10, onOpenChange: o10, modal: s10 = true } = e10, a10 = za(t10), [c, l10] = R.useState(null), u10 = R.useRef(false), d6 = wr(o10), p = A0(i10);
  return R.useEffect(() => {
    const y = () => {
      u10.current = true, document.addEventListener("pointerdown", x, { capture: true, once: true }), document.addEventListener("pointermove", x, { capture: true, once: true });
    }, x = () => u10.current = false;
    return document.addEventListener("keydown", y, { capture: true }), () => {
      document.removeEventListener("keydown", y, { capture: true }), document.removeEventListener("pointerdown", x, { capture: true }), document.removeEventListener("pointermove", x, { capture: true });
    };
  }, []), w.jsx(ty, { ...a10, children: w.jsx(
    c2,
    {
      scope: t10,
      open: r10,
      onOpenChange: d6,
      content: c,
      onContentChange: l10,
      children: w.jsx(
        QI,
        {
          scope: t10,
          onClose: R.useCallback(() => d6(false), [d6]),
          isUsingKeyboardRef: u10,
          dir: p,
          modal: s10,
          children: n10
        }
      )
    }
  ) });
};
l2.displayName = Va;
var eO = "MenuAnchor";
var k0 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, ...n10 } = e10, i10 = za(r10);
    return w.jsx(ry, { ...i10, ...n10, ref: t10 });
  }
);
k0.displayName = eO;
var D0 = "MenuPortal";
var [tO, u2] = Ho(D0, {
  forceMount: void 0
});
var f2 = (e10) => {
  const { __scopeMenu: t10, forceMount: r10, children: n10, container: i10 } = e10, o10 = lo(D0, t10);
  return w.jsx(tO, { scope: t10, forceMount: r10, children: w.jsx($n, { present: r10 || o10.open, children: w.jsx(oy, { asChild: true, container: i10, children: n10 }) }) });
};
f2.displayName = D0;
var vn = "MenuContent";
var [rO, L0] = Ho(vn);
var d2 = R.forwardRef(
  (e10, t10) => {
    const r10 = u2(vn, e10.__scopeMenu), { forceMount: n10 = r10.forceMount, ...i10 } = e10, o10 = lo(vn, e10.__scopeMenu), s10 = qa(vn, e10.__scopeMenu);
    return w.jsx(Sa.Provider, { scope: e10.__scopeMenu, children: w.jsx($n, { present: n10 || o10.open, children: w.jsx(Sa.Slot, { scope: e10.__scopeMenu, children: s10.modal ? w.jsx(nO, { ...i10, ref: t10 }) : w.jsx(iO, { ...i10, ref: t10 }) }) }) });
  }
);
var nO = R.forwardRef(
  (e10, t10) => {
    const r10 = lo(vn, e10.__scopeMenu), n10 = R.useRef(null), i10 = sr(t10, n10);
    return R.useEffect(() => {
      const o10 = n10.current;
      if (o10)
        return $M(o10);
    }, []), w.jsx(
      B0,
      {
        ...e10,
        ref: i10,
        trapFocus: r10.open,
        disableOutsidePointerEvents: r10.open,
        disableOutsideScroll: true,
        onFocusOutside: Ze(
          e10.onFocusOutside,
          (o10) => o10.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => r10.onOpenChange(false)
      }
    );
  }
);
var iO = R.forwardRef((e10, t10) => {
  const r10 = lo(vn, e10.__scopeMenu);
  return w.jsx(
    B0,
    {
      ...e10,
      ref: t10,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => r10.onOpenChange(false)
    }
  );
});
var B0 = R.forwardRef(
  (e10, t10) => {
    const {
      __scopeMenu: r10,
      loop: n10 = false,
      trapFocus: i10,
      onOpenAutoFocus: o10,
      onCloseAutoFocus: s10,
      disableOutsidePointerEvents: a10,
      onEntryFocus: c,
      onEscapeKeyDown: l10,
      onPointerDownOutside: u10,
      onFocusOutside: d6,
      onInteractOutside: p,
      onDismiss: y,
      disableOutsideScroll: x,
      ...b
    } = e10, M = lo(vn, r10), O = qa(vn, r10), P = za(r10), j = a22(r10), F = JI(r10), [B, W] = R.useState(null), z = R.useRef(null), G = sr(t10, z, M.onContentChange), re = R.useRef(0), ie = R.useRef(""), oe = R.useRef(0), q = R.useRef(null), L = R.useRef("right"), h = R.useRef(0), f = x ? EI : R.Fragment, m = x ? { as: Ri, allowPinchZoom: true } : void 0, S = (E) => {
      var ae, ve;
      const I = ie.current + E, C = F().filter((we) => !we.disabled), g = document.activeElement, v10 = (ae = C.find((we) => we.ref.current === g)) == null ? void 0 : ae.textValue, k = C.map((we) => we.textValue), Q = gO(k, I, v10), Z = (ve = C.find((we) => we.textValue === Q)) == null ? void 0 : ve.ref.current;
      (function we(he) {
        ie.current = he, window.clearTimeout(re.current), he !== "" && (re.current = window.setTimeout(() => we(""), 1e3));
      })(I), Z && setTimeout(() => Z.focus());
    };
    R.useEffect(() => () => window.clearTimeout(re.current), []), OM();
    const T = R.useCallback((E) => {
      var C, g;
      return L.current === ((C = q.current) == null ? void 0 : C.side) && bO(E, (g = q.current) == null ? void 0 : g.area);
    }, []);
    return w.jsx(
      rO,
      {
        scope: r10,
        searchRef: ie,
        onItemEnter: R.useCallback(
          (E) => {
            T(E) && E.preventDefault();
          },
          [T]
        ),
        onItemLeave: R.useCallback(
          (E) => {
            var I;
            T(E) || ((I = z.current) == null || I.focus(), W(null));
          },
          [T]
        ),
        onTriggerLeave: R.useCallback(
          (E) => {
            T(E) && E.preventDefault();
          },
          [T]
        ),
        pointerGraceTimerRef: oe,
        onPointerGraceIntentChange: R.useCallback((E) => {
          q.current = E;
        }, []),
        children: w.jsx(f, { ...m, children: w.jsx(
          Oy,
          {
            asChild: true,
            trapped: i10,
            onMountAutoFocus: Ze(o10, (E) => {
              var I;
              E.preventDefault(), (I = z.current) == null || I.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: s10,
            children: w.jsx(
              m0,
              {
                asChild: true,
                disableOutsidePointerEvents: a10,
                onEscapeKeyDown: l10,
                onPointerDownOutside: u10,
                onFocusOutside: d6,
                onInteractOutside: p,
                onDismiss: y,
                children: w.jsx(
                  AM,
                  {
                    asChild: true,
                    ...j,
                    dir: O.dir,
                    orientation: "vertical",
                    loop: n10,
                    currentTabStopId: B,
                    onCurrentTabStopIdChange: W,
                    onEntryFocus: Ze(c, (E) => {
                      O.isUsingKeyboardRef.current || E.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: w.jsx(
                      ny,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": I2(M.open),
                        "data-radix-menu-content": "",
                        dir: O.dir,
                        ...P,
                        ...b,
                        ref: G,
                        style: { outline: "none", ...b.style },
                        onKeyDown: Ze(b.onKeyDown, (E) => {
                          const C = E.target.closest("[data-radix-menu-content]") === E.currentTarget, g = E.ctrlKey || E.altKey || E.metaKey, v10 = E.key.length === 1;
                          C && (E.key === "Tab" && E.preventDefault(), !g && v10 && S(E.key));
                          const k = z.current;
                          if (E.target !== k || !KI.includes(E.key))
                            return;
                          E.preventDefault();
                          const Z = F().filter((ae) => !ae.disabled).map((ae) => ae.ref.current);
                          o2.includes(E.key) && Z.reverse(), pO(Z);
                        }),
                        onBlur: Ze(e10.onBlur, (E) => {
                          E.currentTarget.contains(E.target) || (window.clearTimeout(re.current), ie.current = "");
                        }),
                        onPointerMove: Ze(
                          e10.onPointerMove,
                          _a6((E) => {
                            const I = E.target, C = h.current !== E.clientX;
                            if (E.currentTarget.contains(I) && C) {
                              const g = E.clientX > h.current ? "right" : "left";
                              L.current = g, h.current = E.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
d2.displayName = vn;
var oO = "MenuGroup";
var U0 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, ...n10 } = e10;
    return w.jsx(Zt.div, { role: "group", ...n10, ref: t10 });
  }
);
U0.displayName = oO;
var sO = "MenuLabel";
var h2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, ...n10 } = e10;
    return w.jsx(Zt.div, { ...n10, ref: t10 });
  }
);
h2.displayName = sO;
var nl = "MenuItem";
var Yp = "menu.itemSelect";
var Zl = R.forwardRef(
  (e10, t10) => {
    const { disabled: r10 = false, onSelect: n10, ...i10 } = e10, o10 = R.useRef(null), s10 = qa(nl, e10.__scopeMenu), a10 = L0(nl, e10.__scopeMenu), c = sr(t10, o10), l10 = R.useRef(false), u10 = () => {
      const d6 = o10.current;
      if (!r10 && d6) {
        const p = new CustomEvent(Yp, { bubbles: true, cancelable: true });
        d6.addEventListener(Yp, (y) => n10 == null ? void 0 : n10(y), { once: true }), Pb(d6, p), p.defaultPrevented ? l10.current = false : s10.onClose();
      }
    };
    return w.jsx(
      p2,
      {
        ...i10,
        ref: c,
        disabled: r10,
        onClick: Ze(e10.onClick, u10),
        onPointerDown: (d6) => {
          var p;
          (p = e10.onPointerDown) == null || p.call(e10, d6), l10.current = true;
        },
        onPointerUp: Ze(e10.onPointerUp, (d6) => {
          var p;
          l10.current || (p = d6.currentTarget) == null || p.click();
        }),
        onKeyDown: Ze(e10.onKeyDown, (d6) => {
          const p = a10.searchRef.current !== "";
          r10 || p && d6.key === " " || sd.includes(d6.key) && (d6.currentTarget.click(), d6.preventDefault());
        })
      }
    );
  }
);
Zl.displayName = nl;
var p2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, disabled: n10 = false, textValue: i10, ...o10 } = e10, s10 = L0(nl, r10), a10 = a22(r10), c = R.useRef(null), l10 = sr(t10, c), [u10, d6] = R.useState(false), [p, y] = R.useState("");
    return R.useEffect(() => {
      const x = c.current;
      x && y((x.textContent ?? "").trim());
    }, [o10.children]), w.jsx(
      Sa.ItemSlot,
      {
        scope: r10,
        disabled: n10,
        textValue: i10 ?? p,
        children: w.jsx(MM, { asChild: true, ...a10, focusable: !n10, children: w.jsx(
          Zt.div,
          {
            role: "menuitem",
            "data-highlighted": u10 ? "" : void 0,
            "aria-disabled": n10 || void 0,
            "data-disabled": n10 ? "" : void 0,
            ...o10,
            ref: l10,
            onPointerMove: Ze(
              e10.onPointerMove,
              _a6((x) => {
                n10 ? s10.onItemLeave(x) : (s10.onItemEnter(x), x.defaultPrevented || x.currentTarget.focus({ preventScroll: true }));
              })
            ),
            onPointerLeave: Ze(
              e10.onPointerLeave,
              _a6((x) => s10.onItemLeave(x))
            ),
            onFocus: Ze(e10.onFocus, () => d6(true)),
            onBlur: Ze(e10.onBlur, () => d6(false))
          }
        ) })
      }
    );
  }
);
var aO = "MenuCheckboxItem";
var m2 = R.forwardRef(
  (e10, t10) => {
    const { checked: r10 = false, onCheckedChange: n10, ...i10 } = e10;
    return w.jsx(w2, { scope: e10.__scopeMenu, checked: r10, children: w.jsx(
      Zl,
      {
        role: "menuitemcheckbox",
        "aria-checked": il(r10) ? "mixed" : r10,
        ...i10,
        ref: t10,
        "data-state": V0(r10),
        onSelect: Ze(
          i10.onSelect,
          () => n10 == null ? void 0 : n10(il(r10) ? true : !r10),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
m2.displayName = aO;
var g2 = "MenuRadioGroup";
var [cO, lO] = Ho(
  g2,
  { value: void 0, onValueChange: () => {
  } }
);
var v2 = R.forwardRef(
  (e10, t10) => {
    const { value: r10, onValueChange: n10, ...i10 } = e10, o10 = wr(n10);
    return w.jsx(cO, { scope: e10.__scopeMenu, value: r10, onValueChange: o10, children: w.jsx(U0, { ...i10, ref: t10 }) });
  }
);
v2.displayName = g2;
var b2 = "MenuRadioItem";
var y2 = R.forwardRef(
  (e10, t10) => {
    const { value: r10, ...n10 } = e10, i10 = lO(b2, e10.__scopeMenu), o10 = r10 === i10.value;
    return w.jsx(w2, { scope: e10.__scopeMenu, checked: o10, children: w.jsx(
      Zl,
      {
        role: "menuitemradio",
        "aria-checked": o10,
        ...n10,
        ref: t10,
        "data-state": V0(o10),
        onSelect: Ze(
          n10.onSelect,
          () => {
            var s10;
            return (s10 = i10.onValueChange) == null ? void 0 : s10.call(i10, r10);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
y2.displayName = b2;
var F0 = "MenuItemIndicator";
var [w2, uO] = Ho(
  F0,
  { checked: false }
);
var x2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, forceMount: n10, ...i10 } = e10, o10 = uO(F0, r10);
    return w.jsx(
      $n,
      {
        present: n10 || il(o10.checked) || o10.checked === true,
        children: w.jsx(
          Zt.span,
          {
            ...i10,
            ref: t10,
            "data-state": V0(o10.checked)
          }
        )
      }
    );
  }
);
x2.displayName = F0;
var fO = "MenuSeparator";
var S2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, ...n10 } = e10;
    return w.jsx(
      Zt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...n10,
        ref: t10
      }
    );
  }
);
S2.displayName = fO;
var dO = "MenuArrow";
var _2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeMenu: r10, ...n10 } = e10, i10 = za(r10);
    return w.jsx(iy, { ...i10, ...n10, ref: t10 });
  }
);
_2.displayName = dO;
var $0 = "MenuSub";
var [hO, E2] = Ho($0);
var C2 = (e10) => {
  const { __scopeMenu: t10, children: r10, open: n10 = false, onOpenChange: i10 } = e10, o10 = lo($0, t10), s10 = za(t10), [a10, c] = R.useState(null), [l10, u10] = R.useState(null), d6 = wr(i10);
  return R.useEffect(() => (o10.open === false && d6(false), () => d6(false)), [o10.open, d6]), w.jsx(ty, { ...s10, children: w.jsx(
    c2,
    {
      scope: t10,
      open: n10,
      onOpenChange: d6,
      content: l10,
      onContentChange: u10,
      children: w.jsx(
        hO,
        {
          scope: t10,
          contentId: ya(),
          triggerId: ya(),
          trigger: a10,
          onTriggerChange: c,
          children: r10
        }
      )
    }
  ) });
};
C2.displayName = $0;
var na = "MenuSubTrigger";
var T2 = R.forwardRef(
  (e10, t10) => {
    const r10 = lo(na, e10.__scopeMenu), n10 = qa(na, e10.__scopeMenu), i10 = E2(na, e10.__scopeMenu), o10 = L0(na, e10.__scopeMenu), s10 = R.useRef(null), { pointerGraceTimerRef: a10, onPointerGraceIntentChange: c } = o10, l10 = { __scopeMenu: e10.__scopeMenu }, u10 = R.useCallback(() => {
      s10.current && window.clearTimeout(s10.current), s10.current = null;
    }, []);
    return R.useEffect(() => u10, [u10]), R.useEffect(() => {
      const d6 = a10.current;
      return () => {
        window.clearTimeout(d6), c(null);
      };
    }, [a10, c]), w.jsx(k0, { asChild: true, ...l10, children: w.jsx(
      p2,
      {
        id: i10.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": r10.open,
        "aria-controls": i10.contentId,
        "data-state": I2(r10.open),
        ...e10,
        ref: Ll(t10, i10.onTriggerChange),
        onClick: (d6) => {
          var p;
          (p = e10.onClick) == null || p.call(e10, d6), !(e10.disabled || d6.defaultPrevented) && (d6.currentTarget.focus(), r10.open || r10.onOpenChange(true));
        },
        onPointerMove: Ze(
          e10.onPointerMove,
          _a6((d6) => {
            o10.onItemEnter(d6), !d6.defaultPrevented && !e10.disabled && !r10.open && !s10.current && (o10.onPointerGraceIntentChange(null), s10.current = window.setTimeout(() => {
              r10.onOpenChange(true), u10();
            }, 100));
          })
        ),
        onPointerLeave: Ze(
          e10.onPointerLeave,
          _a6((d6) => {
            var y, x;
            u10();
            const p = (y = r10.content) == null ? void 0 : y.getBoundingClientRect();
            if (p) {
              const b = (x = r10.content) == null ? void 0 : x.dataset.side, M = b === "right", O = M ? -5 : 5, P = p[M ? "left" : "right"], j = p[M ? "right" : "left"];
              o10.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: d6.clientX + O, y: d6.clientY },
                  { x: P, y: p.top },
                  { x: j, y: p.top },
                  { x: j, y: p.bottom },
                  { x: P, y: p.bottom }
                ],
                side: b
              }), window.clearTimeout(a10.current), a10.current = window.setTimeout(
                () => o10.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o10.onTriggerLeave(d6), d6.defaultPrevented)
                return;
              o10.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ze(e10.onKeyDown, (d6) => {
          var y;
          const p = o10.searchRef.current !== "";
          e10.disabled || p && d6.key === " " || YI[n10.dir].includes(d6.key) && (r10.onOpenChange(true), (y = r10.content) == null || y.focus(), d6.preventDefault());
        })
      }
    ) });
  }
);
T2.displayName = na;
var A2 = "MenuSubContent";
var M2 = R.forwardRef(
  (e10, t10) => {
    const r10 = u2(vn, e10.__scopeMenu), { forceMount: n10 = r10.forceMount, ...i10 } = e10, o10 = lo(vn, e10.__scopeMenu), s10 = qa(vn, e10.__scopeMenu), a10 = E2(A2, e10.__scopeMenu), c = R.useRef(null), l10 = sr(t10, c);
    return w.jsx(Sa.Provider, { scope: e10.__scopeMenu, children: w.jsx($n, { present: n10 || o10.open, children: w.jsx(Sa.Slot, { scope: e10.__scopeMenu, children: w.jsx(
      B0,
      {
        id: a10.contentId,
        "aria-labelledby": a10.triggerId,
        ...i10,
        ref: l10,
        align: "start",
        side: s10.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (u10) => {
          var d6;
          s10.isUsingKeyboardRef.current && ((d6 = c.current) == null || d6.focus()), u10.preventDefault();
        },
        onCloseAutoFocus: (u10) => u10.preventDefault(),
        onFocusOutside: Ze(e10.onFocusOutside, (u10) => {
          u10.target !== a10.trigger && o10.onOpenChange(false);
        }),
        onEscapeKeyDown: Ze(e10.onEscapeKeyDown, (u10) => {
          s10.onClose(), u10.preventDefault();
        }),
        onKeyDown: Ze(e10.onKeyDown, (u10) => {
          var y;
          const d6 = u10.currentTarget.contains(u10.target), p = XI[s10.dir].includes(u10.key);
          d6 && p && (o10.onOpenChange(false), (y = a10.trigger) == null || y.focus(), u10.preventDefault());
        })
      }
    ) }) }) });
  }
);
M2.displayName = A2;
function I2(e10) {
  return e10 ? "open" : "closed";
}
function il(e10) {
  return e10 === "indeterminate";
}
function V0(e10) {
  return il(e10) ? "indeterminate" : e10 ? "checked" : "unchecked";
}
function pO(e10) {
  const t10 = document.activeElement;
  for (const r10 of e10)
    if (r10 === t10 || (r10.focus(), document.activeElement !== t10))
      return;
}
function mO(e10, t10) {
  return e10.map((r10, n10) => e10[(t10 + n10) % e10.length]);
}
function gO(e10, t10, r10) {
  const i10 = t10.length > 1 && Array.from(t10).every((l10) => l10 === t10[0]) ? t10[0] : t10, o10 = r10 ? e10.indexOf(r10) : -1;
  let s10 = mO(e10, Math.max(o10, 0));
  i10.length === 1 && (s10 = s10.filter((l10) => l10 !== r10));
  const c = s10.find(
    (l10) => l10.toLowerCase().startsWith(i10.toLowerCase())
  );
  return c !== r10 ? c : void 0;
}
function vO(e10, t10) {
  const { x: r10, y: n10 } = e10;
  let i10 = false;
  for (let o10 = 0, s10 = t10.length - 1; o10 < t10.length; s10 = o10++) {
    const a10 = t10[o10].x, c = t10[o10].y, l10 = t10[s10].x, u10 = t10[s10].y;
    c > n10 != u10 > n10 && r10 < (l10 - a10) * (n10 - c) / (u10 - c) + a10 && (i10 = !i10);
  }
  return i10;
}
function bO(e10, t10) {
  if (!t10)
    return false;
  const r10 = { x: e10.clientX, y: e10.clientY };
  return vO(r10, t10);
}
function _a6(e10) {
  return (t10) => t10.pointerType === "mouse" ? e10(t10) : void 0;
}
var yO = l2;
var wO = k0;
var xO = f2;
var SO = d2;
var _O = U0;
var EO = h2;
var CO = Zl;
var TO = m2;
var AO = v2;
var MO = y2;
var IO = x2;
var OO = S2;
var RO = _2;
var PO = C2;
var NO = T2;
var jO = M2;
var z0 = "DropdownMenu";
var [kO, EU] = Di(
  z0,
  [s2]
);
var $r = s2();
var [DO, O2] = kO(z0);
var R2 = (e10) => {
  const {
    __scopeDropdownMenu: t10,
    children: r10,
    dir: n10,
    open: i10,
    defaultOpen: o10,
    onOpenChange: s10,
    modal: a10 = true
  } = e10, c = $r(t10), l10 = R.useRef(null), [u10 = false, d6] = Fa({
    prop: i10,
    defaultProp: o10,
    onChange: s10
  });
  return w.jsx(
    DO,
    {
      scope: t10,
      triggerId: ya(),
      triggerRef: l10,
      contentId: ya(),
      open: u10,
      onOpenChange: d6,
      onOpenToggle: R.useCallback(() => d6((p) => !p), [d6]),
      modal: a10,
      children: w.jsx(yO, { ...c, open: u10, onOpenChange: d6, dir: n10, modal: a10, children: r10 })
    }
  );
};
R2.displayName = z0;
var P2 = "DropdownMenuTrigger";
var N2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeDropdownMenu: r10, disabled: n10 = false, ...i10 } = e10, o10 = O2(P2, r10), s10 = $r(r10);
    return w.jsx(wO, { asChild: true, ...s10, children: w.jsx(
      Zt.button,
      {
        type: "button",
        id: o10.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o10.open,
        "aria-controls": o10.open ? o10.contentId : void 0,
        "data-state": o10.open ? "open" : "closed",
        "data-disabled": n10 ? "" : void 0,
        disabled: n10,
        ...i10,
        ref: Ll(t10, o10.triggerRef),
        onPointerDown: Ze(e10.onPointerDown, (a10) => {
          !n10 && a10.button === 0 && a10.ctrlKey === false && (o10.onOpenToggle(), o10.open || a10.preventDefault());
        }),
        onKeyDown: Ze(e10.onKeyDown, (a10) => {
          n10 || (["Enter", " "].includes(a10.key) && o10.onOpenToggle(), a10.key === "ArrowDown" && o10.onOpenChange(true), ["Enter", " ", "ArrowDown"].includes(a10.key) && a10.preventDefault());
        })
      }
    ) });
  }
);
N2.displayName = P2;
var LO = "DropdownMenuPortal";
var j2 = (e10) => {
  const { __scopeDropdownMenu: t10, ...r10 } = e10, n10 = $r(t10);
  return w.jsx(xO, { ...n10, ...r10 });
};
j2.displayName = LO;
var k2 = "DropdownMenuContent";
var D2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = O2(k2, r10), o10 = $r(r10), s10 = R.useRef(false);
    return w.jsx(
      SO,
      {
        id: i10.contentId,
        "aria-labelledby": i10.triggerId,
        ...o10,
        ...n10,
        ref: t10,
        onCloseAutoFocus: Ze(e10.onCloseAutoFocus, (a10) => {
          var c;
          s10.current || (c = i10.triggerRef.current) == null || c.focus(), s10.current = false, a10.preventDefault();
        }),
        onInteractOutside: Ze(e10.onInteractOutside, (a10) => {
          const c = a10.detail.originalEvent, l10 = c.button === 0 && c.ctrlKey === true, u10 = c.button === 2 || l10;
          (!i10.modal || u10) && (s10.current = true);
        }),
        style: {
          ...e10.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
D2.displayName = k2;
var BO = "DropdownMenuGroup";
var L2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
    return w.jsx(_O, { ...i10, ...n10, ref: t10 });
  }
);
L2.displayName = BO;
var UO = "DropdownMenuLabel";
var B2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
    return w.jsx(EO, { ...i10, ...n10, ref: t10 });
  }
);
B2.displayName = UO;
var FO = "DropdownMenuItem";
var U2 = R.forwardRef(
  (e10, t10) => {
    const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
    return w.jsx(CO, { ...i10, ...n10, ref: t10 });
  }
);
U2.displayName = FO;
var $O = "DropdownMenuCheckboxItem";
var F2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(TO, { ...i10, ...n10, ref: t10 });
});
F2.displayName = $O;
var VO = "DropdownMenuRadioGroup";
var $2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(AO, { ...i10, ...n10, ref: t10 });
});
$2.displayName = VO;
var zO = "DropdownMenuRadioItem";
var V2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(MO, { ...i10, ...n10, ref: t10 });
});
V2.displayName = zO;
var qO = "DropdownMenuItemIndicator";
var z2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(IO, { ...i10, ...n10, ref: t10 });
});
z2.displayName = qO;
var HO = "DropdownMenuSeparator";
var q2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(OO, { ...i10, ...n10, ref: t10 });
});
q2.displayName = HO;
var WO = "DropdownMenuArrow";
var GO = R.forwardRef(
  (e10, t10) => {
    const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
    return w.jsx(RO, { ...i10, ...n10, ref: t10 });
  }
);
GO.displayName = WO;
var KO = (e10) => {
  const { __scopeDropdownMenu: t10, children: r10, open: n10, onOpenChange: i10, defaultOpen: o10 } = e10, s10 = $r(t10), [a10 = false, c] = Fa({
    prop: n10,
    defaultProp: o10,
    onChange: i10
  });
  return w.jsx(PO, { ...s10, open: a10, onOpenChange: c, children: r10 });
};
var YO = "DropdownMenuSubTrigger";
var H2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(NO, { ...i10, ...n10, ref: t10 });
});
H2.displayName = YO;
var XO = "DropdownMenuSubContent";
var W2 = R.forwardRef((e10, t10) => {
  const { __scopeDropdownMenu: r10, ...n10 } = e10, i10 = $r(r10);
  return w.jsx(
    jO,
    {
      ...i10,
      ...n10,
      ref: t10,
      style: {
        ...e10.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
W2.displayName = XO;
var JO = R2;
var ZO = N2;
var G2 = j2;
var QO = D2;
var eR = L2;
var tR = B2;
var rR = U2;
var nR = F2;
var iR = $2;
var oR = V2;
var K2 = z2;
var sR = q2;
var aR = KO;
var cR = H2;
var lR = W2;
var uR = ["1", "2", "3"];
var fR = ["vertical", "horizontal", "both"];
var rf = {
  size: { type: "enum", values: uR, default: "1", responsive: true },
  radius: I0,
  scrollbars: { type: "enum", values: fR, default: "both" }
};
var q0 = R.forwardRef((e10, t10) => {
  const { rest: r10, ...n10 } = ks(e10), { className: i10, style: o10, type: s10, scrollHideDelay: a10 = s10 !== "scroll" ? 0 : void 0, dir: c, size: l10 = rf.size.default, radius: u10 = rf.radius.default, scrollbars: d6 = rf.scrollbars.default, ...p } = r10;
  return R.createElement(
    DI,
    { type: s10, scrollHideDelay: a10, className: rr("rt-ScrollAreaRoot", i10, Ds(n10)), style: o10 },
    R.createElement(LI, { ...p, ref: t10, className: "rt-ScrollAreaViewport" }),
    R.createElement("div", { className: "rt-ScrollAreaViewportFocusRing" }),
    d6 !== "vertical" ? R.createElement(
      Gp,
      { "data-radius": u10, orientation: "horizontal", className: rr("rt-ScrollAreaScrollbar", St(l10, "rt-r-size")) },
      R.createElement(Kp, { className: "rt-ScrollAreaThumb" })
    ) : null,
    d6 !== "horizontal" ? R.createElement(
      Gp,
      { "data-radius": u10, orientation: "vertical", className: rr("rt-ScrollAreaScrollbar", St(l10, "rt-r-size")) },
      R.createElement(Kp, { className: "rt-ScrollAreaThumb" })
    ) : null,
    d6 === "both" ? R.createElement(BI, { className: "rt-ScrollAreaCorner" }) : null
  );
});
q0.displayName = "ScrollArea";
var dR = ["1", "2"];
var hR = ["solid", "soft"];
var nf = {
  size: { type: "enum", values: dR, default: "2", responsive: true },
  variant: { type: "enum", values: hR, default: "solid" },
  color: $a,
  highContrast: Hl
};
var Y2 = {
  color: $a,
  shortcut: { type: "string", default: void 0 }
};
var X2 = (e10) => R.createElement(JO, { ...e10 });
X2.displayName = "DropdownMenuRoot";
var J2 = R.forwardRef((e10, t10) => R.createElement(ZO, { ...e10, ref: t10, asChild: true }));
J2.displayName = "DropdownMenuTrigger";
var Z2 = R.createContext({});
var Q2 = R.forwardRef((e10, t10) => {
  const r10 = HA(), { className: n10, children: i10, size: o10 = nf.size.default, variant: s10 = nf.variant.default, highContrast: a10 = nf.highContrast.default, color: c = Y2.color.default, container: l10, forceMount: u10, ...d6 } = e10, p = c ?? r10.accentColor;
  return R.createElement(
    G2,
    { container: l10, forceMount: u10 },
    R.createElement(
      ql,
      { asChild: true },
      R.createElement(
        QO,
        { "data-accent-color": p, align: "start", sideOffset: 4, collisionPadding: 10, ...d6, ref: t10, className: rr("rt-PopperContent", "rt-BaseMenuContent", "rt-DropdownMenuContent", n10, St(o10, "rt-r-size"), `rt-variant-${s10}`, { "rt-high-contrast": a10 }) },
        R.createElement(
          q0,
          { type: "auto" },
          R.createElement(
            "div",
            { className: rr("rt-BaseMenuViewport", "rt-DropdownMenuViewport") },
            R.createElement(Z2.Provider, { value: R.useMemo(() => ({ size: o10, variant: s10, color: p, highContrast: a10 }), [o10, s10, p, a10]) }, i10)
          )
        )
      )
    )
  );
});
Q2.displayName = "DropdownMenuContent";
var ew = R.forwardRef((e10, t10) => R.createElement(tR, { ...e10, ref: t10, className: rr("rt-BaseMenuLabel", "rt-DropdownMenuLabel", e10.className) }));
ew.displayName = "DropdownMenuLabel";
var tw = R.forwardRef((e10, t10) => {
  const { className: r10, children: n10, color: i10 = Y2.color.default, shortcut: o10, ...s10 } = e10;
  return R.createElement(
    rR,
    { "data-accent-color": i10, ...s10, ref: t10, className: rr("rt-reset", "rt-BaseMenuItem", "rt-DropdownMenuItem", r10) },
    R.createElement(Ps, null, n10),
    o10 && R.createElement("div", { className: "rt-BaseMenuShortcut rt-DropdownMenuShortcut" }, o10)
  );
});
tw.displayName = "DropdownMenuItem";
var rw = R.forwardRef((e10, t10) => R.createElement(eR, { ...e10, ref: t10, className: rr("rt-BaseMenuGroup", "rt-DropdownMenuGroup", e10.className) }));
rw.displayName = "DropdownMenuGroup";
var nw = R.forwardRef((e10, t10) => R.createElement(iR, { ...e10, ref: t10, className: rr("rt-BaseMenuRadioGroup", "rt-DropdownMenuRadioGroup", e10.className) }));
nw.displayName = "DropdownMenuRadioGroup";
var iw = R.forwardRef((e10, t10) => {
  const { children: r10, className: n10, ...i10 } = e10;
  return R.createElement(
    oR,
    { ...i10, ref: t10, className: rr("rt-BaseMenuItem", "rt-BaseMenuRadioItem", "rt-DropdownMenuItem", "rt-DropdownMenuRadioItem", n10) },
    R.createElement(Ps, null, r10),
    R.createElement(
      K2,
      { className: "rt-BaseMenuItemIndicator rt-DropdownMenuItemIndicator" },
      R.createElement(Wl, { className: "rt-BaseMenuItemIndicatorIcon rt-DropdownMenuItemIndicatorIcon" })
    )
  );
});
iw.displayName = "DropdownMenuRadioItem";
var ow = R.forwardRef((e10, t10) => {
  const { children: r10, className: n10, shortcut: i10, ...o10 } = e10;
  return R.createElement(
    nR,
    { ...o10, ref: t10, className: rr("rt-BaseMenuItem", "rt-BaseMenuCheckboxItem", "rt-DropdownMenuItem", "rt-DropdownMenuCheckboxItem", n10) },
    R.createElement(Ps, null, r10),
    R.createElement(
      K2,
      { className: "rt-BaseMenuItemIndicator rt-DropdownMenuItemIndicator" },
      R.createElement(Wl, { className: "rt-BaseMenuItemIndicatorIcon rt-ContextMenuItemIndicatorIcon" })
    ),
    i10 && R.createElement("div", { className: "rt-BaseMenuShortcut rt-DropdownMenuShortcut" }, i10)
  );
});
ow.displayName = "DropdownMenuCheckboxItem";
var sw = (e10) => R.createElement(aR, { ...e10 });
sw.displayName = "DropdownMenuSub";
var aw = R.forwardRef((e10, t10) => {
  const { className: r10, children: n10, ...i10 } = e10;
  return R.createElement(
    cR,
    { ...i10, ref: t10, className: rr("rt-BaseMenuItem", "rt-BaseMenuSubTrigger", "rt-DropdownMenuItem", "rt-DropdownMenuSubTrigger", r10) },
    R.createElement(Ps, null, n10),
    R.createElement(
      "div",
      { className: "rt-BaseMenuShortcut rt-DropdownMenuShortcut" },
      R.createElement(Sy, { className: "rt-BaseMenuSubTriggerIcon rt-DropdownMenuSubtriggerIcon" })
    )
  );
});
aw.displayName = "DropdownMenuSubTrigger";
var cw = R.forwardRef((e10, t10) => {
  const { className: r10, children: n10, container: i10, forceMount: o10, ...s10 } = e10, { size: a10, variant: c, color: l10, highContrast: u10 } = R.useContext(Z2);
  return R.createElement(
    G2,
    { container: i10, forceMount: o10 },
    R.createElement(
      ql,
      { asChild: true },
      R.createElement(
        lR,
        {
          "data-accent-color": l10,
          alignOffset: -Number(a10) * 4,
          // Side offset accounts for the outer solid box-shadow
          sideOffset: 1,
          collisionPadding: 10,
          ...s10,
          ref: t10,
          className: rr("rt-PopperContent", "rt-BaseMenuContent", "rt-BaseMenuSubContent", "rt-DropdownMenuContent", "rt-DropdownMenuSubContent", r10, St(a10, "rt-r-size"), `rt-variant-${c}`, { "rt-high-contrast": u10 })
        },
        R.createElement(
          q0,
          { type: "auto" },
          R.createElement("div", { className: rr("rt-BaseMenuViewport", "rt-DropdownMenuViewport") }, n10)
        )
      )
    )
  );
});
cw.displayName = "DropdownMenuSubContent";
var lw = R.forwardRef((e10, t10) => R.createElement(sR, { ...e10, ref: t10, className: rr("rt-BaseMenuSeparator", "rt-DropdownMenuSeparator", e10.className) }));
lw.displayName = "DropdownMenuSeparator";
var bn = Object.assign({}, {
  Root: X2,
  Trigger: J2,
  Content: Q2,
  Label: ew,
  Item: tw,
  Group: rw,
  RadioGroup: nw,
  RadioItem: iw,
  CheckboxItem: ow,
  Sub: sw,
  SubTrigger: aw,
  SubContent: cw,
  Separator: lw
});
var pR = ["1", "2", "3", "4"];
var mR = ["classic", "solid", "soft", "surface", "outline", "ghost"];
var Xs = {
  size: { type: "enum", values: pR, default: "2", responsive: true },
  variant: { type: "enum", values: mR, default: "solid" },
  color: $a,
  highContrast: Hl,
  radius: I0
};
var uw = R.forwardRef((e10, t10) => {
  const { rest: r10, ...n10 } = ks(e10), { className: i10, asChild: o10 = false, size: s10 = Xs.size.default, variant: a10 = Xs.variant.default, color: c = Xs.color.default, highContrast: l10 = Xs.highContrast.default, radius: u10 = Xs.radius.default, ...d6 } = r10, p = o10 ? Ri : "button";
  return R.createElement(
    p,
    { "data-disabled": d6.disabled || void 0, "data-accent-color": c, "data-radius": u10, ...d6, ref: t10, className: rr("rt-reset", "rt-BaseButton", i10, St(s10, "rt-r-size"), `rt-variant-${a10}`, { "rt-high-contrast": l10 }, Ds(n10)) }
  );
});
uw.displayName = "BaseButton";
var fw = R.forwardRef((e10, t10) => R.createElement(uw, { ...e10, ref: t10, className: rr("rt-Button", e10.className) }));
fw.displayName = "Button";
var gR = {
  loading: { type: "boolean", default: true }
};
var Ls = R.forwardRef((e10, t10) => {
  const { rest: r10, ...n10 } = ks(e10), { className: i10, children: o10, loading: s10 = gR.loading.default, ...a10 } = r10;
  if (!s10)
    return R.createElement(R.Fragment, null, o10);
  const c = R.isValidElement(o10) ? Ri : "span";
  return R.createElement(c, { ref: t10, "aria-hidden": true, className: rr("rt-Skeleton", i10, Ds(n10)), "data-inline-skeleton": R.isValidElement(o10) ? void 0 : true, tabIndex: -1, inert: "", ...a10 }, o10);
});
Ls.displayName = "Skeleton";
var vR = At("/images/ghost_loading.png");
var bR = At("/images/primary_loading.png");
var yR = {
  primary: bR,
  ghost: vR
};
function wR({
  size: e10 = "24px",
  variant: t10 = "primary",
  wrapStyle: r10 = {}
}) {
  return w.jsx(
    gy,
    {
      align: "center",
      justify: "center",
      style: { width: "100%", height: "100%", ...r10 },
      children: w.jsx(
        "img",
        {
          src: yR[t10],
          alt: "Loading",
          style: {
            width: e10,
            height: e10,
            animation: "spin 1s linear infinite"
          }
        }
      )
    }
  );
}
var xR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAPKADAAQAAAABAAAAPAAAAACL3+lcAAAJW0lEQVRoBd1be1BU1xk/LstLdtlVUYKoKKA8fJBKJDVxovYxTadC0zY1/2jaKWM0GRsnTTOpEQNGqc34mGicNpqxGkirMYk4QFONqTG01WioFXzwFhRfUJTl/dple37XnmUf93Hu3Uuknpmdc/ec7/vO97vn9Z3vfHcUGaa0a+2PxlnN9hVWU+Aia5gxLsIaHGk1GUNCAgMCRocaRqHZ7p5BZ++Aw2HrtPe22PqabF32Olun46Stw/Du6s0Fd4ZDNaFhvQS/k/P95ChryKb4iaO/NX1yWHhgwD1gauUPOAadNY1d7bU3u0/csvVmrcr562W1MqTodQGcvzlj9cwppqw5ceYJFKMuMpnCFLuzvK6j+dK1zk3L1xbuYuVac7+Uy8tNf2legiU7cYrJolUBNXyV1zrbSqvas5evK9yhhs+dVhPgd9YvSUmJCzvyzeQxU92FfV3PX15ubSir63pq1cbiMrVtBqhlyM/9wfqli6MOxkaFjVHLqxf9pPGh1sSY0SuT46MGC07UlKiRq6qHC3c8Vbhk/kNLKJMqPjUKqaF1EuIsPn27OGPNkQxePi7F976ZYU6ICDn3+Oyx8byCv066f164W1vV0js389XCDqV2FYf07pz0xAWJlsq5MyxRSsLuV/2UyNCxoQGjVs9JjikoPlndIqeHbA+jZx+LC79BV2GznBDeuu4+B9l+qI4Un2oSWNIfe4j86plYEhqk+N65mqCreMepuvZouZ42yknCMNYLbL/dSX7xu/Pk3zVtribzjjWSC1faSd66b5Ago8FVrvUBut5p6z9H+adLyZB8tVigvpM6fr4Uo9ry7YeukE++vNez7ry37/aRvv5BsmD2WPdizc8Y3qmzJqUeOFp5QEyIKGBsPU8vjF6p12pMhxpZu6eCOOmyKpbKaS9/O3U8ibAEiVWrLpsx2TQjfmqk6JblAxhGBfbZYKM2O9hbO2D85VsXyM2WXu8q13+8iCr6Un6yaKIu+x06KjY6bFHMpIlHikuqPYaVz8SBBWUKMcouZi5NOR4+/Pymx7yVYsHc/ujkTalq1eXAACzejB6A83Mz1uhpLrZ2DJBtdFXmTVs/qCPg0SsBCzC5y/MA/EhC+Ab3Sn+ftxysJTYVAEAL0Homb0wuwHmb0l/U89Rzjg7Rj7+4pVp3DGvw6pWACdiYPBfgWdPMr7FCf3O7w0ly9lVxizGFGsn8WUPbEnjpOZibX4nQHZsAGJ4KHN6VGHnrYVBg1eVJgXR9/MPLc0hb59DcBe97Rxt52LlogA0YQSwAhltGL09FU2sfeftwPZci8I1sfWEmocOOVFz1tPt3FTQQyNIjARswQpYAGD4oPQRDRm5+DenudXCJy3p2BnkybQIprbL5GCVdPXZBFpcgDiKG0QDvIhxuHDyKJH8vv0uOnW1WpAPBqh9OJcu+O0mgPVthE+WBLMjUIwEjsBrgStXqXXRXpG9gkGzYz7dQ/fiJKPLST2Nd7GcrWl3P3g9vvFdFcPDwNwEjsBrgN/ZXGPh3F14ljc09iqIWPjyObMxMdNF10KF7ucFz/roq6cO1ph4qu8G9SPMzsBrgJNcs4X+MDbe7yZ6iBkUxKfHhZMeLs4gxYMhyLa1s85m/3oIA+CoF7m8CVgNuBPwVtGF/NRlQGHbTokaT3S+n+Bz2z1Qoz1HI5p0ucliAlQ5pY4gckVIdzrinLsorPWFMMNn76sNkjDnQR9xXtId5EvVbiZ6neXgZDbAacdfDCtTmnXT+bf5TrSwbrKh3X0kh0RG+7xXG1NzpFpISFy7IYOflkvI75LrIeoC2nkgZRyBTSwJWI7vY0iJg58f1pFnGOGBWFAwLsYQT97rlnt6Yo3QrOvC362LkQlto87VlnjyixCKFwCoYHiJ1ikXwYuR/Kq4YmJkVlZZoVZTFCM7Q7enXv78ku4ihTbStNRlxZWkxqfNuYFd8/Y+VZFDGwI8eH0rOXLYJP3a9RrdCspb2jlhrAPHC9guKix/azKaHi4PZqaq9I8BqxP2shahzGcKLUVbbLvuSMQf//JnnCJg5zSwK9gZ1/6zYUkawJvCk8/T4CB2WLp7IQ+6iAVYDLqNdJRwPdzv6NR/S05J8hzc8HJlvnpddC8TUgicFuqhJwGrAzbsapi0H6jyOcmp405I87996+h1k5bYyUn+rW40YgVbwjhxU5x0BVgPCDHhb+1e1jRwuUe/FgHzM43luCxicBGt2XlScGnK6waMCnXgTsNIh7TjJw3DPi1HNQypKkxRjJma3/XP93kryxXn/wzhy9lUT6MaTgNWAABLEVCgx5B27TqobtW8HjyYPDWfcL2kdKd56QifoppSAEVgNiJZBAIkcwz0vxhU5EsU6tmC9f/y6cLJSZFBB8PbhK6TZJu8dAUZgFQwPRMvIyccb5PViiMnB/H0kwUpgRW3K0z4txGSjDLrt+0TeB8YwCoCb2u3rES0jJfDTr/i8GFL8MC1hWChZUVL8POXHS/8jSQZsCH8CgQD4udeLLiE0SIrDX2ea1RxEnt9WrmhFSbXPUy43pIGNxXq5bGnqdciVEhxLz7L+pNP0+MhrRWltJz46TJIVMV6scsj1QEsqPlpmg6eeVbIcjrTntpbJ2s6M9n7kAdSDgiPo427OfKYHnUptSU+/7zLxPM7Cj6bE9NGz6fcYMctjIkPJQnoObe+2E1vXAOmlF9jSM55xDX8eYQ0SQG5emUTm0UVRLB092/KbghNVZ1idRw+j8PT+Z+r1vEFkDd2PHAFs83/+wTT3tl1zmBUiwq2zV8FBxYhHcA4MwOKtoseQRiVuzBHhNjvOsoh2v88I8BYwEv/T/dX54ec3sjOz/3LIWz8fwCBAOB8CQxImmxK8Gf4f/iM6b+krRc+L6Srbg//Yu7RmpEbfiYFBGaLyFmQeknR6+cxhd0EI56PLuvS1gDvxCHiGrtBZThXRIc0YCj+r6kc4X1iw4Wc0pCiYlY/EHGBLLralrcgqko2MkR3SDNiDFFzKBZgBfxDCh2WHNAPKcoTzIcINQV80NlLVy2Iy9Mqxz2LrkVqNpdpRBRhCsGUhws3ucDyJyHQpwcNZDgvqeGnrYrF9Vqldv3oJQV+IgxI7cCg1rKUeB4H78pGHt7KIg0Jo0HB+xnOxvuO3z2YV7fRuW+1/v3rYu7E9b6TPjAw3bnzgP9TyBo7/2j/FG6Cf4hmH7VO8/wJSjxTWAm8L8gAAAABJRU5ErkJggg==";
var of = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABGUUKwAAAQcklEQVR4Ac07C3BUVZb33vfp7nQSgiEhYYYgESEj40oZjERH/MxAnFEGQQYUZILRGix1y3V3q3bZqd2trZpZqram1rJ2tMZZiUGFAURQ4romiALjmlkFB2eGEVyMEAQSEiSQ9O+9fvfuOfe923Q66aQ7dDS3q/vcd9+553fPOffzXlMyxqX4hc1Vls9p4Iao5nm8Mp5HSoSfmsIUGjcJRfbMIoJa1CFRbhlh2k3CrJ3F6EG/rTWee3DlkbEUUQqQawYTX3ppVTxInoxN4rPjVxAfAf0kDwG/WEM4RKGUEiEEQYgF0ITxJY2ZPfSwHiJPnV+9etMQ3S6rKWcGmPTcq+XWxOhzVhlfGJ8oQGkoSlnFJcUAAlSk8EHoort1bPMaXGN5lzoao5O1muf9a3vW3nvGRbq8XyXaqKlMebG5IpTXtzF6JZ/PfYINSyjFADDUoCA0eiN+SVvXINIuKKF3qQzKLMr9x9n+YLig/vSPF3UMy3OEm6M2ALgqLd6y5fnwVXyNCJChFZcKU2GcoyGtlx6FuD7MYuQDjemHhNC7mLggR5HTCeWUxic7JD6HG6QGDDmbTxSzrCtEELRPKyOLEB74jDWdu+++hyFslJlGUHng7bTEB6INvPrGC6/O65tmt1iTeKGKWxfDGy7OhL+Tduq9ZLMZ9j19uuGekwMpZHY1pfG1qVZe7Il4EV8ZLSNlYGZgIK3qEXDrZje5GOgw67oevPd3mVG+hJW1AUpf3vpI+GrxjAOj7qmrIpZQhwr/CdbG+sz67tWLj11ic/m1kpden8ELrI2RabyWaIO9QkNv+D/9sbMPLPtVNtyyMsDkra809s8iawjjXj9lAhjxk+TTYLdY1bFm+cFsBMgWt6JpW3WomG6KVpCZhCg5XCqUMBE8Qpq6VvyoIVO6GRmg+oAwvji9sy00zalWKrsMBPF1sW69kzzU9eNlzZkyzQXelM2vLbImORtik3mJoqeCw39CO1gxZUntwbnUVvfSwRENgMp39OzoiJWJsgFZG5JO8BjdfWbpkrp0xL+K9sk7drZEruILYDZxZ0/PCj7IQRXFSytGMsLQ2TtJ8tOnX2+zy2kZo5CBgAdCZjNR8Alb/3Urj2J2wQAUHNHWs7gGczBmSfxlxC6jZadA9iRVhqwOa4CpW3c1RqeRalRcKg+E9X5m5x81lp1acc9Ph6T4NTSiLPlH2TI9BEMDJlDyxipI9dStzY3DiZQ2BK78TfMjfVXiWYHUvKKHme1v1+Z0PPCDP6u28QQrXn7zmmilcyieB6sJKFJwUAA85NHj99815OwwpAfM2PLmvHCleAbmeHR86VK6o4n8z/X7xqvyqDDKhjKirDIc0HOhhKc7z6BOiJNaBhkAV3jhUtEiTMZcV5ImEAXt+vr2Vd/fkUpgvF2jjCgrGEAagaED+xiTOmGiTCmDGiq3v7khdBVpkHjeOj3vBG39/J7v5yTbz9y2pyZO4/cIH68RGisV1PEJjerUZr3MEqepTd+JGUUvnlp647kUWbO6nL7rv1vC3+QLZRzgzAAl2E4b25f94CH3yv0dYICq37Rd2VfZ+5ljgNdjQeP10O4TC+4sddFH94tTae/J1v+0J4il9kRRgHbFkroXSuyLOBG+bnbcd8H4+6Mr7tjmYmf/O233W2djk0SJUpLGCJ/YUTD98PLvdChqA0IgHux/QRiUuRMJ/moi0E0HWEx1zBRevW33yp7w7guRaaTeLiIFFBwTJ2z5wRjFD0L4qqkWJKDWZDK972p7y1Vv7P4thmWm/JLxUHYIBJnHZS6HsI75IxuTcRKEv/Xq/vL+qdEvhA7B42H4z7Kjn935varkDtnUZ2/f+9cXKuxfEH1oBbw1S2K3m0obhUOcwBn6x2N3LfiL1PuZXF/91ttHwiV8lsJlccLzv/B/85N755/BtoQHCM1+juhgepnzYfS5JvIuslWqY7Zw1ta9t/dNc35BNfR0dy7BnS3W5Q4XR9yrJzzOa8PEJZOXB2EneO23tu/5WbYyIL4fdGACZgVcwCE/g8El6OqVhAGsK8hC5YoI8zq1tj8uv2NUGxt0WV4qXgd+lKEFgB5+UQAFk+uJ+x4u9pFf7IF1+MRK2d8oobOBqAPqInl44WaDroqGNMC1r7y3igeZLyEc7OeDjlmvkLKF1726/x/sQoz3S/GtaCPUYESCZ/S2CZ/7/nLSZ+bcwuPaT/292peEo0uC4wNMrmMbDwr/ddvfW56tLIjvt7QHkSfSQWM6Qeq79pV90rt1RIDT2ielc4KzYsz5e1nnR4tvGvV+PjaBPCGVl2kes72XaoA4A+MWHGf1Hy+/5SXk7RX0tH+dtWffWasIsrbKTIAv6ygUFJg6lwDIelb4eOktn1a17uu0ilm5O9OAQfPok0Brk/SAeFDMxpjDDI3QF9ZfRoajKTVv/2+xU0QnSWvLpQjGM9JF21OS36ntTFE+wSZw3vgXxFOeI3uAPAjx42gkkcwSnTKs+EJsM+YepIPQBp2xK6vefqDKKdB8ig06qBHW/yNDuoPQ7Ivxh3HIL9FT4sOkaml81qKb07qxYeu70BM176PqCGVd6P2DGGbYYEZ9T+O0rsKAg86oOxOG1QCjLnMk+r+vn4U+vL/mZIZ0B6E5wfxfFp7QH8w/pW0PnGPHjQizlQK+C/TYKxQegKQpIo/f7I4QIKD7w0gpKHMHZ6fSdB2xGXUy+2kIB0Z6GAdgOA260Fk1k5GPvAQxI9rREakNg/CHuutCcLvJ+0rM2uYDVZbD7xe287FsSPNj+cXPpHAw3ljQj2BGkRCMKLSY9m9pumbUjLo5QQ6nWi59WPNU67DyqyTczTJyrozTP2VELQuktkVz8fHWPw/XZe6uD/89VMwrKYehUVkQvQCFBeg/T08eWHbD74ejMdI9nWuHIQNUKzyui0omfLRERSlaH7aSHyqErwreuPPAP0ZK+V8BfxmK0k1lunIj1rA1J9hv/PBy5dFs9gHqqkKSmFqJDkskHzapAiIcUvWvAtb810cbw6V8NSjtPtrA0XcdUoYkCCzyusnj7y29ftjwyURWqZsAD1PIBjV1ouHy1ysQb36f2aUuxxLiarHmrY/ejxTzeaiwikulPPLW4owHv6SPv7/4+iFPc7KVD3ULEczBrsaCMU2nGuiPqwNsBuubNC43CbJhDH/mtfz+gFVMr8cHWirmVcJDqEdppKBPq9t393W/zZUYqFtykoVzCKpj4kOGsiiYK45p6Nz8xh/+KTTRcZXH0fDYq4QX6NU+KY36bty1uKovDYlRN8NaAAzudsddtq7B4yzHSwIogBXVy+H2qJfBmUhm5Yu/w5GQkqDRPYnAE/D8YdP/3HXt6kzoZIuDulEShwnV7QkPuCAK4hT0dz/SPQxtcraEs8G/tfmTRTzA8uQuD4yQgFDP+5K1jJXyKCMF3dwlPww18NMc5jDmUAsb5VeGA5+TjUJZ4zJxp4x7GAU5JXnQtDWrvG723VnTy6KDcPgceeokp0IIhjixdCPOuh2Bz+HBQvDljN6QBc2sUSHpTlErT+yssr8ZoYeGWyZnzWiIDtSgNW4SdG/qFu1msPBp12Dk8St3gxr99hB9c9hE8y+FnAo95K3hEnpMC+yEZrte5+qqC61d17h2kApxB3LG0eAmHfWWMxPpNc4+CPSTShcXfQ4zEmRjTrN+uSETfsk43NRmUbkQcqcBqfvC5s+r+kvif5ZPVyU2FfkX6bTWuhmj3hEmMx0v9YUtx6b2F/ATcpTdmUfk9xjXsNZF04+YMRZTbgnOAZMRe2K8CJ4rOVAn1E3paVoshrrLIzHDZocdgyd2SY5JVgLjv80Vc0Xn7uaeb0Ty+xJr+ksB4GIELO3h5rqK1xR+LiHqJDdZEHH4cp5hk8NIH3aHcAji6E956UhOTXaAlv3w3ZMz8F4uC2fRYNwniuM+Ir+2V0eIXzgLxUVYzgvqYvnhHQdQ3D0Wg2M/x3wKGUkDvFE3dZNhURkGOE3gCVGc8425lqQACMqZBgRBYSQvD8qFiStOrtkSC3RJuD8EAaw5YqgzMpIGwIrfYq3JAsX8tPaultOJsECcyy4+d/GT7sEIYdpls0glgDrYAVarpj+EvhhtVXgJA5j+wFo4O4fXrnBssBmSoc6llRRyLiCuAlUiSoW5oJ9KQ+qAp2rg2cgbpmFu8sBahZcwwI75JWf8UbbftZTrnpaPzry35dQihXz50Jd40qP4KIgCqofSl8/HpYCyW342UxkaBxZ13HFnSWLLnzAAdvH7J9aDD3DVAb0garINuRII0q2Me3c0UBzwNsw53ifXISBlT4w+GJhrHHVM1sddEiW1LNl9dkPY7zRgEwSBPCvIg/yw87uT65LQRl39kRBpAz2Xe4Ele7paIj6ReAaIAgcirHHngtKHkoUfZAA8qlq8r7vX1gS8BwyzBsQNPOEUeRG2fvv3Jo2bN8OSlUitL3u75+chP193aXULD4UdevH1W0uKcJmXjD8gBPAGIgRsrQ4e6cN7GuieYAU4R4yYfN2Kd3qWJncej3WUMWqKdTiVQyaTwQWvFnPUKVV5lH+QAbBx64Li3wUd/TGNum9byVgFN4jpbMuqt/uuQZzxWFA2lBFHEZWXD9YpE/mO+RjqNJTMQxoAEbfcfsWvIPabXC9w05QD/2CJmM6h8egJK945vzRsxA/BatJQSRZlRx223F6U9lR5UA5ItdLydy8ciGnePgGxMSdAbsxztPWbbyscFzlh5d6LPw8zZx2Kliw//IHl4LZbJ8xNbkutp/UAhVh0W2Gtj7NOdClpWeQB8RXWxLqVe/taFN7XBVEGlAWHRYYqyIfQz7XOovmFtSPJNcBi6ZB/IoTRv7+/LUrEwKUxuILBRXfAMR9q+q6/OV3/sWhfs+fioohGNsCj5xJFHyMfj/gDVDsYvCWv9tc0B6/LK+IIH9jb3xhjdA3HA3VZcEYBzwC+JiefGpyu2nhHcFTvFbn0Rv6tfydU7TC6KcbETJyyB/TA0OS06cXbgg0D2oe5GEhgGER1a827oUcijDwjX+fBcPCOtLz7wk9oW4Hhr3/2JprTZwuPvi9m9NmRjVFCwK09xV37SxEglnlAkMeabg+mTXhKh2SYtQGw88PvWfMijtNiC1KYbADwBLlwwreMDSE6dUI3BwK+p5+toaM6Xnv0AzE1EoE/TRGyEly9LHXE0d3R7eFU52JA0+qe/4455FSXrHBqfVQGQCIoTMN+6/kYERASQ68nJDNYWIEhQhoRR+H57580h3zo9xuHoE9XXpDITUk4RMpjlEymUXsOvAd0A4TYtx1CZ8UJHNenunmSBvBUk8PuoqlxvvnV/m0uSQbyxGFR0X8uvjFGyHzO4eB5mKJGDKEsKRGEM436N+lQZJTHg4fhHwL2Fxbr9U/Pph1D4WbaNmoPSGXwk/2inAvnOYuLhfAA2of3lcCeuoMzhooZhLIDYKo2t2XArw7vSxqEtsLjtLW/nk+l9wxAGMVFzgyQzPvRNrHKtvmTNiezwZV96dx4JAPBcgPCR8R0Sg6bJnvq2Vqa+wOaZMHHov74+6LKiZMGSGTVEPeV4P0lkMNNgBrMJHIAIG7gRRV4c0EQS6OkG1rbIbEd1HTS+Mub6JGxkEvR/H/1GixGG+ou8QAAAABJRU5ErkJggg==";
function Xr({
  src: e10,
  alt: t10,
  className: r10,
  style: n10,
  showWarn: i10,
  ...o10
}) {
  const [s10, a10] = (0, import_react25.useState)(of), c = (l10) => {
    a10(of);
  };
  return (0, import_react25.useEffect)(() => {
    a10(e10 || of);
  }, [e10]), w.jsxs(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        position: "relative"
      },
      children: [
        w.jsx(
          "img",
          {
            src: s10,
            alt: t10 || "",
            className: r10,
            loading: "lazy",
            decoding: "async",
            style: { borderRadius: "100%", ...n10 },
            onError: c,
            ...o10
          }
        ),
        i10 && w.jsx(
          "img",
          {
            style: {
              position: "absolute",
              right: -2,
              bottom: -2,
              width: "16px",
              height: "16px"
            },
            src: xR
          }
        )
      ]
    }
  );
}
function SR({ toastData: e10, onClose: t10 }) {
  const { status: r10, buildShowInfo: n10, tx: i10, id: o10 } = e10, { getExplorerUrl: s10 } = Rs(), a10 = (0, import_react25.useMemo)(() => {
    if (n10 && r10)
      return n10(r10);
  }, [r10]), c = (0, import_react25.useMemo)(() => {
    if (r10) {
      if (r10 === "rejected")
        return "#ff5073";
      if (r10 === "success")
        return "#68ffd8";
    }
    return "#909ca4";
  }, [r10]);
  return w.jsxs("div", { className: "cs-toast", children: [
    w.jsxs("div", { style: { gap: "0px", display: "flex", flexDirection: "column" }, children: [
      w.jsxs(
        "div",
        {
          style: {
            display: "flex",
            gap: "10px",
            alignItems: "center"
          },
          children: [
            r10 === "submitted" && w.jsx("div", { children: w.jsx(wR, {}) }),
            w.jsxs(
              "svg",
              {
                className: "cs-icon",
                style: { width: "16px", height: "16px", fill: c },
                children: [
                  r10 === "rejected" && w.jsx("use", { xlinkHref: "#icon-close" }),
                  r10 === "success" && w.jsx("use", { xlinkHref: "#icon-sel" })
                ]
              }
            ),
            r10 === "submitted" && w.jsxs(
              "span",
              {
                style: {
                  marginLeft: "-28px"
                },
                children: [
                  " ",
                  "Transaction in progress",
                  " "
                ]
              }
            ),
            r10 === "rejected" && w.jsx("span", { className: "red", children: (a10 == null ? void 0 : a10.toastTitleText) || "Transaction failed" }),
            r10 === "success" && w.jsx("span", { className: "green", children: (a10 == null ? void 0 : a10.toastTitleText) || "Transaction Successful" })
          ]
        }
      ),
      r10 === "submitted" && w.jsxs("div", { children: [
        a10 != null && a10.toastDescriptionContent && typeof a10.toastDescriptionContent == "function" ? a10.toastDescriptionContent() : w.jsx("span", { children: a10 == null ? void 0 : a10.toastDescriptionContent }),
        !(a10 != null && a10.toastDescriptionContent) && i10 && w.jsx(
          Ob,
          {
            text: "Confirmation is in progress. Check your transaction on here",
            keywords: ["here"],
            text_highlight_color: "#72c1f7",
            onKeywordClick: () => {
              window.open(s10(i10, "tx"), "_blank");
            }
          }
        )
      ] }),
      r10 === "rejected" && w.jsxs(w.Fragment, { children: [
        a10 != null && a10.toastDescriptionContent && typeof a10.toastDescriptionContent == "function" ? a10.toastDescriptionContent() : w.jsx("span", { children: a10 == null ? void 0 : a10.toastDescriptionContent }),
        !(a10 != null && a10.toastDescriptionContent) && w.jsx("span", { children: "Something went wrong" })
      ] }),
      r10 === "success" && w.jsx(w.Fragment, { children: a10 != null && a10.toastDescriptionContent && typeof a10.toastDescriptionContent == "function" ? a10.toastDescriptionContent() : w.jsx("span", { children: a10 == null ? void 0 : a10.toastDescriptionContent }) }),
      r10 === "success" && i10 && w.jsxs("div", { className: "view-transaction", children: [
        w.jsx("span", { children: "View Transaction" }),
        Dl.map((l10) => w.jsx(
          "a",
          {
            href: s10(i10, "tx", l10.link),
            target: "_blank",
            children: w.jsx(Xr, { src: l10.img })
          },
          l10.link
        ))
      ] })
    ] }),
    w.jsx(
      "svg",
      {
        className: "cs-icon close",
        "aria-hidden": "true",
        onClick: () => t10(o10),
        children: w.jsx("use", { xlinkHref: "#icon-close" })
      }
    )
  ] });
}
var _R = ki((e10, t10) => ({
  toasts: [],
  setToasts: (r10) => {
    e10((n10) => ({
      toasts: [...n10.toasts, r10]
    })), setTimeout(() => {
      e10((n10) => ({
        toasts: n10.toasts.filter(
          (i10) => i10.id !== r10.id
        )
      }));
    }, 3e3);
  },
  removeToast: (r10) => {
    e10((n10) => ({
      toasts: n10.toasts.filter((i10) => i10.id !== r10)
    }));
  }
}));
var Bs = (e10 = "cs-swap-widget") => {
  const { toasts: t10, setToasts: r10, removeToast: n10 } = _R(), i10 = (a10, c = "success") => {
    const u10 = {
      id: Date.now(),
      status: c,
      buildShowInfo: () => ({
        toastTitleText: a10
      })
    };
    r10(u10);
  }, o10 = (a10) => {
    const c = Date.now();
    return a10.id = c, r10(a10), c;
  }, s10 = (0, import_react25.useCallback)(() => {
    let a10 = document.getElementById(e10);
    return a10 || (a10 = document.createElement("div"), a10.id = e10, document.body.appendChild(a10)), import_react_dom3.default.createPortal(
      w.jsx("div", { className: "cs-toast-wrapper", children: t10 && t10.map((c) => w.jsx(
        SR,
        {
          toastData: c,
          onClose: () => {
            n10(c.id);
          }
        },
        c.id
      )) }),
      a10
    );
  }, [t10]);
  return { addCommonToast: i10, addTxToast: o10, ToastContainer: s10, removeToast: n10 };
};
function ER() {
  const { mevProtect: e10, setMevProtect: t10 } = Hr();
  return w.jsxs(bn.Root, { children: [
    w.jsx(bn.Trigger, { children: w.jsx("div", { className: "cs-settings-btn", children: w.jsx(
      "svg",
      {
        "aria-hidden": "true",
        cursor: "pointer",
        fill: e10 ? "var(--cs-primary)" : "var(--cs-icon-fill)",
        children: w.jsx("use", { xlinkHref: "#icon-mev" })
      }
    ) }) }),
    w.jsx(
      bn.Content,
      {
        variant: "soft",
        className: "cs-dropdown-content",
        side: "bottom",
        align: "end",
        style: { maxWidth: "328px" },
        children: w.jsxs("div", { className: "mev-settings-box", children: [
          w.jsxs("div", { className: "mev-setting-title", children: [
            w.jsxs("div", { className: "name", children: [
              w.jsx("img", { src: At("/images/icon_mev@2x.png") }),
              w.jsx("span", { children: "MEV Protect" })
            ] }),
            w.jsx(
              i2,
              {
                checked: e10,
                className: "cs-switch",
                onClick: () => {
                  t10(!e10);
                }
              }
            )
          ] }),
          w.jsx("p", { className: "mev-tips", children: "By enabling this, your txn will be submitted via 3rd party MEV service provider. MEV value retained will be redistributed to all users who successfully execute their trades with Shio through its point campaign." })
        ] })
      }
    )
  ] });
}
function CR({ onClick: e10 }) {
  const [t10, r10] = (0, import_react25.useState)(false), n10 = () => {
    r10(true), setTimeout(() => {
      r10(false);
    }, 1e3), e10();
  };
  return w.jsx("div", { className: "refresh-button", children: w.jsx(
    "svg",
    {
      className: t10 ? "rotate cs-icon-hover" : "cs-icon-hover",
      "aria-hidden": "true",
      onClick: n10,
      children: w.jsx("use", { xlinkHref: "#icon-refresh" })
    }
  ) });
}
function H0(e10) {
  const { text: t10, onClick: r10, className: n10, btnIsDisabled: i10 = false } = e10, o10 = () => {
    r10 && r10();
  };
  return w.jsx(
    fw,
    {
      disabled: i10,
      className: n10 ? `cs-button ${n10}` : "cs-button",
      onClick: o10,
      children: t10
    }
  );
}
function TR() {
  const { setIsOpenSlippageDialog: e10, isOpenSlippageDialog: t10, slippage: r10 } = Hr();
  return w.jsxs(w.Fragment, { children: [
    w.jsxs(
      "div",
      {
        className: "slippage-button",
        onClick: () => e10(true),
        children: [
          w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-verticalslider" }) }),
          w.jsxs("span", { children: [
            r10,
            "%"
          ] })
        ]
      }
    ),
    t10 && w.jsx(AR, { onClose: () => e10(false) })
  ] });
}
function AR({ onClose: e10 }) {
  const { slippage: t10, setSlippage: r10 } = Hr(), [n10, i10] = (0, import_react25.useState)(t10), o10 = (l10) => {
    i10(l10.display);
  }, s10 = (l10) => {
    const u10 = new RegExp("[^\\d-]*(\\d*(?:\\.\\d{0,2})?).*$");
    l10.target.value = l10.target.value.replace(u10, "$1"), i10(l10.target.value);
  }, a10 = () => {
    n10 && r10(n10), e10();
  }, c = (0, import_react25.useMemo)(() => +n10 ? Number(n10) > 50 || Number(n10) < 0.01 : true, [t10, n10]);
  return w.jsxs(w.Fragment, { children: [
    w.jsx("div", { className: "dialog-mask", style: { zIndex: "100" } }),
    w.jsx("div", { className: "slippage-settings-dialog", style: { zIndex: "100" }, children: w.jsxs("div", { className: "slippage-settings", children: [
      w.jsxs("div", { className: "slippage-settings-header", children: [
        w.jsx("div", { className: "title", children: "Slippage Settings" }),
        w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", onClick: e10, children: w.jsx("use", { xlinkHref: "#icon-close" }) })
      ] }),
      w.jsxs("div", { className: "title", children: [
        w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-verticalslider" }) }),
        w.jsx("span", { children: "Slippage Tolerance" })
      ] }),
      w.jsxs("div", { className: "form-box", children: [
        w.jsx("div", { className: "slippage-tab-list", children: xC.map((l10) => w.jsxs(
          "span",
          {
            className: l10.display === n10 ? "active" : "",
            onClick: () => o10(l10),
            children: [
              l10.display,
              " %"
            ]
          }
        )) }),
        w.jsxs("div", { className: "input-box", children: [
          w.jsx("span", { children: "Custom" }),
          w.jsx(
            "input",
            {
              className: "cs-input",
              placeholder: "0.0",
              value: n10,
              onChange: s10
            }
          ),
          w.jsx("div", { style: { fontSize: "14px", color: "#fff" }, children: "%" })
        ] })
      ] }),
      Number(n10) <= 0.05 && w.jsx("div", { className: "tips warning", children: "Slippage is low. Your transaction may fail." }),
      Number(n10) <= 50 && Number(n10) > 1 && w.jsx("div", { className: "tips warning", children: "Your transaction may frontrun" }),
      Number(n10) > 50 && w.jsx("div", { className: "tips error", children: " Enter a valid slippage percentage" }),
      w.jsx(
        H0,
        {
          text: "Save",
          btnIsDisabled: c,
          className: "slippage-save-btn",
          onClick: a10
        }
      )
    ] }) })
  ] });
}
function MR({ handleRefresh: e10 }) {
  return w.jsx(w.Fragment, { children: w.jsxs("div", { className: "swap-header", children: [
    w.jsx("h3", { className: "swap-title", children: "Swap" }),
    w.jsxs("div", { className: "right", children: [
      w.jsx(TR, {}),
      w.jsx(ER, {}),
      w.jsx(CR, { onClick: e10 })
    ] })
  ] }) });
}
function IR() {
  const [e10, t10] = (0, import_react25.useState)(false);
  return w.jsxs(bn.Root, { open: e10, onOpenChange: t10, children: [
    w.jsx(bn.Trigger, { children: w.jsx("div", { className: "cs-settings-btn", children: w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-settings" }) }) }) }),
    w.jsx(
      bn.Content,
      {
        variant: "soft",
        className: "cs-dropdown-content",
        style: {
          backgroundColor: "#2B3643"
        },
        side: "bottom",
        align: "end",
        children: w.jsxs("div", { className: "cs-settings-box", children: [
          w.jsx("h3", { children: "Settings" }),
          w.jsx(OR, {}),
          w.jsx(
            PR,
            {
              onClose: () => {
                t10(false);
              }
            }
          )
        ] })
      }
    )
  ] });
}
function OR() {
  const { currentExplorer: e10, setCurrentExplorer: t10, currentRpc: r10, setCurrentRpc: n10 } = Hr(), i10 = (o10) => {
    t10(o10);
  };
  return w.jsxs("div", { className: "settings-card", style: { marginTop: "12px" }, children: [
    w.jsxs("h3", { className: "card-title", children: [
      w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-plorer" }) }),
      w.jsx("span", { children: "Preferred Explorer" })
    ] }),
    w.jsx("div", { className: "explorer-checkbox-group", children: Dl.map((o10) => w.jsxs(
      "div",
      {
        className: "group-item",
        style: { justifyContent: "center" },
        onClick: () => i10(o10.link),
        children: [
          w.jsx(
            Gl,
            {
              color: "indigo",
              checked: o10.link === e10,
              variant: "soft",
              className: "cs-checkbox"
            }
          ),
          w.jsx("img", { src: o10.img }),
          w.jsx("span", { children: o10.name })
        ]
      }
    )) })
  ] });
}
var RR = (e10) => !/^(http|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?/.test(e10);
function PR({ onClose: e10 }) {
  const { addTxToast: t10 } = Bs(), { currentRpc: r10, setCurrentRpc: n10, customRpc: i10, setCustomRpc: o10, rpcList: s10 } = Hr(), [a10, c] = (0, import_react25.useState)(i10), [l10, u10] = (0, import_react25.useState)(r10), d6 = (b) => {
    t10({
      id: 0,
      status: "success",
      buildShowInfo: () => ({
        toastTitleText: "RPC update",
        toastDescriptionContent: `RPC is currently set to ${b}`
      })
    });
  }, p = (b) => {
    u10(b), b.isCustom || (n10(b), d6(b.link), e10());
  }, y = (b) => {
    c(b.target.value);
  }, x = () => {
    if (a10) {
      const b = {
        name: "Custom RPC URL",
        link: a10,
        isCustom: true
      };
      o10(a10), n10(b), d6(a10), e10();
    }
  };
  return w.jsxs("div", { className: "settings-card rpc-settings-card", children: [
    w.jsxs("h3", { className: "card-title", children: [
      w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-settings" }) }),
      w.jsx("span", { children: "RPC Node" })
    ] }),
    w.jsxs("div", { className: "rpc-checkbox-group", children: [
      s10.map((b) => w.jsxs("div", { className: "rpc-item", onClick: () => p(b), children: [
        w.jsx(
          Gl,
          {
            color: "indigo",
            checked: l10.name === b.name,
            variant: "soft",
            className: "cs-checkbox"
          }
        ),
        w.jsx("span", { children: b.name })
      ] })),
      l10.isCustom && w.jsxs("div", { className: "custom-rpc-input-box", children: [
        w.jsx(
          "input",
          {
            className: "cs-input",
            placeholder: "Custom RPC URL",
            onChange: y,
            value: a10
          }
        ),
        w.jsx(
          H0,
          {
            btnIsDisabled: RR(a10),
            text: "Save",
            onClick: x
          }
        )
      ] })
    ] })
  ] });
}
var Zr = ki((e10, t10) => ({
  accounts: [],
  currentAccount: void 0,
  isOpenWalletModal: false,
  saveCurrentAccount: (r10) => {
    e10({
      currentAccount: r10
    });
  },
  saveAccounts: (r10) => {
    e10({
      accounts: r10
    });
  },
  onWalletModal: (r10) => {
    e10({
      isOpenWalletModal: r10
    });
  },
  isOpenAccountList: false,
  setIsOpenAccountList: (r10) => {
    e10(() => ({
      isOpenAccountList: r10
    }));
  },
  tokenBalanceObj: {},
  setTokenBalanceObj: (r10) => {
    e10(() => ({
      tokenBalanceObj: r10
    }));
  },
  accountServiceNameObj: {},
  setAccountServiceNameObj: (r10) => {
    const n10 = t10().accountServiceNameObj;
    e10({
      accountServiceNameObj: { ...n10, ...r10 }
    });
  }
}));
var uo = ki((e10, t10) => ({
  suiClient: new bs({ url: hs.fullRpcUrl }),
  setSuiClient: (r10) => {
    e10(() => ({
      suiClient: r10
    }));
  },
  aggregatorSDK: new sb({
    signer: hs.simulationAccount,
    client: new bs({ url: hs.fullRpcUrl }),
    env: d0.Mainnet
  }),
  setAggregatorSDK: (r10) => {
    e10(() => ({
      aggregatorSDK: r10
    }));
  }
}));
function dw() {
  const { suiClient: e10 } = uo(), { setAccountServiceNameObj: t10, accountServiceNameObj: r10 } = Zr(), n10 = async (o10) => {
    if (!((o10 == null ? void 0 : o10.length) < 1))
      try {
        const s10 = o10.map(async (l10) => {
          var d6;
          const u10 = await e10.resolveNameServiceNames({
            address: l10
          });
          return {
            address: l10,
            name: ((d6 = u10 == null ? void 0 : u10.data) == null ? void 0 : d6[0]) || ""
          };
        }), a10 = await Promise.all(s10), c = Object.fromEntries(
          a10 == null ? void 0 : a10.map((l10) => [l10.address, l10.name])
        );
        t10(c);
      } catch {
      }
  };
  return {
    fetchServiceNames: n10,
    getServiceNames: async (o10) => {
      const s10 = [];
      o10 == null || o10.forEach((a10) => {
        const c = a10 == null ? void 0 : a10.address;
        r10 != null && r10[c] || s10.push(c);
      }), (s10 == null ? void 0 : s10.length) > 0 && n10(s10);
    }
  };
}
var NR = function() {
  var e10 = document.getSelection();
  if (!e10.rangeCount)
    return function() {
    };
  for (var t10 = document.activeElement, r10 = [], n10 = 0; n10 < e10.rangeCount; n10++)
    r10.push(e10.getRangeAt(n10));
  switch (t10.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t10.blur();
      break;
    default:
      t10 = null;
      break;
  }
  return e10.removeAllRanges(), function() {
    e10.type === "Caret" && e10.removeAllRanges(), e10.rangeCount || r10.forEach(function(i10) {
      e10.addRange(i10);
    }), t10 && t10.focus();
  };
};
var jR = NR;
var Xp = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
};
var kR = "Copy to clipboard: #{key}, Enter";
function DR(e10) {
  var t10 = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return e10.replace(/#{\s*key\s*}/g, t10);
}
function LR(e10, t10) {
  var r10, n10, i10, o10, s10, a10, c = false;
  t10 || (t10 = {}), r10 = t10.debug || false;
  try {
    i10 = jR(), o10 = document.createRange(), s10 = document.getSelection(), a10 = document.createElement("span"), a10.textContent = e10, a10.ariaHidden = "true", a10.style.all = "unset", a10.style.position = "fixed", a10.style.top = 0, a10.style.clip = "rect(0, 0, 0, 0)", a10.style.whiteSpace = "pre", a10.style.webkitUserSelect = "text", a10.style.MozUserSelect = "text", a10.style.msUserSelect = "text", a10.style.userSelect = "text", a10.addEventListener("copy", function(u10) {
      if (u10.stopPropagation(), t10.format)
        if (u10.preventDefault(), typeof u10.clipboardData > "u") {
          r10 && console.warn("unable to use e.clipboardData"), r10 && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var d6 = Xp[t10.format] || Xp.default;
          window.clipboardData.setData(d6, e10);
        } else
          u10.clipboardData.clearData(), u10.clipboardData.setData(t10.format, e10);
      t10.onCopy && (u10.preventDefault(), t10.onCopy(u10.clipboardData));
    }), document.body.appendChild(a10), o10.selectNodeContents(a10), s10.addRange(o10);
    var l10 = document.execCommand("copy");
    if (!l10)
      throw new Error("copy command was unsuccessful");
    c = true;
  } catch (u10) {
    r10 && console.error("unable to copy using execCommand: ", u10), r10 && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t10.format || "text", e10), t10.onCopy && t10.onCopy(window.clipboardData), c = true;
    } catch (d6) {
      r10 && console.error("unable to copy using clipboardData: ", d6), r10 && console.error("falling back to prompt"), n10 = DR("message" in t10 ? t10.message : kR), window.prompt(n10, e10);
    }
  } finally {
    s10 && (typeof s10.removeRange == "function" ? s10.removeRange(o10) : s10.removeAllRanges()), a10 && document.body.removeChild(a10), i10();
  }
  return c;
}
var BR = LR;
var hw = Oa(BR);
function UR({
  currentAccount: e10
}) {
  const { mutate: t10 } = useSwitchAccount(), r10 = useAccounts(), { isOpenAccountList: n10, setIsOpenAccountList: i10, accountServiceNameObj: o10 } = Zr(), { getServiceNames: s10 } = dw(), a10 = (0, import_react25.useCallback)(() => {
    n10 || s10(r10), i10(!n10);
  }, [n10, r10]);
  (0, import_react25.useEffect)(() => () => {
    i10(false);
  }, []);
  const c = (0, import_react25.useMemo)(() => r10.filter((u10) => u10.address !== e10), [r10, e10]);
  (0, import_react25.useEffect)(() => {
  }, [c]);
  const l10 = (u10) => {
    t10(
      { account: u10 },
      {
        onSuccess: () => {
        }
      }
    );
  };
  return w.jsxs("div", { className: "cs-account-switch", children: [
    w.jsxs("div", { className: "account", onClick: a10, children: [
      w.jsx("span", { children: e10 && (o10 == null ? void 0 : o10[e10]) || Do(e10) }),
      (c == null ? void 0 : c.length) > 0 && w.jsx(
        "svg",
        {
          className: `cs-icon ${n10 ? "open" : "close"}`,
          "aria-hidden": "true",
          children: w.jsx("use", { xlinkHref: "#icon-unfold" })
        }
      )
    ] }),
    w.jsx("div", { className: `account-list ${n10 ? "open" : "close"}`, children: c.map((u10) => w.jsxs("div", { className: "account-item", children: [
      w.jsxs("div", { className: "left", children: [
        w.jsx("div", { className: "label", children: u10 == null ? void 0 : u10.label }),
        w.jsx("div", { className: "address", children: (o10 == null ? void 0 : o10[u10 == null ? void 0 : u10.address]) || Do(u10 == null ? void 0 : u10.address) })
      ] }),
      w.jsx(
        "button",
        {
          className: "cs-outline-btn",
          onClick: () => l10(u10),
          children: "Switch"
        }
      )
    ] })) })
  ] });
}
var FR = (0, import_react25.forwardRef)(
  ({ connect: e10 }) => {
    const t10 = useCurrentAccount();
    return w.jsx("div", { children: t10 ? w.jsx($R, {}) : w.jsx(
      H0,
      {
        text: "Connect",
        className: "cs-connect-button",
        onClick: () => e10(true)
      }
    ) });
  }
);
function $R() {
  const { mutate: e10 } = useDisconnectWallet(), t10 = useCurrentAccount(), { currentWallet: r10 } = useCurrentWallet(), { addCommonToast: n10 } = Bs(), { getExplorerUrl: i10 } = Rs(), { accountServiceNameObj: o10 } = Zr(), s10 = () => {
    t10 && (hw(t10.address || "", {
      debug: false,
      message: "message"
    }), n10("Copied"));
  }, a10 = () => {
    t10 && window.open(i10(t10.address, "account"), "_blank");
  };
  return (0, import_react25.useEffect)(() => {
  }, [r10]), w.jsxs(bn.Root, { children: [
    w.jsx(bn.Trigger, { children: w.jsxs("div", { className: "cs-connected-button", children: [
      w.jsx(
        "img",
        {
          src: r10 == null ? void 0 : r10.icon,
          style: { width: "20px", height: "20px" }
        }
      ),
      w.jsx("span", { children: (t10 == null ? void 0 : t10.address) && (o10 == null ? void 0 : o10[t10 == null ? void 0 : t10.address]) || Do(t10 == null ? void 0 : t10.address) })
    ] }) }),
    w.jsx(
      bn.Content,
      {
        variant: "soft",
        className: "cs-dropdown-content",
        style: {
          backgroundColor: "#2B3643"
        },
        side: "bottom",
        align: "end",
        children: w.jsxs("div", { className: "account-op-box", children: [
          w.jsx(
            "span",
            {
              style: {
                fontSize: "14px",
                color: "#909CA4",
                marginBottom: "6px"
              },
              children: t10 == null ? void 0 : t10.label
            }
          ),
          w.jsx(UR, { currentAccount: t10 == null ? void 0 : t10.address }),
          w.jsxs(
            "div",
            {
              className: "account-op-item",
              onClick: s10,
              style: { marginTop: "12px" },
              children: [
                w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-copy" }) }),
                w.jsx("span", { children: "Copy address" })
              ]
            }
          ),
          w.jsxs("div", { className: "account-op-item", onClick: a10, children: [
            w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-link" }) }),
            w.jsx("span", { children: "Open explorer" })
          ] }),
          w.jsxs("div", { className: "account-op-item", onClick: () => e10(), children: [
            w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-disconnect" }) }),
            w.jsx("span", { children: "Disconnect" })
          ] })
        ] })
      }
    )
  ] });
}
function VR() {
  const { fetchServiceNames: e10 } = dw(), t10 = useCurrentAccount();
  useCurrentWallet();
  const { isOpenWalletModal: r10, onWalletModal: n10, saveCurrentAccount: i10 } = Zr();
  return useWallets(), (0, import_react25.useEffect)(() => {
    t10 != null && t10.address && e10([t10 == null ? void 0 : t10.address]);
  }, [t10 == null ? void 0 : t10.address]), w.jsx(w.Fragment, { children: w.jsx(
    ConnectModal,
    {
      trigger: w.jsx(FR, { connect: n10 }),
      open: r10,
      onOpenChange: (o10) => n10(o10)
    }
  ) });
}
function zR({
  independentWallet: e10,
  customWallet: t10
}) {
  return w.jsxs(w.Fragment, { children: [
    w.jsxs("div", { className: "widget-header", children: [
      w.jsx("img", { src: At("/images/logo@2x.png"), className: "cetus-logo" }),
      w.jsxs("div", { className: "right", children: [
        e10 && w.jsx(VR, {}),
        w.jsx(IR, {})
      ] })
    ] }),
    w.jsx("div", { style: { marginTop: "20px" } })
  ] });
}
var pw = () => {
  const e10 = (0, import_react25.useRef)(null);
  (0, import_react25.useEffect)(() => {
    if (e10.current) {
      const n10 = e10.current.style;
      n10.setProperty("--size-loader", "50px"), n10.setProperty("--size-orbe", "10px");
    }
  }, []);
  const t10 = (n10) => ({
    position: "absolute",
    width: "100%",
    height: "100%",
    animation: `webLoading ease-in-out 1.5s calc(${n10} * 0.1s) infinite`,
    opacity: `calc(1 - calc(0.2 * ${n10}))`
  }), r10 = {
    position: "absolute",
    content: "''",
    top: 0,
    left: 0,
    width: "var(--size-orbe)",
    height: "var(--size-orbe)",
    backgroundColor: "#75C8FF",
    // Use CSS variable or replace with your theme color
    boxShadow: "0px 0px 20px 2px #75C8FF",
    // Use theme color
    borderRadius: "50%"
  };
  return w.jsx(
    "div",
    {
      style: {
        width: "100%",
        height: "100%",
        position: "absolute",
        zIndex: 100
      },
      children: w.jsx(
        "div",
        {
          ref: e10,
          style: {
            width: "var(--size-loader)",
            height: "var(--size-loader)",
            position: "absolute",
            top: "50%",
            left: "50%",
            marginTop: "-25px",
            marginLeft: "-25px",
            transform: "rotate(45deg)"
          },
          children: [...Array(5)].map((n10, i10) => w.jsx("div", { style: t10(i10), children: w.jsx("div", { style: r10 }) }, i10))
        }
      )
    }
  );
};
function qR({
  onClose: e10,
  transactionData: t10
}) {
  const { status: r10, buildShowInfo: n10, tx: i10 } = t10, o10 = (0, import_react25.useMemo)(() => {
    if (n10 && r10)
      return n10(r10);
  }, [r10]);
  return w.jsxs("div", { className: "ts-status-dialog", children: [
    (r10 === "confirmation" || r10 === "submitted") && w.jsx(HR, { info: o10, status: r10 }),
    (r10 === "success" || r10 === "rejected") && w.jsx(
      WR,
      {
        info: o10,
        status: r10,
        tx: i10,
        onClose: e10
      }
    )
  ] });
}
function HR({
  info: e10,
  status: t10
}) {
  return w.jsxs("div", { className: "progress-dialog", children: [
    w.jsx("div", { className: "title", children: t10 === "confirmation" ? "Waiting for Confirmation" : "Transaction in progress" }),
    w.jsx("div", { className: "loading-box", children: w.jsx(pw, {}) }),
    w.jsxs("div", { className: "ts-content", children: [
      e10 == null ? void 0 : e10.modalDescriptionText,
      " "
    ] }),
    w.jsxs("p", { className: "ts-desc", children: [
      " ",
      t10 === "confirmation" ? "Confirm this transaction in your wallet." : "Confirmation is in progress."
    ] })
  ] });
}
function WR({
  info: e10,
  status: t10,
  tx: r10,
  onClose: n10
}) {
  const { getExplorerUrl: i10 } = Rs();
  return w.jsxs("div", { className: "finally-status-dialog", children: [
    w.jsxs("div", { className: "center-content", children: [
      w.jsxs(
        "div",
        {
          className: t10 === "success" ? "status-box is-success" : "status-box is-error",
          children: [
            w.jsx("div", { className: "status-icon-box", children: w.jsx("div", { className: "status-icon", children: w.jsx("svg", { className: "icon", "aria-hidden": "true", children: t10 === "success" ? w.jsx("use", { xlinkHref: "#icon-sel" }) : w.jsx("use", { xlinkHref: "#icon-caution" }) }) }) }),
            t10 === "success" ? w.jsx("span", { children: "Swap Success" }) : w.jsx("span", { children: "Swap failed" })
          ]
        }
      ),
      w.jsx("div", { className: "ts-content", children: e10 == null ? void 0 : e10.modalDescriptionText }),
      r10 && w.jsxs("div", { className: "view-transaction", children: [
        w.jsx("span", { children: "View Transaction" }),
        Dl.map((o10) => w.jsx(
          "a",
          {
            href: i10(r10, "tx", o10.link),
            target: "_blank",
            children: w.jsx("img", { src: o10.img })
          },
          o10.link
        ))
      ] })
    ] }),
    w.jsx("button", { className: "cs-solid-btn swap-more-btn", onClick: n10, children: t10 === "success" ? "Swap More" : "Retry" })
  ] });
}
function Ql() {
  return {
    fetchByApi: async (t10, r10, n10, i10) => {
      try {
        return r10 === "GET" ? await bC(`${i10 || hs.api}${t10}`, n10) : await yC(`${i10 || hs.api}${t10}`, n10);
      } catch (o10) {
        throw o10;
      }
    }
  };
}
function GR() {
  const { fetchByApi: e10 } = Ql(), { setProviders: t10 } = Hr();
  return {
    fetchRouterConfig: async () => {
      try {
        const n10 = await e10("/router_v2/status", "GET"), { providers: i10 } = n10;
        i10 && t10(i10);
      } catch {
      }
    }
  };
}
function KR({ interval: e10, callback: t10 }) {
  const r10 = (0, import_react25.useRef)(), n10 = (0, import_react25.useRef)(null);
  (0, import_react25.useEffect)(() => {
    r10.current = t10;
  }, [t10]);
  const i10 = (0, import_react25.useCallback)(() => {
    n10.current && clearInterval(n10.current), e10 > 0 && (n10.current = setInterval(() => {
      r10.current && r10.current(Date.now());
    }, e10));
  }, [e10]), o10 = (0, import_react25.useCallback)(() => {
    n10.current && (clearInterval(n10.current), n10.current = null);
  }, []);
  return (0, import_react25.useEffect)(() => (i10(), () => o10()), []), { startTimer: i10, stopTimer: o10 };
}
var YR = (e10, t10) => ({
  coinPriceObj: {},
  setPriceObj: (r10) => {
    const n10 = t10().coinPriceObj;
    e10({
      coinPriceObj: {
        ...n10,
        ...r10
      }
    });
  },
  clearPriceObj: (r10) => {
    const n10 = t10().coinPriceObj;
    r10.forEach((i10) => {
      delete n10[Br(i10).full_address];
    }), e10({
      coinPriceObj: {
        ...n10
      }
    });
  }
});
var mw = ki(YR);
function XR(e10, t10) {
  const r10 = [];
  for (let n10 = 0; n10 < e10.length; n10 += t10)
    r10.push(e10.slice(n10, n10 + t10));
  return r10;
}
function Ha() {
  const { fetchByApi: e10 } = Ql(), { coinPriceObj: t10, setPriceObj: r10, clearPriceObj: n10 } = mw(), i10 = async (a10) => {
    const l10 = XR(a10, 10);
    try {
      const d6 = (await Promise.all(
        l10.map((p) => e10("/v2/sui/market_price", "GET", {
          base_symbol_address_pair: p.map(
            (y) => Oi(y, false)
          )
        }))
      )).map((p) => p.prices).flat();
      if (d6) {
        const p = {};
        d6.forEach((y) => {
          p[Br(y.base_symbol).full_address] = y;
        }), r10(p);
      }
      return d6;
    } catch {
      return n10(a10), null;
    }
  }, o10 = (0, import_react25.useCallback)(
    (a10) => {
      if (!a10)
        return;
      const c = t10[Br(a10).full_address];
      if (c)
        return c;
    },
    [t10]
  ), s10 = (0, import_react25.useCallback)(
    (a10, c, l10) => {
      const u10 = Number(c) == 0 || !l10 ? "0" : l10;
      if (c && a10 && +c) {
        const d6 = o10(a10);
        if (d6)
          return Le(c).mul(d6.price).toString();
      }
      return u10;
    },
    [t10]
  );
  return {
    fetchTokenPrices: i10,
    getTokenPrice: o10,
    getTokenAmountValue: s10
  };
}
var JR = (e10, t10) => ({
  isOpenTokensDialog: false,
  defaultFromCoinType: void 0,
  defaultToCoinCoinType: void 0,
  isOpenSecondary: false,
  byAmountIn: true,
  findRouterLoading: false,
  fromAmount: "",
  toAmount: "",
  fromCoin: void 0,
  toCoin: void 0,
  routerData: void 0,
  setDefaultCoin: (r10, n10) => {
    e10(() => ({
      defaultFromCoinType: r10,
      defaultToCoinCoinType: n10
    }));
  },
  setFromCoin: (r10) => {
    e10(() => ({
      fromCoin: r10
    }));
  },
  setToCoin: (r10) => {
    e10(() => ({
      toCoin: r10
    }));
  },
  setFromAmount: (r10) => {
    e10(() => ({
      fromAmount: r10
    }));
  },
  setToAmount: (r10) => {
    e10(() => ({
      toAmount: r10
    }));
  },
  setRouterData: (r10) => {
    e10(() => ({
      routerData: r10
    }));
  },
  setFindRouterLoading: (r10) => {
    e10(() => ({
      findRouterLoading: r10
    }));
  },
  setByAmountIn: (r10) => {
    e10(() => ({
      byAmountIn: r10
    }));
  },
  setIsOpenSecondary: (r10) => {
    e10(() => ({
      isOpenSecondary: r10
    }));
  },
  setIsOpenTokensDialog: (r10) => {
    e10(() => ({
      isOpenTokensDialog: r10
    }));
  }
});
var an = ki(JR);
function ZR() {
  const { tokenBalanceObj: e10 } = Zr(), { fetchTokenPrices: t10 } = Ha(), { isOpenTokensDialog: r10 } = an(), n10 = (0, import_react25.useCallback)(() => {
    if (vC(e10)) {
      const i10 = Object.keys(e10);
      t10(i10);
    }
  }, [e10]);
  return (0, import_react25.useEffect)(() => {
    r10 && n10();
  }, [r10]), { getMyAssetsPrice: n10 };
}
var QR = (e10, t10) => ({
  tokenMapIsInit: false,
  requestTokenList: [],
  addRequestTokenList: (r10) => {
    e10(() => ({
      requestTokenList: [...t10().requestTokenList, r10]
    }));
  },
  setToken: (r10) => {
    const { tokenMap: n10, requestTokenList: i10 } = t10(), o10 = Br(r10.coin_type).full_address;
    if (!n10.has(o10)) {
      const s10 = new Map(n10);
      s10.set(o10, r10);
      const a10 = i10.filter(
        (c) => c !== r10.coin_type
      );
      e10(() => ({
        tokenMap: s10,
        requestTokenList: [...a10]
      })), Ti.setItem(Xf, s10);
    }
  },
  tokenMap: /* @__PURE__ */ new Map(),
  setTokenMap: (r10, n10 = false) => {
    r10.size > 0 ? e10(() => ({
      tokenMap: r10,
      tokenMapIsInit: true
    })) : e10(() => ({
      tokenMap: r10
    })), n10 || Ti.setItem(Xf, r10);
  },
  trustedTokenList: [],
  setTrustedTokenList: (r10, n10 = false) => {
    e10(() => ({
      trustedTokenList: r10
    })), n10 || Ti.setItem(Eb, r10);
  }
});
var Wa = ki(QR);
Ti.getItem(Xf).then((e10) => {
  e10 !== null && Wa.getState().setTokenMap(e10, true);
});
Ti.getItem(Eb).then(
  (e10) => {
    e10 !== null && Wa.getState().setTrustedTokenList(e10, true);
  }
);
var eP = [
  {
    name: "Sudo LP Token",
    symbol: "SLP",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/slp.png",
    coinType: "0xc44d97a4bc4e5a33ca847b72b123172c88a6328196b71414f32c3070233604b2::slp::SLP",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xc44d97a4bc4e5a33ca847b72b123172c88a6328196b71414f32c3070233604b2::slp::SLP",
      coin_priority: 720,
      coingecko_id: "slp"
    }
  },
  {
    name: "❄️ WAL",
    symbol: "wWAL",
    decimals: 9,
    logoURL: "https://interestprotocol.infura-ipfs.io/ipfs/QmPLCVWv7citJSc813NbcbZnRSXAEJ4BWVKq4zK8pPVEWq",
    coinType: "0xb1b0650a8862e30e3f604fd6c5838bc25464b8d3d827fbd58af7cb9685b832bf::wwal::WWAL",
    isVerified: true
  },
  {
    name: "Wrapped GLMR (Portal from Moonbeam)",
    symbol: "WGLMR",
    decimals: 8,
    logoURL: "https://zuwfvhekgt5rgxaa5e5yraqnxeivprtu2siky5qtffa2ysvcvh6q.arweave.net/zSxanIo0-xNcAOk7iIINuRFXxnTUkKx2EylBrEqiqf0",
    coinType: "0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75::coin::COIN",
      labels: ["Wormhole"]
    }
  },
  {
    name: "Spring SUI",
    symbol: "sSUI",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/5iJkTTWnZnTF5vpZA31F5vZZSqGPHuTMNCQSBTqkYGMV",
    coinType: "0x83556891f4a0f233ce7b05cfe7f957d4020492a34f5405b2cb9377d060bef4bf::spring_sui::SPRING_SUI",
    isVerified: true,
    extensionFields: {
      coin_priority: 908,
      rank: 840,
      suggested_priority: 909
    }
  },
  {
    name: "Volo Staked SUI",
    symbol: "vSUI",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/vsui.png",
    coinType: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT",
      coin_priority: 910,
      coingecko_id: "volo-staked-sui",
      pyth_id: "57ff7100a282e4af0c91154679c5dae2e5dcacb93fd467ea9cb7e58afdcfde27",
      rank: 860,
      suggested_priority: 910
    }
  },
  {
    name: "AXOLcoin",
    symbol: "AXOL",
    decimals: 9,
    logoURL: "https://api.interestlabs.io/files/99e91dc540e4d32971972eed8ecae0958f0cb3e84018dd1b.png",
    coinType: "0xf00eb7ab086967a33c04a853ad960e5c6b0955ef5a47d50b376d83856dc1215e::axol::AXOL",
    isVerified: true
  },
  {
    name: "SEND",
    symbol: "SEND",
    decimals: 6,
    logoURL: "https://suilend-assets.s3.us-east-2.amazonaws.com/SEND/SEND.svg",
    coinType: "0xb45fcfcc2cc07ce0702cc2d229621e046c906ef14d9b25e8e4d25f6e8763fef7::send::SEND",
    isVerified: true
  },
  {
    name: "TIMES",
    symbol: "TIMES",
    decimals: 5,
    logoURL: "https://assets.playdarktimes.com/images/icons/darktimes_logo.png",
    coinType: "0x46fbe54691b27d7abd2c9e5a01088913531f241b98f3c2351f8215e45cc17a4c::times::TIMES",
    isVerified: true,
    extensionFields: {
      coingecko_id: "times"
    }
  },
  {
    name: "Aptos Coin (Portal from Aptos)",
    symbol: "APT",
    decimals: 8,
    logoURL: "https://hvyfngb6s6wsyytjzbvqjunzqvwlzjjhfmk4z44yacx7sq7fidxa.arweave.net/PXBWmD6XrSxiachrBNG5hWy8pScrFczzmACv-UPlQO4",
    coinType: "0x3a5143bb1196e3bcdfab6203d1683ae29edd26294fc8bfeafe4aaa9d2704df37::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x3a5143bb1196e3bcdfab6203d1683ae29edd26294fc8bfeafe4aaa9d2704df37::coin::COIN",
      coin_priority: 590,
      labels: ["Wormhole"],
      pyth_id: "03ae4db29ed4ae33d323568895aa00337e658e348b37509f5372ae51f0af00d5"
    }
  },
  {
    name: "Haedal staked SUI",
    symbol: "haSUI",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/hasui.png",
    coinType: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI",
      coin_priority: 960,
      coingecko_id: "haedal-staked-sui",
      pyth_id: "6120ffcf96395c70aa77e72dcb900bf9d40dccab228efca59a17b90ce423d5e8",
      rank: 870,
      suggested_priority: 960
    }
  },
  {
    name: "sNS",
    symbol: "sNS",
    decimals: 6,
    logoURL: "https://3vhaecwgpni3lhtpvmwylermast5evx5e7x46x3hw534olzdqq7q.arweave.net/3U4CCsZ7UbWeb6sthZIsBKfSVv0n789fZ7d3xy8jhD8",
    coinType: "0x6511052d2f1404934e0d877709949bcda7c1d451d1218a4b2643ca2f3fa93991::scallop_ns::SCALLOP_NS",
    isVerified: true
  },
  {
    name: "sSCA",
    symbol: "sSCA",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/6HrUJbgHzoHMq952F1PG36L94BQkuyjnqAjfPLo3hJ3D",
    coinType: "0x5ca17430c1d046fae9edeaa8fd76c7b4193a00d764a0ecfa9418d733ad27bc1e::scallop_sca::SCALLOP_SCA",
    isVerified: true,
    extensionFields: {
      rank: 820
    }
  },
  {
    name: "CAP",
    symbol: "CAP",
    decimals: 9,
    logoURL: "https://owhanwxsgozv6rpjuntz4a32lqhb2tl4kurcmyltpd6ipysudv2a.arweave.net/dY4G2vIzs19F6aNnngN6XA4dTXxVIiZhc3j8h-JUHXQ",
    coinType: "0x893aa3f358b70e7dbcf957c64a1f016633630af42fb6097f25c33ef9fa738dd2::cap::CAP",
    isVerified: true
  },
  {
    name: "mUSD",
    symbol: "mUSD",
    decimals: 9,
    logoURL: "https://mstable.io/coins/musd.svg",
    coinType: "0xe44df51c0b21a27ab915fa1fe2ca610cd3eaa6d9666fe5e62b988bf7f0bd8722::musd::MUSD",
    isVerified: true
  },
  {
    name: "sSBUSDT",
    symbol: "sSBUSDT",
    decimals: 6,
    logoURL: "https://zu6izvoktna456r6pbxg3knacc4bysfalutz25xo6zfkx6x3wvda.arweave.net/zTyM1cqbQc76PnhubamgELgcSKBdJ5127vZKq_r7tUY",
    coinType: "0xb1d7df34829d1513b73ba17cb7ad90c88d1e104bb65ab8f62f13e0cc103783d3::scallop_sb_usdt::SCALLOP_SB_USDT",
    isVerified: true
  },
  {
    name: "Wrapped AVAX (Portal from Avalanche)",
    symbol: "WAVAX",
    decimals: 8,
    logoURL: "https://dvv5kcjybfklcqlql7dj7mfrfzj4bgunkcdgz6uh3re4usboi5ba.arweave.net/HWvVCTgJVLFBcF_Gn7CxLlPAmo1Qhmz6h9xJykguR0I",
    coinType: "0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766::coin::COIN",
      coingecko_id: "avalanche-wormhole",
      labels: ["Wormhole"],
      pyth_id: "93da3352f9f1d105fdfe4971cfa80e9dd777bfc5d0f683ebb6e1294b92137bb7"
    }
  },
  {
    name: "suibeaver",
    symbol: "DAM",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8yU5QsDMFoLAoXFfSDrE5m3ZMMAzCzewtwfAy6qHvpju",
    coinType: "0xaf3aae4940a248739ce4964857381fc3f3149a6d05375bfbb2118592907e3bbb::dam::DAM",
    isVerified: true
  },
  {
    name: "svSUI",
    symbol: "svSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8ot3tVqpC3hhGQhf2sNyGC27Z877ZtcEb79RY1W4fzrB",
    coinType: "0xe1a1cc6bcf0001a015eab84bcc6713393ce20535f55b8b6f35c142e057a25fbe::scallop_v_sui::SCALLOP_V_SUI",
    isVerified: true
  },
  {
    name: "USD Coin (Portal from Eth)",
    symbol: "wUSDC",
    decimals: 6,
    logoURL: "https://klrhtty4kphjcsrez2eaeh6r27tbaayw3odjadigbrek544f3i2a.arweave.net/UuJ5zxxTzpFKJM6IAh_R1-YQAxbbhpANBgxIrvOF2jQ",
    coinType: "0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN",
      coin_priority: 990,
      coingecko_id: "usd-coin-wormhole-from-ethereum",
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 990
    }
  },
  {
    name: "Wrapped Ether (Portal from Eth)",
    symbol: "WETH",
    decimals: 8,
    logoURL: "https://t4gq524jdiihjr6ihouhzsemfczi3eq2cnjyhbfms5utl3hueu6q.arweave.net/nw0O64kaEHTHyDuofMiMKLKNkhoTU4OErJdpNez0JT0",
    coinType: "0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5::coin::COIN",
      coin_priority: 940,
      coingecko_id: "ethereum-wormhole",
      labels: ["Wormhole"],
      pyth_id: "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
      rank: 800
    }
  },
  {
    name: "Mirai Staked SUI",
    symbol: "mSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/3pwmCNEzHcDWVdobJJa2275EVQupXGzffjahSCPiw9G4",
    coinType: "0x922d15d7f55c13fd790f6e54397470ec592caa2b508df292a2e8553f3d3b274f::msui::MSUI",
    isVerified: true
  },
  {
    name: "ZO Perpetuals LP Token",
    symbol: "ZLP",
    decimals: 6,
    logoURL: "https://img.zofinance.io/zlp.png",
    coinType: "0xf7fade57462e56e2eff1d7adef32e4fd285b21fd81f983f407bb7110ca766cda::zlp::ZLP",
    isVerified: true
  },
  {
    name: "Wrapped Fantom (Portal from Fantom)",
    symbol: "WFTM",
    decimals: 8,
    logoURL: "https://tqhb43iz7vqrys2frjp73jn2o3uzehbmybq2sv2me2fpo4rocbja.arweave.net/nA4ebRn9YRxLRYpf_aW6dumSHCzAYalXTCaK93IuEFI",
    coinType: "0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396::coin::COIN",
      labels: ["Wormhole"],
      pyth_id: "5c6c0d2386e3352356c3ab84434fafb5ea067ac2678a38a338c4a69ddc4bdb0c"
    }
  },
  {
    name: "swUSDT",
    symbol: "swUSDT",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/GNNHRxZcwE3QnxL39LZQksEHB1JARX2bhBHGbcZCvfWg",
    coinType: "0xe6e5a012ec20a49a3d1d57bd2b67140b96cd4d3400b9d79e541f7bdbab661f95::scallop_wormhole_usdt::SCALLOP_WORMHOLE_USDT",
    isVerified: true
  },
  {
    name: "sUSDY",
    symbol: "sUSDY",
    decimals: 6,
    logoURL: "https://v4kpvw5rr2kprz4echmm33xktmu4lu7kh3qncwrw7xvzdipatkya.arweave.net/rxT627GOlPjnhBHYze7qmynF0-o-4NFaNv3rkaHgmrA",
    coinType: "0xd285cbbf54c87fd93cd15227547467bb3e405da8bbf2ab99f83f323f88ac9a65::scallop_usdy::SCALLOP_USDY",
    isVerified: true
  },
  {
    name: "$DRF",
    symbol: "DRF",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/4tJCmQbwABnc8z1e8Wyy89j8kCinLdN915LucsZusH2r",
    coinType: "0x294de7579d55c110a00a7c4946e09a1b5cbeca2592fbb83fd7bfacba3cfeaf0e::drf::DRF",
    isVerified: true
  },
  {
    name: "swSOL",
    symbol: "swSOL",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/38CYobsZ6resAMb939doWgMwcKrVJm7mDXzXNjKHxTfX",
    coinType: "0x1392650f2eca9e3f6ffae3ff89e42a3590d7102b80e2b430f674730bc30d3259::scallop_wormhole_sol::SCALLOP_WORMHOLE_SOL",
    isVerified: true
  },
  {
    name: "Scallop",
    symbol: "SCA",
    decimals: 9,
    logoURL: "https://vrr7y7aent4hea3r444jrrsvgvgwsz6zi2r2vv2odhgfrgvvs6iq.arweave.net/rGP8fARs-HIDcec4mMZVNU1pZ9lGo6rXThnMWJq1l5E",
    coinType: "0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",
      coin_priority: 900,
      coingecko_id: "scallop-2",
      pyth_id: "7e17f0ac105abe9214deb9944c30264f5986bf292869c6bd8e8da3ccd92d79bc",
      rank: 830
    }
  },
  {
    name: "Daossui Token",
    symbol: "DAOS",
    decimals: 6,
    logoURL: "https://public.daossui.io/dao-sui/assets/daossui-token.png",
    projectURL: "https://daossui.io/",
    coinType: "0xd40cec91f6dca0673b25451fb0d654e62ad13bf6546a32a21ef0c59eba42e71c::daos::DAOS",
    isVerified: true
  },
  {
    name: "SPT",
    symbol: "SPT",
    decimals: 9,
    logoURL: "https://seapad.s3.ap-southeast-1.amazonaws.com/uploads/PROD/public/media/images/logo_1685439392353.png",
    coinType: "0xb779486cfd6c19e9218cc7dc17c453014d2d9ba12d2ee4dbb0ec4e1e02ae1cca::spt::SPT",
    isVerified: true
  },
  {
    name: "Suiba Inu",
    symbol: "SUIB",
    decimals: 9,
    logoURL: "https://fvies4qayyhittfc6gxdfldafsmynmk5o5yitbrtnujlpbktv77a.arweave.net/LVBJcgDGDonMovGuMqxgLJmGsV13cImGM20St4VTr_4",
    coinType: "0xed4504e791e1dad7bf93b41e089b4733c27f35fde505693e18186c2ba8e2e14b::suib::SUIB",
    isVerified: true
  },
  {
    name: "USD Coin (Celer)",
    symbol: "cUSDC",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/usdc_celer.png",
    coinType: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdc_coin::CELER_USDC_COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdc_coin::CELER_USDC_COIN",
      coin_priority: 830,
      labels: ["Celer"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 930
    }
  },
  {
    name: "FOMO",
    symbol: "FOMO",
    decimals: 2,
    logoURL: "https://7ms6dw2zbrlaaeadpyyz7cy5pwdlz64atqh6gdkpuws3uxpesxeq.arweave.net/-yXh21kMVgAQA34xn4sdfYa8-4CcD-MNT6Wlul3klck",
    coinType: "0xa340e3db1332c21f20f5c08bef0fa459e733575f9a7e2f5faca64f72cd5a54f2::fomo::FOMO",
    isVerified: true
  },
  {
    name: "MOVE",
    symbol: "MOVE",
    decimals: 9,
    logoURL: "https://gk4id6fee24ru5cdipjxyz6cl42yjtzl3xfuizlpqjub42hx5rvq.arweave.net/MriB-KQmuRp0Q0PTfGfCXzWEzyvdy0Rlb4JoHmj37Gs",
    coinType: "0x648f9eab1434c056d509ad857fb657ac170528798d771f7eb1edc35639e3e75c::movecoin::MOVECOIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x648f9eab1434c056d509ad857fb657ac170528798d771f7eb1edc35639e3e75c::movecoin::MOVECOIN",
      coin_priority: 690
    }
  },
  {
    name: "KOI",
    symbol: "KOI",
    decimals: 6,
    logoURL: "https://ubxwf7ujw5ktuqvndqeqogfoiu343qxl2a3h3i5l5zkzj66fp6xa.arweave.net/oG9i_om3VTpCrRwJBxiuRTfNwuvQNn2jq-5VlPvFf64",
    coinType: "0x01d430425a8a681ef26315e78a082fe744f8d0bbdbd1ab76b9fd78ada09bedca::Koi::KOI",
    isVerified: true
  },
  {
    name: "Bucket Token",
    symbol: "BUT",
    decimals: 9,
    logoURL: "https://aqua-natural-grasshopper-705.mypinata.cloud/ipfs/QmUKAX4PME9Wb9VU6CMJPisNysaVKZNKpiB3gtMVVZTfjt",
    coinType: "0xbc858cb910b9914bee64fff0f9b38855355a040c49155a17b265d9086d256545::but::BUT",
    isVerified: true
  },
  {
    name: "USD Coin (Portal from BSC)",
    symbol: "USDCbnb",
    decimals: 8,
    logoURL: "https://co3xbx3vz2ww7tcs2tp4p36hdnkz677tuvqt6wgyfyoeefj6or6a.arweave.net/E7dw33XOrW_MUtTfx-_HG1Wff_OlYT9Y2C4cQhU-dHw",
    coinType: "0x909cba62ce96d54de25bec9502de5ca7b4f28901747bbf96b76c2e63ec5f1cba::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x909cba62ce96d54de25bec9502de5ca7b4f28901747bbf96b76c2e63ec5f1cba::coin::COIN",
      coin_priority: 860,
      coingecko_id: "usd-coin-wormhole-bnb",
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 970
    }
  },
  {
    name: "haWAL",
    symbol: "haWAL",
    decimals: 9,
    logoURL: "https://assets.haedal.xyz/logos/hawal.svg",
    coinType: "0x8b4d553839b219c3fd47608a0cc3d5fcc572cb25d41b7df3833208586a8d2470::hawal::HAWAL",
    isVerified: true
  },
  {
    name: "USD Coin (Portal from Solana)",
    symbol: "USDCsol",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/2q5BcNXs91mPPSaYLCbLRS8Pyha8N76dafj51HdMmrh6",
    coinType: "0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037::coin::COIN",
      coin_priority: 870,
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 980
    }
  },
  {
    name: "SPAM",
    symbol: "SPAM",
    decimals: 4,
    logoURL: "https://3fc4a4tjkjryoqps44rgwhydihn5htqyfjmrrmlouf6rt5qyxjbq.arweave.net/2UXAcmlSY4dB8uciax8DQdvTzhgqWRixbqF9GfYYukM",
    coinType: "0x30a644c3485ee9b604f52165668895092191fcaf5489a846afa7fc11cdb9b24a::spam::SPAM",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x30a644c3485ee9b604f52165668895092191fcaf5489a846afa7fc11cdb9b24a::spam::SPAM"
    }
  },
  {
    name: "sKART",
    symbol: "sKARTCOIN",
    decimals: 9,
    logoURL: "https://osp3bhhpqkgtrtuww3cn6cqpcy36lxhu2j4djhbr5fu4fzusrt2a.arweave.net/dJ-wnO-CjTjOlrbE3woPFjfl3PTSeDScMelpwuaSjPQ",
    coinType: "0xfd48ffd0e62ed5cb839400b7e0bee870cd752f9d01c657a665be2afff16995eb::skart::SKART",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xfd48ffd0e62ed5cb839400b7e0bee870cd752f9d01c657a665be2afff16995eb::skart::SKART",
      coin_priority: 770
    }
  },
  {
    name: "FUD Staked SUI",
    symbol: "fudSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8qhJwoDEavz5KdkJEK9FaiHp9rYEqbWhF7HrqsJpUG4F",
    coinType: "0x02358129a7d66f943786a10b518fdc79145f1fc8d23420d9948c4aeea190f603::fud_sui::FUD_SUI",
    isVerified: true
  },
  {
    name: "suitard",
    symbol: "STD",
    decimals: 9,
    logoURL: "https://hawbf2zd3vl47ileyqlznfwluvtyis7bnbfkadg7vpsvxbpe5h4a.arweave.net/OCwS6yPdV8-hZMQXlpbLpWeES-FoSqAM36vlW4Xk6fg",
    coinType: "0x2cddfc6d4fc855917e990e71cd122b1ee8098aa890186ee15a84524ed17cd8c9::suitard::SUITARD",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x2cddfc6d4fc855917e990e71cd122b1ee8098aa890186ee15a84524ed17cd8c9::suitard::SUITARD",
      coingecko_id: "suitard"
    }
  },
  {
    name: "NAVX Token",
    symbol: "NAVX",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/navx.png",
    coinType: "0xa99b8952d4f7d947ea77fe0ecdcc9e5fc0bcab2841d6e2a5aa00c3044e5544b5::navx::NAVX",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xa99b8952d4f7d947ea77fe0ecdcc9e5fc0bcab2841d6e2a5aa00c3044e5544b5::navx::NAVX",
      coin_priority: 950,
      coingecko_id: "navi",
      pyth_id: "88250f854c019ef4f88a5c073d52a18bb1c6ac437033f5932cd017d24917ab46",
      rank: 770
    }
  },
  {
    name: "Wrapped SOL (Portal from Solana)",
    symbol: "WSOL",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/Ek2PhfPT6AgsJ7TYXx4NQJ1WPtNSxPkCo5bVmGRr1aUo",
    coinType: "0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8::coin::COIN",
      coin_priority: 790,
      labels: ["Wormhole"],
      pyth_id: "ef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d"
    }
  },
  {
    name: "Suilama",
    symbol: "SUILAMA",
    decimals: 6,
    logoURL: "https://api.movepump.com/uploads/1000030596_8a14750351.jpg",
    coinType: "0x5a4f64079daed04d923c93f3ac4ee04b637e5b3ea2db87d591981c1049508a27::suilama::SUILAMA",
    isVerified: true
  },
  {
    name: "MEMEFI",
    symbol: "MEMEFI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/AymYAvpqK3rnQE9AqtXwzHzPMQeiqdmm9yamxryDsZCT",
    coinType: "0x506a6fc25f1c7d52ceb06ea44a3114c9380f8e2029b4356019822f248b49e411::memefi::MEMEFI",
    isVerified: true
  },
  {
    name: "SCUBA DOG",
    symbol: "SCUBA",
    decimals: 6,
    logoURL: "https://j3i5gtlp36ptsx6lyygrujd2cx7vgzaxbqyeiyqded67ihlbehva.arweave.net/TtHTTW_fnzlfy8YNGiR6Ff9TZBcMMERiAyD99B1hIeo",
    coinType: "0x9e6d6124287360cc110044d1f1d7d04a0954eb317c76cf7927244bef0706b113::SCUBA::SCUBA",
    isVerified: true
  },
  {
    name: "Suiman",
    symbol: "Suiman",
    decimals: 6,
    logoURL: "https://cwwuyv2vk4qwk4vdtkub2hlhwy7vy7wqm5ar6hmxdikusgzcxi4a.arweave.net/Fa1MV1VXIWVyo5qoHR1ntj9cftBnQR8dlxoVSRsiujg",
    coinType: "0xa8b69040684d576828475115b30cc4ce7c7743eab9c7d669535ee31caccef4f5::suiman::SUIMAN",
    isVerified: true
  },
  {
    name: "ALPHA Token",
    symbol: "ALPHA",
    decimals: 9,
    logoURL: "https://7taj6jfau6n3dri7agspzfnva7qbj5sizz5xc3lb56nmxpsyoiba.arweave.net/_MCfJKCnm7HFHwGk_JW1B-AU9kjOe3FtYe-ay75YcgI",
    coinType: "0xfe3afec26c59e874f3c1d60b8203cb3852d2bb2aa415df9548b8d688e6683f93::alpha::ALPHA",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xfe3afec26c59e874f3c1d60b8203cb3852d2bb2aa415df9548b8d688e6683f93::alpha::ALPHA",
      coingecko_id: "alpha-fi"
    }
  },
  {
    name: "sSBWBTC",
    symbol: "sSBWBTC",
    decimals: 8,
    logoURL: "https://ferq2danvxy5xrhvml37sv3nlwaraso6iwfjtdops7rscscy7zba.arweave.net/KSMNDA2t8dvE9WL3-VdtXYEQSd5FipmNz5fjIUhY_kI",
    coinType: "0x08c0fe357d3a138f4552bee393ce3a28a45bebcca43373d6a90bc44ab76f82e2::scallop_sb_wbtc::SCALLOP_SB_WBTC",
    isVerified: true
  },
  {
    name: "DeepBook Token",
    symbol: "DEEP",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/5LqWyWG5EU9wPknvW5rY6qSQPtnNAfP27X1PnAiesyFG",
    coinType: "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
    isVerified: true,
    extensionFields: {
      coingecko_id: "deep",
      suggested_priority: 908
    }
  },
  {
    name: "sDEEP",
    symbol: "sDEEP",
    decimals: 6,
    logoURL: "https://lkjkjfqta7322ikfbcklyovddpnjqrba3hlhhq4u4ilhcfbbjecq.arweave.net/WpKklhMH960hRQiUvDqjG9qYRCDZ1nPDlOIWcRQhSQU",
    coinType: "0xeb7a05a3224837c5e5503575aed0be73c091d1ce5e43aa3c3e716e0ae614608f::scallop_deep::SCALLOP_DEEP",
    isVerified: true
  },
  {
    name: "SUIME",
    symbol: "SUIME",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/suime.png",
    coinType: "0x934692a74595c4f5a0c026130eb2143eea6fc313742f5d7dd9e45fd6ddbb00f1::suime::SUIME",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x934692a74595c4f5a0c026130eb2143eea6fc313742f5d7dd9e45fd6ddbb00f1::suime::SUIME",
      coin_priority: 610
    }
  },
  {
    name: "dak",
    symbol: "dak",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/JAgm2ztSdQGU5CncYUtNSp4Ce6qtv29nttZKAeQn441S",
    coinType: "0x41636c138167952207c88f5a75e433c9e880bc7bd5e4e46047d82be266d36712::dak::DAK",
    isVerified: true
  },
  {
    name: "Tocen Token",
    symbol: "TOCE",
    decimals: 9,
    logoURL: "https://ipfs.tocen.co/tocen/toce.png",
    coinType: "0xd2013e206f7983f06132d5b61f7c577638ff63171221f4f600a98863febdfb47::toce::TOCE",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xd2013e206f7983f06132d5b61f7c577638ff63171221f4f600a98863febdfb47::toce::TOCE",
      coin_priority: 650
    }
  },
  {
    name: "sWAL",
    symbol: "sWAL",
    decimals: 9,
    logoURL: "https://demac7qmvo7cyr42swwzpki63in27j35g4b6rropmrwsmiszjbsq.arweave.net/GRgBfgyrvixHmpWtl6ke2huvp303A-jFz2RtJiJZSGU",
    coinType: "0x622345b3f80ea5947567760eec7b9639d0582adcfd6ab9fccb85437aeda7c0d0::scallop_wal::SCALLOP_WAL",
    isVerified: true
  },
  {
    name: "safSUI",
    symbol: "safSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/3XoP2XumjxAAYDBWRJHhBLSHsLzH4jNnxWF6DB4rfWhN",
    coinType: "0x00671b1fa2a124f5be8bdae8b91ee711462c5d9e31bda232e70fd9607b523c88::scallop_af_sui::SCALLOP_AF_SUI",
    isVerified: true
  },
  {
    name: "Agent S",
    symbol: "S",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/B1xigsnVycuq7LkED5LybeZ6HhLyU14ZMDffDL4q577D",
    coinType: "0xea65bb5a79ff34ca83e2995f9ff6edd0887b08da9b45bf2e31f930d3efb82866::s::S",
    isVerified: true
  },
  {
    name: "OceansGallerie",
    symbol: "OCEANS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8a67JLSE8m56kK8bMFFt9HUhpSa1XeGFzSxqdrRcKtjB",
    coinType: "0xe90c71d308d8e6fed933d20f8b94d811e1dac649dac7815762520e90f84392f7::oceans::OCEANS",
    isVerified: true
  },
  {
    name: "SuiBoxer",
    symbol: "SBOX",
    decimals: 1,
    logoURL: "https://archive.cetus.zone/assets/image/sui/sbox.png",
    coinType: "0xbff8dc60d3f714f678cd4490ff08cabbea95d308c6de47a150c79cc875e0c7c6::sbox::SBOX",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xbff8dc60d3f714f678cd4490ff08cabbea95d308c6de47a150c79cc875e0c7c6::sbox::SBOX",
      coin_priority: 630,
      coingecko_id: "suiboxer"
    }
  },
  {
    name: "Fud The Pug",
    symbol: "FUD",
    decimals: 5,
    logoURL: "https://archive.cetus.zone/assets/image/sui/fud.png",
    coinType: "0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1::fud::FUD",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1::fud::FUD",
      coin_priority: 820,
      pyth_id: "6a4090703da959247727f2b490eb21aea95c8684ecfac675f432008830890c75"
    }
  },
  {
    name: "sBLUB",
    symbol: "sBLUB",
    decimals: 2,
    logoURL: "https://gutxmo5scqefen42iu6ysi5unhdsdenwtcqe2z5hxszz3ssdhzsa.arweave.net/NSd2O7IUCFI3mkU9iSO0acchkbaYoE1np7yzncpDPmQ",
    coinType: "0xe72f65446eabfad2103037af2d49d24599106fb44bf4c046c1e7e9acf6844dd0::scallop_blub::SCALLOP_BLUB",
    isVerified: true
  },
  {
    name: "Typus",
    symbol: "TYPUS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/CQCvjKXMzASaCMXWx1SyUMa6syFJqtwAaAsAhbzsHGXi",
    coinType: "0xf82dc05634970553615eef6112a1ac4fb7bf10272bf6cbe0f80ef44a6c489385::typus::TYPUS",
    isVerified: true
  },
  {
    name: "sFUD",
    symbol: "sFUD",
    decimals: 5,
    logoURL: "https://enx3zetzw42z2gpckvye66ljal2vfu63rb2qc5arvq7wof3xdbhq.arweave.net/I2-8knm3NZ0Z4lVwT3lpAvVS09uIdQF0Eaw_Zxd3GE8",
    coinType: "0xe56d5167f427cbe597da9e8150ef5c337839aaf46891d62468dcf80bdd8e10d1::scallop_fud::SCALLOP_FUD",
    isVerified: true
  },
  {
    name: "shaSUI",
    symbol: "shaSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8raXDMcjv2y9sV6pXSJkiyw6PXa7B44GRXNzuBBstfQL",
    coinType: "0x9a2376943f7d22f88087c259c5889925f332ca4347e669dc37d54c2bf651af3c::scallop_ha_sui::SCALLOP_HA_SUI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9a2376943f7d22f88087c259c5889925f332ca4347e669dc37d54c2bf651af3c::scallop_ha_sui::SCALLOP_HA_SUI"
    }
  },
  {
    name: "Lorenzo stBTC",
    symbol: "stBTC",
    decimals: 8,
    logoURL: "https://node1.irys.xyz/qg69O3RwWkFt8QG2_GeTh-xGOQEkLbaiPjuU-yDsHqM",
    coinType: "0x5f496ed5d9d045c5b788dc1bb85f54100f2ede11e46f6a232c29daada4c5bdb6::coin::COIN",
    isVerified: true,
    extensionFields: {
      coingecko_id: "lorenzo-stbtc"
    }
  },
  {
    name: "Suia Token",
    symbol: "SUIA",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/suia.png",
    coinType: "0x1d58e26e85fbf9ee8596872686da75544342487f95b1773be3c9a49ab1061b19::suia_token::SUIA_TOKEN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x1d58e26e85fbf9ee8596872686da75544342487f95b1773be3c9a49ab1061b19::suia_token::SUIA_TOKEN",
      coin_priority: 800,
      coingecko_id: "suia"
    }
  },
  {
    name: "Wrapped Matic (Portal from Polygon)",
    symbol: "WMATIC",
    decimals: 8,
    logoURL: "https://fe3wnx45vysrtzfr7kwg4aowt7aqb2tku4szytg2ayfwdyp3jk6q.arweave.net/KTdm352uJRnksfqsbgHWn8EA6mqnJZxM2gYLYeH7Sr0",
    coinType: "0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676::coin::COIN",
      coin_priority: 710,
      coingecko_id: "matic-wormhole",
      labels: ["Wormhole"],
      pyth_id: "5de33a9112c2b700b8d30b8a3402c103578ccfa2765696471cc672bd5cf6ac52"
    }
  },
  {
    name: "Bucket USD",
    symbol: "BUCK",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/buck.png",
    coinType: "0xce7ff77a83ea0cb6fd39bd8748e2ec89a3f41e8efdc3f4eb123e0ca37b184db2::buck::BUCK",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xce7ff77a83ea0cb6fd39bd8748e2ec89a3f41e8efdc3f4eb123e0ca37b184db2::buck::BUCK",
      coin_priority: 920,
      coingecko_id: "bucket-protocol-buck-stablecoin",
      pyth_id: "fdf28a46570252b25fd31cb257973f865afc5ca2f320439e45d95e0394bc7382",
      rank: 900,
      suggested_priority: 900
    }
  },
  {
    name: "CETUS Token",
    symbol: "CETUS",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/cetus.png",
    coinType: "0x06864a6f921804860930db6ddbe2e16acdf8504495ea7481637a1c8b9a8fe54b::cetus::CETUS",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x06864a6f921804860930db6ddbe2e16acdf8504495ea7481637a1c8b9a8fe54b::cetus::CETUS",
      coin_priority: 970,
      coingecko_id: "cetus-protocol",
      pyth_id: "e5b274b2611143df055d6e7cd8d93fe1961716bcd4dca1cad87a83bc1e78c1ef",
      rank: 810,
      suggested_priority: 980
    }
  },
  {
    name: "Ondo US Dollar Yield",
    symbol: "USDY",
    decimals: 6,
    logoURL: "https://66wosxwjgpz7qbv4psulb555d35nxqn6h6jtgu2cxzw4awrbtw3q.arweave.net/96zpXskz8_gGvHyosPe9Hvrbwb4_kzNTQr5twFohnbc",
    coinType: "0x960b531667636f39e85867775f52f6b1f220a058c4de786905bdf761e06a56bb::usdy::USDY",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x960b531667636f39e85867775f52f6b1f220a058c4de786905bdf761e06a56bb::usdy::USDY",
      coin_priority: 880,
      coingecko_id: "ondo-us-dollar-yield",
      pyth_id: "e393449f6aff8a4b6d3e1165a7c9ebec103685f3b41e60db4277b5b6d10e7326",
      rank: 890
    }
  },
  {
    name: "Bluefin",
    symbol: "BLUE",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/CppTxB1NXfoDaJL4cjB6RyzFFwzySRF8zD8t2pBaMy8s",
    coinType: "0xe1b45a0e641b9955a20aa0ad1c1f4ad86aad8afb07296d4085e349a50e90bdca::blue::BLUE",
    isVerified: true
  },
  {
    name: "swBTC",
    symbol: "swBTC",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/82YqjZLgZo2wjsbktvPnKgAaSrUbkfJuL3zq4GBASjnP",
    coinType: "0x2cf76a9cf5d3337961d1154283234f94da2dcff18544dfe5cbdef65f319591b5::scallop_wormhole_btc::SCALLOP_WORMHOLE_BTC",
    isVerified: true
  },
  {
    name: "Tether (Celer)",
    symbol: "cUSDT",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/usdt_celer.png",
    coinType: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdt_coin::CELER_USDT_COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdt_coin::CELER_USDT_COIN",
      labels: ["Celer"],
      pyth_id: "2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b"
    }
  },
  {
    name: "WEWE",
    symbol: "WEWE",
    decimals: 9,
    logoURL: "https://file-walletapp.waveonsui.com/logos/wewe.png",
    coinType: "0xb5b603827d1bfb2859200fd332d5e139ccac2598f0625de153a87cf78954e0c4::wewe::WEWE",
    isVerified: true
  },
  {
    name: "sSUI",
    symbol: "sSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/GYmShkpMcYFgSsEcpCEZUPiChhBaFeXMQnFrxxjqZdhE",
    coinType: "0xaafc4f740de0dd0dde642a31148fb94517087052f19afb0f7bed1dc41a50c77b::scallop_sui::SCALLOP_SUI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xaafc4f740de0dd0dde642a31148fb94517087052f19afb0f7bed1dc41a50c77b::scallop_sui::SCALLOP_SUI"
    }
  },
  {
    name: "USD Coin (Portal from Arbitrum, New)",
    symbol: "USDCarb",
    decimals: 6,
    logoURL: "https://boqgq74qfqr7gfo4x7tpesefwkzawnbe4e3anop54gwsh3ctfdoa.arweave.net/C6Bof5AsI_MV3L_m8kiFsrILNCThNga5_eGtI-xTKNw",
    coinType: "0xc3f8927de33d3deb52c282a836082a413bc73c6ee0bd4d7ec7e3b6b4c28e9abf::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xc3f8927de33d3deb52c282a836082a413bc73c6ee0bd4d7ec7e3b6b4c28e9abf::coin::COIN",
      coin_priority: 841,
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 950
    }
  },
  {
    name: "Meadow",
    symbol: "MED",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/meadow.png",
    coinType: "0x9a7ca7b6de5b6e9a4dadec42fada7cd84068aebd7adbd1faeb713622c4628ca9::meadow::MEADOW",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9a7ca7b6de5b6e9a4dadec42fada7cd84068aebd7adbd1faeb713622c4628ca9::meadow::MEADOW",
      coin_priority: 670,
      coingecko_id: "meadow"
    }
  },
  {
    name: "Tether by Sui Bridge",
    symbol: "suiUSDT",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/H6RiSi7PDvKaKCzgsLybW1Pdaq4pvakBHnTvghWD5Kad",
    coinType: "0x375f70cf2ae4c00bf37117d0c85a2c71545e6ee05c4a5c7d282cd66a4504b068::usdt::USDT",
    isVerified: true,
    extensionFields: {
      coin_priority: 831,
      rank: 931,
      suggested_priority: 990
    }
  },
  {
    name: "BLUB",
    symbol: "BLUB",
    decimals: 2,
    logoURL: "https://453ilwcfza3uzupxtaell2f2acwezft7jynjduuc3skuehtu76pq.arweave.net/53aF2EXIN0zR95gItei6AKxMln9OGpHSgtyVQh50_58",
    coinType: "0xfa7ac3951fdca92c5200d468d31a365eb03b2be9936fde615e69f0c1274ad3a0::BLUB::BLUB",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xfa7ac3951fdca92c5200d468d31a365eb03b2be9936fde615e69f0c1274ad3a0::BLUB::BLUB",
      coin_priority: 821,
      coingecko_id: "blub"
    }
  },
  {
    name: "Pum Pup",
    symbol: "PUP",
    decimals: 9,
    logoURL: "https://res.cetus.zone/coin-metadata/mainnet/icon/pup.png",
    coinType: "0x980ec1e7d5a3d11c95039cab901f02a044df2d82bc79d99b60455c02524fad83::pup::PUP",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x980ec1e7d5a3d11c95039cab901f02a044df2d82bc79d99b60455c02524fad83::pup::PUP"
    }
  },
  {
    name: "sSBETH",
    symbol: "sSBETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/4Zaceo2mJ9SQFKFdoqib1WMjdW1oYkNmTqV8MEsHjCCP",
    coinType: "0xb14f82d8506d139eacef109688d1b71e7236bcce9b2c0ad526abcd6aa5be7de0::scallop_sb_eth::SCALLOP_SB_ETH",
    isVerified: true
  },
  {
    name: "USD Coin (Portal from Arbitrum, Old)",
    symbol: "USDCarb",
    decimals: 6,
    logoURL: "https://zesrehijzslvuwaf7vplw5qsnhjdz4cpsighhn65watc4fwl22gq.arweave.net/ySUSHQnMl1pYBf1eu3YSadI88E-SDHO33bAmLhbL1o0",
    coinType: "0xe32d3ebafa42e6011b87ef1087bbc6053b499bf6f095807b9013aff5a6ecd7bb::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xe32d3ebafa42e6011b87ef1087bbc6053b499bf6f095807b9013aff5a6ecd7bb::coin::COIN",
      coin_priority: 840,
      coingecko_id: "usd-coin-wormhole-arb",
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 940
    }
  },
  {
    name: "aaa cat",
    symbol: "AAA",
    decimals: 6,
    logoURL: "https://45hgkrkliypqc7rpknvnhhqvsdpk23m2sfphh3vcmqrukddd74la.arweave.net/505lRUtGHwF-L1Nq054VkN6tbZqRXnPuomQjRQxj_xY",
    coinType: "0xd976fda9a9786cda1a36dee360013d775a5e5f206f8e20f84fad3385e99eeb2d::aaa::AAA",
    isVerified: true
  },
  {
    name: "mETH",
    symbol: "mETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/83AAjCZKyL3VKpxDZG71f4qNWuuqg4uHp4BHVLA3G14e",
    coinType: "0xccd628c2334c5ed33e6c47d6c21bb664f8b6307b2ac32c2462a61f69a31ebcee::meth::METH",
    isVerified: true
  },
  {
    name: "WAVE",
    symbol: "WAV",
    decimals: 9,
    logoURL: "https://files.waveonsui.com/logos/wav.png",
    coinType: "0x82616322719cb327186d5b83a6d7783ce5cef4c5dbd4c6d1b5f3d6e5d288e2be::wav::WAV",
    isVerified: true
  },
  {
    name: "PIGU",
    symbol: "PIGU",
    decimals: 5,
    logoURL: "https://idcawqx5x4ziq6wq7xck7wlleckqbzv5jbhqpgbbeynww2kd4pda.arweave.net/QMQLQv2_Moh60P3Er9lrIJUA5r1ITweYISYba2lD48Y",
    coinType: "0xfc71274a94f5d9cd1ae6928ecfc9fa910d03eb28258fddeb9842ac3c7b4f3ae6::pigu::PIGU",
    isVerified: true
  },
  {
    name: "Tether (Portal from Eth)",
    symbol: "wUSDT",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/DJs8CsKRW4sP5dgi8zfZRWiFXpzNsN3EnUYkQknu4dyd",
    coinType: "0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c::coin::COIN",
      coin_priority: 980,
      coingecko_id: "tether-usd-wormhole-from-ethereum",
      labels: ["Wormhole"],
      pyth_id: "2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b",
      rank: 920
    }
  },
  {
    name: "sMOVE",
    symbol: "sMOVECOIN",
    logoURL: "https://4g7mzcwybmcqsnwiygg4eotqtqkays7y6qyyuycm7tetewing4da.arweave.net/4b7MitgLBQk2yMGNwjpwnBQMS_j0MYpgTPzJMlkNNwY",
    coinType: "0xf925a9e67cbe498c7e5cd87a17fc09692c455b940f065f4b462f885ea196a89d::smove::SMOVE",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xf925a9e67cbe498c7e5cd87a17fc09692c455b940f065f4b462f885ea196a89d::smove::SMOVE",
      coin_priority: 760
    }
  },
  {
    name: "SuiAI",
    symbol: "SUAI",
    decimals: 6,
    logoURL: "https://api.suiai.fun/uploads/suai_logo.png",
    coinType: "0xbc732bc5f1e9a9f4bdf4c0672ee538dbf56c161afe04ff1de2176efabdf41f92::suai::SUAI",
    isVerified: true
  },
  {
    name: "SuiPad",
    symbol: "SUIP",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/suip.png",
    coinType: "0xe4239cd951f6c53d9c41e25270d80d31f925ad1655e5ba5b543843d4a66975ee::SUIP::SUIP",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xe4239cd951f6c53d9c41e25270d80d31f925ad1655e5ba5b543843d4a66975ee::SUIP::SUIP",
      coin_priority: 780,
      coingecko_id: "suipad"
    }
  },
  {
    name: "BULLA",
    symbol: "BULLA",
    decimals: 8,
    logoURL: "https://i.imgur.com/YPFKKZw.jpeg",
    coinType: "0xeec46a9527885ade0b62b984315f2f45d4cd40d9a8c19a553e553e722ab33239::bulla::BULLA",
    isVerified: true
  },
  {
    name: "Dungeon Gold",
    symbol: "DGG",
    decimals: 6,
    logoURL: "https://h6bzmql5j4nlpj3hiiizzqdmygd7xfbkzcn2gtfy4chmjsmmpdsq.arweave.net/P4OWQX1PGrenZ0IRnMBswYf7lCrIm6NMuOCOxMmMeOU",
    coinType: "0x625d518a3cc78899742d76cf785609cd707e15228d4284aa4fee5ca53caa9849::dgg_token::DGG_TOKEN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x625d518a3cc78899742d76cf785609cd707e15228d4284aa4fee5ca53caa9849::dgg_token::DGG_TOKEN"
    }
  },
  {
    name: "sFDUSD",
    symbol: "sFDUSD",
    decimals: 6,
    logoURL: "https://am6vo2vn4mg2lm7vmajonsipgkat56z75mxe55babpztrbssmb4a.arweave.net/Az1Xaq3jDaWz9WAS5skPMoE--z_rLk70IAvzOIZSYHg",
    coinType: "0x6711551c1e7652a270d9fbf0eee25d99594c157cde3cb5fbb49035eb59b1b001::scallop_fdusd::SCALLOP_FDUSD",
    isVerified: true
  },
  {
    name: "KDX",
    symbol: "KDX",
    decimals: 6,
    logoURL: "https://i.ibb.co/Wsbch2z/kriya.png",
    coinType: "0x3b68324b392cee9cd28eba82df39860b6b220dc89bdd9b21f675d23d6b7416f1::kdx::KDX",
    isVerified: true
  },
  {
    name: "LuckyStar",
    symbol: "LUCK",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/luck.png",
    coinType: "0x202591744d54ee4f4af736ef3b8508f3d46d982c36747d9587032bd549122179::luck::LUCK",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x202591744d54ee4f4af736ef3b8508f3d46d982c36747d9587032bd549122179::luck::LUCK",
      coin_priority: 640
    }
  },
  {
    name: "OTTER",
    symbol: "OTTER",
    decimals: 9,
    logoURL: "https://i52dwsbjw2rvuagb4yknsxruq2vwqprdhga6p53ik3co6kzdiwea.arweave.net/R3Q7SCm2o1oAweYU2V40hqtoPiM5gef3aFbE7ysjRYg",
    coinType: "0x297b7f887a47fdcdf82364b5b175c2f00c2ece012c06ec7dc58ee7bc0c63aa07::otter::OTTER",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x297b7f887a47fdcdf82364b5b175c2f00c2ece012c06ec7dc58ee7bc0c63aa07::otter::OTTER",
      coin_priority: 660
    }
  },
  {
    name: "Suiswap",
    symbol: "SSWP",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/sswp.png",
    coinType: "0x361dd589b98e8fcda9a7ee53b85efabef3569d00416640d2faa516e3801d7ffc::TOKEN::TOKEN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x361dd589b98e8fcda9a7ee53b85efabef3569d00416640d2faa516e3801d7ffc::TOKEN::TOKEN",
      coin_priority: 740
    }
  },
  {
    name: "First Digital USD",
    symbol: "FDUSD",
    decimals: 6,
    logoURL: "https://cdn.1stdigital.com/icon/fdusd.svg",
    coinType: "0xf16e6b723f242ec745dfd7634ad072c42d5c1d9ac9d62a39c381303eaa57693a::fdusd::FDUSD",
    isVerified: true,
    extensionFields: {
      coin_priority: 971,
      pyth_id: "ccdc1a08923e2e4f4b1e6ea89de6acbc5fe1948e9706f5604b8cb50bc1ed3979"
    }
  },
  {
    name: "Dripward",
    symbol: "DRIP",
    decimals: 9,
    logoURL: "https://gh63r3fltrhlf22hh6722j667hyk546aycyevlmody46swnzh5da.arweave.net/Mf247KucTrLrRz-_rSfe-fCu88DAsEqtjh456Vm5P0Y",
    coinType: "0x9eed28fc98688a799fe51aa6ed39b851bd09d950fc785b2d7c9f543796254631::drip::DRIP",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9eed28fc98688a799fe51aa6ed39b851bd09d950fc785b2d7c9f543796254631::drip::DRIP"
    }
  },
  {
    name: "superSUI",
    symbol: "superSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/TAKkVW5fTxDGTTgM22eFNEQX2V6JbLuN2ckBtFybrix",
    coinType: "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI"
    }
  },
  {
    name: "SuiNS Token",
    symbol: "NS",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/FRs7eLL3B5eABDW3hG5xwtaATaU4x8fEZm9V5z8GdFYr",
    coinType: "0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178::ns::NS",
    isVerified: true
  },
  {
    name: "ARTFI",
    symbol: "ARTFI",
    decimals: 9,
    logoURL: "https://rao3tdm6qnrnk3z6tga4jsnn5ufuapmlqoffpatiqligyjb2vnga.arweave.net/iB25jZ6DYtVvPpmBxMmt7QtAPYuDileCaILQbCQ6q0w",
    coinType: "0x706fa7723231e13e8d37dad56da55c027f3163094aa31c867ca254ba0e0dc79f::artfi::ARTFI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x706fa7723231e13e8d37dad56da55c027f3163094aa31c867ca254ba0e0dc79f::artfi::ARTFI",
      coingecko_id: "artfi"
    }
  },
  {
    name: "sCETUS",
    symbol: "sCETUS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/FfmvsmthhRiAaBwY8nZjx8uavV2ySs7USgn5xamsxFf5",
    coinType: "0xea346ce428f91ab007210443efcea5f5cdbbb3aae7e9affc0ca93f9203c31f0c::scallop_cetus::SCALLOP_CETUS",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xea346ce428f91ab007210443efcea5f5cdbbb3aae7e9affc0ca93f9203c31f0c::scallop_cetus::SCALLOP_CETUS"
    }
  },
  {
    name: "Sacabam",
    symbol: "SCB",
    decimals: 5,
    logoURL: "https://archive.cetus.zone/assets/image/sui/scb.png",
    coinType: "0x9a5502414b5d51d01c8b5641db7436d789fa15a245694b24aa37c25c2a6ce001::scb::SCB",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9a5502414b5d51d01c8b5641db7436d789fa15a245694b24aa37c25c2a6ce001::scb::SCB",
      coin_priority: 730,
      coingecko_id: "sacabam"
    }
  },
  {
    name: "Pearl",
    symbol: "PRL",
    decimals: 12,
    logoURL: "https://archive.cetus.zone/assets/image/sui/pearl.png",
    coinType: "0x4e56b39acd75721999cf833062dfb77b1d51e749b02d90f049a5688e21919a64::prl::PRL",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x4e56b39acd75721999cf833062dfb77b1d51e749b02d90f049a5688e21919a64::prl::PRL"
    }
  },
  {
    name: "Pyth Network",
    symbol: "PYTH",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/pyth.png",
    coinType: "0x9c6d76eb273e6b5ba2ec8d708b7fa336a5531f6be59f326b5be8d4d8b12348a4::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9c6d76eb273e6b5ba2ec8d708b7fa336a5531f6be59f326b5be8d4d8b12348a4::coin::COIN",
      coin_priority: 810,
      pyth_id: "0bbf28e9a841a1cc788f6a361b17ca072d0ea3098a1e5df1c3922d06719579ff"
    }
  },
  {
    name: "LOOPY",
    symbol: "LOOPY",
    decimals: 6,
    logoURL: "https://lk47si3fdmkhszxbmzuksrg5gcbum5rbnudnjd7cnzxor7g2cd7a.arweave.net/Wrn5I2UbFHlm4WZoqUTdMINGdiFtBtSP4m5u6PzaEP4",
    coinType: "0x9b9c0e26a8ace7edb8fce14acd81507c507c677a400cfb9cc9a0ca4a8432a97a::loopy_sui::LOOPY_SUI",
    isVerified: true
  },
  {
    name: "JWLSCA",
    symbol: "JWLSCA",
    decimals: 9,
    logoURL: "https://ocknifrosvx5vmpte2zavnpv7fpkauqsqu5tij43iy5shxdle6ha.arweave.net/cJTUFi6Vb9qx8yayCrX1-V6gUhKFOzQnm0Y7I9xrJ44",
    coinType: "0x0e25582daef54ee41052390c4db5e70a82ec1baed97942db0eb6094267624b5d::jwlsca::JWLSCA",
    isVerified: true
  },
  {
    name: "JWLSUI",
    symbol: "JWLSUI",
    decimals: 9,
    logoURL: "https://bwxyokyoypcv4zjesyqn6gnjfopzohnrcv2lqwdvcccgahccintq.arweave.net/Da-HKw7DxV5lJJYg3xmpK5-XHbEVdLhYdRCEYBxCQ2c",
    coinType: "0x2921ca2fe6ee99698b095f046bc9759ce7a764d2e91ab0ad182c143649c3df79::jwlsui::JWLSUI",
    isVerified: true
  },
  {
    name: "SLOVE",
    symbol: "SLOVE",
    decimals: 6,
    logoURL: "https://ipfs.io/ipfs/bafkreigt2pvpzokflugamigupuwo3xfw3agg3xcfuiduqpv3j6hfooh65a",
    coinType: "0x6dd439dee053557b3dd340287a4b81099b3e729cb48fbdae726dd2dff82736c3::slove::SLOVE",
    isVerified: true
  },
  {
    name: "FroggnRatt",
    symbol: "FRATT",
    decimals: 2,
    logoURL: "https://xatontgesaqf7cfeboedtsik7xnnz2wespeifbf3igqzifiqi6fa.arweave.net/uCbmzMSQIF-IpAuIOckK_drc6sSTyIKEu0GhlBUQR4o",
    coinType: "0x31348f17429e6b37ed269cc667cc83947ff8c54593dcbd1a56cae06a895a38be::fratt::FRATT",
    isVerified: true
  },
  {
    name: "Aftermath Staked SUI",
    symbol: "afSUI",
    decimals: 9,
    logoURL: "https://aftermath.finance/coins/afsui.svg",
    coinType: "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI",
      coin_priority: 909,
      pyth_id: "17cd845b16e874485b2684f8b8d1517d744105dbb904eec30222717f4bc9ee0d",
      rank: 850
    }
  },
  {
    name: "JWLCETUS",
    symbol: "JWLCETUS",
    decimals: 9,
    logoURL: "https://t3d7i5s4u6ntxge7nqkwjnfnyswrk22ymd4utk4qmaxlh7zofgyq.arweave.net/nsf0dlynmzuYn2wVZLStxK0Va1hg-UmrkGAus_8uKbE",
    coinType: "0x0e25582daef54ee41052390c4db5e70a82ec1baed97942db0eb6094267624b5d::jwlcetus::JWLCETUS",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x0e25582daef54ee41052390c4db5e70a82ec1baed97942db0eb6094267624b5d::jwlcetus::JWLCETUS"
    }
  },
  {
    name: "SUI Token",
    symbol: "SUI",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/sui.png",
    coinType: "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x2::sui::SUI",
      coin_priority: 1e3,
      coingecko_id: "sui",
      pyth_id: "23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744",
      rank: 880,
      suggested_priority: 1e3
    }
  },
  {
    name: "LOFI",
    symbol: "LOFI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/GqFLYxhLNuKYbSYCVJrjqnARisqogKhggngtYg9sZ9uw",
    coinType: "0xf22da9a24ad027cccb5f2d496cbe91de953d363513db08a3a734d361c7c17503::LOFI::LOFI",
    isVerified: true
  },
  {
    name: "Sonic Snipe Bot",
    symbol: "Sonic",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/E82DQkogizAv1CYi8nbgWydVx49DHy42qSRzksMx4iwx",
    coinType: "0x555f3aa7c9c60ca67f906557777fab78fd70a302da7d66a23fcb4f8808d15010::sonic::SONIC",
    isVerified: true
  },
  {
    name: "Sui Plop",
    symbol: "PLOP",
    decimals: 6,
    logoURL: "https://fj74jg6iknyhnkkajybduxndrgvp3r7lklyjnlj7w2cvflsc574a.arweave.net/Kn_Em8hTcHapQE4COl2jiar9x-tS8JatP7aFUq5C7_g",
    coinType: "0x1c6cd615ed4c42a34977212a3407a28eec21acc572c8dbe7d0382bf0289a2590::plop::PLOP",
    isVerified: true
  },
  {
    name: "WAL Token",
    symbol: "WAL",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/7dgjqChkGXxmhFvqR5AWP4vWUs8hNiJpe9Cw7K4x7GP2",
    coinType: "0x356a26eb9e012a68958082340d4c4116e7f55615cf27affcff209cf0ae544f59::wal::WAL",
    isVerified: true,
    extensionFields: {
      suggested_priority: 904
    }
  },
  {
    name: "Native USDC",
    symbol: "USDC",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/EGpc2cG886CrWwLMneF2RyVpZ7D33a6znz6XE8n8nU7h",
    coinType: "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
    isVerified: true,
    extensionFields: {
      coin_priority: 991,
      coingecko_id: "usd-coin",
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 1e3,
      suggested_priority: 991
    }
  },
  {
    name: "STASH",
    symbol: "STASH",
    decimals: 9,
    logoURL: "https://7kyn2qaielikddp6kpi7dtriubzemb2pthesca33bxsxskusunhq.arweave.net/-rDdQAgi0KGN_lPR8c4ooHJGB0-ZySEDew3leSqSo08",
    coinType: "0x2cff601fe16f622fd6203f8f64bef4e68d687f51f4d06f13c2bbba17cb84c87e::stash::STASH",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x2cff601fe16f622fd6203f8f64bef4e68d687f51f4d06f13c2bbba17cb84c87e::stash::STASH"
    }
  },
  {
    name: "swETH",
    symbol: "swETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/J1Ni98whDmtXgtGYDmk7Hy6qfoHas9MJYwMnixgDSdNo",
    coinType: "0x67540ceb850d418679e69f1fb6b2093d6df78a2a699ffc733f7646096d552e9b::scallop_wormhole_eth::SCALLOP_WORMHOLE_ETH",
    isVerified: true
  },
  {
    name: "meow",
    symbol: "meow",
    decimals: 6,
    logoURL: "https://g2eop2adggvbnllpabicghum55pai3bt23c5yvo3c5gohtix6fma.arweave.net/Nojn6AMxqhatbwBQIx6M714EbDPWxdxV2xdM480X8Vg",
    coinType: "0x06b145d0322e389d6225f336ab57bba4c67e4e701bd6c6bc959d90675900a17e::meow::MEOW",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x06b145d0322e389d6225f336ab57bba4c67e4e701bd6c6bc959d90675900a17e::meow::MEOW"
    }
  },
  {
    name: "SUI TRUMP",
    symbol: "SUITRUMP",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/9Q89LeyqhQSDGun24w1PYZC6zZ4KTGhCPDC2rJpQieY1",
    coinType: "0xdeb831e796f16f8257681c0d5d4108fa94333060300b2459133a96631bf470b8::suitrump::SUITRUMP",
    isVerified: true
  },
  {
    name: "Wrapped BTC (Portal from Eth)",
    symbol: "WBTC",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/dNcUM18WoBxiGE55MrQVgt9kZ7yho9WbyJWa8NbSxDH",
    coinType: "0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881::coin::COIN",
      coin_priority: 890,
      coingecko_id: "wrapped-btc-wormhole",
      labels: ["Wormhole"],
      pyth_id: "e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
      rank: 790
    }
  },
  {
    name: "Releap",
    symbol: "REAP",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/reap.png",
    coinType: "0xde2d3e02ba60b806f81ee9220be2a34932a513fe8d7f553167649e95de21c066::reap_token::REAP_TOKEN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xde2d3e02ba60b806f81ee9220be2a34932a513fe8d7f553167649e95de21c066::reap_token::REAP_TOKEN",
      coin_priority: 750
    }
  },
  {
    name: "ETH by Sui Bridge",
    symbol: "ETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/435auUGaKQ3FAT7CZnegmvNNJnbuRc7aSkwTTDJ5JmNw",
    coinType: "0xd0e89b2af5e4910726fbcd8b8dd37bb79b29e5f83f7491bca830e94f7f226d29::eth::ETH",
    isVerified: true,
    extensionFields: {
      coin_priority: 941,
      coingecko_id: "ethereum",
      pyth_id: "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
      rank: 780,
      suggested_priority: 890
    }
  },
  {
    name: "BonkCoin (Portal from Solana)",
    symbol: "BONK",
    decimals: 5,
    logoURL: "https://3dgyzd2llawd2e6monsrlnrj4ijs3n3zkno37khmqcfbfjquvknq.arweave.net/2M2Mj0tYLD0TzHNlFbYp4hMtt3lTXb-o7ICKEqYUqps",
    coinType: "0x6907963ca849faff0957b9a8269a7a07065e3def2eef49cc33b50ab946ea5a9f::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x6907963ca849faff0957b9a8269a7a07065e3def2eef49cc33b50ab946ea5a9f::coin::COIN",
      coin_priority: 680,
      labels: ["Wormhole"],
      pyth_id: "72b021217ca3fe68922a19aaf990109cb9d84e9ad004b4d2025ad6f529314419"
    }
  },
  {
    name: "SroomAI DAO",
    symbol: "SHR0",
    decimals: 9,
    logoURL: "https://suidaos.com/logo/shro.png",
    coinType: "0x16ab6a14d76a90328a6b04f06b0a0ce952847017023624e0c37bf8aa314c39ba::shr::SHR",
    isVerified: true
  },
  {
    name: "USD Coin (Portal from Polygon)",
    symbol: "USDCpol",
    decimals: 6,
    logoURL: "https://otjatct2scltanet7e7untvl3lx4kccddwx5pusxqr6a2pd3qe5a.arweave.net/dNIJinqQlzA0k_k_Rs6r2u_FCEMdr9fSV4R8DTx7gTo",
    coinType: "0xcf72ec52c0f8ddead746252481fb44ff6e8485a39b803825bde6b00d77cdb0bb::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xcf72ec52c0f8ddead746252481fb44ff6e8485a39b803825bde6b00d77cdb0bb::coin::COIN",
      coin_priority: 850,
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 960
    }
  },
  {
    name: "AlphaFi Staked SUI",
    symbol: "stSUI",
    decimals: 9,
    logoURL: "https://images.alphafi.xyz/stSUI.png",
    coinType: "0xd1b72982e40348d069bb1ff701e634c117bb5f741f44dff91e472d3b01461e55::stsui::STSUI",
    isVerified: true
  },
  {
    name: "FLAMINGO GRINGO",
    symbol: "FLAMINGO",
    decimals: 6,
    logoURL: "https://oggdkiqjw4niipp2w7r2ooeujubnhynevxkdwlqlqzqnrb7lufwa.arweave.net/cYw1Igm3GoQ9-rfjpziUTQLT4aSt1DsuC4Zg2IfroWw",
    coinType: "0x17c334979cd0698ccf9450a3ec2ae0ce1e4c6b0935353fe5facbf69fa77a72af::flamingo::FLAMINGO",
    isVerified: true
  },
  {
    name: "AUSD",
    symbol: "AUSD",
    decimals: 6,
    logoURL: "https://qele7wvrqjkzonp2egfsagymxbgrewy7adtywuxng4tmpdaycfxa.arweave.net/gRZP2rGCVZc1-iGLIBsMuE0SWx8A54tS7Tcmx4wYEW4",
    coinType: "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2::ausd::AUSD",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2::ausd::AUSD",
      coin_priority: 822,
      coingecko_id: "agora-dollar",
      rank: 910
    }
  },
  {
    name: "Chirp Token",
    symbol: "CHIRP",
    decimals: 10,
    logoURL: "https://download.chirpwireless.io/images/CHIRP_White_OBG.svg",
    coinType: "0x1ef4c0b20340b8c6a59438204467ca71e1e7cbe918526f9c2c6c5444517cd5ca::chirp::CHIRP",
    isVerified: true
  },
  {
    name: "pSTAKE Finance",
    symbol: "PSTAKE",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/3iYkJnAE2Kt14r6DoRvbbntbdVRjBt9LAURH4DTKmmrb",
    coinType: "0x61017ce4bd0b75b266af53edd60bbe391ba1a9fbe9a7d8553657c94ef73ee2ab::coin::COIN",
    isVerified: true
  },
  {
    name: "xAIFRENS",
    symbol: "xAIFRENS",
    logoURL: "https://archive.cetus.zone/assets/image/sui/xAIFRENS.png",
    coinType: "0x9fe1780ac27ec50c9c441fb31822f5c148f841f09ee455c6a0daf7c634a30a27::aifrens::AIFRENS",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9fe1780ac27ec50c9c441fb31822f5c148f841f09ee455c6a0daf7c634a30a27::aifrens::AIFRENS",
      coin_priority: 620
    }
  },
  {
    name: "Tardi",
    symbol: "TARDI",
    decimals: 9,
    logoURL: "https://bafybeieycjagqv7xtenzxss5xkcxgeru7wql6izhzokr4ay4xdbrul4ef4.ipfs.w3s.link",
    coinType: "0x4cf08813756dfa7519cb480a1a1a3472b5b4ec067592a8bee0f826808d218158::tardi::TARDI",
    isVerified: true
  },
  {
    name: "Turbos",
    symbol: "TURBOS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/4ov3eH2cE4B4DzTsSLmAQNnnmo8zc5MRSFR6wcN4XyLU",
    coinType: "0x5d1f47ea69bb0de31c313d7acf89b890dbb8991ea8e03c6c355171f84bb1ba4a::turbos::TURBOS",
    isVerified: true
  },
  {
    name: "sudeng",
    symbol: "HIPPO",
    decimals: 9,
    logoURL: "https://i.imgur.com/j2EuFh5.png",
    coinType: "0x8993129d72e733985f7f1a00396cbd055bad6f817fee36576ce483c8bbb8b87b::sudeng::SUDENG",
    isVerified: true
  },
  {
    name: "Liquor",
    symbol: "LIQ",
    decimals: 6,
    logoURL: "https://cehaawdywth4eyp6isj3vmv3ie2g5s3x4w36u3yrl6ytjeqcnulq.arweave.net/EQ4AWHi0z8Jh_kSTurK7QTRuy3flt-pvEV-xNJICbRc",
    coinType: "0x9c86d1926a0a39e906f20674d6a35f337be8625ebcb6b799ee8ff011f328bee2::liq::LIQ",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x9c86d1926a0a39e906f20674d6a35f337be8625ebcb6b799ee8ff011f328bee2::liq::LIQ"
    }
  },
  {
    name: "Uni",
    symbol: "Uni",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/HK51s6xHPbFRHjHjTLna5XyypW5Yk94c1zjok822FJ88",
    coinType: "0xaf9e228fd0292e2a27b4859bc57a2f3a9faedb9341b6307c84fef163e44790cc::uni::UNI",
    isVerified: true
  },
  {
    name: "Kriya Staked SUI",
    symbol: "kSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/HdCzDMJeQ6zE5LPFrknSXBkZityS1KZX2SzC1isZn6Ey",
    coinType: "0x41ff228bfd566f0c707173ee6413962a77e3929588d010250e4e76f0d1cc0ad4::ksui::KSUI",
    isVerified: true
  },
  {
    name: "Pugwifhat",
    symbol: "PUGWIF",
    decimals: 9,
    logoURL: "https://2fqoiyw7ewk4ecchpakhk5rr4brbfy7abyidgjw6cphzlgg464ba.arweave.net/0WDkYt8llcIIR3gUdXYx4GIS4-AOEDMm3hPPlZjc9wI",
    coinType: "0x2cd6f14a4b64c3a0fa9c644e8ed88d9c91d789a071886d67d24e6b435147063d::pugwif::PUGWIF",
    isVerified: true
  },
  {
    name: "swUSDC",
    symbol: "swUSDC",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/29eNJ7Qu9B5CDy8Gr58TxtR8QWUKPN2XWsVYK9cLr4Zu",
    coinType: "0xad4d71551d31092230db1fd482008ea42867dbf27b286e9c70a79d2a6191d58d::scallop_wormhole_usdc::SCALLOP_WORMHOLE_USDC",
    isVerified: true
  },
  {
    name: "awww~~~awww",
    symbol: "awww",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/9GnzhvzZsXdpZPGV7YH4nEwaYogYdWTVV8Y2JYGgqmJf",
    coinType: "0x594b539e0020ca22f83e9a8f55c1fede4c5730130d5b100fcf01f98ddb4f94c8::awww::AWWW",
    isVerified: true
  },
  {
    name: "KIMCHI",
    symbol: "KIMCHI",
    decimals: 5,
    logoURL: "https://archive.cetus.zone/assets/image/sui/kimchi.png",
    coinType: "0xb6baa75577e4bbffba70207651824606e51d38ae23aa94fb9fb700e0ecf50064::kimchi::KIMCHI",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xb6baa75577e4bbffba70207651824606e51d38ae23aa94fb9fb700e0ecf50064::kimchi::KIMCHI",
      coin_priority: 600
    }
  },
  {
    name: "AXOL",
    symbol: "AXOL",
    decimals: 9,
    logoURL: "https://p7op7v4f4nub263xmrqch45p32rkeclriobps4v6nrut5g7q464q.arweave.net/f9z_14XjaB17d2RgI_Ov3qKiCXFDgvlyvmxpPpvw57k",
    coinType: "0xae00e078a46616bf6e1e6fb673d18dcd2aa31319a07c9bc92f6063363f597b4e::AXOL::AXOL",
    isVerified: true
  },
  {
    name: "sUSDC",
    symbol: "sUSDC",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/29eNJ7Qu9B5CDy8Gr58TxtR8QWUKPN2XWsVYK9cLr4Zu",
    coinType: "0x854950aa624b1df59fe64e630b2ba7c550642e9342267a33061d59fb31582da5::scallop_usdc::SCALLOP_USDC",
    isVerified: true
  },
  {
    name: "Wrapped Bitcoin by Sui Bridge",
    symbol: "wBTC",
    decimals: 9,
    logoURL: "https://bridge-assets.sui.io/suiWBTC.png",
    coinType: "0xaafb102dd0902f5055cadecd687fb5b71ca82ef0e0285d90afde828ec58ca96b::btc::BTC",
    isVerified: true,
    extensionFields: {
      coin_priority: 889,
      suggested_priority: 880
    }
  },
  {
    name: "Lombard Staked BTC",
    symbol: "LBTC",
    decimals: 8,
    logoURL: "https://www.lombard.finance/lbtc/LBTC.png",
    projectURL: "https://www.lombard.finance/",
    coinType: "0x3e8e9423d80e1774a7ca128fccd8bf5f1f7753be658c5e645929037f7c819040::lbtc::LBTC",
    isVerified: true,
    extensionFields: {
      pyth_id: "8f257aab6e7698bb92b15511915e593d6f8eae914452f781874754b03d0c612b"
    }
  },
  {
    name: "xWSB on SUI",
    symbol: "WSB",
    decimals: 6,
    logoURL: "https://api.movepump.com/uploads/asui_4106b1fb1d.jpg",
    coinType: "0x4db126eac4fa99207e98db61d968477021fdeae153de3b244bcfbdc468ef0722::wsb::WSB",
    isVerified: true
  },
  {
    name: "MOVER USD",
    symbol: "moverUSD",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/moverUSD.png",
    coinType: "0x32d5056aaac1be1f9ae44c1d0728792255a05f1475d458287ee463cc26806ca0::mover_usd::MOVER_USD",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0x32d5056aaac1be1f9ae44c1d0728792255a05f1475d458287ee463cc26806ca0::mover_usd::MOVER_USD",
      coin_priority: 570
    }
  },
  {
    name: "Wrapped BNB (Portal from BSC)",
    symbol: "WBNB",
    decimals: 8,
    logoURL: "https://4hl5riddvifwsfzqzggti3dyrekvhogjvwkaduy5w5bgs2k7zwga.arweave.net/4dfYoGOqC2kXMMmNNGx4iRVTuMmtlAHTHbdCaWlfzYw",
    coinType: "0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f::coin::COIN",
    isVerified: true,
    extensionFields: {
      birdeyeid: "0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f::coin::COIN",
      coin_priority: 700,
      coingecko_id: "binance-coin-wormhole",
      labels: ["Wormhole"],
      pyth_id: "2f95862b045670cd22bee3114c39763a4a08beeb663b145d283c31d7d1101c4f",
      rank: 760
    }
  }
];
function tP(e10, t10) {
  return {
    id: e10.id || void 0,
    logo_url: e10.iconUrl || void 0,
    coin_type: t10,
    decimals: e10.decimals,
    description: e10.description,
    name: e10.name,
    symbol: e10.symbol
  };
}
function cc(e10) {
  var t10;
  return {
    // ...token,
    is_trusted: !!(e10 != null && e10.isVerified) || (e10 == null ? void 0 : e10.is_trusted),
    coin_type: Br((e10 == null ? void 0 : e10.coinType) || (e10 == null ? void 0 : e10.coin_type)).full_address,
    logo_url: (e10 == null ? void 0 : e10.logoURL) || (e10 == null ? void 0 : e10.logo_url) || "",
    decimals: e10 == null ? void 0 : e10.decimals,
    symbol: e10 == null ? void 0 : e10.symbol,
    name: e10 == null ? void 0 : e10.name,
    labels: ((t10 = e10 == null ? void 0 : e10.extensionFields) == null ? void 0 : t10.labels) || (e10 == null ? void 0 : e10.labels)
  };
}
function fo() {
  const { suiClient: e10 } = uo(), { fetchByApi: t10 } = Ql(), {
    setTokenMap: r10,
    tokenMap: n10,
    setToken: i10,
    requestTokenList: o10,
    addRequestTokenList: s10,
    setTrustedTokenList: a10
  } = Wa(), c = async () => {
    var M;
    let y = [];
    try {
      const O = await t10("/v3/sui/clmm/verified_coins_info", "GET");
      if (!(O != null && O.list) || ((M = O == null ? void 0 : O.list) == null ? void 0 : M.length) === 0)
        throw Error("api no trust tokens data");
      y = O == null ? void 0 : O.list;
    } catch {
      y = eP;
    }
    const x = [], b = y == null ? void 0 : y.reduce((O, P) => (O.set(P.coinType || P.coin_type, cc(P)), (P.isVerified || P != null && P.is_trusted) && x.push(cc(P)), O), /* @__PURE__ */ new Map());
    b && (b.get(
      "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
    ) && !b.get("0x2::sui::SUI") ? b.set("0x2::sui::SUI", {
      ...b.get(
        "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
      ),
      coin_type: "0x2::sui::SUI"
    }) : !b.get(
      "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
    ) && b.get("0x2::sui::SUI") && b.set(
      "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",
      {
        ...b.get("0x2::sui::SUI"),
        coin_type: "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
      }
    ), r10(new Map([...n10, ...b])), a10(x));
  }, l10 = async (y) => {
    var O;
    if ((y == null ? void 0 : y.length) === 0)
      return;
    const x = await t10("/v3/sui/clmm/coins_info", "POST", {
      coinTypes: y
    }), b = (O = x == null ? void 0 : x.data) == null ? void 0 : O.list, M = b == null ? void 0 : b.reduce((P, j) => (P.set(j.coinType, cc(j)), P), /* @__PURE__ */ new Map());
    return r10(new Map([...n10, ...M])), M;
  }, u10 = async (y) => {
    var x, b, M, O;
    try {
      if (!y)
        return;
      let P = y;
      y === "0x2::sui::SUI" && (P = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI");
      const j = await t10("/v3/sui/clmm/coins_info", "POST", {
        coinTypes: [P]
      });
      if ((b = (x = j == null ? void 0 : j.data) == null ? void 0 : x.list) != null && b[0]) {
        const F = cc((O = (M = j == null ? void 0 : j.data) == null ? void 0 : M.list) == null ? void 0 : O[0]);
        return i10(F), F;
      }
      throw Error("api no this coin types");
    } catch (P) {
      console.error("🚀 ~ getTokenInfo ~ 57:", P);
    }
  }, d6 = async (y) => {
    try {
      const x = p(y);
      if (x)
        return x;
      if (o10.includes(y))
        return;
      s10(y);
      try {
        const b = await u10(y);
        if (b)
          return b;
        throw Error("api return is null");
      } catch {
        const M = await e10.getCoinMetadata({ coinType: y });
        if (M) {
          lb(y) && (M.iconUrl = "https://archive.cetus.zone/assets/image/sui/sui.png");
          const O = tP(M, y);
          return i10(O), O;
        }
      }
    } catch {
    }
  }, p = (0, import_react25.useCallback)(
    (y) => {
      if (y)
        return n10.get(Br(y).full_address) || n10.get(y);
    },
    [n10]
  );
  return {
    getTrustTokens: c,
    fetchTokenInfo: d6,
    getTokenInfo: p,
    getTokens: l10
  };
}
var Tc = (e10, t10) => {
  if (!(e10 != null && e10.totalBalance) || t10 === void 0 || t10 === null)
    return;
  const r10 = fC(e10.totalBalance, t10 == null ? void 0 : t10.decimals), n10 = Lr(r10, 4);
  return {
    ...t10,
    displayBalance: n10,
    totalBalanceFormat: r10
  };
};
function ol(e10) {
  const { suiClient: t10 } = uo(), { currentAccount: r10, setTokenBalanceObj: n10, tokenBalanceObj: i10 } = Zr();
  fo();
  const [o10, s10] = (0, import_react25.useState)([]), a10 = async (u10 = (r10 == null ? void 0 : r10.address) || "", d6) => {
    try {
      if (!u10) {
        c();
        return;
      }
      let p = [];
      d6 ? p = [await t10.getBalance({
        owner: u10,
        coinType: d6
      })] : p = [...await t10.getAllBalances({
        owner: u10
      })], s10(p);
      const y = {};
      p.forEach((x) => {
        y[Br(x.coinType).full_address] = x;
      }), n10(y);
    } catch {
      s10([]);
    }
  }, c = () => {
    n10({});
  }, l10 = (0, import_react25.useMemo)(() => {
    const u10 = e10 == null ? void 0 : e10.coin_type;
    if (u10 && r10) {
      const d6 = i10[u10] || i10[Br(u10).full_address];
      return d6 ? Tc(d6, e10) : void 0;
    }
  }, [e10 == null ? void 0 : e10.coin_type, i10, r10]);
  return {
    getOwnerCoinBalances: a10,
    balanceInfo: l10
  };
}
var rP = {
  id: "0x9258181f5ceac8dbffb7030890243caed69a9599d2886d957a9cb7656af3bdb3",
  coin_type: "0x2::sui::SUI",
  decimals: 9,
  description: "",
  name: "Sui",
  symbol: "SUI",
  logo_url: "https://imagedelivery.net/cBNDGgkrsEA-b_ixIp9SkQ/sui-coin.svg/public",
  is_trusted: true,
  extensions: {
    rank: "880"
  }
};
var nP = {
  id: "0x69b7a7c3c200439c1b5f3b19d7d495d5966d5f08de66c69276152f8db3992ec6",
  coin_type: "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
  decimals: 6,
  description: "",
  name: "USDC",
  symbol: "USDC",
  logo_url: "https://circle.com/usdc-icon",
  is_trusted: true,
  extensions: {
    rank: "1000"
  }
};
var gw = nP;
var vw = rP;
function iP(e10, t10) {
  const { fetchTokenInfo: r10 } = fo(), { setFromCoin: n10, setToCoin: i10, setDefaultCoin: o10 } = an(), { setSlippage: s10, setRpcList: a10, setCurrentRpc: c } = Hr(), { tokenMapIsInit: l10 } = Wa(), u10 = (0, import_react25.useRef)({}), d6 = async (y, x) => {
    const b = y ? await r10(y) : gw, M = x ? await r10(x) : vw;
    n10(b), i10(M), o10(b == null ? void 0 : b.coin_type, M == null ? void 0 : M.coin_type);
  }, p = (y, x) => {
    const b = [Yc[0]];
    let M = Yc[0];
    y.forEach((O) => {
      const P = {
        name: O,
        link: O,
        isCustom: false
      };
      b.push(P), O === x && (M = P);
    }), a10([
      ...b,
      {
        name: "Custom RPC URL",
        link: "",
        isCustom: true
      }
    ]), c(M);
  };
  return (0, import_react25.useEffect)(() => {
    if (l10 && !p0(e10, u10.current)) {
      const {
        defaultFromToken: y,
        defaultToToken: x,
        defaultSlippage: b,
        customRpcList: M,
        defaultRpc: O
      } = e10;
      d6(y, x), b && s10(b), (M == null ? void 0 : M.length) > 0 && p(M, O), u10.current = e10;
    }
  }, [e10, l10]), {
    handleSetDefaultPair: d6
  };
}
function oP() {
  const { currentRpc: e10 } = Hr(), { setSuiClient: t10, setAggregatorSDK: r10 } = uo(), { currentAccount: n10 } = Zr();
  (0, import_react25.useEffect)(() => {
    if (e10) {
      const i10 = new bs({ url: e10.link });
      t10(i10);
    }
  }, [e10]), (0, import_react25.useEffect)(() => {
    if (e10) {
      const i10 = new sb({
        endpoint: hs.aggregatorUrl,
        signer: (n10 == null ? void 0 : n10.address) || "",
        client: new bs({ url: e10.link }),
        env: d0.Mainnet
      });
      r10(i10);
    }
  }, [e10.link, n10 == null ? void 0 : n10.address]);
}
var W0 = ki((e10, t10) => ({
  transactionData: void 0,
  setTransactionData: (r10) => {
    e10(() => ({
      transactionData: r10
    }));
  }
}));
var Mr = [];
for (let e10 = 0; e10 < 256; ++e10)
  Mr.push((e10 + 256).toString(16).slice(1));
function sP(e10, t10 = 0) {
  return (Mr[e10[t10 + 0]] + Mr[e10[t10 + 1]] + Mr[e10[t10 + 2]] + Mr[e10[t10 + 3]] + "-" + Mr[e10[t10 + 4]] + Mr[e10[t10 + 5]] + "-" + Mr[e10[t10 + 6]] + Mr[e10[t10 + 7]] + "-" + Mr[e10[t10 + 8]] + Mr[e10[t10 + 9]] + "-" + Mr[e10[t10 + 10]] + Mr[e10[t10 + 11]] + Mr[e10[t10 + 12]] + Mr[e10[t10 + 13]] + Mr[e10[t10 + 14]] + Mr[e10[t10 + 15]]).toLowerCase();
}
var sf;
var aP = new Uint8Array(16);
function cP() {
  if (!sf) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    sf = crypto.getRandomValues.bind(crypto);
  }
  return sf(aP);
}
var lP = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var Jp = { randomUUID: lP };
function Zp(e10, t10, r10) {
  var i10;
  if (Jp.randomUUID && !t10 && !e10)
    return Jp.randomUUID();
  e10 = e10 || {};
  const n10 = e10.random ?? ((i10 = e10.rng) == null ? void 0 : i10.call(e10)) ?? cP();
  if (n10.length < 16)
    throw new Error("Random bytes length must be >= 16");
  if (n10[6] = n10[6] & 15 | 64, n10[8] = n10[8] & 63 | 128, t10) {
    if (r10 = r10 || 0, r10 < 0 || r10 + 16 > t10.length)
      throw new RangeError(`UUID byte range ${r10}:${r10 + 15} is out of buffer bounds`);
    for (let o10 = 0; o10 < 16; ++o10)
      t10[r10 + o10] = n10[o10];
    return t10;
  }
  return sP(n10);
}
var Po = ((e10) => (e10[e10.CalculateError = 1e4] = "CalculateError", e10[e10.NumberTooLarge = 10001] = "NumberTooLarge", e10[e10.NoRouter = 10002] = "NoRouter", e10[e10.InsufficientLiquidity = 10003] = "InsufficientLiquidity", e10[e10.HoneyPot = 10004] = "HoneyPot", e10))(Po || {});
var uP = new bs({
  url: og("mainnet")
});
var fP = [
  "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
  // Circle Native USDC
  "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2::ausd::AUSD",
  // Agora USD
  "0xf16e6b723f242ec745dfd7634ad072c42d5c1d9ac9d62a39c381303eaa57693a::fdusd::FDUSD",
  // FDUSD
  "0x960b531667636f39e85867775f52f6b1f220a058c4de786905bdf761e06a56bb::usdy::USDY",
  // Ondo USDY
  "0x294de7579d55c110a00a7c4946e09a1b5cbeca2592fbb83fd7bfacba3cfeaf0e::drf::DRF"
  // DRF
];
var dP = ["deny_list", "DenyList", "DenyCap", "create_regulated_currency"];
var hP = {
  showType: true,
  showContent: true,
  showOwner: false,
  showPreviousTransaction: false,
  showStorageRebate: false,
  showDisplay: false
};
var pP = async (e10) => {
  let t10 = false;
  if (fP.includes(e10))
    return t10;
  const r10 = e10.split("::"), n10 = r10[0] && Ft(r10[0]), i10 = r10[1], o10 = await uP.getObject({ id: n10, options: hP }), s10 = "disassembled" in o10.data.content ? o10.data.content.disassembled[i10] : null;
  return s10 && typeof s10 == "string" && new RegExp(dP.join("|"), "i").test(s10) && (t10 = true), t10;
};
var mP = (e10) => {
  var n10;
  if (!e10)
    return "";
  const t10 = e10 == null ? void 0 : e10.split(",");
  return (n10 = t10 == null ? void 0 : t10.map((i10) => Oi(i10, false))) == null ? void 0 : n10.join(",");
};
function gP() {
  const { fetchByApi: e10 } = Ql(), t10 = async (n10) => {
    try {
      const i10 = { ...n10 }, o10 = mP(n10 == null ? void 0 : n10.coin_type);
      o10 && (i10.coin_type = o10);
      const s10 = await e10("/v2/sui/stats_pools", "GET", i10);
      if (s10 != null && s10.lp_list)
        return {
          list: (s10 == null ? void 0 : s10.lp_list) || [],
          total: s10 == null ? void 0 : s10.total
        };
    } catch (i10) {
      return console.error("getPoolList ~ Error:", i10), await r10(n10);
    }
    return {
      list: [],
      total: 0
    };
  }, r10 = async (n10) => {
    var i10, o10, s10, a10;
    try {
      const c = At("/data/pools.json"), l10 = await fetch(c).then((u10) => u10.json());
      if ((i10 = l10 == null ? void 0 : l10.data) != null && i10.lp_list) {
        const u10 = (o10 = l10 == null ? void 0 : l10.data) == null ? void 0 : o10.lp_list;
        let d6 = u10;
        if (n10 != null && n10.coin_type) {
          const y = (a10 = (s10 = n10 == null ? void 0 : n10.coin_type) == null ? void 0 : s10.split(",")) == null ? void 0 : a10.map((x) => jn(x).source_address);
          d6 = u10 == null ? void 0 : u10.filter((x) => {
            var O, P;
            const b = jn(
              (O = x == null ? void 0 : x.coin_a) == null ? void 0 : O.address
            ).source_address, M = jn(
              (P = x == null ? void 0 : x.coin_b) == null ? void 0 : P.address
            ).source_address;
            return (y == null ? void 0 : y.length) > 1 && y.includes(b) && y.includes(M) ? true : !!((y == null ? void 0 : y.length) === 1 && (y.includes(b) || y.includes(M)));
          });
        }
        n10 != null && n10.is_vaults && (d6 = u10 == null ? void 0 : u10.filter((y) => y == null ? void 0 : y.is_vaults)), n10 != null && n10.has_farming && !(n10 != null && n10.is_vaults) && !(n10 != null && n10.has_mining) && !(n10 != null && n10.no_incentives) && (d6 = u10 == null ? void 0 : u10.filter((y) => y == null ? void 0 : y.has_farming));
        const p = d6;
        return {
          list: p,
          total: (p == null ? void 0 : p.length) || 0
        };
      }
    } catch (c) {
      console.error("getLocalJsonPoolList Error:", c);
    }
    return {
      list: [],
      total: 0
    };
  };
  return {
    getPoolList: t10,
    getLocalJsonPoolList: r10
  };
}
function vP(e10 = true) {
  const { poolApiMap: t10, setPoolApiMap: r10 } = Hr(), { getPoolList: n10, getLocalJsonPoolList: i10 } = gP();
  return {
    getPoolListByCoinType: async (s10, a10) => {
      if (s10 && a10) {
        const c = [s10, a10].sort(), l10 = `${c[0]}_${c[1]}`, u10 = t10[l10];
        if (u10)
          return u10;
        const d6 = {
          coin_type: `${s10},${a10}`,
          display_all_pools: true,
          offset: 0,
          limit: 100,
          order_by: "-tvl",
          no_incentives: true,
          has_farming: true,
          has_mining: true
        };
        let p = e10 ? await i10(d6) : void 0;
        (p === void 0 || p.list.length === 0) && (p = await n10(d6));
        const y = p.list;
        if (y.length > 0)
          return t10[l10] = y, r10(l10, y), y;
      }
      return [];
    }
  };
}
function bP(e10) {
  const { routerData: t10 } = an();
  return { priceAcceptRouterData: (0, import_react25.useMemo)(() => {
    if (t10 && e10) {
      if (e10.byAmountIn) {
        if (!Le(e10.toAmountUi).eq(t10.toAmountUi || "0"))
          return t10;
      } else if (!Le(e10.fromAmountUi).eq(t10.fromAmountUi || "0"))
        return t10;
      return;
    }
  }, [t10, e10]) };
}
function bw(e10, t10) {
  return { amountLimit: (0, import_react25.useMemo)(() => {
    if (t10 && t10.routerData) {
      const { byAmountIn: n10, fromAmountUi: i10, toAmountUi: o10 } = t10;
      return n10 ? Le(o10).mul(Le(1).sub(Le(e10).div(100))).toString() : Le(i10).mul(Le(1).add(Le(e10).div(100))).toString();
    }
  }, [e10, t10]) };
}
function yP(e10) {
  const { getTokenInfo: t10, fetchTokenInfo: r10 } = fo();
  return { formatSwapRouter: (0, import_react25.useMemo)(() => {
    if (e10 && e10.routerData) {
      const i10 = [], o10 = e10.byAmountIn ? e10.routerData.amountIn.toString() : e10.routerData.amountOut.toString(), s10 = [], a10 = [];
      let c = Le(0);
      if (e10.routerData.routes.forEach((u10, d6) => {
        const p = {}, y = e10.byAmountIn ? u10.amountIn.toString() : u10.amountOut.toString();
        d6 === e10.routerData.routes.length - 1 ? p.percentage = Le(1).sub(c).toFixed(2) : p.percentage = Le(y).div(o10).toFixed(2), c = Le(c).add(p.percentage);
        const x = [];
        u10.path.forEach((b) => {
          i10.includes(b.provider) || i10.push(b.provider);
          const M = Br(b.from).full_address, O = Br(b.target).full_address, P = t10(M), j = t10(O);
          P || a10.includes(M) && a10.push(M), j || a10.includes(O) && a10.push(O);
          const F = b.provider === ua.SCALLOP || b.provider === ua.FLOWX || b.provider === ua.FLOWXV3;
          x.push({
            from_type: M,
            to_type: O,
            pool_address: F ? "" : b.id,
            fee_rate: b.feeRate,
            provider: b.provider
          });
        }), p.paths = x, s10.push(p);
      }), a10.length > 0)
        for (const u10 in a10)
          r10(u10);
      return {
        router_summery: `${e10.routerData.routes.length} Streams`,
        providers: i10,
        routers: s10
      };
    }
  }, [e10]) };
}
function wP() {
  const { fromCoin: e10, toCoin: t10 } = an(), { getPoolListByCoinType: r10 } = vP();
  return {
    getSwapPoolAddress: async () => e10 && t10 ? (await r10(
      e10.coin_type,
      t10.coin_type
    )).map((s10) => s10.address) : []
  };
}
function yw(e10, t10, r10) {
  return (0, import_react25.useMemo)(() => t10 && r10 && +t10 && +r10 ? e10 ? Le(r10).div(t10).toString() : Le(t10).div(r10).toString() : "0", [t10, r10, e10]);
}
function Qp(e10) {
  const [t10, r10] = (0, import_react25.useState)(), n10 = async (i10) => {
    if (i10.is_trusted)
      return false;
    try {
      return await pP(i10.coin_type);
    } catch {
    }
    return false;
  };
  return (0, import_react25.useEffect)(() => {
    r10(void 0), e10 && n10(e10).then((i10) => {
      r10(i10);
    });
  }, [e10 == null ? void 0 : e10.coin_type]), {
    isScamsCoin: t10
  };
}
function xP(e10, t10) {
  const { defaultFromCoinType: r10, defaultToCoinCoinType: n10 } = an(), { getTokenInfo: i10 } = fo(), { ignoreWarnTokenMap: o10 } = Hr(), s10 = i10(e10), a10 = i10(t10), c = (0, import_react25.useMemo)(() => !Qa(r10, gw.coin_type) || !Qa(n10, vw.coin_type), [r10, n10]), l10 = (0, import_react25.useCallback)(
    (d6) => d6 && !o10[Oi(d6.coin_type)] && (Qa(r10, d6.coin_type) || Qa(n10, d6.coin_type)) ? !d6.is_trusted : false,
    [r10, n10, o10]
  ), u10 = (0, import_react25.useMemo)(() => {
    const d6 = [];
    return c && (s10 && l10(s10) && d6.push({ ...s10 }), a10 && l10(a10) && d6.push({ ...a10 })), d6;
  }, [
    s10 == null ? void 0 : s10.coin_type,
    a10 == null ? void 0 : a10.coin_type,
    c,
    o10
  ]);
  return {
    isCustomMode: c,
    customWarnTokenList: u10
  };
}
function SP() {
  const { aggregatorSDK: e10 } = uo(), { getSwapPoolAddress: t10 } = wP(), r10 = (o10) => o10 && o10.error ? o10.error.code === Po.InsufficientLiquidity || Po.HoneyPot || Po.NumberTooLarge : false, n10 = async (o10) => {
    const { fromToken: s10, toToken: a10, amount: c, providersKeys: l10, by_amount_in: u10, uuid: d6 } = o10;
    try {
      const p = {
        from: s10.coin_type,
        target: a10.coin_type,
        amount: new Th(c),
        byAmountIn: u10,
        depth: 3,
        splitAlgorithm: void 0,
        splitFactor: void 0,
        splitCount: void 0,
        providers: l10
      }, y = await e10.findRouters(p);
      if (y && r10(y))
        return i10(
          false,
          u10,
          d6,
          s10,
          a10,
          y
        );
      if (!y || y.routes.length === 0)
        throw Error("not find router");
      return i10(
        false,
        u10,
        d6,
        s10,
        a10,
        y
      );
    } catch {
      const y = await t10(), x = {
        from: s10.coin_type,
        target: a10.coin_type,
        amount: new Th(c),
        byAmountIn: u10,
        pools: y
      };
      try {
        const b = await e10.swapInPools(x);
        return !b || !b.routeData ? i10(true, u10, d6, s10, a10) : i10(
          true,
          u10,
          d6,
          s10,
          a10,
          b.routeData
        );
      } catch {
        return {
          uuid: d6,
          byAmountIn: u10,
          isDegrade: true
        };
      }
    }
  }, i10 = (o10, s10, a10, c, l10, u10) => {
    var d6;
    if (u10) {
      const p = u10.error !== void 0, y = Yf(
        u10.amountIn.toString(),
        c.decimals
      ).toString(), x = Yf(
        u10.amountOut.toString(),
        l10.decimals
      ).toString();
      return {
        routerData: p ? void 0 : u10,
        fromAmountUi: p ? s10 ? y : "" : y,
        toAmountUi: p && s10 ? "" : x,
        uuid: a10,
        byAmountIn: s10,
        isDegrade: o10,
        errorCode: (d6 = u10.error) == null ? void 0 : d6.code
      };
    } else
      return {
        uuid: a10,
        byAmountIn: s10,
        isDegrade: o10
      };
  };
  return {
    findBestRouters: n10
  };
}
function rs(e10) {
  const t10 = (0, import_react25.useRef)(e10);
  return (0, import_react25.useEffect)(() => {
    t10.current = e10;
  }, [e10]), t10;
}
function _P(e10) {
  try {
    return e10 && e10.toString().includes("Rejected from user");
  } catch {
    return false;
  }
}
function EP(e10) {
  const t10 = String(e10);
  return t10.indexOf("withdraw_with_proof") > -1 || t10.indexOf("check_coin_threshold") > -1 || t10.indexOf('Identifier("balance")') > -1;
}
function CP(e10) {
  return !!String(e10).includes("Could not find the referenced transaction");
}
function TP(e10) {
  return _P(e10) ? "User rejected the request" : EP(e10) ? "Exceeded price slippage" : CP(e10) ? "Oops. Failed to sync data from your txid. Please check your txn status from explorer or from your wallet." : "Transaction failed";
}
var G0 = {};
var AP = Rr && Rr.__importDefault || function(e10) {
  return e10 && e10.__esModule ? e10 : { default: e10 };
};
Object.defineProperty(G0, "__esModule", { value: true });
var MP = G0.executeAuction = ww;
var IP = AP(F1);
var OP = "https://rpc.getshio.com";
var RP = 500;
var PP = 300;
function ww(e10, t10, r10 = RP) {
  const n10 = {
    jsonrpc: "2.0",
    method: "shio_executeAuction",
    params: [e10, t10],
    id: 1
  };
  return new Promise((i10, o10) => {
    setTimeout(i10, r10), IP.default.post(OP, n10, {
      headers: {
        "Content-Type": "application/json"
      },
      timeout: r10
    }).then((s10) => {
      setTimeout(i10, PP);
    }).catch(o10);
  });
}
G0.default = { executeAuction: ww };
function NP() {
  const { suiClient: e10 } = uo(), { currentAccount: t10 } = Zr(), { mutateAsync: r10 } = useSignTransaction(), { mutate: n10 } = useSignAndExecuteTransaction({
    execute: async ({ bytes: c, signature: l10 }) => await o10(c, l10)
  }), i10 = (0, import_react25.useMemo)(() => t10 == null ? void 0 : t10.chains[0], [t10]), o10 = async (c, l10, u10 = false) => {
    var p, y;
    if (u10) {
      const x = await e10.devInspectTransactionBlock({
        transactionBlock: Oo.from(Cr(c)),
        sender: t10.address
      });
      if (!x || ((p = x.effects) == null ? void 0 : p.status.status) === "failure")
        throw Error((y = x.effects) == null ? void 0 : y.status.error);
    }
    return await e10.executeTransactionBlock({
      transactionBlock: c,
      signature: l10,
      options: {
        showEvents: true,
        showRawEffects: true,
        showEffects: true,
        showBalanceChanges: true,
        showObjectChanges: true,
        showInput: true
      }
    });
  };
  return {
    signAndExecuteTransactionBlock: async (c, l10 = false) => {
      var d6, p;
      let u10;
      if (typeof c == "string" ? u10 = Oo.from(c) : u10 = c, l10) {
        const y = await e10.devInspectTransactionBlock({
          transactionBlock: c,
          sender: t10.address
        });
        if (!y || ((d6 = y.effects) == null ? void 0 : d6.status.status) === "failure")
          throw Error((p = y.effects) == null ? void 0 : p.status.error);
      }
      return u10.setGasBudget(1e8), new Promise((y, x) => {
        n10(
          {
            transaction: u10,
            chain: i10
          },
          {
            onSuccess: (b) => {
              y(b);
            },
            onError: (b) => {
              console.error(
                "signAndExecuteTransactionBlock transaction failed",
                b
              ), x(b);
            }
          }
        );
      });
    },
    signTransactionBlock: async (c) => (c instanceof Uint8Array && (c = Oo.from(c)), typeof c == "string" && (c = Oo.from(Cr(c))), new Promise((l10, u10) => {
      r10(
        {
          transaction: c,
          chain: i10
        },
        {
          onSuccess: (d6) => {
            l10(d6);
          },
          onError: (d6) => {
            console.error("signTransactionBlock failed", d6), u10(d6);
          },
          onSettled: (d6, p, y, x) => {
            console.error("signTransactionBlock onSettled", {
              data: d6,
              error: p,
              variables: y
            });
          }
        }
      );
    })),
    executeTransactionBlock: o10
  };
}
function jP() {
  const {
    signTransactionBlock: e10,
    executeTransactionBlock: t10,
    signAndExecuteTransactionBlock: r10
  } = NP(), { currentAccount: n10 } = Zr(), { suiClient: i10 } = uo(), { setTransactionData: o10 } = W0(), { addTxToast: s10, removeToast: a10 } = Bs(), c = 5, l10 = 2e3;
  async function u10(y, x = 1) {
    try {
      let b;
      try {
        b = await i10.getTransactionBlock({
          digest: y,
          options: {
            showEvents: true,
            showEffects: true,
            showBalanceChanges: true,
            showInput: true,
            showRawInput: true,
            showObjectChanges: true
          }
        });
      } catch {
        b = await i10.getTransactionBlock({
          digest: y,
          options: {
            showEvents: true,
            showEffects: true
          }
        });
      }
      if (b)
        return b;
      throw new Error("Empty response");
    } catch (b) {
      if (console.error(`Attempt ${x} failed:`, b), x >= c)
        throw new Error(
          "Failed to fetch transaction status after maximum retries."
        );
      return await bp(l10), u10(y, x + 1);
    }
  }
  const d6 = async (y, x, b = {
    useDevInspect: false,
    useMev: false,
    txAction: "signTransactionBlock"
  }) => {
    var F, B;
    const {
      useDevInspect: M = false,
      useMev: O,
      txAction: P = "signTransactionBlock"
    } = b;
    let j;
    x.status = "confirmation", o10(x);
    try {
      let W;
      if (P === "signTransactionBlock") {
        const G = await e10(y), { bytes: re, signature: ie } = G;
        if (O)
          try {
            const oe = await MP(re, ie, 500);
          } catch {
          }
        W = await t10(
          re,
          ie,
          M
        );
      } else
        W = await r10(y, M);
      x.status = "submitted", o10({ ...x }), x.tx = W.digest, j = s10(x), await bp(l10);
      const z = await u10(W.digest, 0);
      if (!z || ((F = z.effects) == null ? void 0 : F.status.status) === "failure")
        p(x, (B = z.effects) == null ? void 0 : B.status.error);
      else {
        const G = gC(
          z,
          n10 == null ? void 0 : n10.address,
          false
        );
        if (x.buildShowInfo) {
          const re = x.buildShowInfo("success", G);
          x.buildShowInfo = (ie) => re;
        }
        a10(j), x.status = "success", o10({ ...x });
      }
      return z;
    } catch (W) {
      p(x, W);
    }
  }, p = (y, x) => {
    const b = TP(x);
    if (y.buildShowInfo) {
      const M = y.buildShowInfo("confirmation");
      y.buildShowInfo = (O) => (M.toastDescriptionContent = b, M.modalDescriptionText = b, M), y.status = "rejected", o10({ ...y });
    } else
      y.buildShowInfo = (M) => {
        const O = {};
        return O.toastDescriptionContent = b, O.modalDescriptionText = b, O;
      }, y.status = "rejected", o10({ ...y });
  };
  return {
    signAndExecuteTransaction: d6
  };
}
function K0(e10, t10 = 1e3) {
  const r10 = (0, import_react25.useRef)(), n10 = (0, import_react25.useCallback)(
    (...i10) => {
      r10.current && clearTimeout(r10.current), r10.current = setTimeout(() => {
        e10(...i10);
      }, t10);
    },
    [e10, t10]
  );
  return (0, import_react25.useEffect)(() => () => {
    r10.current && clearTimeout(r10.current);
  }, []), n10;
}
function kP() {
  const { aggregatorSDK: e10 } = uo(), { findBestRouters: t10 } = SP(), { getTokenAmountValue: r10, fetchTokenPrices: n10 } = Ha(), { providers: i10, slippage: o10, mevProtect: s10 } = Hr(), { signAndExecuteTransaction: a10 } = jP(), { setTransactionData: c } = W0(), { addTxToast: l10 } = Bs(), {
    fromCoin: u10,
    toCoin: d6,
    setFromCoin: p,
    setToCoin: y,
    setToAmount: x,
    fromAmount: b,
    toAmount: M,
    setFromAmount: O,
    setFindRouterLoading: P,
    setRouterData: j,
    setByAmountIn: F,
    byAmountIn: B
  } = an(), [W, z] = (0, import_react25.useState)(""), G = rs(W), re = rs(B), ie = rs(b), oe = rs(M), q = rs(u10), L = rs(d6), { balanceInfo: h, getOwnerCoinBalances: f } = ol(u10), { balanceInfo: m } = ol(d6), S = r10(u10 == null ? void 0 : u10.coin_type, b), T = r10(d6 == null ? void 0 : d6.coin_type, M), I = K0(async (he, De, Te) => {
    if (q.current && L.current && +he) {
      (+ie.current || +oe.current) && P(true);
      const Xe = hC(
        he,
        De ? q.current.decimals : L.current.decimals
      ), ft = await t10({
        fromToken: q.current,
        toToken: L.current,
        amount: Xe.toString(),
        providersKeys: i10,
        by_amount_in: De,
        uuid: Te
      });
      P(false), G.current === Te && (De ? +ie.current ? (x(ft.toAmountUi || ""), j(ft)) : x("") : +oe.current ? (O(ft.fromAmountUi || "ß"), j(ft)) : O(""));
    } else
      v10(!De);
  }, 500), C = (he, De, Te = false) => {
    if (F(De), De ? (O(he), Te && x("")) : (x(he), Te && O("")), +he) {
      const Xe = Zp();
      z(Xe), I(he, De, Xe);
    } else
      P(false), j(void 0), v10(!De);
  }, g = (he, De = true) => {
    v10(), De ? ((he == null ? void 0 : he.coin_type) === (d6 == null ? void 0 : d6.coin_type) && y(u10), p(he)) : ((he == null ? void 0 : he.coin_type) === (u10 == null ? void 0 : u10.coin_type) && p(d6), y(he));
  }, v10 = (he) => {
    he === void 0 ? (O(""), x("")) : he ? O("") : x(""), P(false), j(void 0);
  }, k = () => {
    const he = re.current ? ie.current : oe.current;
    if (+he) {
      const De = Zp();
      z(De), I(he, re.current, De);
    }
  }, Q = async (he, De) => {
    const { routerData: Te, byAmountIn: Xe, fromAmountUi: ft, toAmountUi: je } = he, ht = new Oo(), ye = {
      routers: Te,
      slippage: Number(o10) / 100,
      txb: ht,
      partner: De || EC
    };
    try {
      await e10.fastRouterSwap(ye);
      const de = {
        status: "confirmation",
        buildShowInfo: ($e, Ne) => {
          const Ce = `Swap ${Lr(ft, u10 == null ? void 0 : u10.decimals)} ${u10 == null ? void 0 : u10.symbol} for ${Lr(je, d6 == null ? void 0 : d6.decimals)} ${d6 == null ? void 0 : d6.symbol}`, Ae = {
            modalDescriptionText: Ce,
            toastTitleText: Ce
          };
          if ($e === "success") {
            let Be = ft, lt = je;
            Ne && (Be = yp(Ne, u10) || ft, lt = yp(Ne, d6) || je);
            const ut = `Swapped ${Lr(Be, u10 == null ? void 0 : u10.decimals)} ${u10 == null ? void 0 : u10.symbol} for ${Lr(lt, d6 == null ? void 0 : d6.decimals)} ${d6 == null ? void 0 : d6.symbol}`;
            Ae.toastTitleText = ut, Ae.modalDescriptionText = ut;
          }
          return Ae;
        },
        id: 0
      };
      c(de), await a10(ht, de, {
        useMev: s10
      }) ? (v10(), f()) : k();
    } catch (de) {
      String(de).includes("TypeError: Failed to fetch") && l10({
        id: 0,
        status: "rejected",
        buildShowInfo(Ee, $e) {
          return {
            toastTitleText: "RPC loading failed",
            toastDescriptionContent: "Try resubmission. Or to check your network and switch an RPC in settings to try again."
          };
        }
      });
    }
  };
  (0, import_react25.useEffect)(() => {
    Z(), v10();
  }, [u10 == null ? void 0 : u10.coin_type, d6 == null ? void 0 : d6.coin_type]);
  const Z = () => {
    const he = [];
    u10 && he.push(u10.coin_type), d6 && he.push(d6.coin_type), he.length > 0 && n10(he);
  }, { isScamsCoin: ae } = Qp(u10), { isScamsCoin: ve } = Qp(d6), we = (0, import_react25.useMemo)(() => {
    if (!(!ae && !ve)) {
      if (ae && ve)
        return `${u10 == null ? void 0 : u10.symbol} and ${d6 == null ? void 0 : d6.symbol} are`;
      if (ae)
        return `${u10 == null ? void 0 : u10.symbol} token is `;
      if (ve)
        return `${d6 == null ? void 0 : d6.symbol} token is `;
    }
  }, [ae, ve]);
  return {
    handleAmountChange: C,
    handleSelectToken: g,
    fromBalanceInfo: h,
    toBalanceInfo: m,
    fromAmountValue: S,
    toAmountValue: T,
    doSwapAction: Q,
    reCalculateRouteData: k,
    refreshMarketPrice: Z,
    scamsText: we
  };
}
function DP(e10) {
  const { fromCoin: t10, toCoin: r10, fromAmount: n10, toAmount: i10, routerData: o10 } = an(), { currentAccount: s10 } = Zr(), a10 = (0, import_react25.useMemo)(() => {
    const c = {
      text: "Swap",
      disabled: false
    };
    if (!(s10 != null && s10.address))
      return c.text = "Connect Wallet", c.disabled = false, c;
    if (!t10 || !r10)
      return c.text = "Select a token", c.disabled = true, c;
    if (!+n10 && !+i10)
      return c.text = "Enter an amount", c.disabled = true, c;
    if (o10 && o10.errorCode) {
      if (o10.errorCode === Po.InsufficientLiquidity)
        return c.text = "Insufficient liquidity for this trade", c.disabled = true, c;
      if (o10.errorCode === Po.NoRouter || o10.errorCode === Po.HoneyPot)
        return c.text = "No Available Route", c.disabled = true, c;
    }
    return +n10 && Le(n10).gt(e10 || 0) ? (c.disabled = true, c.text = `Insufficient ${mn(t10 == null ? void 0 : t10.symbol)} Balance`, c) : ((!+n10 || !+i10) && (c.disabled = true), c);
  }, [
    s10 == null ? void 0 : s10.address,
    n10,
    i10,
    e10,
    o10 == null ? void 0 : o10.errorCode,
    t10,
    r10
  ]);
  return {
    btnText: a10.text,
    btnDisabled: a10.disabled
  };
}
function xw({
  size: e10 = "24px",
  strokeWidth: t10 = "10",
  color: r10 = "#909ca4",
  emptyColor: n10 = "transparent",
  gapPercentage: i10 = 0.5
  // 缺口占比
}) {
  const o10 = 50 - parseFloat(t10), s10 = 2 * Math.PI * o10, a10 = s10 * i10, c = s10 - a10;
  return w.jsxs("svg", { width: e10, height: e10, viewBox: "0 0 100 100", children: [
    w.jsx(
      "circle",
      {
        cx: "50",
        cy: "50",
        r: o10,
        fill: "none",
        stroke: n10,
        strokeWidth: t10
      }
    ),
    w.jsx(
      "circle",
      {
        cx: "50",
        cy: "50",
        r: o10,
        fill: "none",
        stroke: r10,
        strokeWidth: t10,
        strokeDasharray: `${c} ${a10}`,
        strokeDashoffset: "0",
        strokeLinecap: "round",
        style: {
          animation: "dash 0.5s linear infinite"
          // 动画：填充部分滑动
        }
      }
    ),
    w.jsx("style", { children: `
          @keyframes dash {
            0% {
              stroke-dashoffset: 0;
            }
            100% {
              stroke-dashoffset: -${s10};
            }
          }
        ` })
  ] });
}
function Y0({
  baseToken: e10,
  quoteToken: t10,
  baseAmount: r10,
  quoteAmount: n10,
  loading: i10
}) {
  const [o10, s10] = (0, import_react25.useState)(true), a10 = yw(o10, r10, n10);
  return w.jsxs(
    "div",
    {
      className: "current-price-block",
      style: {
        cursor: "pointer"
      },
      onClick: () => {
        s10(!o10);
      },
      children: [
        w.jsx(Xr, { src: o10 ? e10 == null ? void 0 : e10.logo_url : t10 == null ? void 0 : t10.logo_url }),
        w.jsxs(
          "span",
          {
            style: {
              display: "flex",
              alignItems: "center",
              color: "var(--cs-text-title)",
              fontSize: "12px",
              maxWidth: "80%"
            },
            children: [
              "1",
              " ",
              mn(o10 ? e10 == null ? void 0 : e10.symbol : t10 == null ? void 0 : t10.symbol),
              " ",
              "=",
              " ",
              i10 ? w.jsx(
                Ls,
                {
                  style: {
                    height: "16px",
                    width: "40px",
                    marginLeft: "2px",
                    marginRight: "2px"
                  }
                }
              ) : Lr(a10, t10 == null ? void 0 : t10.decimals),
              " ",
              mn(o10 ? t10 == null ? void 0 : t10.symbol : e10 == null ? void 0 : e10.symbol)
            ]
          }
        ),
        w.jsx(Xr, { src: o10 ? t10 == null ? void 0 : t10.logo_url : e10 == null ? void 0 : e10.logo_url }),
        w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-swap" }) })
      ]
    }
  );
}
function eu() {
  const [e10, t10] = (0, import_react25.useState)(window.innerWidth), r10 = K0(() => {
    t10(window.innerWidth);
  }, 300);
  (0, import_react25.useEffect)(() => (window.addEventListener("resize", r10), () => {
    window.removeEventListener("resize", r10);
  }), []);
  const n10 = (0, import_react25.useMemo)(() => e10 < 810, [e10]);
  return { windowWidth: e10, isApp: n10 };
}
function Sw(e10, t10, r10, n10) {
  const { getTokenPrice: i10 } = Ha(), o10 = i10(e10 == null ? void 0 : e10.coin_type), s10 = i10(t10 == null ? void 0 : t10.coin_type), a10 = yw(true, r10, n10), c = (0, import_react25.useMemo)(() => {
    if (s10 && o10)
      return Le(o10.price).div(s10.price).toString();
  }, [o10 == null ? void 0 : o10.price, s10 == null ? void 0 : s10.price]), l10 = (0, import_react25.useMemo)(() => {
    if (c && +a10)
      return Le(a10).sub(c).div(a10).mul(100).toFixed(10);
  }, [c, a10]), u10 = (0, import_react25.useMemo)(() => {
    const b = [];
    return o10 && b.push(o10.market), s10 && !b.includes(s10.market) && b.push(s10.market), b;
  }, [o10 == null ? void 0 : o10.market, s10 == null ? void 0 : s10.market]), d6 = (0, import_react25.useMemo)(() => l10 && Le(l10).lt(0) ? Le(l10).abs().gt(5) : false, [l10]), p = (0, import_react25.useMemo)(() => l10 && Le(l10).lt(0) ? Le(l10).abs().gt(10) : false, [l10]), y = (0, import_react25.useMemo)(() => {
    let b, M = "yellow";
    if (l10)
      if (Le(l10).gt(0))
        M = "green", Le(l10).lt(0.1) ? b = "< 0.1% cheaper than" : b = `${Lr(l10, 2, true, qr.ROUND_UP)}% cheaper than`;
      else if (Le(l10).eq(0))
        b = "0%", M = "green";
      else {
        const O = Le(l10).abs();
        O.lte(5) ? (M = "green", b = `Within ${Lr(O.toString(), 2, true, qr.ROUND_UP)}%`) : O.lte(10) ? (M = "yellow", b = `${Lr(O.toString(), 2, true, qr.ROUND_UP)}% more than`) : O.lte(100) ? (M = "red", b = `${Lr(O.toString(), 2, true, qr.ROUND_UP)}% more than`) : (M = "red", b = "> 100% more than");
      }
    return {
      priceImpactText: b,
      textColor: M
    };
  }, [l10]), x = (0, import_react25.useMemo)(() => (o10 == null ? void 0 : o10.market) === "Cetus" || (s10 == null ? void 0 : s10.market) === "Cetus", [o10, s10]);
  return {
    swapPrice: a10,
    marketPrice: c,
    priceImpact: l10,
    sources: u10,
    showPriceImpactTips: d6,
    showPriceImpactWarn: p,
    priceImpactTextInfo: y,
    hideShowPriceImpact: x
  };
}
function tu({
  content: e10,
  children: t10,
  position: r10 = "top",
  delay: n10 = 0
}) {
  const [i10, o10] = (0, import_react25.useState)(false), [s10, a10] = (0, import_react25.useState)(false), c = (0, import_react25.useRef)(null), l10 = () => {
    c.current && (clearTimeout(c.current), c.current = null), o10(true);
  };
  (0, import_react25.useEffect)(() => () => {
    i10 || c.current && (clearTimeout(c.current), c.current = null);
  }, [i10]);
  const u10 = () => {
    c.current = setTimeout(() => {
      s10 || (o10(false), c.current && (clearTimeout(c.current), c.current = null));
    }, 0);
  }, d6 = () => {
    switch (r10) {
      case "top":
        return {
          transform: "translateX(-50%)"
        };
      case "bottom":
        return {
          transform: "translateX(-50%)",
          marginTop: "0px"
        };
      case "left":
        return {
          transform: "translateY(-50%)",
          marginRight: "8px"
        };
      case "right":
        return {
          transform: "translateY(-50%)"
        };
      default:
        return {};
    }
  }, p = (0, import_react25.useRef)(null), [y, x] = (0, import_react25.useState)({
    left: void 0,
    top: void 0
  });
  return (0, import_react25.useEffect)(() => {
    var b;
    if (i10 && p.current) {
      const M = (b = p.current) == null ? void 0 : b.getBoundingClientRect();
      let O, P;
      r10 === "top" ? (O = `${window.scrollX + M.left + M.width / 2}px`, P = `${window.scrollY + M.top - 2 * M.height - 8}px`) : r10 === "bottom" ? (O = `${window.scrollX + M.left + M.width / 2}px`, P = `${window.scrollY + M.bottom}px`) : r10 === "left" ? (O = `${window.scrollX + M.left - 8}px`, P = `${window.scrollY + M.top + M.height / 2}px`) : r10 === "right" ? (O = `${window.scrollX + M.right + 8}px`, P = `${window.scrollY + M.top + M.height / 2}px`) : (O = `${window.scrollX + M.left + M.width / 2}px`, P = `${window.scrollY + M.top + M.height / 2}px`), x({ left: O, top: P });
    }
  }, [i10]), w.jsxs(
    "div",
    {
      ref: p,
      style: { position: "relative", display: "inline-block" },
      onMouseEnter: l10,
      onMouseLeave: u10,
      children: [
        t10,
        i10 && (0, import_react_dom3.createPortal)(
          w.jsx(
            "div",
            {
              style: {
                transition: "opacity 0.3s ease",
                opacity: i10 ? 1 : 0,
                position: "absolute",
                zIndex: 9e3,
                padding: "8px 12px",
                backgroundColor: "var(--cs-dialog-bg)",
                color: "var(--cs-text-con)",
                borderRadius: "8px",
                fontSize: "12px",
                whiteSpace: "nowrap",
                border: "1px solid",
                borderColor: "var(--cs-border)",
                boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                ...d6(),
                ...y
              },
              onMouseEnter: () => a10(true),
              onMouseLeave: () => {
                c.current && (clearTimeout(c.current), c.current = null), a10(false), o10(false);
              },
              children: e10
            }
          ),
          document.body
        )
      ]
    }
  );
}
function _w({
  content: e10,
  children: t10,
  position: r10,
  autoSwitchTooltip: n10 = false
}) {
  const { isApp: i10 } = eu();
  return i10 && n10 ? w.jsxs(bn.Root, { children: [
    w.jsx(bn.Trigger, { children: w.jsx(
      "button",
      {
        style: {
          background: "none",
          border: "none",
          padding: "0",
          margin: "0",
          outline: "none",
          boxShadow: "none",
          color: "inherit",
          font: "inherit",
          textAlign: "inherit"
        },
        children: t10
      }
    ) }),
    w.jsx(
      bn.Content,
      {
        variant: "soft",
        style: {
          transition: "opacity 0.3s ease",
          display: "block",
          zIndex: 9e3,
          padding: "8px 12px",
          backgroundColor: "var(--cs-dialog-bg)",
          color: "var(--cs-text-con)",
          borderRadius: "8px",
          fontSize: "12px",
          whiteSpace: "nowrap",
          border: "1px solid",
          borderColor: "var(--cs-border)",
          boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)"
        },
        side: r10,
        align: "center",
        children: e10
      }
    )
  ] }) : w.jsx(tu, { content: e10, position: r10, children: t10 });
}
function Ew({
  isLoading: e10,
  routerData: t10,
  noTips: r10
}) {
  const { fromCoin: n10, toCoin: i10, fromAmount: o10, toAmount: s10 } = an();
  eu();
  const {
    priceImpact: a10,
    sources: c,
    marketPrice: l10,
    priceImpactTextInfo: u10,
    hideShowPriceImpact: d6
  } = Sw(
    n10,
    i10,
    t10 == null ? void 0 : t10.fromAmountUi,
    t10 == null ? void 0 : t10.toAmountUi
  );
  return w.jsx(w.Fragment, { children: d6 ? w.jsx(w.Fragment, {}) : w.jsxs(w.Fragment, { children: [
    !r10 && Le(a10).lte(-30) && w.jsx("div", { className: "price-impact-tips red", children: "High price difference. Be cautious before submitting your order." }),
    w.jsxs("div", { className: "price-impact-block", children: [
      w.jsxs("div", { className: "left", children: [
        w.jsx("span", { style: { color: "var(--cs-text-con)" }, children: "Price Difference" }),
        w.jsx(
          _w,
          {
            autoSwitchTooltip: true,
            position: "top",
            content: w.jsx(
              LP,
              {
                fromToken: n10,
                toToken: i10,
                sources: c,
                baseAmount: "1",
                quoteAmount: l10
              }
            ),
            children: w.jsx(
              "svg",
              {
                className: "cs-icon",
                "aria-hidden": "true",
                style: {
                  cursor: "pointer",
                  width: "20px",
                  height: "20px"
                },
                children: w.jsx("use", { xlinkHref: "#icon-tips" })
              }
            )
          }
        )
      ] }),
      w.jsxs("div", { children: [
        e10 && w.jsx(Ls, { style: { width: "80px", height: "20px" } }),
        !e10 && w.jsxs("div", { className: "right", children: [
          w.jsx("span", { className: u10 == null ? void 0 : u10.textColor, children: u10.priceImpactText ? u10 == null ? void 0 : u10.priceImpactText : "Incalculable" }),
          w.jsx("div", { className: "platforms", children: c.map((p) => w.jsx(
            tu,
            {
              content: w.jsx("span", { style: { fontSize: "12px" }, children: Mb[p] }),
              position: "top",
              delay: 300,
              children: w.jsx(
                Xr,
                {
                  src: IC[p]
                }
              )
            },
            p
          )) })
        ] })
      ] })
    ] })
  ] }) });
}
function LP({
  fromToken: e10,
  toToken: t10,
  baseAmount: r10,
  quoteAmount: n10,
  sources: i10
}) {
  const { isApp: o10 } = eu();
  return w.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        gap: "12px"
      },
      children: [
        w.jsx(
          "p",
          {
            style: {
              color: "var(--cs-text-con)",
              fontSize: "12px",
              lineHeight: "18px",
              width: o10 ? "200px" : "300px",
              textAlign: "start",
              whiteSpace: "normal"
            },
            children: "The difference between the market price and estimated price due to trade size."
          }
        ),
        w.jsxs(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              flexDirection: "column",
              alignItems: "flex-start"
            },
            children: [
              w.jsx("p", { style: { fontSize: "12px", color: "var(--cs-text-title)" }, children: "Market price sources:" }),
              r10 && n10 ? w.jsx(
                Y0,
                {
                  baseToken: e10,
                  quoteToken: t10,
                  baseAmount: "1",
                  quoteAmount: n10,
                  loading: false
                }
              ) : w.jsx("p", { style: { color: "var(--cs-text-title)", fontSize: "12px" }, children: "Price is unknown" })
            ]
          }
        ),
        w.jsxs(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginTop: "5px"
            },
            children: [
              w.jsx(
                "p",
                {
                  style: {
                    color: "var(--cs-text-con)",
                    fontSize: "12px",
                    whiteSpace: "pre"
                  },
                  children: "Market price sources:"
                }
              ),
              w.jsx(
                "p",
                {
                  style: {
                    color: "var(--cs-text-con)",
                    fontSize: "12px",
                    whiteSpace: "pre"
                  },
                  children: i10.map((s10) => Mb[s10] + "  ").join("")
                }
              )
            ]
          }
        )
      ]
    }
  );
}
function Cw({
  pr: e10 = "8px",
  pl: t10 = "8px",
  amountLimit: r10,
  isLoading: n10
}) {
  const { fromCoin: i10, toCoin: o10, byAmountIn: s10 } = an();
  return w.jsxs(
    "div",
    {
      className: "swap-info-between",
      style: {
        paddingLeft: t10,
        paddingRight: e10
      },
      children: [
        w.jsx("div", { className: "left", children: s10 ? "Minimum Received" : "Maximum Sold" }),
        n10 ? w.jsx(Ls, { style: { height: "18px", width: "80px" } }) : w.jsxs("div", { className: "right", children: [
          Lr(
            r10,
            s10 ? o10 == null ? void 0 : o10.decimals : i10 == null ? void 0 : i10.decimals,
            false,
            qr.ROUND_DOWN
          ),
          " ",
          mn(s10 ? (o10 == null ? void 0 : o10.symbol) || "" : (i10 == null ? void 0 : i10.symbol) || "")
        ] })
      ]
    }
  );
}
function BP({ scamsText: e10 }) {
  return w.jsxs(
    "div",
    {
      style: {
        marginTop: "16px",
        borderRadius: "8px",
        border: "1px solid #2A3238",
        paddingTop: "12px",
        width: "100%",
        backgroundColor: "#161A1E"
      },
      children: [
        w.jsxs(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              padding: "0 12px",
              justifyContent: "center",
              textAlign: "center"
            },
            children: [
              w.jsx(
                "svg",
                {
                  className: "cs-icon",
                  style: {
                    width: "20px",
                    height: "20px",
                    fill: "#ffca68"
                  },
                  "aria-hidden": "true",
                  children: w.jsx("use", { xlinkHref: "#icon-alert" })
                }
              ),
              w.jsx("span", { style: { color: "#ffca68", marginLeft: "4px" }, children: "Alert" })
            ]
          }
        ),
        w.jsx(
          "div",
          {
            style: {
              borderRadius: "8px",
              padding: "11px",
              margin: "-1px",
              marginTop: "14px",
              border: "1px solid #2A3238",
              lineHeight: "1"
            },
            children: w.jsx(
              Ob,
              {
                text: `${e10} detected to have Deny List feature. It's an optional feature on Sui designed for regulated coins (learn more). However, it could be misused by HoneyPot scams, which may restrict users from selling the tokens after buying. Please be cautious.`,
                keywords: ["learn more"],
                onKeywordClick: (t10) => {
                  window.open(
                    "https://docs.sui.io/guides/developer/coin/regulated",
                    "_blank"
                  );
                }
              }
            )
          }
        )
      ]
    }
  );
}
function UP({ onClick: e10 }) {
  return w.jsxs("div", { className: "cs-icon-button cs-back-button", onClick: (t10) => {
    t10.stopPropagation(), e10();
  }, children: [
    w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-back" }) }),
    w.jsx("span", { children: "Back" })
  ] });
}
function X0({
  title: e10,
  backClick: t10
}) {
  return w.jsxs("div", { className: "cs-have-back-header", children: [
    w.jsx(UP, { onClick: t10 }),
    w.jsx("span", { className: "title", children: e10 })
  ] });
}
var lc = globalThis || void 0 || self;
var FP = typeof lc == "object" && lc && lc.Object === Object && lc;
var Tw = FP;
var $P = typeof self == "object" && self && self.Object === Object && self;
var VP = Tw || $P || Function("return this")();
var ai = VP;
var zP = ai.Symbol;
var ii = zP;
var Aw = Object.prototype;
var qP = Aw.hasOwnProperty;
var HP = Aw.toString;
var Js = ii ? ii.toStringTag : void 0;
function WP(e10) {
  var t10 = qP.call(e10, Js), r10 = e10[Js];
  try {
    e10[Js] = void 0;
    var n10 = true;
  } catch {
  }
  var i10 = HP.call(e10);
  return n10 && (t10 ? e10[Js] = r10 : delete e10[Js]), i10;
}
var GP = Object.prototype;
var KP = GP.toString;
function YP(e10) {
  return KP.call(e10);
}
var XP = "[object Null]";
var JP = "[object Undefined]";
var em = ii ? ii.toStringTag : void 0;
function Us(e10) {
  return e10 == null ? e10 === void 0 ? JP : XP : em && em in Object(e10) ? WP(e10) : YP(e10);
}
function so(e10) {
  return e10 != null && typeof e10 == "object";
}
var ZP = "[object Symbol]";
function Ea(e10) {
  return typeof e10 == "symbol" || so(e10) && Us(e10) == ZP;
}
function Ac(e10, t10) {
  for (var r10 = -1, n10 = e10 == null ? 0 : e10.length, i10 = Array(n10); ++r10 < n10; )
    i10[r10] = t10(e10[r10], r10, e10);
  return i10;
}
var QP = Array.isArray;
var Jr = QP;
var eN = 1 / 0;
var tm = ii ? ii.prototype : void 0;
var rm = tm ? tm.toString : void 0;
function Mw(e10) {
  if (typeof e10 == "string")
    return e10;
  if (Jr(e10))
    return Ac(e10, Mw) + "";
  if (Ea(e10))
    return rm ? rm.call(e10) : "";
  var t10 = e10 + "";
  return t10 == "0" && 1 / e10 == -eN ? "-0" : t10;
}
function Fs(e10) {
  var t10 = typeof e10;
  return e10 != null && (t10 == "object" || t10 == "function");
}
function Iw(e10) {
  return e10;
}
var tN = "[object AsyncFunction]";
var rN = "[object Function]";
var nN = "[object GeneratorFunction]";
var iN = "[object Proxy]";
function Ow(e10) {
  if (!Fs(e10))
    return false;
  var t10 = Us(e10);
  return t10 == rN || t10 == nN || t10 == tN || t10 == iN;
}
var oN = ai["__core-js_shared__"];
var af = oN;
var nm = function() {
  var e10 = /[^.]+$/.exec(af && af.keys && af.keys.IE_PROTO || "");
  return e10 ? "Symbol(src)_1." + e10 : "";
}();
function sN(e10) {
  return !!nm && nm in e10;
}
var aN = Function.prototype;
var cN = aN.toString;
function Wo(e10) {
  if (e10 != null) {
    try {
      return cN.call(e10);
    } catch {
    }
    try {
      return e10 + "";
    } catch {
    }
  }
  return "";
}
var lN = /[\\^$.*+?()[\]{}|]/g;
var uN = /^\[object .+?Constructor\]$/;
var fN = Function.prototype;
var dN = Object.prototype;
var hN = fN.toString;
var pN = dN.hasOwnProperty;
var mN = RegExp(
  "^" + hN.call(pN).replace(lN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function gN(e10) {
  if (!Fs(e10) || sN(e10))
    return false;
  var t10 = Ow(e10) ? mN : uN;
  return t10.test(Wo(e10));
}
function vN(e10, t10) {
  return e10 == null ? void 0 : e10[t10];
}
function Go(e10, t10) {
  var r10 = vN(e10, t10);
  return gN(r10) ? r10 : void 0;
}
var bN = Go(ai, "WeakMap");
var ad = bN;
var im = Object.create;
var yN = /* @__PURE__ */ function() {
  function e10() {
  }
  return function(t10) {
    if (!Fs(t10))
      return {};
    if (im)
      return im(t10);
    e10.prototype = t10;
    var r10 = new e10();
    return e10.prototype = void 0, r10;
  };
}();
var wN = yN;
function xN(e10, t10) {
  var r10 = -1, n10 = e10.length;
  for (t10 || (t10 = Array(n10)); ++r10 < n10; )
    t10[r10] = e10[r10];
  return t10;
}
var SN = function() {
  try {
    var e10 = Go(Object, "defineProperty");
    return e10({}, "", {}), e10;
  } catch {
  }
}();
var om = SN;
function _N(e10, t10) {
  for (var r10 = -1, n10 = e10 == null ? 0 : e10.length; ++r10 < n10 && t10(e10[r10], r10, e10) !== false; )
    ;
  return e10;
}
var EN = 9007199254740991;
var CN = /^(?:0|[1-9]\d*)$/;
function Rw(e10, t10) {
  var r10 = typeof e10;
  return t10 = t10 ?? EN, !!t10 && (r10 == "number" || r10 != "symbol" && CN.test(e10)) && e10 > -1 && e10 % 1 == 0 && e10 < t10;
}
function Pw(e10, t10, r10) {
  t10 == "__proto__" && om ? om(e10, t10, {
    configurable: true,
    enumerable: true,
    value: r10,
    writable: true
  }) : e10[t10] = r10;
}
function J0(e10, t10) {
  return e10 === t10 || e10 !== e10 && t10 !== t10;
}
var TN = Object.prototype;
var AN = TN.hasOwnProperty;
function Nw(e10, t10, r10) {
  var n10 = e10[t10];
  (!(AN.call(e10, t10) && J0(n10, r10)) || r10 === void 0 && !(t10 in e10)) && Pw(e10, t10, r10);
}
function ru(e10, t10, r10, n10) {
  var i10 = !r10;
  r10 || (r10 = {});
  for (var o10 = -1, s10 = t10.length; ++o10 < s10; ) {
    var a10 = t10[o10], c = n10 ? n10(r10[a10], e10[a10], a10, r10, e10) : void 0;
    c === void 0 && (c = e10[a10]), i10 ? Pw(r10, a10, c) : Nw(r10, a10, c);
  }
  return r10;
}
var MN = 9007199254740991;
function Z0(e10) {
  return typeof e10 == "number" && e10 > -1 && e10 % 1 == 0 && e10 <= MN;
}
function nu(e10) {
  return e10 != null && Z0(e10.length) && !Ow(e10);
}
var IN = Object.prototype;
function Q0(e10) {
  var t10 = e10 && e10.constructor, r10 = typeof t10 == "function" && t10.prototype || IN;
  return e10 === r10;
}
function ON(e10, t10) {
  for (var r10 = -1, n10 = Array(e10); ++r10 < e10; )
    n10[r10] = t10(r10);
  return n10;
}
var RN = "[object Arguments]";
function sm(e10) {
  return so(e10) && Us(e10) == RN;
}
var jw = Object.prototype;
var PN = jw.hasOwnProperty;
var NN = jw.propertyIsEnumerable;
var jN = sm(/* @__PURE__ */ function() {
  return arguments;
}()) ? sm : function(e10) {
  return so(e10) && PN.call(e10, "callee") && !NN.call(e10, "callee");
};
var kw = jN;
function kN() {
  return false;
}
var Dw = typeof exports == "object" && exports && !exports.nodeType && exports;
var am = Dw && typeof module == "object" && module && !module.nodeType && module;
var DN = am && am.exports === Dw;
var cm = DN ? ai.Buffer : void 0;
var LN = cm ? cm.isBuffer : void 0;
var BN = LN || kN;
var sl = BN;
var UN = "[object Arguments]";
var FN = "[object Array]";
var $N = "[object Boolean]";
var VN = "[object Date]";
var zN = "[object Error]";
var qN = "[object Function]";
var HN = "[object Map]";
var WN = "[object Number]";
var GN = "[object Object]";
var KN = "[object RegExp]";
var YN = "[object Set]";
var XN = "[object String]";
var JN = "[object WeakMap]";
var ZN = "[object ArrayBuffer]";
var QN = "[object DataView]";
var ej = "[object Float32Array]";
var tj = "[object Float64Array]";
var rj = "[object Int8Array]";
var nj = "[object Int16Array]";
var ij = "[object Int32Array]";
var oj = "[object Uint8Array]";
var sj = "[object Uint8ClampedArray]";
var aj = "[object Uint16Array]";
var cj = "[object Uint32Array]";
var tr = {};
tr[ej] = tr[tj] = tr[rj] = tr[nj] = tr[ij] = tr[oj] = tr[sj] = tr[aj] = tr[cj] = true;
tr[UN] = tr[FN] = tr[ZN] = tr[$N] = tr[QN] = tr[VN] = tr[zN] = tr[qN] = tr[HN] = tr[WN] = tr[GN] = tr[KN] = tr[YN] = tr[XN] = tr[JN] = false;
function lj(e10) {
  return so(e10) && Z0(e10.length) && !!tr[Us(e10)];
}
function iu(e10) {
  return function(t10) {
    return e10(t10);
  };
}
var Lw = typeof exports == "object" && exports && !exports.nodeType && exports;
var fa = Lw && typeof module == "object" && module && !module.nodeType && module;
var uj = fa && fa.exports === Lw;
var cf = uj && Tw.process;
var fj = function() {
  try {
    var e10 = fa && fa.require && fa.require("util").types;
    return e10 || cf && cf.binding && cf.binding("util");
  } catch {
  }
}();
var Ts = fj;
var lm = Ts && Ts.isTypedArray;
var dj = lm ? iu(lm) : lj;
var Bw = dj;
var hj = Object.prototype;
var pj = hj.hasOwnProperty;
function Uw(e10, t10) {
  var r10 = Jr(e10), n10 = !r10 && kw(e10), i10 = !r10 && !n10 && sl(e10), o10 = !r10 && !n10 && !i10 && Bw(e10), s10 = r10 || n10 || i10 || o10, a10 = s10 ? ON(e10.length, String) : [], c = a10.length;
  for (var l10 in e10)
    (t10 || pj.call(e10, l10)) && !(s10 && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l10 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i10 && (l10 == "offset" || l10 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o10 && (l10 == "buffer" || l10 == "byteLength" || l10 == "byteOffset") || // Skip index properties.
    Rw(l10, c))) && a10.push(l10);
  return a10;
}
function Fw(e10, t10) {
  return function(r10) {
    return e10(t10(r10));
  };
}
var mj = Fw(Object.keys, Object);
var gj = mj;
var vj = Object.prototype;
var bj = vj.hasOwnProperty;
function yj(e10) {
  if (!Q0(e10))
    return gj(e10);
  var t10 = [];
  for (var r10 in Object(e10))
    bj.call(e10, r10) && r10 != "constructor" && t10.push(r10);
  return t10;
}
function Ga(e10) {
  return nu(e10) ? Uw(e10) : yj(e10);
}
function wj(e10) {
  var t10 = [];
  if (e10 != null)
    for (var r10 in Object(e10))
      t10.push(r10);
  return t10;
}
var xj = Object.prototype;
var Sj = xj.hasOwnProperty;
function _j(e10) {
  if (!Fs(e10))
    return wj(e10);
  var t10 = Q0(e10), r10 = [];
  for (var n10 in e10)
    n10 == "constructor" && (t10 || !Sj.call(e10, n10)) || r10.push(n10);
  return r10;
}
function eh(e10) {
  return nu(e10) ? Uw(e10, true) : _j(e10);
}
var Ej = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Cj = /^\w*$/;
function th(e10, t10) {
  if (Jr(e10))
    return false;
  var r10 = typeof e10;
  return r10 == "number" || r10 == "symbol" || r10 == "boolean" || e10 == null || Ea(e10) ? true : Cj.test(e10) || !Ej.test(e10) || t10 != null && e10 in Object(t10);
}
var Tj = Go(Object, "create");
var Ca = Tj;
function Aj() {
  this.__data__ = Ca ? Ca(null) : {}, this.size = 0;
}
function Mj(e10) {
  var t10 = this.has(e10) && delete this.__data__[e10];
  return this.size -= t10 ? 1 : 0, t10;
}
var Ij = "__lodash_hash_undefined__";
var Oj = Object.prototype;
var Rj = Oj.hasOwnProperty;
function Pj(e10) {
  var t10 = this.__data__;
  if (Ca) {
    var r10 = t10[e10];
    return r10 === Ij ? void 0 : r10;
  }
  return Rj.call(t10, e10) ? t10[e10] : void 0;
}
var Nj = Object.prototype;
var jj = Nj.hasOwnProperty;
function kj(e10) {
  var t10 = this.__data__;
  return Ca ? t10[e10] !== void 0 : jj.call(t10, e10);
}
var Dj = "__lodash_hash_undefined__";
function Lj(e10, t10) {
  var r10 = this.__data__;
  return this.size += this.has(e10) ? 0 : 1, r10[e10] = Ca && t10 === void 0 ? Dj : t10, this;
}
function Bo(e10) {
  var t10 = -1, r10 = e10 == null ? 0 : e10.length;
  for (this.clear(); ++t10 < r10; ) {
    var n10 = e10[t10];
    this.set(n10[0], n10[1]);
  }
}
Bo.prototype.clear = Aj;
Bo.prototype.delete = Mj;
Bo.prototype.get = Pj;
Bo.prototype.has = kj;
Bo.prototype.set = Lj;
function Bj() {
  this.__data__ = [], this.size = 0;
}
function ou(e10, t10) {
  for (var r10 = e10.length; r10--; )
    if (J0(e10[r10][0], t10))
      return r10;
  return -1;
}
var Uj = Array.prototype;
var Fj = Uj.splice;
function $j(e10) {
  var t10 = this.__data__, r10 = ou(t10, e10);
  if (r10 < 0)
    return false;
  var n10 = t10.length - 1;
  return r10 == n10 ? t10.pop() : Fj.call(t10, r10, 1), --this.size, true;
}
function Vj(e10) {
  var t10 = this.__data__, r10 = ou(t10, e10);
  return r10 < 0 ? void 0 : t10[r10][1];
}
function zj(e10) {
  return ou(this.__data__, e10) > -1;
}
function qj(e10, t10) {
  var r10 = this.__data__, n10 = ou(r10, e10);
  return n10 < 0 ? (++this.size, r10.push([e10, t10])) : r10[n10][1] = t10, this;
}
function Li(e10) {
  var t10 = -1, r10 = e10 == null ? 0 : e10.length;
  for (this.clear(); ++t10 < r10; ) {
    var n10 = e10[t10];
    this.set(n10[0], n10[1]);
  }
}
Li.prototype.clear = Bj;
Li.prototype.delete = $j;
Li.prototype.get = Vj;
Li.prototype.has = zj;
Li.prototype.set = qj;
var Hj = Go(ai, "Map");
var Ta = Hj;
function Wj() {
  this.size = 0, this.__data__ = {
    hash: new Bo(),
    map: new (Ta || Li)(),
    string: new Bo()
  };
}
function Gj(e10) {
  var t10 = typeof e10;
  return t10 == "string" || t10 == "number" || t10 == "symbol" || t10 == "boolean" ? e10 !== "__proto__" : e10 === null;
}
function su(e10, t10) {
  var r10 = e10.__data__;
  return Gj(t10) ? r10[typeof t10 == "string" ? "string" : "hash"] : r10.map;
}
function Kj(e10) {
  var t10 = su(this, e10).delete(e10);
  return this.size -= t10 ? 1 : 0, t10;
}
function Yj(e10) {
  return su(this, e10).get(e10);
}
function Xj(e10) {
  return su(this, e10).has(e10);
}
function Jj(e10, t10) {
  var r10 = su(this, e10), n10 = r10.size;
  return r10.set(e10, t10), this.size += r10.size == n10 ? 0 : 1, this;
}
function Bi(e10) {
  var t10 = -1, r10 = e10 == null ? 0 : e10.length;
  for (this.clear(); ++t10 < r10; ) {
    var n10 = e10[t10];
    this.set(n10[0], n10[1]);
  }
}
Bi.prototype.clear = Wj;
Bi.prototype.delete = Kj;
Bi.prototype.get = Yj;
Bi.prototype.has = Xj;
Bi.prototype.set = Jj;
var Zj = "Expected a function";
function rh(e10, t10) {
  if (typeof e10 != "function" || t10 != null && typeof t10 != "function")
    throw new TypeError(Zj);
  var r10 = function() {
    var n10 = arguments, i10 = t10 ? t10.apply(this, n10) : n10[0], o10 = r10.cache;
    if (o10.has(i10))
      return o10.get(i10);
    var s10 = e10.apply(this, n10);
    return r10.cache = o10.set(i10, s10) || o10, s10;
  };
  return r10.cache = new (rh.Cache || Bi)(), r10;
}
rh.Cache = Bi;
var Qj = 500;
function ek(e10) {
  var t10 = rh(e10, function(n10) {
    return r10.size === Qj && r10.clear(), n10;
  }), r10 = t10.cache;
  return t10;
}
var tk = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var rk = /\\(\\)?/g;
var nk = ek(function(e10) {
  var t10 = [];
  return e10.charCodeAt(0) === 46 && t10.push(""), e10.replace(tk, function(r10, n10, i10, o10) {
    t10.push(i10 ? o10.replace(rk, "$1") : n10 || r10);
  }), t10;
});
var ik = nk;
function ok(e10) {
  return e10 == null ? "" : Mw(e10);
}
function $w(e10, t10) {
  return Jr(e10) ? e10 : th(e10, t10) ? [e10] : ik(ok(e10));
}
var sk = 1 / 0;
function au(e10) {
  if (typeof e10 == "string" || Ea(e10))
    return e10;
  var t10 = e10 + "";
  return t10 == "0" && 1 / e10 == -sk ? "-0" : t10;
}
function nh(e10, t10) {
  t10 = $w(t10, e10);
  for (var r10 = 0, n10 = t10.length; e10 != null && r10 < n10; )
    e10 = e10[au(t10[r10++])];
  return r10 && r10 == n10 ? e10 : void 0;
}
function ak(e10, t10, r10) {
  var n10 = e10 == null ? void 0 : nh(e10, t10);
  return n10 === void 0 ? r10 : n10;
}
function Vw(e10, t10) {
  for (var r10 = -1, n10 = t10.length, i10 = e10.length; ++r10 < n10; )
    e10[i10 + r10] = t10[r10];
  return e10;
}
var ck = Fw(Object.getPrototypeOf, Object);
var zw = ck;
function lk() {
  this.__data__ = new Li(), this.size = 0;
}
function uk(e10) {
  var t10 = this.__data__, r10 = t10.delete(e10);
  return this.size = t10.size, r10;
}
function fk(e10) {
  return this.__data__.get(e10);
}
function dk(e10) {
  return this.__data__.has(e10);
}
var hk = 200;
function pk(e10, t10) {
  var r10 = this.__data__;
  if (r10 instanceof Li) {
    var n10 = r10.__data__;
    if (!Ta || n10.length < hk - 1)
      return n10.push([e10, t10]), this.size = ++r10.size, this;
    r10 = this.__data__ = new Bi(n10);
  }
  return r10.set(e10, t10), this.size = r10.size, this;
}
function ei(e10) {
  var t10 = this.__data__ = new Li(e10);
  this.size = t10.size;
}
ei.prototype.clear = lk;
ei.prototype.delete = uk;
ei.prototype.get = fk;
ei.prototype.has = dk;
ei.prototype.set = pk;
function mk(e10, t10) {
  return e10 && ru(t10, Ga(t10), e10);
}
function gk(e10, t10) {
  return e10 && ru(t10, eh(t10), e10);
}
var qw = typeof exports == "object" && exports && !exports.nodeType && exports;
var um = qw && typeof module == "object" && module && !module.nodeType && module;
var vk = um && um.exports === qw;
var fm = vk ? ai.Buffer : void 0;
var dm = fm ? fm.allocUnsafe : void 0;
function bk(e10, t10) {
  if (t10)
    return e10.slice();
  var r10 = e10.length, n10 = dm ? dm(r10) : new e10.constructor(r10);
  return e10.copy(n10), n10;
}
function Hw(e10, t10) {
  for (var r10 = -1, n10 = e10 == null ? 0 : e10.length, i10 = 0, o10 = []; ++r10 < n10; ) {
    var s10 = e10[r10];
    t10(s10, r10, e10) && (o10[i10++] = s10);
  }
  return o10;
}
function Ww() {
  return [];
}
var yk = Object.prototype;
var wk = yk.propertyIsEnumerable;
var hm = Object.getOwnPropertySymbols;
var xk = hm ? function(e10) {
  return e10 == null ? [] : (e10 = Object(e10), Hw(hm(e10), function(t10) {
    return wk.call(e10, t10);
  }));
} : Ww;
var ih = xk;
function Sk(e10, t10) {
  return ru(e10, ih(e10), t10);
}
var _k = Object.getOwnPropertySymbols;
var Ek = _k ? function(e10) {
  for (var t10 = []; e10; )
    Vw(t10, ih(e10)), e10 = zw(e10);
  return t10;
} : Ww;
var Gw = Ek;
function Ck(e10, t10) {
  return ru(e10, Gw(e10), t10);
}
function Kw(e10, t10, r10) {
  var n10 = t10(e10);
  return Jr(e10) ? n10 : Vw(n10, r10(e10));
}
function cd(e10) {
  return Kw(e10, Ga, ih);
}
function Tk(e10) {
  return Kw(e10, eh, Gw);
}
var Ak = Go(ai, "DataView");
var ld = Ak;
var Mk = Go(ai, "Promise");
var ud = Mk;
var Ik = Go(ai, "Set");
var fd = Ik;
var pm = "[object Map]";
var Ok = "[object Object]";
var mm = "[object Promise]";
var gm = "[object Set]";
var vm = "[object WeakMap]";
var bm = "[object DataView]";
var Rk = Wo(ld);
var Pk = Wo(Ta);
var Nk = Wo(ud);
var jk = Wo(fd);
var kk = Wo(ad);
var Eo = Us;
(ld && Eo(new ld(new ArrayBuffer(1))) != bm || Ta && Eo(new Ta()) != pm || ud && Eo(ud.resolve()) != mm || fd && Eo(new fd()) != gm || ad && Eo(new ad()) != vm) && (Eo = function(e10) {
  var t10 = Us(e10), r10 = t10 == Ok ? e10.constructor : void 0, n10 = r10 ? Wo(r10) : "";
  if (n10)
    switch (n10) {
      case Rk:
        return bm;
      case Pk:
        return pm;
      case Nk:
        return mm;
      case jk:
        return gm;
      case kk:
        return vm;
    }
  return t10;
});
var Aa = Eo;
var Dk = Object.prototype;
var Lk = Dk.hasOwnProperty;
function Bk(e10) {
  var t10 = e10.length, r10 = new e10.constructor(t10);
  return t10 && typeof e10[0] == "string" && Lk.call(e10, "index") && (r10.index = e10.index, r10.input = e10.input), r10;
}
var Uk = ai.Uint8Array;
var al = Uk;
function oh(e10) {
  var t10 = new e10.constructor(e10.byteLength);
  return new al(t10).set(new al(e10)), t10;
}
function Fk(e10, t10) {
  var r10 = t10 ? oh(e10.buffer) : e10.buffer;
  return new e10.constructor(r10, e10.byteOffset, e10.byteLength);
}
var $k = /\w*$/;
function Vk(e10) {
  var t10 = new e10.constructor(e10.source, $k.exec(e10));
  return t10.lastIndex = e10.lastIndex, t10;
}
var ym = ii ? ii.prototype : void 0;
var wm = ym ? ym.valueOf : void 0;
function zk(e10) {
  return wm ? Object(wm.call(e10)) : {};
}
function qk(e10, t10) {
  var r10 = t10 ? oh(e10.buffer) : e10.buffer;
  return new e10.constructor(r10, e10.byteOffset, e10.length);
}
var Hk = "[object Boolean]";
var Wk = "[object Date]";
var Gk = "[object Map]";
var Kk = "[object Number]";
var Yk = "[object RegExp]";
var Xk = "[object Set]";
var Jk = "[object String]";
var Zk = "[object Symbol]";
var Qk = "[object ArrayBuffer]";
var eD = "[object DataView]";
var tD = "[object Float32Array]";
var rD = "[object Float64Array]";
var nD = "[object Int8Array]";
var iD = "[object Int16Array]";
var oD = "[object Int32Array]";
var sD = "[object Uint8Array]";
var aD = "[object Uint8ClampedArray]";
var cD = "[object Uint16Array]";
var lD = "[object Uint32Array]";
function uD(e10, t10, r10) {
  var n10 = e10.constructor;
  switch (t10) {
    case Qk:
      return oh(e10);
    case Hk:
    case Wk:
      return new n10(+e10);
    case eD:
      return Fk(e10, r10);
    case tD:
    case rD:
    case nD:
    case iD:
    case oD:
    case sD:
    case aD:
    case cD:
    case lD:
      return qk(e10, r10);
    case Gk:
      return new n10();
    case Kk:
    case Jk:
      return new n10(e10);
    case Yk:
      return Vk(e10);
    case Xk:
      return new n10();
    case Zk:
      return zk(e10);
  }
}
function fD(e10) {
  return typeof e10.constructor == "function" && !Q0(e10) ? wN(zw(e10)) : {};
}
var dD = "[object Map]";
function hD(e10) {
  return so(e10) && Aa(e10) == dD;
}
var xm = Ts && Ts.isMap;
var pD = xm ? iu(xm) : hD;
var mD = pD;
var gD = "[object Set]";
function vD(e10) {
  return so(e10) && Aa(e10) == gD;
}
var Sm = Ts && Ts.isSet;
var bD = Sm ? iu(Sm) : vD;
var yD = bD;
var wD = 1;
var xD = 2;
var SD = 4;
var Yw = "[object Arguments]";
var _D = "[object Array]";
var ED = "[object Boolean]";
var CD = "[object Date]";
var TD = "[object Error]";
var Xw = "[object Function]";
var AD = "[object GeneratorFunction]";
var MD = "[object Map]";
var ID = "[object Number]";
var Jw = "[object Object]";
var OD = "[object RegExp]";
var RD = "[object Set]";
var PD = "[object String]";
var ND = "[object Symbol]";
var jD = "[object WeakMap]";
var kD = "[object ArrayBuffer]";
var DD = "[object DataView]";
var LD = "[object Float32Array]";
var BD = "[object Float64Array]";
var UD = "[object Int8Array]";
var FD = "[object Int16Array]";
var $D = "[object Int32Array]";
var VD = "[object Uint8Array]";
var zD = "[object Uint8ClampedArray]";
var qD = "[object Uint16Array]";
var HD = "[object Uint32Array]";
var Jt = {};
Jt[Yw] = Jt[_D] = Jt[kD] = Jt[DD] = Jt[ED] = Jt[CD] = Jt[LD] = Jt[BD] = Jt[UD] = Jt[FD] = Jt[$D] = Jt[MD] = Jt[ID] = Jt[Jw] = Jt[OD] = Jt[RD] = Jt[PD] = Jt[ND] = Jt[VD] = Jt[zD] = Jt[qD] = Jt[HD] = true;
Jt[TD] = Jt[Xw] = Jt[jD] = false;
function Mc(e10, t10, r10, n10, i10, o10) {
  var s10, a10 = t10 & wD, c = t10 & xD, l10 = t10 & SD;
  if (r10 && (s10 = i10 ? r10(e10, n10, i10, o10) : r10(e10)), s10 !== void 0)
    return s10;
  if (!Fs(e10))
    return e10;
  var u10 = Jr(e10);
  if (u10) {
    if (s10 = Bk(e10), !a10)
      return xN(e10, s10);
  } else {
    var d6 = Aa(e10), p = d6 == Xw || d6 == AD;
    if (sl(e10))
      return bk(e10, a10);
    if (d6 == Jw || d6 == Yw || p && !i10) {
      if (s10 = c || p ? {} : fD(e10), !a10)
        return c ? Ck(e10, gk(s10, e10)) : Sk(e10, mk(s10, e10));
    } else {
      if (!Jt[d6])
        return i10 ? e10 : {};
      s10 = uD(e10, d6, a10);
    }
  }
  o10 || (o10 = new ei());
  var y = o10.get(e10);
  if (y)
    return y;
  o10.set(e10, s10), yD(e10) ? e10.forEach(function(M) {
    s10.add(Mc(M, t10, r10, M, e10, o10));
  }) : mD(e10) && e10.forEach(function(M, O) {
    s10.set(O, Mc(M, t10, r10, O, e10, o10));
  });
  var x = l10 ? c ? Tk : cd : c ? eh : Ga, b = u10 ? void 0 : x(e10);
  return _N(b || e10, function(M, O) {
    b && (O = M, M = e10[O]), Nw(s10, O, Mc(M, t10, r10, O, e10, o10));
  }), s10;
}
var WD = 1;
var GD = 4;
function KD(e10) {
  return Mc(e10, WD | GD);
}
var YD = "__lodash_hash_undefined__";
function XD(e10) {
  return this.__data__.set(e10, YD), this;
}
function JD(e10) {
  return this.__data__.has(e10);
}
function cl(e10) {
  var t10 = -1, r10 = e10 == null ? 0 : e10.length;
  for (this.__data__ = new Bi(); ++t10 < r10; )
    this.add(e10[t10]);
}
cl.prototype.add = cl.prototype.push = XD;
cl.prototype.has = JD;
function ZD(e10, t10) {
  for (var r10 = -1, n10 = e10 == null ? 0 : e10.length; ++r10 < n10; )
    if (t10(e10[r10], r10, e10))
      return true;
  return false;
}
function QD(e10, t10) {
  return e10.has(t10);
}
var eL = 1;
var tL = 2;
function Zw(e10, t10, r10, n10, i10, o10) {
  var s10 = r10 & eL, a10 = e10.length, c = t10.length;
  if (a10 != c && !(s10 && c > a10))
    return false;
  var l10 = o10.get(e10), u10 = o10.get(t10);
  if (l10 && u10)
    return l10 == t10 && u10 == e10;
  var d6 = -1, p = true, y = r10 & tL ? new cl() : void 0;
  for (o10.set(e10, t10), o10.set(t10, e10); ++d6 < a10; ) {
    var x = e10[d6], b = t10[d6];
    if (n10)
      var M = s10 ? n10(b, x, d6, t10, e10, o10) : n10(x, b, d6, e10, t10, o10);
    if (M !== void 0) {
      if (M)
        continue;
      p = false;
      break;
    }
    if (y) {
      if (!ZD(t10, function(O, P) {
        if (!QD(y, P) && (x === O || i10(x, O, r10, n10, o10)))
          return y.push(P);
      })) {
        p = false;
        break;
      }
    } else if (!(x === b || i10(x, b, r10, n10, o10))) {
      p = false;
      break;
    }
  }
  return o10.delete(e10), o10.delete(t10), p;
}
function rL(e10) {
  var t10 = -1, r10 = Array(e10.size);
  return e10.forEach(function(n10, i10) {
    r10[++t10] = [i10, n10];
  }), r10;
}
function nL(e10) {
  var t10 = -1, r10 = Array(e10.size);
  return e10.forEach(function(n10) {
    r10[++t10] = n10;
  }), r10;
}
var iL = 1;
var oL = 2;
var sL = "[object Boolean]";
var aL = "[object Date]";
var cL = "[object Error]";
var lL = "[object Map]";
var uL = "[object Number]";
var fL = "[object RegExp]";
var dL = "[object Set]";
var hL = "[object String]";
var pL = "[object Symbol]";
var mL = "[object ArrayBuffer]";
var gL = "[object DataView]";
var _m = ii ? ii.prototype : void 0;
var lf = _m ? _m.valueOf : void 0;
function vL(e10, t10, r10, n10, i10, o10, s10) {
  switch (r10) {
    case gL:
      if (e10.byteLength != t10.byteLength || e10.byteOffset != t10.byteOffset)
        return false;
      e10 = e10.buffer, t10 = t10.buffer;
    case mL:
      return !(e10.byteLength != t10.byteLength || !o10(new al(e10), new al(t10)));
    case sL:
    case aL:
    case uL:
      return J0(+e10, +t10);
    case cL:
      return e10.name == t10.name && e10.message == t10.message;
    case fL:
    case hL:
      return e10 == t10 + "";
    case lL:
      var a10 = rL;
    case dL:
      var c = n10 & iL;
      if (a10 || (a10 = nL), e10.size != t10.size && !c)
        return false;
      var l10 = s10.get(e10);
      if (l10)
        return l10 == t10;
      n10 |= oL, s10.set(e10, t10);
      var u10 = Zw(a10(e10), a10(t10), n10, i10, o10, s10);
      return s10.delete(e10), u10;
    case pL:
      if (lf)
        return lf.call(e10) == lf.call(t10);
  }
  return false;
}
var bL = 1;
var yL = Object.prototype;
var wL = yL.hasOwnProperty;
function xL(e10, t10, r10, n10, i10, o10) {
  var s10 = r10 & bL, a10 = cd(e10), c = a10.length, l10 = cd(t10), u10 = l10.length;
  if (c != u10 && !s10)
    return false;
  for (var d6 = c; d6--; ) {
    var p = a10[d6];
    if (!(s10 ? p in t10 : wL.call(t10, p)))
      return false;
  }
  var y = o10.get(e10), x = o10.get(t10);
  if (y && x)
    return y == t10 && x == e10;
  var b = true;
  o10.set(e10, t10), o10.set(t10, e10);
  for (var M = s10; ++d6 < c; ) {
    p = a10[d6];
    var O = e10[p], P = t10[p];
    if (n10)
      var j = s10 ? n10(P, O, p, t10, e10, o10) : n10(O, P, p, e10, t10, o10);
    if (!(j === void 0 ? O === P || i10(O, P, r10, n10, o10) : j)) {
      b = false;
      break;
    }
    M || (M = p == "constructor");
  }
  if (b && !M) {
    var F = e10.constructor, B = t10.constructor;
    F != B && "constructor" in e10 && "constructor" in t10 && !(typeof F == "function" && F instanceof F && typeof B == "function" && B instanceof B) && (b = false);
  }
  return o10.delete(e10), o10.delete(t10), b;
}
var SL = 1;
var Em = "[object Arguments]";
var Cm = "[object Array]";
var uc = "[object Object]";
var _L = Object.prototype;
var Tm = _L.hasOwnProperty;
function EL(e10, t10, r10, n10, i10, o10) {
  var s10 = Jr(e10), a10 = Jr(t10), c = s10 ? Cm : Aa(e10), l10 = a10 ? Cm : Aa(t10);
  c = c == Em ? uc : c, l10 = l10 == Em ? uc : l10;
  var u10 = c == uc, d6 = l10 == uc, p = c == l10;
  if (p && sl(e10)) {
    if (!sl(t10))
      return false;
    s10 = true, u10 = false;
  }
  if (p && !u10)
    return o10 || (o10 = new ei()), s10 || Bw(e10) ? Zw(e10, t10, r10, n10, i10, o10) : vL(e10, t10, c, r10, n10, i10, o10);
  if (!(r10 & SL)) {
    var y = u10 && Tm.call(e10, "__wrapped__"), x = d6 && Tm.call(t10, "__wrapped__");
    if (y || x) {
      var b = y ? e10.value() : e10, M = x ? t10.value() : t10;
      return o10 || (o10 = new ei()), i10(b, M, r10, n10, o10);
    }
  }
  return p ? (o10 || (o10 = new ei()), xL(e10, t10, r10, n10, i10, o10)) : false;
}
function cu(e10, t10, r10, n10, i10) {
  return e10 === t10 ? true : e10 == null || t10 == null || !so(e10) && !so(t10) ? e10 !== e10 && t10 !== t10 : EL(e10, t10, r10, n10, cu, i10);
}
var CL = 1;
var TL = 2;
function AL(e10, t10, r10, n10) {
  var i10 = r10.length, o10 = i10, s10 = !n10;
  if (e10 == null)
    return !o10;
  for (e10 = Object(e10); i10--; ) {
    var a10 = r10[i10];
    if (s10 && a10[2] ? a10[1] !== e10[a10[0]] : !(a10[0] in e10))
      return false;
  }
  for (; ++i10 < o10; ) {
    a10 = r10[i10];
    var c = a10[0], l10 = e10[c], u10 = a10[1];
    if (s10 && a10[2]) {
      if (l10 === void 0 && !(c in e10))
        return false;
    } else {
      var d6 = new ei();
      if (n10)
        var p = n10(l10, u10, c, e10, t10, d6);
      if (!(p === void 0 ? cu(u10, l10, CL | TL, n10, d6) : p))
        return false;
    }
  }
  return true;
}
function Qw(e10) {
  return e10 === e10 && !Fs(e10);
}
function ML(e10) {
  for (var t10 = Ga(e10), r10 = t10.length; r10--; ) {
    var n10 = t10[r10], i10 = e10[n10];
    t10[r10] = [n10, i10, Qw(i10)];
  }
  return t10;
}
function e6(e10, t10) {
  return function(r10) {
    return r10 == null ? false : r10[e10] === t10 && (t10 !== void 0 || e10 in Object(r10));
  };
}
function IL(e10) {
  var t10 = ML(e10);
  return t10.length == 1 && t10[0][2] ? e6(t10[0][0], t10[0][1]) : function(r10) {
    return r10 === e10 || AL(r10, e10, t10);
  };
}
function OL(e10, t10) {
  return e10 != null && t10 in Object(e10);
}
function RL(e10, t10, r10) {
  t10 = $w(t10, e10);
  for (var n10 = -1, i10 = t10.length, o10 = false; ++n10 < i10; ) {
    var s10 = au(t10[n10]);
    if (!(o10 = e10 != null && r10(e10, s10)))
      break;
    e10 = e10[s10];
  }
  return o10 || ++n10 != i10 ? o10 : (i10 = e10 == null ? 0 : e10.length, !!i10 && Z0(i10) && Rw(s10, i10) && (Jr(e10) || kw(e10)));
}
function PL(e10, t10) {
  return e10 != null && RL(e10, t10, OL);
}
var NL = 1;
var jL = 2;
function kL(e10, t10) {
  return th(e10) && Qw(t10) ? e6(au(e10), t10) : function(r10) {
    var n10 = ak(r10, e10);
    return n10 === void 0 && n10 === t10 ? PL(r10, e10) : cu(t10, n10, NL | jL);
  };
}
function DL(e10) {
  return function(t10) {
    return t10 == null ? void 0 : t10[e10];
  };
}
function LL(e10) {
  return function(t10) {
    return nh(t10, e10);
  };
}
function BL(e10) {
  return th(e10) ? DL(au(e10)) : LL(e10);
}
function t6(e10) {
  return typeof e10 == "function" ? e10 : e10 == null ? Iw : typeof e10 == "object" ? Jr(e10) ? kL(e10[0], e10[1]) : IL(e10) : BL(e10);
}
function UL(e10) {
  return function(t10, r10, n10) {
    for (var i10 = -1, o10 = Object(t10), s10 = n10(t10), a10 = s10.length; a10--; ) {
      var c = s10[e10 ? a10 : ++i10];
      if (r10(o10[c], c, o10) === false)
        break;
    }
    return t10;
  };
}
var FL = UL();
var $L = FL;
function VL(e10, t10) {
  return e10 && $L(e10, t10, Ga);
}
function zL(e10, t10) {
  return function(r10, n10) {
    if (r10 == null)
      return r10;
    if (!nu(r10))
      return e10(r10, n10);
    for (var i10 = r10.length, o10 = t10 ? i10 : -1, s10 = Object(r10); (t10 ? o10-- : ++o10 < i10) && n10(s10[o10], o10, s10) !== false; )
      ;
    return r10;
  };
}
var qL = zL(VL);
var r6 = qL;
function HL(e10, t10) {
  var r10 = [];
  return r6(e10, function(n10, i10, o10) {
    t10(n10, i10, o10) && r10.push(n10);
  }), r10;
}
function WL(e10, t10) {
  var r10 = Jr(e10) ? Hw : HL;
  return r10(e10, t6(t10));
}
function GL(e10, t10) {
  var r10 = -1, n10 = nu(e10) ? Array(e10.length) : [];
  return r6(e10, function(i10, o10, s10) {
    n10[++r10] = t10(i10, o10, s10);
  }), n10;
}
function KL(e10, t10) {
  return cu(e10, t10);
}
function YL(e10, t10) {
  var r10 = e10.length;
  for (e10.sort(t10); r10--; )
    e10[r10] = e10[r10].value;
  return e10;
}
function XL(e10, t10) {
  if (e10 !== t10) {
    var r10 = e10 !== void 0, n10 = e10 === null, i10 = e10 === e10, o10 = Ea(e10), s10 = t10 !== void 0, a10 = t10 === null, c = t10 === t10, l10 = Ea(t10);
    if (!a10 && !l10 && !o10 && e10 > t10 || o10 && s10 && c && !a10 && !l10 || n10 && s10 && c || !r10 && c || !i10)
      return 1;
    if (!n10 && !o10 && !l10 && e10 < t10 || l10 && r10 && i10 && !n10 && !o10 || a10 && r10 && i10 || !s10 && i10 || !c)
      return -1;
  }
  return 0;
}
function JL(e10, t10, r10) {
  for (var n10 = -1, i10 = e10.criteria, o10 = t10.criteria, s10 = i10.length, a10 = r10.length; ++n10 < s10; ) {
    var c = XL(i10[n10], o10[n10]);
    if (c) {
      if (n10 >= a10)
        return c;
      var l10 = r10[n10];
      return c * (l10 == "desc" ? -1 : 1);
    }
  }
  return e10.index - t10.index;
}
function ZL(e10, t10, r10) {
  t10.length ? t10 = Ac(t10, function(o10) {
    return Jr(o10) ? function(s10) {
      return nh(s10, o10.length === 1 ? o10[0] : o10);
    } : o10;
  }) : t10 = [Iw];
  var n10 = -1;
  t10 = Ac(t10, iu(t6));
  var i10 = GL(e10, function(o10, s10, a10) {
    var c = Ac(t10, function(l10) {
      return l10(o10);
    });
    return { criteria: c, index: ++n10, value: o10 };
  });
  return YL(i10, function(o10, s10) {
    return JL(o10, s10, r10);
  });
}
function QL(e10, t10, r10, n10) {
  return e10 == null ? [] : (Jr(t10) || (t10 = t10 == null ? [] : [t10]), r10 = n10 ? void 0 : r10, Jr(r10) || (r10 = r10 == null ? [] : [r10]), ZL(e10, t10, r10));
}
function eB({
  toBack: e10,
  onSubmitClick: t10,
  data: r10
}) {
  const { fromCoin: n10, toCoin: i10 } = an(), o10 = (0, import_react25.useRef)(false), { slippage: s10 } = Hr(), [a10, c] = (0, import_react25.useState)(r10), { fromAmountUi: l10, toAmountUi: u10, byAmountIn: d6 } = a10, { amountLimit: p } = bw(s10, a10), { showPriceImpactTips: y, showPriceImpactWarn: x } = Sw(
    n10,
    i10,
    l10,
    u10
  ), { priceAcceptRouterData: b } = bP(a10), [M, O] = (0, import_react25.useState)(false), [P, j] = (0, import_react25.useState)(false);
  (0, import_react25.useMemo)(() => d6 ? i10 : n10, [d6]);
  const F = (0, import_react25.useMemo)(() => b !== void 0, [b]), B = () => {
    if (b) {
      if (o10.current)
        return;
      o10.current = true;
      const z = KD(b);
      c(z), setTimeout(() => {
        o10.current = false;
      }, 300);
    }
  }, W = (0, import_react25.useMemo)(() => M ? false : !!x, [M, x]);
  return w.jsxs("div", { className: "secondary-dialog", children: [
    w.jsx(X0, { title: "Review your order", backClick: e10 }),
    w.jsxs("div", { className: "secondary-content", children: [
      w.jsxs("div", { className: "trade-info", children: [
        w.jsxs("div", { className: "amount-info", children: [
          w.jsx("span", { className: "amount", children: Ss(l10 || "") }),
          w.jsx("img", { src: n10 == null ? void 0 : n10.logo_url }),
          w.jsx("span", { className: "symbol", children: mn((n10 == null ? void 0 : n10.symbol) || "") })
        ] }),
        w.jsx("div", { className: "dividing-line", children: w.jsx("div", { className: "swap-icon", children: w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-trade" }) }) }) }),
        w.jsxs("div", { className: "amount-info", children: [
          w.jsx("span", { className: "amount", children: Ss(u10 || "") }),
          w.jsx("img", { src: i10 == null ? void 0 : i10.logo_url }),
          w.jsx("span", { className: "symbol", children: mn((i10 == null ? void 0 : i10.symbol) || "") })
        ] })
      ] }),
      w.jsxs(
        "div",
        {
          className: "current-price-tips-box yellow",
          style: {
            fontSize: "12px",
            marginTop: "8px",
            flexDirection: "column",
            justifyContent: "start",
            gap: "10px"
          },
          children: [
            w.jsx(
              "div",
              {
                className: "current-price-box",
                style: { backgroundColor: "#1b242c", marginTop: "-1px" },
                children: w.jsx(
                  Y0,
                  {
                    baseToken: n10,
                    quoteToken: i10,
                    baseAmount: l10 || "0",
                    quoteAmount: u10 || "0",
                    loading: false
                  }
                )
              }
            ),
            y && w.jsx("div", { style: { paddingBottom: "10px", color: "var(--cs-warning)" }, children: "High price difference. Be cautious before submitting your order." })
          ]
        }
      ),
      w.jsxs("div", { className: "swap-info-between", children: [
        w.jsx("div", { className: "left", children: "Slippage Tolerance" }),
        w.jsxs("div", { className: "right", children: [
          s10,
          "%"
        ] })
      ] }),
      w.jsx(
        Cw,
        {
          pl: "0px",
          pr: "0px",
          isLoading: false,
          amountLimit: p
        }
      ),
      w.jsx(Ew, { isLoading: false, routerData: a10, noTips: true }),
      x && w.jsxs("div", { style: { width: "100%", marginTop: "8px", gap: "1px" }, children: [
        w.jsx(
          "div",
          {
            style: {
              width: "100%",
              gap: "8px",
              fontSize: "12px",
              backgroundColor: "var(--cs-error-10)",
              paddingLeft: "16px",
              paddingRight: "16px",
              paddingTop: "8px",
              paddingBottom: "8px",
              borderRadius: "12px",
              color: "#ff5073"
            },
            children: "The exchange rate of this order deviates from the market price by a large percentage. Are you sure you want to continue the swap?"
          }
        ),
        w.jsxs(
          "div",
          {
            style: {
              width: "100%",
              gap: "16px",
              display: "flex",
              flexDirection: "row",
              marginTop: "-10px"
            },
            children: [
              w.jsx(
                "button",
                {
                  className: "swap-btn cs-outline-btn secondary-btn",
                  style: {
                    fontSize: "14px",
                    height: "42px",
                    flex: 1,
                    color: M ? "#72c1f7" : "#7F98A7"
                  },
                  onClick: () => {
                    O(true);
                  },
                  children: "Yes, please continue."
                }
              ),
              w.jsx(
                "button",
                {
                  className: "swap-btn cs-outline-btn secondary-btn",
                  style: {
                    fontSize: "14px",
                    height: "42px",
                    color: "#7F98A7",
                    flex: 1
                  },
                  onClick: () => e10(),
                  children: "No,cancel it."
                }
              )
            ]
          }
        )
      ] })
    ] }),
    !F && w.jsx(
      "button",
      {
        disabled: W || P,
        className: "swap-btn cs-solid-btn",
        style: { marginTop: "8px" },
        onClick: () => {
          P || (j(true), t10(a10));
        },
        children: P ? w.jsx(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              justifyContent: "center"
            },
            children: w.jsx(xw, {})
          }
        ) : "Confirm Swap"
      }
    ),
    F && w.jsxs("div", { className: "price-update", children: [
      w.jsxs("div", { className: "left", children: [
        w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-alert" }) }),
        w.jsx("span", { children: "Price update" })
      ] }),
      w.jsx("div", { className: "right", children: w.jsx("button", { className: "cs-solid-btn", onClick: B, children: "Accept" }) })
    ] })
  ] });
}
function lu(e10) {
  const { text: t10, type: r10 } = e10, [n10, i10] = (0, import_react25.useState)(false), { addCommonToast: o10 } = Bs(), s10 = (a10) => {
    n10 || (kl(a10), hw(t10, {
      debug: false,
      message: "message"
    }), o10("Copied"), i10(!n10));
  };
  return (0, import_react25.useEffect)(() => {
    n10 && setTimeout(() => {
      i10(false);
    }, 2e3);
  }, [n10]), w.jsx(w.Fragment, { children: r10 === "btn" ? w.jsxs("div", { className: "copy-btn", onClick: s10, children: [
    w.jsx("svg", { className: "cs-icon cs-copy-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: n10 ? "#icon-sel" : "#icon-copy" }) }),
    w.jsx("span", { children: "Copy" })
  ] }) : w.jsx(
    "svg",
    {
      className: "cs-icon cs-copy-icon",
      "aria-hidden": "true",
      onClick: s10,
      children: w.jsx("use", { xlinkHref: n10 ? "#icon-sel" : "#icon-copy" })
    }
  ) });
}
function tB({
  toBack: e10,
  data: t10,
  isLoading: r10
}) {
  const { fromCoin: n10, toCoin: i10, fromAmount: o10, toAmount: s10 } = an(), { fetchTokenInfo: a10 } = fo(), [c, l10] = (0, import_react25.useState)([]), u10 = async () => {
    var p;
    return await Promise.all(
      ((p = t10 == null ? void 0 : t10.routers) == null ? void 0 : p.map(async (y) => ({
        ...y,
        paths: await Promise.all(
          y.paths.map(async (x) => ({
            ...x,
            fromToken: await a10(x.from_type),
            // 加上 await
            toToken: await a10(x.to_type)
            // 加上 await
          }))
        )
      }))) || []
      // 如果 data?.routers 为 undefined，应返回空数组
    );
  };
  return (0, import_react25.useEffect)(() => {
    u10().then((d6) => {
      l10(d6);
    });
  }, [t10]), w.jsxs("div", { className: "route-dialog", children: [
    w.jsx(X0, { title: "Route", backClick: e10 }),
    w.jsxs("div", { className: "route-dialog-content", children: [
      w.jsx("div", { className: "simple-router-box", children: w.jsx(
        n6,
        {
          hasSubMenu: false,
          isLoading: r10,
          formatSwapRouter: t10
        }
      ) }),
      w.jsxs("div", { className: "center", style: { flexDirection: "column", gap: "0px" }, children: [
        w.jsxs("div", { className: "center", style: { gap: "4px", marginTop: "16px" }, children: [
          w.jsx(
            Xr,
            {
              src: n10 == null ? void 0 : n10.logo_url,
              style: { width: "26px", height: "26px", borderRadius: "100%" }
            }
          ),
          w.jsx("span", { className: "amount", children: Lr(o10, n10 == null ? void 0 : n10.decimals) }),
          w.jsx("span", { className: "symbol", children: n10 == null ? void 0 : n10.symbol })
        ] }),
        w.jsx("div", { className: "route-box-h5 center", children: w.jsx(
          "div",
          {
            style: {
              width: "100%",
              gap: "32px",
              border: "1px dashed #2a3238",
              borderRadius: "8px",
              display: "flex",
              flexDirection: "column",
              paddingTop: "20px",
              paddingBottom: "20px",
              overflowY: "auto",
              maxHeight: "280px",
              position: "relative"
            },
            children: c == null ? void 0 : c.map((d6, p) => w.jsxs("div", { className: "route-item-box-h5", children: [
              w.jsxs("div", { className: "percent", children: [
                Le(d6.percentage).mul(100).toString(),
                "%"
              ] }),
              w.jsx(
                "div",
                {
                  className: d6.paths.length > 1 ? "route-two-h5" : "",
                  style: {
                    width: "100%",
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: "8px"
                  },
                  children: d6.paths.map((y) => w.jsx("div", { className: "route-path-item", children: w.jsx(
                    _w,
                    {
                      autoSwitchTooltip: true,
                      position: "bottom",
                      content: w.jsxs(
                        "div",
                        {
                          className: "router-pool-tip-con",
                          style: {
                            display: "flex",
                            flexDirection: "column",
                            minWidth: "190px"
                          },
                          children: [
                            w.jsx(
                              nB,
                              {
                                poolAddress: y.pool_address
                              }
                            ),
                            w.jsx(Am, { token: y.fromToken }),
                            w.jsx(Am, { token: y.toToken })
                          ]
                        }
                      ),
                      children: w.jsx(rB, { path: y })
                    }
                  ) }, y.to_type))
                }
              )
            ] }, p))
          }
        ) }),
        w.jsxs("div", { className: "center", style: { gap: "4px" }, children: [
          w.jsx(
            Xr,
            {
              src: i10 == null ? void 0 : i10.logo_url,
              style: { width: "26px", height: "26px", borderRadius: "100%" }
            }
          ),
          w.jsx("span", { className: "amount", children: Lr(s10, i10 == null ? void 0 : i10.decimals) }),
          w.jsx("span", { className: "symbol", children: i10 == null ? void 0 : i10.symbol })
        ] })
      ] })
    ] })
  ] });
}
function rB({ path: e10 }) {
  var t10, r10, n10;
  return w.jsxs(
    "div",
    {
      role: "button",
      style: {
        display: "flex",
        flexDirection: "row",
        gap: "0px",
        zIndex: 3
      },
      children: [
        w.jsxs("div", { style: { display: "flex", flexDirection: "row" }, children: [
          w.jsx(
            Xr,
            {
              src: (t10 = e10.fromToken) == null ? void 0 : t10.logo_url,
              style: { width: "24px", height: "24px", borderRadius: "100%" }
            }
          ),
          w.jsx(
            Xr,
            {
              src: (r10 = e10.toToken) == null ? void 0 : r10.logo_url,
              style: { width: "24px", height: "24px", borderRadius: "100%" }
            }
          )
        ] }),
        w.jsxs("span", { className: "provider", children: [
          (n10 = Ib[e10.provider]) == null ? void 0 : n10.name,
          " "
        ] }),
        !!+e10.fee_rate && w.jsxs("div", { className: "fee-tier", children: [
          " ",
          Le(e10.fee_rate).mul(100).toString(),
          "%"
        ] })
      ]
    }
  );
}
function Am({ token: e10 }) {
  const { getExplorerUrl: t10 } = Rs();
  return w.jsxs(
    "div",
    {
      style: {
        width: "100%",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        height: "40px",
        fontSize: "12px",
        gap: "12px"
      },
      children: [
        w.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "8px",
              flexShrink: 0
            },
            children: [
              w.jsx(
                Xr,
                {
                  src: e10 == null ? void 0 : e10.logo_url,
                  style: {
                    width: "20px",
                    height: "20px",
                    borderRadius: "100%"
                  }
                }
              ),
              w.jsx("span", { style: { color: "#fff", fontSize: "12px" }, children: mn((e10 == null ? void 0 : e10.symbol) || "") })
            ]
          }
        ),
        w.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              alignItems: "center"
            },
            children: [
              w.jsx(
                "a",
                {
                  onClick: kl,
                  href: t10(e10 == null ? void 0 : e10.coin_type, "coin"),
                  target: "_blank",
                  style: {
                    textDecoration: "none",
                    color: "#909ca4"
                  },
                  children: Do(e10 == null ? void 0 : e10.coin_type)
                }
              ),
              w.jsx(lu, { text: (e10 == null ? void 0 : e10.coin_type) || "" })
            ]
          }
        )
      ]
    }
  );
}
function nB({ poolAddress: e10 }) {
  const { getExplorerUrl: t10 } = Rs();
  return w.jsxs(w.Fragment, { children: [
    e10 && w.jsxs(
      "div",
      {
        style: {
          width: "100%",
          display: "flex",
          justifyContent: "space-between",
          fontSize: "12px",
          gap: "12px"
        },
        children: [
          w.jsx("span", { style: { color: "fff", fontSize: "12px" }, children: "Pool" }),
          w.jsxs(
            "div",
            {
              style: {
                display: "flex",
                flexDirection: "row",
                alignItems: "center"
              },
              children: [
                w.jsx(
                  "a",
                  {
                    style: { color: "#fff", textDecoration: "none" },
                    onClick: kl,
                    href: t10(e10, "poolAddress"),
                    target: "_blank",
                    children: Do(e10)
                  }
                ),
                w.jsx(lu, { text: e10 })
              ]
            }
          )
        ]
      }
    ),
    e10 && w.jsx(
      "div",
      {
        style: {
          width: "100%",
          height: "1px",
          marginTop: "12px",
          backgroundColor: "var(--cs-border)"
        }
      }
    )
  ] });
}
function n6({
  hasSubMenu: e10,
  isLoading: t10,
  formatSwapRouter: r10
}) {
  var d6;
  const [n10, i10] = (0, import_react25.useState)(false), { isApp: o10 } = eu(), { fetchTokenInfo: s10 } = fo(), a10 = (0, import_react25.useMemo)(() => (r10 == null ? void 0 : r10.routers.length) === 1, [r10 == null ? void 0 : r10.routers.length]), [c, l10] = (0, import_react25.useState)(""), u10 = async () => {
    var b, M;
    const p = [], y = ((M = (b = r10 == null ? void 0 : r10.routers) == null ? void 0 : b[0]) == null ? void 0 : M.paths) || [];
    for (let O = 0; O < y.length; O++) {
      const P = y[O], j = await s10(P == null ? void 0 : P.to_type);
      if (O === 0) {
        const F = await s10(P == null ? void 0 : P.from_type);
        p.push(`${F == null ? void 0 : F.symbol} > ${j == null ? void 0 : j.symbol}`);
      } else
        p.push(j == null ? void 0 : j.symbol);
    }
    const x = p.join(" > ");
    l10(x);
  };
  return (0, import_react25.useEffect)(() => {
    a10 && u10();
  }, [a10]), w.jsxs(
    "div",
    {
      className: "simple-router-block",
      style: {
        paddingLeft: e10 ? "8px" : "0px",
        paddingRight: e10 ? "8px" : "0px"
      },
      children: [
        w.jsx(
          "div",
          {
            className: "left",
            style: {
              whiteSpace: "nowrap",
              color: e10 ? "var(--cs-text-con)" : "#fff",
              paddingRight: "8px"
            },
            children: e10 ? "Auto Router" : "Route"
          }
        ),
        t10 ? w.jsx(Ls, { style: { width: "80px", height: "18px" } }) : w.jsxs(
          "div",
          {
            className: "right",
            onClick: () => {
              i10(true);
            },
            children: [
              w.jsx("span", { style: { textAlign: "right", color: "#fff" }, children: a10 ? c : r10 == null ? void 0 : r10.router_summery }),
              w.jsxs("div", { className: "providers", children: [
                (d6 = r10 == null ? void 0 : r10.providers) == null ? void 0 : d6.map((p, y) => {
                  var x;
                  return o10 ? w.jsx(
                    Xr,
                    {
                      src: nr[p],
                      style: { width: "16px", height: "16px" }
                    }
                  ) : w.jsx(
                    tu,
                    {
                      content: w.jsx("div", { children: ((x = Ib[p]) == null ? void 0 : x.name) || p }),
                      position: "top",
                      delay: 300,
                      children: w.jsx(
                        Xr,
                        {
                          src: nr[p],
                          style: { width: "16px", height: "16px" }
                        }
                      )
                    },
                    p
                  );
                }),
                e10 && w.jsx(
                  "svg",
                  {
                    className: "cs-icon",
                    "aria-hidden": "true",
                    style: { width: "16px", height: "16px", flexShrink: 0 },
                    children: w.jsx("use", { xlinkHref: "#icon-spread" })
                  }
                )
              ] })
            ]
          }
        ),
        n10 && e10 && w.jsx(
          tB,
          {
            data: r10,
            isLoading: t10,
            toBack: () => i10(false)
          }
        )
      ]
    }
  );
}
var Ka = ki((e10, t10) => ({
  currentTypeTab: "Default",
  setCurrentTypeTab: (r10) => {
    e10(() => ({
      currentTypeTab: r10
    }));
  },
  currentPlatformTab: "All",
  setCurrentPlatformTab: (r10) => {
    e10(() => ({
      currentPlatformTab: r10
    }));
  },
  //platformList: ["All", "Native", "Wormhole", "Celer"],
  platformList: ["All", "Wormhole"],
  setPlatformList: (r10) => {
    e10(() => ({
      platformList: r10
    }));
  },
  isOpenImportDialog: false,
  setIsOpenImportDialog: (r10) => {
    e10(() => ({
      isOpenImportDialog: r10
    }));
  },
  collectTokenMap: /* @__PURE__ */ new Map(),
  setCollectTokenMap: (r10, n10 = false) => {
    e10(() => ({
      collectTokenMap: r10
    })), n10 || Ti.setItem(Cb, r10);
  },
  showTokenList: [],
  setShowTokenList: (r10) => {
    e10(() => ({
      showTokenList: [...r10]
    }));
  },
  combineTokenList: [],
  setComBineTokenList: (r10) => {
    e10(() => ({
      combineTokenList: r10
    }));
  },
  currentImportTokenData: void 0,
  setCurrentImportTokenData: (r10) => {
    e10(() => ({
      currentImportTokenData: r10
    }));
  },
  importTokenList: [],
  importTokenIsLoading: false,
  setImportToken: (r10, n10) => {
    const { importTokenList: i10, setImportTokenList: o10 } = t10();
    let s10 = i10;
    if (n10)
      s10 = [r10, ...s10];
    else {
      const a10 = cp(r10.coin_type);
      s10 = i10.filter(
        (c) => cp(c.coin_type) !== a10
      );
    }
    return o10(s10), Ti.setItem(Tb, s10), s10;
  },
  setImportTokenList: (r10) => {
    e10(() => ({
      importTokenList: r10
    }));
  },
  setImportTokenIsLoading: (r10) => {
    e10(() => ({
      importTokenIsLoading: r10
    }));
  },
  searchInput: "",
  setSearchInput: (r10) => {
    e10(() => ({
      searchInput: r10
    }));
  },
  showTokenListIsLoading: false,
  setShowTokenListIsLoading: (r10) => {
    e10(() => ({
      showTokenListIsLoading: r10
    }));
  }
}));
Ti.getItem(Cb).then(
  (e10) => {
    e10 !== null && Ka.getState().setCollectTokenMap(e10, true);
  }
);
Ti.getItem(Tb).then((e10) => {
  e10 && Ka.getState().setImportTokenList(e10);
});
function i6() {
  const { setCollectTokenMap: e10, collectTokenMap: t10 } = Ka(), r10 = (i10) => {
    const o10 = new Map(t10);
    o10.get(i10.coin_type) ? o10.delete(i10.coin_type) : o10.set(i10.coin_type, i10), e10(o10);
  }, n10 = (0, import_react25.useCallback)((i10) => t10.get(i10.coin_type) !== void 0, [t10]);
  return {
    handleCollectToken: r10,
    isCollectToken: n10,
    collectTokenMap: t10
  };
}
function iB(e10) {
  const { trustedTokenList: t10 } = Wa(), { tokenBalanceObj: r10, currentAccount: n10 } = Zr(), { coinPriceObj: i10 } = mw(), { getTokenAmountValue: o10 } = Ha(), { fetchTokenInfo: s10 } = fo(), {
    currentTypeTab: a10,
    showTokenList: c,
    setShowTokenList: l10,
    combineTokenList: u10,
    importTokenList: d6,
    setComBineTokenList: p,
    setImportToken: y,
    setCurrentImportTokenData: x,
    setImportTokenIsLoading: b,
    currentImportTokenData: M,
    searchInput: O,
    setSearchInput: P,
    importTokenIsLoading: j,
    showTokenListIsLoading: F,
    setCurrentTypeTab: B,
    setCurrentPlatformTab: W
  } = Ka(), [z, G] = (0, import_react25.useState)(false);
  (0, import_react25.useEffect)(() => {
    t10 && (t10 == null ? void 0 : t10.length) > 0 && G(true);
  }, [t10]);
  const [re, ie] = (0, import_react25.useState)(false);
  (0, import_react25.useEffect)(() => {
    vp(i10) || ie(true);
  }, [i10]);
  const oe = (0, import_react25.useRef)({}), [q, L] = (0, import_react25.useState)(false);
  (0, import_react25.useEffect)(() => {
    (!vp(r10) || !p0(oe.current, r10)) && (oe.current = r10, L(true));
  }, [r10]);
  const h = (0, import_react25.useMemo)(() => (d6 == null ? void 0 : d6.length) > 1 ? d6 == null ? void 0 : d6.map((Q) => {
    const Z = Tc(
      r10 == null ? void 0 : r10[Q == null ? void 0 : Q.coin_type],
      Q
    ), ae = Z == null ? void 0 : Z.totalBalanceFormat, ve = Le(ae).gt("0") ? o10(Q == null ? void 0 : Q.coin_type, ae) : "0";
    return {
      ...Q,
      balance: ae,
      rate: ve
    };
  }) : d6, [d6, r10, i10]), f = (Q, Z) => {
    const ae = Z && Z.toLocaleLowerCase().trim(), ve = Q.map((he) => {
      let De = 0, Te = 0;
      he.symbol.toLowerCase() === ae || he.name.toLowerCase() === ae || he.coin_type.toLowerCase() === ae ? (De = 1e3, Te = 2) : he.symbol.toLowerCase().indexOf(ae) > -1 ? (De = 100, Te = 0) : he.name.toLowerCase().indexOf(ae) > -1 ? (De = 10, Te = 0) : he.coin_type.toLowerCase().indexOf(ae) > -1 ? (De = 1, Te = 0) : he.coin_type.toLowerCase() == "0x2::sui::sui" && (Te = 1);
      let Xe = Array.isArray(he == null ? void 0 : he.coin_priority) ? Number(he.coin_priority[0]) || 0 : Number(he == null ? void 0 : he.coin_priority) || 0;
      return e10 === he.coin_type && !Z && (Te = 12, De = 1e3, Xe = 1e4), {
        ...he,
        mark: De,
        sort: Te,
        coin_priority_sort: Xe,
        rateNumber: Number((he == null ? void 0 : he.rate) || "0"),
        balanceNumber: Number((he == null ? void 0 : he.balance) || "0")
      };
    });
    return QL(
      ve,
      [
        (he) => !Z && e10 === he.coin_type ? 1 : 0,
        // 当前 token 优先
        "rateNumber",
        "balanceNumber",
        "sort",
        "mark",
        "coin_priority_sort"
      ],
      ["desc", "desc", "desc", "desc", "desc", "desc"]
    );
  }, m = (Q, Z = false) => {
    const ae = Z ? Q.trim() : Q.toLowerCase().trim(), ve = ["symbol", "name", "coin_type"];
    return WL(
      ae.length === 0 ? u10 : [...u10, ...h],
      (he) => ve.some((De) => {
        const Te = he[De];
        if (typeof Te == "string") {
          const Xe = Z ? Te : Te.toLowerCase();
          return De === "coin_type" ? Xe.includes(ae) || Oi(Xe, true).includes(
            Oi(ae, true)
          ) : Xe.includes(ae);
        }
        return false;
      })
    );
  }, S = (Q) => {
    Q || x(void 0);
    const Z = m(Q);
    if ((Z == null ? void 0 : Z.length) === 0) {
      T(Q);
      return;
    } else {
      const ae = f(Z, Q);
      l10(ae);
    }
  }, T = async (Q) => {
    b(true);
    try {
      if (_b2(Q)) {
        const Z = Q.trim(), ae = Br(Z).full_address, ve = await s10(ae);
        if (!ve) {
          l10([]);
          return;
        }
        const we = Tc(
          r10 == null ? void 0 : r10[ae],
          ve
        ), he = (we == null ? void 0 : we.totalBalanceFormat) || "0", De = Le(he).gt("0") ? o10(Z, he) : "0", Te = {
          ...ve,
          balance: he,
          rate: De
        };
        l10([Te]), x(Te);
      } else {
        l10([]);
        return;
      }
    } catch {
      x(void 0), l10([]);
      return;
    } finally {
      b(false);
    }
  }, E = (Q) => {
    if (Q === "Default")
      g("All"), W("All");
    else {
      const Z = f(
        h,
        O
      );
      l10(Z);
    }
  }, I = () => {
    if (M) {
      const Q = y(M, true), Z = f(Q, O);
      l10(Z), x(void 0), P("");
    }
  }, C = (Q) => {
    const Z = y(Q, false), ae = f(Z, O);
    l10(ae);
  }, g = (Q) => {
    const Z = Q === "All" ? [...u10] : u10.filter((ve) => Q == "Native" ? !ve.labels || ve.labels.length == 0 || ve.labels == "Native" : ve.labels && ve.labels.length > 0 && ve.labels[0].toLowerCase() == Q.toLowerCase()), ae = f(Z, O);
    l10(ae);
  };
  (0, import_react25.useEffect)(() => {
    if (!z || !(t10 != null && t10.length)) {
      p([]);
      return;
    }
    if (!(n10 != null && n10.address))
      p(t10);
    else if (n10 != null && n10.address) {
      const Q = [];
      for (const Z of t10) {
        const ae = r10 == null ? void 0 : r10[Z == null ? void 0 : Z.coin_type], ve = Tc(ae, Z), we = (ve == null ? void 0 : ve.totalBalanceFormat) || "0", he = (ve == null ? void 0 : ve.displayBalance) || "0", De = Le(we).gt("0") ? o10(Z == null ? void 0 : Z.coin_type, we) : "0";
        Q.push({
          ...Z,
          balance: he,
          rate: Lr(De, 4, true)
        });
      }
      p(Q);
    }
  }, [
    z,
    re,
    q,
    n10 == null ? void 0 : n10.address,
    i10
  ]);
  const v10 = (0, import_react25.useRef)([]);
  (0, import_react25.useEffect)(() => {
    if ((u10 == null ? void 0 : u10.length) > 0 && !KL(v10.current, u10)) {
      v10.current = u10;
      const Q = f(u10);
      e10 ? h.find(
        (ae) => ae.coin_type === e10
      ) !== void 0 || a10 !== "Default" ? (B("Imported"), E("Imported")) : l10(M ? [M] : Q) : l10(Q);
    }
  }, [u10, e10]);
  const k = (0, import_react25.useMemo)(() => {
    if (a10 === "Default") {
      if (!F && (c == null ? void 0 : c.length) === 0)
        return true;
    } else if ((c == null ? void 0 : c.length) === 0 && !j)
      return true;
    return false;
  }, [
    O,
    c,
    M,
    j,
    F
  ]);
  return {
    showTokenList: c,
    handleSearch: S,
    handleChangePlatform: g,
    currentImportTokenData: M,
    handleChangeType: E,
    handleImportClick: I,
    handleDeleteImportClick: C,
    isNoData: k
  };
}
function oB({
  tokenList: e10,
  onHandleTokenAction: t10
}) {
  return w.jsx("div", { className: "token-collect-list", children: e10.map((r10) => w.jsx(
    sB,
    {
      token: r10,
      onHandleTokenAction: t10
    },
    r10.coin_type
  )) });
}
function sB({
  token: e10,
  onHandleTokenAction: t10
}) {
  return w.jsxs(
    "div",
    {
      className: "token-collect-item",
      onClick: () => {
        t10(e10, "select_token");
      },
      children: [
        w.jsx("img", { src: e10.logo_url, style: { marginRight: "8px" } }),
        w.jsx("span", { children: e10.symbol }),
        w.jsx("i", { children: w.jsx(
          "svg",
          {
            className: "cs-icon",
            "aria-hidden": "true",
            onClick: (r10) => {
              r10.stopPropagation(), t10(e10, "un_collect");
            },
            children: w.jsx("use", { xlinkHref: "#icon-close" })
          }
        ) })
      ]
    }
  );
}
var aB = At("/images/img_no_data@2x.png");
function cB(e10) {
  const {
    img: t10 = aB,
    text: r10,
    width: n10 = "100%",
    height: i10 = "auto",
    padding: o10 = "20px",
    subItem: s10
  } = e10;
  return w.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: n10,
        height: i10,
        padding: o10,
        boxSizing: "border-box",
        textAlign: "center"
      },
      children: [
        t10 && w.jsx(
          "img",
          {
            src: t10,
            alt: "No Data",
            style: {
              width: "160px",
              height: "160px"
            }
          }
        ),
        r10 && w.jsx("div", { style: { color: "#fff", fontSize: "14px" }, children: r10 }),
        s10 && s10
      ]
    }
  );
}
function lB({
  tabList: e10,
  currentTab: t10,
  changeTab: r10
}) {
  return w.jsx("div", { className: "platform-tabs", children: e10.map((n10) => w.jsx(
    "div",
    {
      className: t10 === n10 ? "platform-tab-item active" : "platform-tab-item",
      onClick: () => {
        r10(n10);
      },
      children: n10
    },
    n10
  )) });
}
var Mm = Number.isNaN || function(t10) {
  return typeof t10 == "number" && t10 !== t10;
};
function uB(e10, t10) {
  return !!(e10 === t10 || Mm(e10) && Mm(t10));
}
function fB(e10, t10) {
  if (e10.length !== t10.length)
    return false;
  for (var r10 = 0; r10 < e10.length; r10++)
    if (!uB(e10[r10], t10[r10]))
      return false;
  return true;
}
function dB(e10, t10) {
  t10 === void 0 && (t10 = fB);
  var r10 = null;
  function n10() {
    for (var i10 = [], o10 = 0; o10 < arguments.length; o10++)
      i10[o10] = arguments[o10];
    if (r10 && r10.lastThis === this && t10(i10, r10.lastArgs))
      return r10.lastResult;
    var s10 = e10.apply(this, i10);
    return r10 = {
      lastResult: s10,
      lastArgs: i10,
      lastThis: this
    }, s10;
  }
  return n10.clear = function() {
    r10 = null;
  }, n10;
}
function dd() {
  return dd = Object.assign ? Object.assign.bind() : function(e10) {
    for (var t10 = 1; t10 < arguments.length; t10++) {
      var r10 = arguments[t10];
      for (var n10 in r10)
        ({}).hasOwnProperty.call(r10, n10) && (e10[n10] = r10[n10]);
    }
    return e10;
  }, dd.apply(null, arguments);
}
function Im(e10) {
  if (e10 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e10;
}
function hd(e10, t10) {
  return hd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r10, n10) {
    return r10.__proto__ = n10, r10;
  }, hd(e10, t10);
}
function hB(e10, t10) {
  e10.prototype = Object.create(t10.prototype), e10.prototype.constructor = e10, hd(e10, t10);
}
var Om = Number.isNaN || function(t10) {
  return typeof t10 == "number" && t10 !== t10;
};
function pB(e10, t10) {
  return !!(e10 === t10 || Om(e10) && Om(t10));
}
function mB(e10, t10) {
  if (e10.length !== t10.length)
    return false;
  for (var r10 = 0; r10 < e10.length; r10++)
    if (!pB(e10[r10], t10[r10]))
      return false;
  return true;
}
function uf(e10, t10) {
  t10 === void 0 && (t10 = mB);
  var r10, n10 = [], i10, o10 = false;
  function s10() {
    for (var a10 = [], c = 0; c < arguments.length; c++)
      a10[c] = arguments[c];
    return o10 && r10 === this && t10(a10, n10) || (i10 = e10.apply(this, a10), o10 = true, r10 = this, n10 = a10), i10;
  }
  return s10;
}
function Rm(e10, t10) {
  if (e10 == null)
    return {};
  var r10 = {};
  for (var n10 in e10)
    if ({}.hasOwnProperty.call(e10, n10)) {
      if (t10.indexOf(n10) !== -1)
        continue;
      r10[n10] = e10[n10];
    }
  return r10;
}
var gB = typeof performance == "object" && typeof performance.now == "function";
var Pm = gB ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function Nm(e10) {
  cancelAnimationFrame(e10.id);
}
function vB(e10, t10) {
  var r10 = Pm();
  function n10() {
    Pm() - r10 >= t10 ? e10.call(null) : i10.id = requestAnimationFrame(n10);
  }
  var i10 = {
    id: requestAnimationFrame(n10)
  };
  return i10;
}
var ff = -1;
function jm(e10) {
  if (e10 === void 0 && (e10 = false), ff === -1 || e10) {
    var t10 = document.createElement("div"), r10 = t10.style;
    r10.width = "50px", r10.height = "50px", r10.overflow = "scroll", document.body.appendChild(t10), ff = t10.offsetWidth - t10.clientWidth, document.body.removeChild(t10);
  }
  return ff;
}
var ns = null;
function km(e10) {
  if (e10 === void 0 && (e10 = false), ns === null || e10) {
    var t10 = document.createElement("div"), r10 = t10.style;
    r10.width = "50px", r10.height = "50px", r10.overflow = "scroll", r10.direction = "rtl";
    var n10 = document.createElement("div"), i10 = n10.style;
    return i10.width = "100px", i10.height = "100px", t10.appendChild(n10), document.body.appendChild(t10), t10.scrollLeft > 0 ? ns = "positive-descending" : (t10.scrollLeft = 1, t10.scrollLeft === 0 ? ns = "negative" : ns = "positive-ascending"), document.body.removeChild(t10), ns;
  }
  return ns;
}
Rn.env.NODE_ENV;
var bB = 150;
var yB = function(t10, r10) {
  return t10;
};
var Ic = null;
var Oc = null;
Rn.env.NODE_ENV !== "production" && typeof window < "u" && typeof window.WeakSet < "u" && (Ic = /* @__PURE__ */ new WeakSet(), Oc = /* @__PURE__ */ new WeakSet());
function wB(e10) {
  var t10, r10 = e10.getItemOffset, n10 = e10.getEstimatedTotalSize, i10 = e10.getItemSize, o10 = e10.getOffsetForIndexAndAlignment, s10 = e10.getStartIndexForOffset, a10 = e10.getStopIndexForStartIndex, c = e10.initInstanceProps, l10 = e10.shouldResetStyleCacheOnItemSizeChange, u10 = e10.validateProps;
  return t10 = function(d6) {
    hB(p, d6);
    function p(x) {
      var b;
      return b = d6.call(this, x) || this, b._instanceProps = c(b.props, Im(b)), b._outerRef = void 0, b._resetIsScrollingTimeoutId = null, b.state = {
        instance: Im(b),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof b.props.initialScrollOffset == "number" ? b.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      }, b._callOnItemsRendered = void 0, b._callOnItemsRendered = uf(function(M, O, P, j) {
        return b.props.onItemsRendered({
          overscanStartIndex: M,
          overscanStopIndex: O,
          visibleStartIndex: P,
          visibleStopIndex: j
        });
      }), b._callOnScroll = void 0, b._callOnScroll = uf(function(M, O, P) {
        return b.props.onScroll({
          scrollDirection: M,
          scrollOffset: O,
          scrollUpdateWasRequested: P
        });
      }), b._getItemStyle = void 0, b._getItemStyle = function(M) {
        var O = b.props, P = O.direction, j = O.itemSize, F = O.layout, B = b._getItemStyleCache(l10 && j, l10 && F, l10 && P), W;
        if (B.hasOwnProperty(M))
          W = B[M];
        else {
          var z = r10(b.props, M, b._instanceProps), G = i10(b.props, M, b._instanceProps), re = P === "horizontal" || F === "horizontal", ie = P === "rtl", oe = re ? z : 0;
          B[M] = W = {
            position: "absolute",
            left: ie ? void 0 : oe,
            right: ie ? oe : void 0,
            top: re ? 0 : z,
            height: re ? "100%" : G,
            width: re ? G : "100%"
          };
        }
        return W;
      }, b._getItemStyleCache = void 0, b._getItemStyleCache = uf(function(M, O, P) {
        return {};
      }), b._onScrollHorizontal = function(M) {
        var O = M.currentTarget, P = O.clientWidth, j = O.scrollLeft, F = O.scrollWidth;
        b.setState(function(B) {
          if (B.scrollOffset === j)
            return null;
          var W = b.props.direction, z = j;
          if (W === "rtl")
            switch (km()) {
              case "negative":
                z = -j;
                break;
              case "positive-descending":
                z = F - P - j;
                break;
            }
          return z = Math.max(0, Math.min(z, F - P)), {
            isScrolling: true,
            scrollDirection: B.scrollOffset < z ? "forward" : "backward",
            scrollOffset: z,
            scrollUpdateWasRequested: false
          };
        }, b._resetIsScrollingDebounced);
      }, b._onScrollVertical = function(M) {
        var O = M.currentTarget, P = O.clientHeight, j = O.scrollHeight, F = O.scrollTop;
        b.setState(function(B) {
          if (B.scrollOffset === F)
            return null;
          var W = Math.max(0, Math.min(F, j - P));
          return {
            isScrolling: true,
            scrollDirection: B.scrollOffset < W ? "forward" : "backward",
            scrollOffset: W,
            scrollUpdateWasRequested: false
          };
        }, b._resetIsScrollingDebounced);
      }, b._outerRefSetter = function(M) {
        var O = b.props.outerRef;
        b._outerRef = M, typeof O == "function" ? O(M) : O != null && typeof O == "object" && O.hasOwnProperty("current") && (O.current = M);
      }, b._resetIsScrollingDebounced = function() {
        b._resetIsScrollingTimeoutId !== null && Nm(b._resetIsScrollingTimeoutId), b._resetIsScrollingTimeoutId = vB(b._resetIsScrolling, bB);
      }, b._resetIsScrolling = function() {
        b._resetIsScrollingTimeoutId = null, b.setState({
          isScrolling: false
        }, function() {
          b._getItemStyleCache(-1, null);
        });
      }, b;
    }
    p.getDerivedStateFromProps = function(b, M) {
      return xB(b, M), u10(b), null;
    };
    var y = p.prototype;
    return y.scrollTo = function(b) {
      b = Math.max(0, b), this.setState(function(M) {
        return M.scrollOffset === b ? null : {
          scrollDirection: M.scrollOffset < b ? "forward" : "backward",
          scrollOffset: b,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    }, y.scrollToItem = function(b, M) {
      M === void 0 && (M = "auto");
      var O = this.props, P = O.itemCount, j = O.layout, F = this.state.scrollOffset;
      b = Math.max(0, Math.min(b, P - 1));
      var B = 0;
      if (this._outerRef) {
        var W = this._outerRef;
        j === "vertical" ? B = W.scrollWidth > W.clientWidth ? jm() : 0 : B = W.scrollHeight > W.clientHeight ? jm() : 0;
      }
      this.scrollTo(o10(this.props, b, M, F, this._instanceProps, B));
    }, y.componentDidMount = function() {
      var b = this.props, M = b.direction, O = b.initialScrollOffset, P = b.layout;
      if (typeof O == "number" && this._outerRef != null) {
        var j = this._outerRef;
        M === "horizontal" || P === "horizontal" ? j.scrollLeft = O : j.scrollTop = O;
      }
      this._callPropsCallbacks();
    }, y.componentDidUpdate = function() {
      var b = this.props, M = b.direction, O = b.layout, P = this.state, j = P.scrollOffset, F = P.scrollUpdateWasRequested;
      if (F && this._outerRef != null) {
        var B = this._outerRef;
        if (M === "horizontal" || O === "horizontal")
          if (M === "rtl")
            switch (km()) {
              case "negative":
                B.scrollLeft = -j;
                break;
              case "positive-ascending":
                B.scrollLeft = j;
                break;
              default:
                var W = B.clientWidth, z = B.scrollWidth;
                B.scrollLeft = z - W - j;
                break;
            }
          else
            B.scrollLeft = j;
        else
          B.scrollTop = j;
      }
      this._callPropsCallbacks();
    }, y.componentWillUnmount = function() {
      this._resetIsScrollingTimeoutId !== null && Nm(this._resetIsScrollingTimeoutId);
    }, y.render = function() {
      var b = this.props, M = b.children, O = b.className, P = b.direction, j = b.height, F = b.innerRef, B = b.innerElementType, W = b.innerTagName, z = b.itemCount, G = b.itemData, re = b.itemKey, ie = re === void 0 ? yB : re, oe = b.layout, q = b.outerElementType, L = b.outerTagName, h = b.style, f = b.useIsScrolling, m = b.width, S = this.state.isScrolling, T = P === "horizontal" || oe === "horizontal", E = T ? this._onScrollHorizontal : this._onScrollVertical, I = this._getRangeToRender(), C = I[0], g = I[1], v10 = [];
      if (z > 0)
        for (var k = C; k <= g; k++)
          v10.push((0, import_react25.createElement)(M, {
            data: G,
            key: ie(k, G),
            index: k,
            isScrolling: f ? S : void 0,
            style: this._getItemStyle(k)
          }));
      var Q = n10(this.props, this._instanceProps);
      return (0, import_react25.createElement)(q || L || "div", {
        className: O,
        onScroll: E,
        ref: this._outerRefSetter,
        style: dd({
          position: "relative",
          height: j,
          width: m,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction: P
        }, h)
      }, (0, import_react25.createElement)(B || W || "div", {
        children: v10,
        ref: F,
        style: {
          height: T ? "100%" : Q,
          pointerEvents: S ? "none" : void 0,
          width: T ? Q : "100%"
        }
      }));
    }, y._callPropsCallbacks = function() {
      if (typeof this.props.onItemsRendered == "function") {
        var b = this.props.itemCount;
        if (b > 0) {
          var M = this._getRangeToRender(), O = M[0], P = M[1], j = M[2], F = M[3];
          this._callOnItemsRendered(O, P, j, F);
        }
      }
      if (typeof this.props.onScroll == "function") {
        var B = this.state, W = B.scrollDirection, z = B.scrollOffset, G = B.scrollUpdateWasRequested;
        this._callOnScroll(W, z, G);
      }
    }, y._getRangeToRender = function() {
      var b = this.props, M = b.itemCount, O = b.overscanCount, P = this.state, j = P.isScrolling, F = P.scrollDirection, B = P.scrollOffset;
      if (M === 0)
        return [0, 0, 0, 0];
      var W = s10(this.props, B, this._instanceProps), z = a10(this.props, W, B, this._instanceProps), G = !j || F === "backward" ? Math.max(1, O) : 1, re = !j || F === "forward" ? Math.max(1, O) : 1;
      return [Math.max(0, W - G), Math.max(0, Math.min(M - 1, z + re)), W, z];
    }, p;
  }(import_react25.PureComponent), t10.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, t10;
}
var xB = function(t10, r10) {
  var n10 = t10.children, i10 = t10.direction, o10 = t10.height, s10 = t10.layout, a10 = t10.innerTagName, c = t10.outerTagName, l10 = t10.width, u10 = r10.instance;
  if (Rn.env.NODE_ENV !== "production") {
    (a10 != null || c != null) && Oc && !Oc.has(u10) && (Oc.add(u10), console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead."));
    var d6 = i10 === "horizontal" || s10 === "horizontal";
    switch (i10) {
      case "horizontal":
      case "vertical":
        Ic && !Ic.has(u10) && (Ic.add(u10), console.warn('The direction prop should be either "ltr" (default) or "rtl". Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.'));
        break;
      case "ltr":
      case "rtl":
        break;
      default:
        throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". ' + ('"' + i10 + '" was specified.'));
    }
    switch (s10) {
      case "horizontal":
      case "vertical":
        break;
      default:
        throw Error('An invalid "layout" prop has been specified. Value should be either "horizontal" or "vertical". ' + ('"' + s10 + '" was specified.'));
    }
    if (n10 == null)
      throw Error('An invalid "children" prop has been specified. Value should be a React component. ' + ('"' + (n10 === null ? "null" : typeof n10) + '" was specified.'));
    if (d6 && typeof l10 != "number")
      throw Error('An invalid "width" prop has been specified. Horizontal lists must specify a number for width. ' + ('"' + (l10 === null ? "null" : typeof l10) + '" was specified.'));
    if (!d6 && typeof o10 != "number")
      throw Error('An invalid "height" prop has been specified. Vertical lists must specify a number for height. ' + ('"' + (o10 === null ? "null" : typeof o10) + '" was specified.'));
  }
};
var SB = wB({
  getItemOffset: function(t10, r10) {
    var n10 = t10.itemSize;
    return r10 * n10;
  },
  getItemSize: function(t10, r10) {
    var n10 = t10.itemSize;
    return n10;
  },
  getEstimatedTotalSize: function(t10) {
    var r10 = t10.itemCount, n10 = t10.itemSize;
    return n10 * r10;
  },
  getOffsetForIndexAndAlignment: function(t10, r10, n10, i10, o10, s10) {
    var a10 = t10.direction, c = t10.height, l10 = t10.itemCount, u10 = t10.itemSize, d6 = t10.layout, p = t10.width, y = a10 === "horizontal" || d6 === "horizontal", x = y ? p : c, b = Math.max(0, l10 * u10 - x), M = Math.min(b, r10 * u10), O = Math.max(0, r10 * u10 - x + u10 + s10);
    switch (n10 === "smart" && (i10 >= O - x && i10 <= M + x ? n10 = "auto" : n10 = "center"), n10) {
      case "start":
        return M;
      case "end":
        return O;
      case "center": {
        var P = Math.round(O + (M - O) / 2);
        return P < Math.ceil(x / 2) ? 0 : P > b + Math.floor(x / 2) ? b : P;
      }
      case "auto":
      default:
        return i10 >= O && i10 <= M ? i10 : i10 < O ? O : M;
    }
  },
  getStartIndexForOffset: function(t10, r10) {
    var n10 = t10.itemCount, i10 = t10.itemSize;
    return Math.max(0, Math.min(n10 - 1, Math.floor(r10 / i10)));
  },
  getStopIndexForStartIndex: function(t10, r10, n10) {
    var i10 = t10.direction, o10 = t10.height, s10 = t10.itemCount, a10 = t10.itemSize, c = t10.layout, l10 = t10.width, u10 = i10 === "horizontal" || c === "horizontal", d6 = r10 * a10, p = u10 ? l10 : o10, y = Math.ceil((p + n10 - d6) / a10);
    return Math.max(0, Math.min(
      s10 - 1,
      r10 + y - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function(t10) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function(t10) {
    var r10 = t10.itemSize;
    if (Rn.env.NODE_ENV !== "production" && typeof r10 != "number")
      throw Error('An invalid "itemSize" prop has been specified. Value should be a number. ' + ('"' + (r10 === null ? "null" : typeof r10) + '" was specified.'));
  }
});
function Dm(e10, t10) {
  for (var r10 in e10)
    if (!(r10 in t10))
      return true;
  for (var n10 in t10)
    if (e10[n10] !== t10[n10])
      return true;
  return false;
}
var _B = ["style"];
var EB = ["style"];
function CB(e10, t10) {
  var r10 = e10.style, n10 = Rm(e10, _B), i10 = t10.style, o10 = Rm(t10, EB);
  return !Dm(r10, i10) && !Dm(n10, o10);
}
var TB = (0, import_react25.memo)(({ data: e10, index: t10, style: r10 }) => {
  const { items: n10, onHandleTokenAction: i10, showCollect: o10, showDelete: s10 } = e10, a10 = n10[t10];
  return w.jsx("div", { style: r10, children: w.jsx(
    IB,
    {
      data: a10,
      onHandleTokenAction: i10,
      showCollect: o10,
      showDelete: s10
    }
  ) });
}, CB);
var AB = dB(
  (e10, t10, r10, n10) => ({
    items: e10,
    onHandleTokenAction: t10,
    showCollect: r10,
    showDelete: n10
  })
);
function MB({
  showTokenList: e10,
  onHandleTokenAction: t10,
  showCollect: r10 = true,
  showDelete: n10 = false
}) {
  const i10 = (0, import_react25.useRef)(null);
  (0, import_react25.useEffect)(() => {
    i10.current && i10.current.scrollTo(0);
  }, [e10.length]);
  const o10 = AB(
    e10,
    t10,
    r10,
    n10
  );
  return w.jsx("div", { className: "token-list", children: w.jsx(
    SB,
    {
      ref: i10,
      style: {
        overflowY: "scroll",
        scrollbarWidth: "none",
        msOverflowStyle: "none",
        padding: "8px"
      },
      height: 360,
      itemCount: e10.length,
      itemData: o10,
      itemSize: 72,
      width: "100%",
      children: TB
    }
  ) });
}
function IB({
  data: e10,
  showCollect: t10,
  showDelete: r10,
  onHandleTokenAction: n10
}) {
  const { isCollectToken: i10 } = i6(), { getExplorerUrl: o10 } = Rs();
  return Ha(), w.jsxs(
    "div",
    {
      className: "token-list-item",
      onClick: (s10) => {
        t10 && (s10.stopPropagation(), n10(e10, "select_token"));
      },
      children: [
        w.jsx(
          Xr,
          {
            className: "token-img",
            src: e10 == null ? void 0 : e10.logo_url,
            showWarn: !t10
          }
        ),
        w.jsxs("div", { className: "token-info", children: [
          w.jsx("h4", { className: "token-symbol", children: w.jsx("span", { children: mn(e10.symbol) }) }),
          w.jsx("p", { className: "token-name", children: mn(e10 == null ? void 0 : e10.name, 20) }),
          w.jsxs("div", { className: "copy", children: [
            w.jsx(
              "a",
              {
                onClick: kl,
                href: o10(e10 == null ? void 0 : e10.coin_type, "coin"),
                target: "_blank",
                style: { fontSize: "12px" },
                children: Do(e10 == null ? void 0 : e10.coin_type)
              }
            ),
            w.jsx(lu, { text: e10 == null ? void 0 : e10.coin_type })
          ] })
        ] }),
        w.jsxs("div", { className: "token-balance", children: [
          w.jsxs("div", { className: "balance", children: [
            w.jsx("h4", { children: e10 == null ? void 0 : e10.balance }),
            w.jsx("p", { children: e10 != null && e10.rate ? xb(e10 == null ? void 0 : e10.rate, 2) : "" })
          ] }),
          r10 && w.jsx(
            "div",
            {
              className: "collect-button",
              onClick: (s10) => {
                s10.stopPropagation(), n10(e10, "delete_import");
              },
              children: w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-icon_del" }) })
            }
          ),
          t10 && w.jsx(
            "div",
            {
              className: "collect-button",
              onClick: (s10) => {
                s10.stopPropagation(), n10(e10, "collect_token");
              },
              children: w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx(
                "use",
                {
                  xlinkHref: i10(e10) ? "#icon-star_sel" : "#icon-star"
                }
              ) })
            }
          )
        ] })
      ]
    },
    e10 == null ? void 0 : e10.coin_type
  );
}
function OB({
  currentType: e10,
  changeTab: t10
}) {
  const r10 = ["Default", "Imported"];
  return w.jsx("div", { className: "type-tabs", children: r10.map((n10) => w.jsx(
    "div",
    {
      className: e10 === n10 ? "type-tab-item active" : "type-tab-item",
      onClick: () => t10(n10),
      children: n10
    },
    n10
  )) });
}
function RB({
  backClick: e10,
  onSelectToken: t10,
  currToken: r10
}) {
  const {
    showTokenList: n10,
    isNoData: i10,
    handleSearch: o10,
    handleChangePlatform: s10,
    handleChangeType: a10,
    handleImportClick: c,
    handleDeleteImportClick: l10
  } = iB(r10 == null ? void 0 : r10.coin_type), {
    importTokenList: u10,
    currentTypeTab: d6,
    setCurrentTypeTab: p,
    currentPlatformTab: y,
    setCurrentPlatformTab: x,
    platformList: b,
    isOpenImportDialog: M,
    setIsOpenImportDialog: O,
    setSearchInput: P,
    searchInput: j,
    importTokenIsLoading: F,
    currentImportTokenData: B,
    setCurrentImportTokenData: W
  } = Ka();
  (0, import_react25.useEffect)(() => () => {
    P(""), x("All"), p("Default"), W(void 0);
  }, []);
  const { handleCollectToken: z, collectTokenMap: G } = i6(), re = (m) => {
    p(m), a10(m);
  }, ie = (m) => {
    x(m), s10(m);
  }, oe = () => {
    c(), O(false);
  }, q = (m) => {
    let S = m.replace(/[^a-zA-Z0-9\s]+$/g, "").trim();
    P(S), S ? L(S) : (L(""), re("Default"));
  }, L = K0((m) => {
    _b2(m) ? o10(Oi(m, true)) : o10(m);
  }, 300), h = (m, S) => {
    if (S === "delete_import") {
      l10(m);
      return;
    }
    if (S === "collect_token" || S === "un_collect") {
      z(m);
      return;
    }
    S === "select_token" && (t10(m), e10());
  }, f = (0, import_react25.useMemo)(() => Array.from(G.values()), [G]);
  return w.jsxs("div", { className: "token-select-modal", children: [
    w.jsx(X0, { backClick: e10, title: "Select Token" }),
    w.jsxs("div", { className: "token-select-content", style: { position: "relative" }, children: [
      w.jsxs("div", { className: "center-content", children: [
        w.jsxs("div", { className: "search-input", style: { position: "relative" }, children: [
          w.jsx(
            "input",
            {
              className: "token-search-input",
              placeholder: "Search by token or address",
              value: j,
              onChange: (m) => q(m.target.value),
              style: { paddingRight: "40px" }
            }
          ),
          j.length > 0 && w.jsx(
            "svg",
            {
              className: "cs-icon",
              "aria-hidden": "true",
              style: {
                width: "20px",
                height: "20px",
                cursor: "pointer",
                position: "absolute",
                top: "50%",
                transform: "translateY(-50%)",
                right: "12px"
              },
              onClick: (m) => {
                q("");
              },
              children: w.jsx("use", { xlinkHref: "#icon-close" })
            }
          )
        ] }),
        f.length > 0 && w.jsx(
          oB,
          {
            tokenList: f,
            onHandleTokenAction: h
          }
        ),
        j.length === 0 && w.jsx(
          OB,
          {
            currentType: d6,
            changeTab: re
          }
        ),
        j.length === 0 && d6 === "Default" && w.jsx(
          lB,
          {
            tabList: b,
            currentTab: y,
            changeTab: ie
          }
        )
      ] }),
      i10 && w.jsx(
        PB,
        {
          showTooltip: j.length > 0,
          text: j.length > 0 || B === void 0 ? "No tokens found" : "No Imported Tokens"
        }
      ),
      F && w.jsx(pw, {}),
      B && w.jsx(
        "div",
        {
          style: {
            width: "93%",
            marginLeft: "16px",
            backgroundColor: "var(--cs-warning-10)",
            borderRadius: "12px",
            padding: "16px",
            fontSize: "12px",
            marginTop: "16px",
            color: " var(--cs-warning)"
          },
          children: "The token is not on the Frequently Traded List. Please note that anyone can create a token on Sui blockchain with any name, including creating fake versions of existing tokens or tokens that claim to represent projects that do not have a token. Always conduct your own research before trading."
        }
      ),
      n10.length > 0 && w.jsxs("div", { style: { position: "relative" }, children: [
        w.jsx(
          MB,
          {
            showTokenList: n10,
            showCollect: !B,
            showDelete: !B && d6 === "Imported",
            onHandleTokenAction: h
          }
        ),
        B && w.jsx(
          "div",
          {
            className: "center",
            style: {
              position: "absolute",
              top: "100px",
              left: "50%",
              transform: "translateX(-50%)"
            },
            children: w.jsx(
              "button",
              {
                className: "cs-solid-btn swap-btn",
                style: {
                  height: "32px",
                  width: "140px",
                  fontSize: "14px",
                  borderRadius: "8px",
                  fontFamily: "Inter, Inter",
                  fontWeight: 500
                },
                onClick: () => {
                  oe(), h(B, "select_token");
                },
                children: "Import"
              }
            )
          }
        )
      ] })
    ] })
  ] });
}
function PB({
  showTooltip: e10,
  text: t10
}) {
  return w.jsx("div", { style: { height: "360px" }, children: w.jsx(
    cB,
    {
      text: t10,
      subItem: e10 ? w.jsx("div", { children: w.jsx(
        tu,
        {
          position: "bottom",
          content: w.jsx("div", { children: "The unique id of coin" }),
          children: w.jsxs(
            "div",
            {
              style: {
                fontSize: "12px",
                color: "var(--cs-text-con)",
                display: "flex",
                flexDirection: "row"
              },
              children: [
                "Or you can enter Coin Type",
                w.jsx(
                  "svg",
                  {
                    className: "cs-icon",
                    "aria-hidden": "true",
                    style: {
                      cursor: "pointer",
                      width: "20px",
                      height: "20px"
                    },
                    children: w.jsx("use", { xlinkHref: "#icon-tips" })
                  }
                )
              ]
            }
          )
        }
      ) }) : void 0
    }
  ) });
}
function NB({
  onClose: e10,
  tokenList: t10,
  onSureClick: r10
}) {
  const [n10, i10] = (0, import_react25.useState)(false), { setIgnoreWarnToken: o10 } = Hr();
  return w.jsxs(w.Fragment, { children: [
    w.jsx("div", { className: "dialog-mask", onClick: e10 }),
    w.jsxs("div", { className: "import-dialog", children: [
      w.jsxs("div", { className: "cs-dialog-header", children: [
        w.jsx("div", { className: "title", children: "Tips" }),
        w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", onClick: e10, children: w.jsx("use", { xlinkHref: "#icon-close" }) })
      ] }),
      w.jsxs("div", { className: "import-content", children: [
        w.jsx("div", { className: "tip-text-box", children: w.jsx("p", { className: "tips-text", children: "The default trading pair given in this swap widget contains a community imported token that is imported by the integrator. Please acknowledge the risk and conduct your own research before interacting." }) }),
        t10.map((s10) => w.jsxs("div", { className: "import-token-info", children: [
          w.jsx(
            Xr,
            {
              style: {
                marginRight: "4px",
                width: "30px",
                height: "30px",
                borderRadius: "36px"
              },
              src: s10.logo_url
            }
          ),
          w.jsxs("div", { className: "info", children: [
            w.jsx("div", { className: "name", children: w.jsxs("span", { children: [
              " ",
              s10.symbol,
              " "
            ] }) }),
            w.jsxs("div", { className: "address", children: [
              w.jsx("span", { children: Do(s10.coin_type) }),
              w.jsx(lu, { text: s10.coin_type })
            ] })
          ] })
        ] }, s10.coin_type)),
        w.jsxs("div", { className: "risk-checkbox", children: [
          w.jsx(
            Gl,
            {
              color: "indigo",
              checked: n10,
              variant: "soft",
              className: "cs-checkbox",
              onClick: () => {
                i10(!n10);
              }
            }
          ),
          w.jsx("span", { children: "I acknowledge the risk" })
        ] }),
        w.jsxs("div", { className: "button-block", children: [
          w.jsx("button", { className: "cs-outline-btn", onClick: e10, children: "Cancel" }),
          w.jsx(
            "button",
            {
              className: "cs-solid-btn",
              disabled: !n10,
              onClick: () => {
                r10(), t10.forEach((s10) => {
                  o10(s10.coin_type);
                });
              },
              children: "Confirm"
            }
          )
        ] })
      ] })
    ] })
  ] });
}
function o6(e10, t10) {
  var r10 = {};
  for (var n10 in e10)
    Object.prototype.hasOwnProperty.call(e10, n10) && t10.indexOf(n10) < 0 && (r10[n10] = e10[n10]);
  if (e10 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i10 = 0, n10 = Object.getOwnPropertySymbols(e10); i10 < n10.length; i10++)
      t10.indexOf(n10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(e10, n10[i10]) && (r10[n10[i10]] = e10[n10[i10]]);
  return r10;
}
var Ma;
(function(e10) {
  e10.event = "event", e10.props = "prop";
})(Ma || (Ma = {}));
function Gi() {
}
function jB(e10) {
  var t10, r10 = void 0;
  return function() {
    for (var n10 = [], i10 = arguments.length; i10--; )
      n10[i10] = arguments[i10];
    return t10 && n10.length === t10.length && n10.every(function(o10, s10) {
      return o10 === t10[s10];
    }) || (t10 = n10, r10 = e10.apply(void 0, n10)), r10;
  };
}
function Ia(e10) {
  return !!(e10 || "").match(/\d/);
}
function gs(e10) {
  return e10 == null;
}
function kB(e10) {
  return typeof e10 == "number" && isNaN(e10);
}
function s6(e10) {
  return gs(e10) || kB(e10) || typeof e10 == "number" && !isFinite(e10);
}
function a6(e10) {
  return e10.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function DB(e10) {
  switch (e10) {
    case "lakh":
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case "wan":
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case "thousand":
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function LB(e10, t10, r10) {
  var n10 = DB(r10), i10 = e10.search(/[1-9]/);
  return i10 = i10 === -1 ? e10.length : i10, e10.substring(0, i10) + e10.substring(i10, e10.length).replace(n10, "$1" + t10);
}
function BB(e10) {
  var t10 = (0, import_react25.useRef)(e10);
  t10.current = e10;
  var r10 = (0, import_react25.useRef)(function() {
    for (var n10 = [], i10 = arguments.length; i10--; )
      n10[i10] = arguments[i10];
    return t10.current.apply(t10, n10);
  });
  return r10.current;
}
function sh(e10, t10) {
  t10 === void 0 && (t10 = true);
  var r10 = e10[0] === "-", n10 = r10 && t10;
  e10 = e10.replace("-", "");
  var i10 = e10.split("."), o10 = i10[0], s10 = i10[1] || "";
  return {
    beforeDecimal: o10,
    afterDecimal: s10,
    hasNegation: r10,
    addNegation: n10
  };
}
function UB(e10) {
  if (!e10)
    return e10;
  var t10 = e10[0] === "-";
  t10 && (e10 = e10.substring(1, e10.length));
  var r10 = e10.split("."), n10 = r10[0].replace(/^0+/, "") || "0", i10 = r10[1] || "";
  return (t10 ? "-" : "") + n10 + (i10 ? "." + i10 : "");
}
function c6(e10, t10, r10) {
  for (var n10 = "", i10 = r10 ? "0" : "", o10 = 0; o10 <= t10 - 1; o10++)
    n10 += e10[o10] || i10;
  return n10;
}
function Lm(e10, t10) {
  return Array(t10 + 1).join(e10);
}
function l6(e10) {
  var t10 = e10 + "", r10 = t10[0] === "-" ? "-" : "";
  r10 && (t10 = t10.substring(1));
  var n10 = t10.split(/[eE]/g), i10 = n10[0], o10 = n10[1];
  if (o10 = Number(o10), !o10)
    return r10 + i10;
  i10 = i10.replace(".", "");
  var s10 = 1 + o10, a10 = i10.length;
  return s10 < 0 ? i10 = "0." + Lm("0", Math.abs(s10)) + i10 : s10 >= a10 ? i10 = i10 + Lm("0", s10 - a10) : i10 = (i10.substring(0, s10) || "0") + "." + i10.substring(s10), r10 + i10;
}
function Bm(e10, t10, r10) {
  if (["", "-"].indexOf(e10) !== -1)
    return e10;
  var n10 = (e10.indexOf(".") !== -1 || r10) && t10, i10 = sh(e10), o10 = i10.beforeDecimal, s10 = i10.afterDecimal, a10 = i10.hasNegation, c = parseFloat("0." + (s10 || "0")), l10 = s10.length <= t10 ? "0." + s10 : c.toFixed(t10), u10 = l10.split("."), d6 = o10;
  o10 && Number(u10[0]) && (d6 = o10.split("").reverse().reduce(function(b, M, O) {
    return b.length > O ? (Number(b[0]) + Number(M)).toString() + b.substring(1, b.length) : M + b;
  }, u10[0]));
  var p = c6(u10[1] || "", t10, r10), y = a10 ? "-" : "", x = n10 ? "." : "";
  return "" + y + d6 + x + p;
}
function To(e10, t10) {
  if (e10.value = e10.value, e10 !== null) {
    if (e10.createTextRange) {
      var r10 = e10.createTextRange();
      return r10.move("character", t10), r10.select(), true;
    }
    return e10.selectionStart || e10.selectionStart === 0 ? (e10.focus(), e10.setSelectionRange(t10, t10), true) : (e10.focus(), false);
  }
}
var u6 = jB(function(e10, t10) {
  for (var r10 = 0, n10 = 0, i10 = e10.length, o10 = t10.length; e10[r10] === t10[r10] && r10 < i10; )
    r10++;
  for (; e10[i10 - 1 - n10] === t10[o10 - 1 - n10] && o10 - n10 > r10 && i10 - n10 > r10; )
    n10++;
  return {
    from: { start: r10, end: i10 - n10 },
    to: { start: r10, end: o10 - n10 }
  };
});
var FB = function(e10, t10) {
  var r10 = Math.min(e10.selectionStart, t10);
  return {
    from: { start: r10, end: e10.selectionEnd },
    to: { start: r10, end: t10 }
  };
};
function $B(e10, t10, r10) {
  return Math.min(Math.max(e10, t10), r10);
}
function df(e10) {
  return Math.max(e10.selectionStart, e10.selectionEnd);
}
function VB() {
  return typeof navigator < "u" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function zB(e10) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: e10.length
    },
    lastValue: ""
  };
}
function qB(e10) {
  var t10 = e10.currentValue, r10 = e10.formattedValue, n10 = e10.currentValueIndex, i10 = e10.formattedValueIndex;
  return t10[n10] === r10[i10];
}
function HB(e10, t10, r10, n10, i10, o10, s10) {
  s10 === void 0 && (s10 = qB);
  var a10 = i10.findIndex(function(F) {
    return F;
  }), c = e10.slice(0, a10);
  !t10 && !r10.startsWith(c) && (t10 = c, r10 = c + r10, n10 = n10 + c.length);
  for (var l10 = r10.length, u10 = e10.length, d6 = {}, p = new Array(l10), y = 0; y < l10; y++) {
    p[y] = -1;
    for (var x = 0, b = u10; x < b; x++) {
      var M = s10({
        currentValue: r10,
        lastValue: t10,
        formattedValue: e10,
        currentValueIndex: y,
        formattedValueIndex: x
      });
      if (M && d6[x] !== true) {
        p[y] = x, d6[x] = true;
        break;
      }
    }
  }
  for (var O = n10; O < l10 && (p[O] === -1 || !o10(r10[O])); )
    O++;
  var P = O === l10 || p[O] === -1 ? u10 : p[O];
  for (O = n10 - 1; O > 0 && p[O] === -1; )
    O--;
  var j = O === -1 || p[O] === -1 ? 0 : p[O] + 1;
  return j > P ? P : n10 - j < P - n10 ? j : P;
}
function Um(e10, t10, r10, n10) {
  var i10 = e10.length;
  if (t10 = $B(t10, 0, i10), n10 === "left") {
    for (; t10 >= 0 && !r10[t10]; )
      t10--;
    t10 === -1 && (t10 = r10.indexOf(true));
  } else {
    for (; t10 <= i10 && !r10[t10]; )
      t10++;
    t10 > i10 && (t10 = r10.lastIndexOf(true));
  }
  return t10 === -1 && (t10 = i10), t10;
}
function WB(e10) {
  for (var t10 = Array.from({ length: e10.length + 1 }).map(function() {
    return true;
  }), r10 = 0, n10 = t10.length; r10 < n10; r10++)
    t10[r10] = !!(Ia(e10[r10]) || Ia(e10[r10 - 1]));
  return t10;
}
function f6(e10, t10, r10, n10, i10, o10) {
  o10 === void 0 && (o10 = Gi);
  var s10 = BB(function(x, b) {
    var M, O;
    return s6(x) ? (O = "", M = "") : typeof x == "number" || b ? (O = typeof x == "number" ? l6(x) : x, M = n10(O)) : (O = i10(x, void 0), M = n10(O)), { formattedValue: M, numAsString: O };
  }), a10 = (0, import_react25.useState)(function() {
    return s10(gs(e10) ? t10 : e10, r10);
  }), c = a10[0], l10 = a10[1], u10 = function(x, b) {
    x.formattedValue !== c.formattedValue && l10({
      formattedValue: x.formattedValue,
      numAsString: x.value
    }), o10(x, b);
  }, d6 = e10, p = r10;
  gs(e10) && (d6 = c.numAsString, p = true);
  var y = s10(d6, p);
  return (0, import_react25.useMemo)(function() {
    l10(y);
  }, [y.formattedValue]), [c, u10];
}
function GB(e10) {
  return e10.replace(/[^0-9]/g, "");
}
function KB(e10) {
  return e10;
}
function YB(e10) {
  var t10 = e10.type;
  t10 === void 0 && (t10 = "text");
  var r10 = e10.displayType;
  r10 === void 0 && (r10 = "input");
  var n10 = e10.customInput, i10 = e10.renderText, o10 = e10.getInputRef, s10 = e10.format;
  s10 === void 0 && (s10 = KB);
  var a10 = e10.removeFormatting;
  a10 === void 0 && (a10 = GB);
  var c = e10.defaultValue, l10 = e10.valueIsNumericString, u10 = e10.onValueChange, d6 = e10.isAllowed, p = e10.onChange;
  p === void 0 && (p = Gi);
  var y = e10.onKeyDown;
  y === void 0 && (y = Gi);
  var x = e10.onMouseUp;
  x === void 0 && (x = Gi);
  var b = e10.onFocus;
  b === void 0 && (b = Gi);
  var M = e10.onBlur;
  M === void 0 && (M = Gi);
  var O = e10.value, P = e10.getCaretBoundary;
  P === void 0 && (P = WB);
  var j = e10.isValidInputCharacter;
  j === void 0 && (j = Ia);
  var F = e10.isCharacterSame, B = o6(e10, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]), W = f6(O, c, !!l10, s10, a10, u10), z = W[0], G = z.formattedValue, re = z.numAsString, ie = W[1], oe = (0, import_react25.useRef)(), q = (0, import_react25.useRef)({ formattedValue: G, numAsString: re }), L = function(ye, de) {
    q.current = { formattedValue: ye.formattedValue, numAsString: ye.value }, ie(ye, de);
  }, h = (0, import_react25.useState)(false), f = h[0], m = h[1], S = (0, import_react25.useRef)(null), T = (0, import_react25.useRef)({
    setCaretTimeout: null,
    focusTimeout: null
  });
  (0, import_react25.useEffect)(function() {
    return m(true), function() {
      clearTimeout(T.current.setCaretTimeout), clearTimeout(T.current.focusTimeout);
    };
  }, []);
  var E = s10, I = function(ye, de) {
    var Ee = parseFloat(de);
    return {
      formattedValue: ye,
      value: de,
      floatValue: isNaN(Ee) ? void 0 : Ee
    };
  }, C = function(ye, de, Ee) {
    ye.selectionStart === 0 && ye.selectionEnd === ye.value.length || (To(ye, de), T.current.setCaretTimeout = setTimeout(function() {
      ye.value === Ee && ye.selectionStart !== de && To(ye, de);
    }, 0));
  }, g = function(ye, de, Ee) {
    return Um(ye, de, P(ye), Ee);
  }, v10 = function(ye, de, Ee) {
    var $e = P(de), Ne = HB(de, G, ye, Ee, $e, j, F);
    return Ne = Um(de, Ne, $e), Ne;
  }, k = function(ye) {
    var de = ye.formattedValue;
    de === void 0 && (de = "");
    var Ee = ye.input, $e = ye.source, Ne = ye.event, Ce = ye.numAsString, Ae;
    if (Ee) {
      var Be = ye.inputValue || Ee.value, lt = df(Ee);
      Ee.value = de, Ae = v10(Be, de, lt), Ae !== void 0 && C(Ee, Ae, de);
    }
    de !== G && L(I(de, Ce), { event: Ne, source: $e });
  };
  (0, import_react25.useEffect)(function() {
    var ye = q.current, de = ye.formattedValue, Ee = ye.numAsString;
    (G !== de || re !== Ee) && L(I(G, re), {
      event: void 0,
      source: Ma.props
    });
  }, [G, re]);
  var Q = S.current ? df(S.current) : void 0, Z = typeof window < "u" ? import_react25.useLayoutEffect : import_react25.useEffect;
  Z(function() {
    var ye = S.current;
    if (G !== q.current.formattedValue && ye) {
      var de = v10(q.current.formattedValue, G, Q);
      ye.value = G, C(ye, de, G);
    }
  }, [G]);
  var ae = function(ye, de, Ee) {
    var $e = de.target, Ne = oe.current ? FB(oe.current, $e.selectionEnd) : u6(G, ye), Ce = Object.assign(Object.assign({}, Ne), { lastValue: G }), Ae = a10(ye, Ce), Be = E(Ae);
    if (Ae = a10(Be, void 0), d6 && !d6(I(Be, Ae))) {
      var lt = de.target, ut = df(lt), Ve = v10(ye, G, ut);
      return lt.value = G, C(lt, Ve, G), false;
    }
    return k({
      formattedValue: Be,
      numAsString: Ae,
      inputValue: ye,
      event: de,
      source: Ee,
      input: de.target
    }), true;
  }, ve = function(ye, de) {
    de === void 0 && (de = 0);
    var Ee = ye.selectionStart, $e = ye.selectionEnd;
    oe.current = { selectionStart: Ee, selectionEnd: $e + de };
  }, we = function(ye) {
    var de = ye.target, Ee = de.value, $e = ae(Ee, ye, Ma.event);
    $e && p(ye), oe.current = void 0;
  }, he = function(ye) {
    var de = ye.target, Ee = ye.key, $e = de.selectionStart, Ne = de.selectionEnd, Ce = de.value;
    Ce === void 0 && (Ce = "");
    var Ae;
    Ee === "ArrowLeft" || Ee === "Backspace" ? Ae = Math.max($e - 1, 0) : Ee === "ArrowRight" ? Ae = Math.min($e + 1, Ce.length) : Ee === "Delete" && (Ae = $e);
    var Be = 0;
    Ee === "Delete" && $e === Ne && (Be = 1);
    var lt = Ee === "ArrowLeft" || Ee === "ArrowRight";
    if (Ae === void 0 || $e !== Ne && !lt) {
      y(ye), ve(de, Be);
      return;
    }
    var ut = Ae;
    if (lt) {
      var Ve = Ee === "ArrowLeft" ? "left" : "right";
      ut = g(Ce, Ae, Ve), ut !== Ae && ye.preventDefault();
    } else
      Ee === "Delete" && !j(Ce[Ae]) ? ut = g(Ce, Ae, "right") : Ee === "Backspace" && !j(Ce[Ae]) && (ut = g(Ce, Ae, "left"));
    ut !== Ae && C(de, ut, Ce), y(ye), ve(de, Be);
  }, De = function(ye) {
    var de = ye.target, Ee = function() {
      var $e = de.selectionStart, Ne = de.selectionEnd, Ce = de.value;
      if (Ce === void 0 && (Ce = ""), $e === Ne) {
        var Ae = g(Ce, $e);
        Ae !== $e && C(de, Ae, Ce);
      }
    };
    Ee(), requestAnimationFrame(function() {
      Ee();
    }), x(ye), ve(de);
  }, Te = function(ye) {
    ye.persist && ye.persist();
    var de = ye.target, Ee = ye.currentTarget;
    S.current = de, T.current.focusTimeout = setTimeout(function() {
      var $e = de.selectionStart, Ne = de.selectionEnd, Ce = de.value;
      Ce === void 0 && (Ce = "");
      var Ae = g(Ce, $e);
      Ae !== $e && !($e === 0 && Ne === Ce.length) && C(de, Ae, Ce), b(Object.assign(Object.assign({}, ye), { currentTarget: Ee }));
    }, 0);
  }, Xe = function(ye) {
    S.current = null, clearTimeout(T.current.focusTimeout), clearTimeout(T.current.setCaretTimeout), M(ye);
  }, ft = f && VB() ? "numeric" : void 0, je = Object.assign({ inputMode: ft }, B, {
    type: t10,
    value: G,
    onChange: we,
    onKeyDown: he,
    onMouseUp: De,
    onFocus: Te,
    onBlur: Xe
  });
  if (r10 === "text")
    return i10 ? import_react25.default.createElement(import_react25.default.Fragment, null, i10(G, B) || null) : import_react25.default.createElement("span", Object.assign({}, B, { ref: o10 }), G);
  if (n10) {
    var ht = n10;
    return import_react25.default.createElement(ht, Object.assign({}, je, { ref: o10 }));
  }
  return import_react25.default.createElement("input", Object.assign({}, je, { ref: o10 }));
}
function Fm(e10, t10) {
  var r10 = t10.decimalScale, n10 = t10.fixedDecimalScale, i10 = t10.prefix;
  i10 === void 0 && (i10 = "");
  var o10 = t10.suffix;
  o10 === void 0 && (o10 = "");
  var s10 = t10.allowNegative, a10 = t10.thousandsGroupStyle;
  if (a10 === void 0 && (a10 = "thousand"), e10 === "" || e10 === "-")
    return e10;
  var c = uu(t10), l10 = c.thousandSeparator, u10 = c.decimalSeparator, d6 = r10 !== 0 && e10.indexOf(".") !== -1 || r10 && n10, p = sh(e10, s10), y = p.beforeDecimal, x = p.afterDecimal, b = p.addNegation;
  return r10 !== void 0 && (x = c6(x, r10, !!n10)), l10 && (y = LB(y, l10, a10)), i10 && (y = i10 + y), o10 && (x = x + o10), b && (y = "-" + y), e10 = y + (d6 && u10 || "") + x, e10;
}
function uu(e10) {
  var t10 = e10.decimalSeparator;
  t10 === void 0 && (t10 = ".");
  var r10 = e10.thousandSeparator, n10 = e10.allowedDecimalSeparators;
  return r10 === true && (r10 = ","), n10 || (n10 = [t10, "."]), {
    decimalSeparator: t10,
    thousandSeparator: r10,
    allowedDecimalSeparators: n10
  };
}
function XB(e10, t10) {
  e10 === void 0 && (e10 = "");
  var r10 = new RegExp("(-)"), n10 = new RegExp("(-)(.)*(-)"), i10 = r10.test(e10), o10 = n10.test(e10);
  return e10 = e10.replace(/-/g, ""), i10 && !o10 && t10 && (e10 = "-" + e10), e10;
}
function JB(e10, t10) {
  return new RegExp("(^-)|[0-9]|" + a6(e10), t10 ? "g" : void 0);
}
function ZB(e10, t10, r10) {
  return e10 === "" ? true : !(t10 != null && t10.match(/\d/)) && !(r10 != null && r10.match(/\d/)) && typeof e10 == "string" && !isNaN(Number(e10));
}
function QB(e10, t10, r10) {
  var n10;
  t10 === void 0 && (t10 = zB(e10));
  var i10 = r10.allowNegative, o10 = r10.prefix;
  o10 === void 0 && (o10 = "");
  var s10 = r10.suffix;
  s10 === void 0 && (s10 = "");
  var a10 = r10.decimalScale, c = t10.from, l10 = t10.to, u10 = l10.start, d6 = l10.end, p = uu(r10), y = p.allowedDecimalSeparators, x = p.decimalSeparator, b = e10[d6] === x;
  if (Ia(e10) && (e10 === o10 || e10 === s10) && t10.lastValue === "")
    return e10;
  if (d6 - u10 === 1 && y.indexOf(e10[u10]) !== -1) {
    var M = a10 === 0 ? "" : x;
    e10 = e10.substring(0, u10) + M + e10.substring(u10 + 1, e10.length);
  }
  var O = function(S, T, E) {
    var I = false, C = false;
    o10.startsWith("-") ? I = false : S.startsWith("--") ? (I = false, C = true) : s10.startsWith("-") && S.length === s10.length ? I = false : S[0] === "-" && (I = true);
    var g = I ? 1 : 0;
    return C && (g = 2), g && (S = S.substring(g), T -= g, E -= g), { value: S, start: T, end: E, hasNegation: I };
  }, P = O(e10, u10, d6), j = P.hasNegation;
  n10 = P, e10 = n10.value, u10 = n10.start, d6 = n10.end;
  var F = O(t10.lastValue, c.start, c.end), B = F.start, W = F.end, z = F.value, G = e10.substring(u10, d6);
  e10.length && z.length && (B > z.length - s10.length || W < o10.length) && !(G && s10.startsWith(G)) && (e10 = z);
  var re = 0;
  e10.startsWith(o10) ? re += o10.length : u10 < o10.length && (re = u10), e10 = e10.substring(re), d6 -= re;
  var ie = e10.length, oe = e10.length - s10.length;
  e10.endsWith(s10) ? ie = oe : (d6 > oe || d6 > e10.length - s10.length) && (ie = d6), e10 = e10.substring(0, ie), e10 = XB(j ? "-" + e10 : e10, i10), e10 = (e10.match(JB(x, true)) || []).join("");
  var q = e10.indexOf(x);
  e10 = e10.replace(new RegExp(a6(x), "g"), function(S, T) {
    return T === q ? "." : "";
  });
  var L = sh(e10, i10), h = L.beforeDecimal, f = L.afterDecimal, m = L.addNegation;
  return l10.end - l10.start < c.end - c.start && h === "" && b && !parseFloat(f) && (e10 = m ? "-" : ""), e10;
}
function eU(e10, t10) {
  var r10 = t10.prefix;
  r10 === void 0 && (r10 = "");
  var n10 = t10.suffix;
  n10 === void 0 && (n10 = "");
  var i10 = Array.from({ length: e10.length + 1 }).map(function() {
    return true;
  }), o10 = e10[0] === "-";
  i10.fill(false, 0, r10.length + (o10 ? 1 : 0));
  var s10 = e10.length;
  return i10.fill(false, s10 - n10.length + 1, s10 + 1), i10;
}
function tU(e10) {
  var t10 = uu(e10), r10 = t10.thousandSeparator, n10 = t10.decimalSeparator, i10 = e10.prefix;
  i10 === void 0 && (i10 = "");
  var o10 = e10.allowNegative;
  if (o10 === void 0 && (o10 = true), r10 === n10)
    throw new Error(`
        Decimal separator can't be same as thousand separator.
        thousandSeparator: ` + r10 + ` (thousandSeparator = {true} is same as thousandSeparator = ",")
        decimalSeparator: ` + n10 + ` (default value for decimalSeparator is .)
     `);
  return i10.startsWith("-") && o10 && (console.error(`
      Prefix can't start with '-' when allowNegative is true.
      prefix: ` + i10 + `
      allowNegative: ` + o10 + `
    `), o10 = false), Object.assign(Object.assign({}, e10), { allowNegative: o10 });
}
function rU(e10) {
  e10 = tU(e10), e10.decimalSeparator, e10.allowedDecimalSeparators, e10.thousandsGroupStyle;
  var t10 = e10.suffix, r10 = e10.allowNegative, n10 = e10.allowLeadingZeros, i10 = e10.onKeyDown;
  i10 === void 0 && (i10 = Gi);
  var o10 = e10.onBlur;
  o10 === void 0 && (o10 = Gi);
  var s10 = e10.thousandSeparator, a10 = e10.decimalScale, c = e10.fixedDecimalScale, l10 = e10.prefix;
  l10 === void 0 && (l10 = "");
  var u10 = e10.defaultValue, d6 = e10.value, p = e10.valueIsNumericString, y = e10.onValueChange, x = o6(e10, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]), b = uu(e10), M = b.decimalSeparator, O = b.allowedDecimalSeparators, P = function(m) {
    return Fm(m, e10);
  }, j = function(m, S) {
    return QB(m, S, e10);
  }, F = gs(d6) ? u10 : d6, B = p ?? ZB(F, l10, t10);
  gs(d6) ? gs(u10) || (B = B || typeof u10 == "number") : B = B || typeof d6 == "number";
  var W = function(m) {
    return s6(m) ? m : (typeof m == "number" && (m = l6(m)), B && typeof a10 == "number" ? Bm(m, a10, !!c) : m);
  }, z = f6(W(d6), W(u10), !!B, P, j, y), G = z[0], re = G.numAsString, ie = G.formattedValue, oe = z[1], q = function(m) {
    var S = m.target, T = m.key, E = S.selectionStart, I = S.selectionEnd, C = S.value;
    if (C === void 0 && (C = ""), (T === "Backspace" || T === "Delete") && I < l10.length) {
      m.preventDefault();
      return;
    }
    if (E !== I) {
      i10(m);
      return;
    }
    T === "Backspace" && C[0] === "-" && E === l10.length + 1 && r10 && To(S, 1), a10 && c && (T === "Backspace" && C[E - 1] === M ? (To(S, E - 1), m.preventDefault()) : T === "Delete" && C[E] === M && m.preventDefault()), O != null && O.includes(T) && C[E] === M && To(S, E + 1);
    var g = s10 === true ? "," : s10;
    T === "Backspace" && C[E - 1] === g && To(S, E - 1), T === "Delete" && C[E] === g && To(S, E + 1), i10(m);
  }, L = function(m) {
    var S = re;
    if (S.match(/\d/g) || (S = ""), n10 || (S = UB(S)), c && a10 && (S = Bm(S, a10, c)), S !== re) {
      var T = Fm(S, e10);
      oe({
        formattedValue: T,
        value: S,
        floatValue: parseFloat(S)
      }, {
        event: m,
        source: Ma.event
      });
    }
    o10(m);
  }, h = function(m) {
    return m === M ? true : Ia(m);
  }, f = function(m) {
    var S = m.currentValue, T = m.lastValue, E = m.formattedValue, I = m.currentValueIndex, C = m.formattedValueIndex, g = S[I], v10 = E[C], k = u6(T, S), Q = k.to, Z = function(ae) {
      return j(ae).indexOf(".") + l10.length;
    };
    return d6 === 0 && c && a10 && S[Q.start] === M && Z(S) < I && Z(E) > C ? false : I >= Q.start && I < Q.end && O && O.includes(g) && v10 === M ? true : g === v10;
  };
  return Object.assign(Object.assign({}, x), {
    value: ie,
    valueIsNumericString: false,
    isValidInputCharacter: h,
    isCharacterSame: f,
    onValueChange: oe,
    format: P,
    removeFormatting: j,
    getCaretBoundary: function(m) {
      return eU(m, e10);
    },
    onKeyDown: q,
    onBlur: L
  });
}
function nU(e10) {
  var t10 = rU(e10);
  return import_react25.default.createElement(YB, Object.assign({}, t10));
}
function iU(e10) {
  const {
    className: t10,
    value: r10,
    decimals: n10,
    placeholder: i10,
    style: o10,
    onChange: s10,
    maxValue: a10,
    minValue: c = 0,
    inputAllowed: l10 = true,
    prefix: u10,
    ...d6
  } = e10, p = (y) => {
    var M;
    const x = ((M = y == null ? void 0 : y.target) == null ? void 0 : M.value) || "";
    let b = x;
    if (x.startsWith("0") && x !== "0" && !x.startsWith("0.") && (b = x.replace(/^0+/, "")), b) {
      if (b.startsWith(".")) {
        s10(b.slice(1, b.length));
        return;
      }
      let O = String(b).replace(/,/g, "");
      if (O.startsWith("-")) {
        s10("");
        return;
      }
      u10 && (O = O.replace(u10, "")), a10 !== void 0 && Le(O).gt(a10) ? O = a10.toString() : c !== void 0 && Le(O).lt(c) && (O = c.toString()), s10(String(O));
    } else
      s10("");
  };
  return w.jsx(
    nU,
    {
      className: t10,
      value: r10,
      disabled: !l10,
      placeholder: i10,
      decimalScale: n10,
      prefix: u10,
      allowLeadingZeros: true,
      thousandSeparator: ",",
      isAllowed: (y) => !y.value.startsWith("-"),
      onChange: p,
      ...d6,
      style: {
        ...o10,
        cursor: l10 ? "pointer" : "not-allowed",
        fontFamily: "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji",
        fontFeatureSettings: "tnum",
        fontVariant: "tabular-nums"
      }
    }
  );
}
function oU(e10) {
  const { token: t10, handleTokenSelectClick: r10 } = e10;
  return w.jsxs(
    "div",
    {
      className: "token-select-block",
      onClick: () => {
        r10 && r10();
      },
      children: [
        w.jsx("div", { className: "token-img-box", children: w.jsx(Xr, { src: t10 == null ? void 0 : t10.logo_url }) }, t10 == null ? void 0 : t10.coin_type),
        w.jsx("div", { className: "name", children: w.jsxs("h4", { className: "truncate-text", children: [
          " ",
          (t10 == null ? void 0 : t10.symbol) || "Select"
        ] }) }),
        w.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-arrow" }) })
      ]
    }
  );
}
function $m({
  label: e10,
  amount: t10,
  amountValue: r10,
  balance: n10,
  onInputChange: i10,
  handleTokenSelectClick: o10,
  token: s10,
  loading: a10 = false,
  showMax: c = true,
  showHalf: l10 = true,
  inputAllowed: u10 = true,
  marginTop: d6
}) {
  const [p, y] = (0, import_react25.useState)(false), { currentAccount: x } = Zr(), b = () => {
    const O = Le((n10 == null ? void 0 : n10.totalBalanceFormat) || "0").div(2), P = Lr(
      O.toString(),
      s10 == null ? void 0 : s10.decimals,
      true
    ).toString();
    t10 && Le(P).eq(t10) || i10(P);
  }, M = () => {
    const O = Le((n10 == null ? void 0 : n10.totalBalanceFormat) || 0), P = Br((s10 == null ? void 0 : s10.coin_type) || "").full_address === pl, j = 0.05;
    let F = O;
    P && Le(O).gt(j) && (F = F.sub(j)), !(t10 && Le(F).eq(t10)) && Le(F).gte(0) && i10(F.toString());
  };
  return w.jsxs(
    "div",
    {
      className: p ? "active trade-input-box" : "trade-input-box",
      style: {
        backgroundColor: u10 ? "#121719" : "#161a1e",
        marginTop: d6
      },
      children: [
        w.jsxs("div", { className: "title", children: [
          " ",
          e10,
          " "
        ] }),
        w.jsxs("div", { className: "token-input", children: [
          a10 ? w.jsxs("div", { style: { flex: 1 }, children: [
            " ",
            w.jsx(
              Ls,
              {
                style: { width: "200px", height: "28px", flex: 1 }
              }
            ),
            " "
          ] }) : w.jsx(
            iU,
            {
              inputAllowed: u10,
              value: t10,
              decimals: (s10 == null ? void 0 : s10.decimals) || 9,
              placeholder: "0.0",
              className: "input",
              onChange: i10,
              onFocus: () => y(true),
              onBlur: () => y(false)
            }
          ),
          w.jsx(
            oU,
            {
              token: s10,
              handleTokenSelectClick: o10
            }
          )
        ] }),
        w.jsxs("div", { className: "info-box", children: [
          !a10 && r10 && Le(r10).gt(0) ? w.jsx("div", { className: "input-rate", style: { marginTop: "8px" }, children: xb(r10, 2) }) : w.jsx("div", {}),
          x && s10 && w.jsxs(
            "div",
            {
              style: { display: "flex", flexDirection: "row", marginTop: "8px" },
              children: [
                w.jsxs("div", { className: "token-balance", children: [
                  w.jsx("svg", { className: "icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-wallet" }) }),
                  w.jsx("span", { children: (n10 == null ? void 0 : n10.displayBalance) || 0 })
                ] }),
                w.jsxs("div", { className: "btn-box", children: [
                  l10 && w.jsx("button", { className: "cs-outline-btn", onClick: b, children: "HALF" }),
                  c && w.jsx("button", { className: "cs-outline-btn", onClick: M, children: "MAX" })
                ] })
              ]
            }
          )
        ] })
      ]
    }
  );
}
function sU({
  refreshCount: e10,
  customWallet: t10,
  initProps: r10
}) {
  const { currentAccount: n10, onWalletModal: i10 } = Zr(), { getOwnerCoinBalances: o10 } = ol(), {
    fromCoin: s10,
    toCoin: a10,
    fromAmount: c,
    toAmount: l10,
    findRouterLoading: u10,
    byAmountIn: d6,
    routerData: p,
    isOpenSecondary: y,
    setIsOpenSecondary: x,
    isOpenTokensDialog: b,
    setIsOpenTokensDialog: M
  } = an(), {
    handleAmountChange: O,
    handleSelectToken: P,
    fromBalanceInfo: j,
    toBalanceInfo: F,
    fromAmountValue: B,
    toAmountValue: W,
    doSwapAction: z,
    reCalculateRouteData: G,
    refreshMarketPrice: re,
    scamsText: ie
  } = kP(), { slippage: oe } = Hr(), { isCustomMode: q, customWarnTokenList: L } = xP(
    s10 == null ? void 0 : s10.coin_type,
    a10 == null ? void 0 : a10.coin_type
  ), { amountLimit: h } = bw(oe, p), { formatSwapRouter: f } = yP(p), [m, S] = (0, import_react25.useState)(false), { btnText: T, btnDisabled: E } = DP(
    j == null ? void 0 : j.totalBalanceFormat
  ), [I, C] = (0, import_react25.useState)(false), [g, v10] = (0, import_react25.useState)(false);
  (0, import_react25.useEffect)(() => {
    y ? e10 >= 5 && k() : e10 >= 20 && k();
  }, [e10]);
  const k = () => {
    G(), n10 && o10(), re();
  }, Q = () => ({ ...p }), Z = async () => {
    a10 && P(a10, true);
  };
  return w.jsxs("div", { className: "swap-trade-box", children: [
    w.jsxs(
      "div",
      {
        className: "trade-form",
        style: {
          flexDirection: "column"
        },
        children: [
          w.jsx(
            $m,
            {
              loading: !d6 && u10,
              balance: j,
              amountValue: B,
              handleTokenSelectClick: () => {
                C(true), M(true);
              },
              onInputChange: (ae) => {
                O(ae, true);
              },
              amount: c,
              token: s10
            }
          ),
          w.jsx(
            "div",
            {
              onClick: Z,
              className: "swap-icon",
              onMouseEnter: () => S(true),
              onMouseLeave: () => S(false),
              style: {
                cursor: "pointer"
              },
              children: w.jsx(
                "svg",
                {
                  className: "cs-icon",
                  "aria-hidden": "true",
                  style: {
                    transform: m ? "rotate(90deg)" : "none",
                    width: m ? "16px" : "14px",
                    height: m ? "16px" : "14px"
                  },
                  children: w.jsx("use", { xlinkHref: m ? "#icon-swap" : "#icon-trade" })
                }
              )
            }
          ),
          w.jsx(
            $m,
            {
              marginTop: "-20px",
              loading: d6 && u10,
              balance: F,
              showHalf: false,
              showMax: false,
              amountValue: W,
              handleTokenSelectClick: () => {
                C(false), M(true);
              },
              onInputChange: (ae) => {
                O(ae, false);
              },
              inputAllowed: false,
              amount: l10,
              token: a10
            }
          )
        ]
      }
    ),
    ie && w.jsx(BP, { scamsText: ie }),
    w.jsxs(
      "div",
      {
        className: "swap-bottom-block",
        style: {
          border: E ? "0px solid #2a3238" : "1px solid #2a3238"
        },
        children: [
          w.jsx(
            "button",
            {
              className: "cs-solid-btn swap-btn",
              style: { marginTop: "0px" },
              disabled: E || u10,
              onClick: () => {
                n10 ? q && L.length > 0 ? v10(true) : x(true) : t10 != null && t10.connect ? t10.connect() : i10(true);
              },
              children: u10 ? w.jsx(
                "div",
                {
                  style: {
                    width: "100%",
                    display: "flex",
                    justifyContent: "center"
                  },
                  children: w.jsx(xw, {})
                }
              ) : T
            }
          ),
          c && l10 && Le(c).gt(0) && Le(l10).gt(0) && w.jsxs("div", { className: "content", children: [
            w.jsxs("div", { className: "price-related-info", children: [
              p && !(p != null && p.errorCode) && w.jsx(
                Y0,
                {
                  baseToken: s10,
                  quoteToken: a10,
                  baseAmount: p.fromAmountUi || "",
                  quoteAmount: p.toAmountUi || "",
                  loading: u10
                }
              ),
              w.jsx(
                Ew,
                {
                  isLoading: u10,
                  routerData: p
                }
              )
            ] }),
            w.jsx(
              Cw,
              {
                isLoading: u10,
                amountLimit: h
              }
            ),
            w.jsx(
              n6,
              {
                hasSubMenu: true,
                formatSwapRouter: f,
                isLoading: u10
              }
            )
          ] })
        ]
      }
    ),
    y && w.jsx(
      eB,
      {
        data: Q(),
        toBack: () => x(false),
        onSubmitClick: async (ae) => {
          try {
            await z(ae, r10 == null ? void 0 : r10.partner);
          } finally {
            x(false);
          }
        }
      }
    ),
    b && w.jsx(
      RB,
      {
        currToken: I ? s10 : a10,
        backClick: () => M(false),
        onSelectToken: (ae) => {
          P(ae, I), M(false);
        }
      }
    ),
    g && L.length > 0 && w.jsx(
      NB,
      {
        onClose: () => {
          v10(false);
        },
        tokenList: L,
        onSureClick: () => {
          v10(false), x(true);
        }
      }
    )
  ] });
}
function aU({
  initProps: e10 = {},
  customWallet: t10
}) {
  oP();
  const { ToastContainer: r10 } = Bs(), { fetchRouterConfig: n10 } = GR(), { getTrustTokens: i10 } = fo(), { transactionData: o10, setTransactionData: s10 } = W0(), { isOpenSecondary: a10, fromCoin: c, toAmount: l10, toCoin: u10, fromAmount: d6 } = an(), [p, y] = (0, import_react25.useState)(0), x = (0, import_react25.useRef)(p);
  iP(e10), (0, import_react25.useEffect)(() => {
    i10(), n10();
  }, []), (0, import_react25.useEffect)(() => {
    x.current = 0;
  }, [c == null ? void 0 : c.coin_type, u10 == null ? void 0 : u10.coin_type, d6, l10]), KR({
    interval: 1e3,
    callback: () => {
      x.current = x.current + 1, a10 ? x.current >= 5 && b() : x.current >= 20 && b();
    }
  });
  const b = () => {
    x.current = 20, y(20), setTimeout(() => {
      x.current = 0, y(0);
    }, 20);
  };
  return w.jsx(w.Fragment, { children: w.jsxs("div", { className: "cs-swap-container", id: "cs-swap-widget", children: [
    w.jsx(
      zR,
      {
        independentWallet: !!(e10 != null && e10.independentWallet),
        customWallet: t10
      }
    ),
    w.jsx(MR, { handleRefresh: b }),
    w.jsx(
      sU,
      {
        refreshCount: p,
        customWallet: t10,
        initProps: e10
      }
    ),
    o10 && w.jsx(
      qR,
      {
        transactionData: o10,
        onClose: () => {
          s10(void 0);
        }
      }
    ),
    w.jsx(r10, {})
  ] }) });
}
function ah({
  initProps: e10 = {},
  customWallet: t10
}) {
  var s10;
  ZR();
  const { getOwnerCoinBalances: r10 } = ol(), n10 = useCurrentAccount(), { saveCurrentAccount: i10 } = Zr(), { mutate: o10 } = useConnectWallet();
  return (0, import_react25.useEffect)(() => {
    i10(n10 || void 0), r10(n10 == null ? void 0 : n10.address);
  }, [n10]), (0, import_react25.useEffect)(() => {
    var a10;
    t10 && ((a10 = t10 == null ? void 0 : t10.currentAccount) == null ? void 0 : a10.address) !== (n10 == null ? void 0 : n10.address) && o10(
      { wallet: t10 == null ? void 0 : t10.currentWallet },
      {
        onSuccess: () => {
        }
      }
    );
  }, [(s10 = t10 == null ? void 0 : t10.currentAccount) == null ? void 0 : s10.address, n10 == null ? void 0 : n10.address]), w.jsx(aU, { initProps: e10, customWallet: t10 });
}
function cU({
  initProps: e10,
  customWallet: t10
}) {
  const [r10, n10] = (0, import_react25.useState)(true);
  return w.jsxs(
    "div",
    {
      className: r10 ? "export-modal-container" : "export-modal-container none",
      children: [
        r10 && w.jsx("div", { className: "swap-modal-box", children: w.jsx(ah, { initProps: e10, customWallet: t10 }) }),
        w.jsx("div", { className: "swap-modal-mask", onClick: () => n10(false) })
      ]
    }
  );
}
function lU({
  size: e10,
  direction: t10,
  initProps: r10,
  customWallet: n10
  // isOpen,
  // onToggle,
}) {
  const [i10, o10] = (0, import_react25.useState)(false), s10 = () => {
    o10(!i10);
  };
  return w.jsxs("div", { className: "widget-btn-box", children: [
    w.jsx("div", { className: `img-btn ${e10} ${t10}`, onClick: s10, children: i10 ? w.jsx("svg", { className: "icon", "aria-hidden": "true", children: w.jsx("use", { xlinkHref: "#icon-unfold" }) }) : w.jsx("img", { src: At("/images/img-logo@2x.png") }) }),
    i10 && w.jsx("div", { className: `widget-modal ${t10} ${e10}`, children: w.jsx(ah, { initProps: r10, customWallet: n10 }) })
  ] });
}
function uU({
  initProps: e10 = {},
  customWallet: t10
}) {
  const { displayMode: r10, widgetBtnDirection: n10, widgetBtnSize: i10 } = e10;
  return w.jsxs(ql, { appearance: "dark", children: [
    r10 === "Integrated" && w.jsx(ah, { initProps: e10, customWallet: t10 }),
    r10 === "Widget" && w.jsx(
      lU,
      {
        initProps: e10,
        customWallet: t10,
        direction: n10 || "right-bottom",
        size: i10 || "Default"
      }
    ),
    (!r10 || r10 === "Modal") && w.jsx(cU, { initProps: e10, customWallet: t10 })
  ] });
}
var CU = uU;
export {
  CU as CetusSwap
};
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/p256.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

media-query-parser/dist/media-query-parser.esm.js:
  (*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@cetusprotocol/terminal/dist/cetus-swap.es.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=@cetusprotocol_terminal.js.map
